<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>&lt;Digital Design and Computer Architecture> MIPS 版本 阅读笔记 - Wen Gao 的小站</title><meta name=Description content="Wen Gao 的个人博客"><meta property="og:url" content="https://salvely.github.io/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">
<meta property="og:site_name" content="Wen Gao 的小站"><meta property="og:title" content=" MIPS 版本 阅读笔记"><meta property="og:description" content="以下是 《Digital Design and Computer Architecture》 第 1-8 章的阅读笔记，目录采用原书结构，笔记内容为自己整理（3.5节 时序逻辑电路的时序特性分析跳过）。数字电路部分还可以参考这本教材：Fundamentals of Digital Logic with Verilog Design, THIRD EDITION (auhd.edu.ye)"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-01T09:36:04+08:00"><meta property="article:modified_time" content="2025-03-24T18:19:49+08:00"><meta property="article:tag" content="计算机组成原理"><meta property="og:image" content="https://salvely.github.io/images/avatar.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://salvely.github.io/images/avatar.webp"><meta name=twitter:title content=" MIPS 版本 阅读笔记"><meta name=twitter:description content="以下是 《Digital Design and Computer Architecture》 第 1-8 章的阅读笔记，目录采用原书结构，笔记内容为自己整理（3.5节 时序逻辑电路的时序特性分析跳过）。数字电路部分还可以参考这本教材：Fundamentals of Digital Logic with Verilog Design, THIRD EDITION (auhd.edu.ye)"><meta name=application-name content="DoIt"><meta name=apple-mobile-web-app-title content="DoIt"><meta name=theme-color content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://salvely.github.io/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/><link rel=prev href=https://salvely.github.io/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/><link rel=next href=https://salvely.github.io/rustlings-%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/><link rel=stylesheet href=/css/main.min.css><link rel=stylesheet href=/css/style.min.css><meta name=google-site-verification content="UJapM2d84iH6w1FVXFWeXhz_PoqtMDTU3mmNjGfRe1E"><meta name=msvalidate.01 content="C974411E5F5A79173F7830327E92F59E"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https://salvely.github.io/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},"image":["https://salvely.github.io/images/Apple-Devices-Preview.png"],"genre":"posts","keywords":["计算机组成原理"],"wordcount":14343,"url":"https://salvely.github.io/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","datePublished":"2024-05-01T09:36:04+08:00","dateModified":"2025-03-24T18:19:49+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":{"@type":"ImageObject","url":"https://salvely.github.io/images/Salvely.jpg","width":400,"height":400}},"author":[{"@type":"Person","name":"Wen Gao","url":"https://github.com/Salvely"}],"description":""}</script></head><body data-instant-intensity=viewport class="tw-flex tw-min-h-screen tw-flex-col"><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e),document.documentElement.className=e,document.documentElement.style.setProperty("color-scheme",e==="light"?"light":"dark"),e==="light"?document.documentElement.classList.remove("tw-dark"):document.documentElement.classList.add("tw-dark"),window.theme=e,window.isDark=window.theme!=="light"}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(e){const t=document.getElementsByTagName("meta");for(let n=0;n<t.length;n++)if(t[n].getAttribute("name")===e)return t[n];return""}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"?setTheme(e):setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}else"auto"==="light"||"auto"==="dark"?(setTheme("auto"),saveTheme("auto")):(saveTheme("auto"),setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"));let metaColors={light:"#f8f8f8",dark:"#161b22"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")],window.switchThemeEventSet=new Set</script><div id=back-to-top></div><div id=mask></div><header class="desktop print:!tw-hidden" id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Wen Gao 的小站"><span class=tw-mr-1><svg class="icon" viewBox="0 0 576 512"><path d="M402.3 344.9l32-32c5-5 13.7-1.5 13.7 5.7V464c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h273.5c7.1.0 10.7 8.6 5.7 13.7l-32 32c-1.5 1.5-3.5 2.3-5.7 2.3H48v352h352V350.5c0-2.1.8-4.1 2.3-5.6zm156.6-201.8L296.3 405.7l-90.4 10c-26.2 2.9-48.5-19.2-45.6-45.6l10-90.4L432.9 17.1c22.9-22.9 59.9-22.9 82.7.0l43.2 43.2c22.9 22.9 22.9 60 .1 82.8zM460.1 174 402 115.9 216.2 301.8l-7.3 65.3 65.3-7.3L460.1 174zm64.8-79.7-43.2-43.2c-4.1-4.1-10.8-4.1-14.8.0L436 82l58.1 58.1 30.9-30.9c4-4.2 4-10.8-.1-14.9z"/></svg></span>Wen Gao 的小站</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/series/>系列 </a><a class=menu-item href=/about/>关于 </a><a class=menu-item href=/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/>任务列表 </a><a class=menu-item href=/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/>计算机科学之路 </a><a class=menu-item href=/series/%E8%AE%B0%E5%BD%95/>周记 </a><a class=menu-item href=https://github.com/Salvely/salvely.github.io title=GitHub rel="noopener noreferrer" target=_blank><svg class="icon" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<button class="search-button search-toggle" id=search-toggle-desktop title=搜索>
<svg class="icon" viewBox="0 0 512 512"><path d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</button>
<button class="search-button search-clear" id=search-clear-desktop title=清空>
<svg class="icon" viewBox="0 0 512 512"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3.0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3.0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3.0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3.0 17L312 256l65.6 65.1z"/></svg>
</button>
<span class="search-button search-loading tw-animate-spin" id=search-loading-desktop><svg class="icon" viewBox="0 0 512 512"><path d="M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49.0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156.0c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"/></svg>
</span></span><button class="menu-item theme-select" aria-label=切换主题>
<svg class="icon" viewBox="0 0 512 512"><path d="M8 256c0 136.966 111.033 248 248 248s248-111.034 248-248S392.966 8 256 8 8 119.033 8 256zm248 184V72c101.705.0 184 82.311 184 184 0 101.705-82.311 184-184 184z"/></svg>
<select class=color-theme-select id=theme-select-desktop aria-label=切换主题><option value=light>浅色</option><option value=dark>深色</option><option value=auto>跟随系统</option></select></button></div></div></div></header><header class="mobile print:!tw-hidden" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Wen Gao 的小站"><span class=tw-mr-1><svg class="icon" viewBox="0 0 576 512"><path d="M402.3 344.9l32-32c5-5 13.7-1.5 13.7 5.7V464c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h273.5c7.1.0 10.7 8.6 5.7 13.7l-32 32c-1.5 1.5-3.5 2.3-5.7 2.3H48v352h352V350.5c0-2.1.8-4.1 2.3-5.6zm156.6-201.8L296.3 405.7l-90.4 10c-26.2 2.9-48.5-19.2-45.6-45.6l10-90.4L432.9 17.1c22.9-22.9 59.9-22.9 82.7.0l43.2 43.2c22.9 22.9 22.9 60 .1 82.8zM460.1 174 402 115.9 216.2 301.8l-7.3 65.3 65.3-7.3L460.1 174zm64.8-79.7-43.2-43.2c-4.1-4.1-10.8-4.1-14.8.0L436 82l58.1 58.1 30.9-30.9c4-4.2 4-10.8-.1-14.9z"/></svg></span>Wen Gao 的小站</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<button class="search-button search-toggle tw-h-10" id=search-toggle-mobile title=搜索>
<svg class="icon" viewBox="0 0 512 512"><path d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</button>
<button class="search-button search-clear tw-h-fit" id=search-clear-mobile title=清空>
<svg class="icon" viewBox="0 0 512 512"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3.0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3.0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3.0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3.0 17L312 256l65.6 65.1z"/></svg>
</button>
<span class="search-button search-loading tw-animate-spin" id=search-loading-mobile><svg class="icon" viewBox="0 0 512 512"><path d="M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49.0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156.0c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51.0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"/></svg></span></div><button class=search-cancel id=search-cancel-mobile>
取消</button></div><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/series/ title>系列</a><a class=menu-item href=/about/ title>关于</a><a class=menu-item href=/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/ title>任务列表</a><a class=menu-item href=/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/ title>计算机科学之路</a><a class=menu-item href=/series/%E8%AE%B0%E5%BD%95/ title>周记</a><a class=menu-item href=https://github.com/Salvely/salvely.github.io title=GitHub rel="noopener noreferrer" target=_blank><svg class="icon" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></a><button class="menu-item theme-select tw-w-full" aria-label=切换主题>
<svg class="icon" viewBox="0 0 512 512"><path d="M8 256c0 136.966 111.033 248 248 248s248-111.034 248-248S392.966 8 256 8 8 119.033 8 256zm248 184V72c101.705.0 184 82.311 184 184 0 101.705-82.311 184-184 184z"/></svg>
<select class=color-theme-select id=theme-select-mobile aria-label=切换主题><option value=light>浅色</option><option value=dark>深色</option><option value=auto>跟随系统</option></select></button></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class="tw-mx-4 tw-flex-1"><div class="toc print:!tw-hidden" id=toc-auto><h2 class=toc-title>目录</h2><div class="toc-content always-active" id=toc-content-auto><nav id=TableOfContents><ul><li><a href=#chapter-1从-0-到-1>Chapter 1：从 0 到 1</a><ul><li><a href=#11-大纲>1.1 大纲</a></li></ul></li><li><a href=#chapter-2组合逻辑设计>Chapter 2：组合逻辑设计</a><ul><li><a href=#21-introduction>2.1 Introduction</a></li><li><a href=#22-boolean-equations>2.2 Boolean Equations</a><ul><li><a href=#最小项>最小项</a></li><li><a href=#最大项>最大项</a></li><li><a href=#最大项和最小项的关系>最大项和最小项的关系</a></li></ul></li><li><a href=#23-boolean-algebra>2.3 Boolean Algebra</a></li><li><a href=#24-from-logic-to-gates>2.4 From Logic to Gates</a></li><li><a href=#25-multilevel-combinational-logic>2.5 Multilevel Combinational Logic</a></li><li><a href=#26-xs-and-zs-oh-my>2.6 X&rsquo;s and Z&rsquo;s, Oh My</a></li><li><a href=#27-karnaugh-maps>2.7 Karnaugh Maps</a></li><li><a href=#28-combinational-building-blocks>2.8 Combinational Building Blocks</a></li><li><a href=#29-timing>2.9 Timing</a><ul><li><a href=#propagation>Propagation</a></li><li><a href=#glitches>Glitches</a></li></ul></li></ul></li><li><a href=#chapter-3时序逻辑设计>Chapter 3：时序逻辑设计</a><ul><li><a href=#31-introduction>3.1 Introduction</a></li><li><a href=#32-latches-and-flip-flops>3.2 Latches and Flip-Flops</a><ul><li><a href=#sr-latch>SR Latch</a></li><li><a href=#d-latch>D Latch</a></li><li><a href=#d-flip-flop>D flip-flop</a></li><li><a href=#register>Register</a></li><li><a href=#enabled-flip-flop>Enabled Flip-Flop</a></li><li><a href=#resettable-flip-flop>Resettable Flip-Flop</a></li><li><a href=#transistor-level-latch-and-flip-flop-designs>Transistor-Level Latch and Flip-Flop Designs*</a></li><li><a href=#putting-it-all-together>Putting It All Together</a></li><li><a href=#summary>Summary</a></li></ul></li><li><a href=#33-synchronous-logic-design>3.3 Synchronous Logic Design</a><ul><li><a href=#331-some-problematic-circuits>3.3.1 Some Problematic Circuits</a></li><li><a href=#332-synchronous-sequential-circuits>3.3.2 Synchronous Sequential Circuits</a></li><li><a href=#333-synchronous-and-asynchronous-circuits>3.3.3 Synchronous and Asynchronous Circuits</a></li></ul></li><li><a href=#34-finite-state-machines>3.4 Finite State Machines</a><ul><li><a href=#341-fsm-design-example>3.4.1 FSM Design Example</a><ul><li><a href=#步骤一明确问题背景>步骤一：明确问题背景</a></li><li><a href=#步骤二绘制状态转换图>步骤二：绘制状态转换图</a></li><li><a href=#步骤三绘制状态转换表>步骤三：绘制状态转换表</a></li><li><a href=#步骤四对状态进行二进制编码>步骤四：对状态进行二进制编码</a></li><li><a href=#步骤五对输出进行二进制编码>步骤五：对输出进行二进制编码</a></li><li><a href=#步骤六确定状态与输入关系表将状态编码嵌入到状态转换表>步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表）</a></li><li><a href=#步骤七确定状态与输出的关系表根据电路分析状态编码和输出编码>步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码）</a></li><li><a href=#步骤八写出状态表达式>步骤八：写出状态表达式</a></li><li><a href=#步骤九写出输出表达式>步骤九：写出输出表达式</a></li><li><a href=#步骤十画出电路图>步骤十：画出电路图</a></li></ul></li><li><a href=#342-state-encodings>3.4.2 State Encodings</a><ul><li><a href=#binary-encoding>Binary Encoding</a></li><li><a href=#one-hot-encoding>One-hot Encoding</a></li><li><a href=#设计示例13进制计数器>设计示例1：3进制计数器</a><ul><li><a href=#背景分析>背景分析</a></li><li><a href=#状态转换图绘制>状态转换图绘制</a></li><li><a href=#采用二进制编码设计>采用二进制编码设计</a></li><li><a href=#采用独热编码设计>采用独热编码设计</a></li></ul></li><li><a href=#设计示例23进制累加器>设计示例2：3进制累加器</a><ul><li><a href=#背景分析-1>背景分析</a></li><li><a href=#状态转换图绘制-1>状态转换图绘制</a></li><li><a href=#状态转换表绘制>状态转换表绘制</a></li><li><a href=#二进制编码实现>二进制编码实现</a></li></ul></li></ul></li><li><a href=#343-moore-and-mealy-machines>3.4.3 Moore and Mealy Machines</a></li><li><a href=#344-factoring-state-machines>3.4.4 Factoring State Machines</a></li><li><a href=#345-deriving-an-fsm-from-a-schematic>3.4.5 Deriving an FSM from a Schematic</a></li><li><a href=#346-fsm-review>3.4.6 FSM Review</a></li></ul></li><li><a href=#35-timing-of-sequential-logic>3.5 Timing of Sequential Logic</a><ul><li><a href=#351-the-dynamic-discipline>3.5.1 The Dynamic Discipline</a></li><li><a href=#352-system-timing>3.5.2 System Timing</a><ul><li><a href=#setup-time-constraint>Setup Time Constraint</a></li><li><a href=#hold-time-constraint>Hold Time Constraint</a></li><li><a href=#putting-it-all-together-1>Putting It All Together</a></li></ul></li><li><a href=#353-clock-skew>3.5.3 Clock Skew</a><ul><li><a href=#setup-time-constraint分析>setup time constraint分析</a></li><li><a href=#hold-time-constraint分析>hold time constraint分析</a></li><li><a href=#put-it-all-together>Put it all together</a></li></ul></li><li><a href=#354-metastability>3.5.4 Metastability</a><ul><li><a href=#metastable-state>Metastable State</a></li><li><a href=#resolution-time>Resolution Time</a></li></ul></li><li><a href=#355-synchronizers>3.5.5 Synchronizers</a></li><li><a href=#356-derivation-of-resolution-time>3.5.6 Derivation of Resolution Time*</a></li></ul></li><li><a href=#36-parallelism>3.6 Parallelism</a></li><li><a href=#37-summary>3.7 Summary</a></li><li><a href=#exercises>Exercises</a><ul><li><a href=#基础的锁存器--触发器特性>基础的锁存器 & 触发器特性</a></li><li><a href=#各类触发器之间的互相转换>各类触发器之间的互相转换</a></li><li><a href=#同步电路-vs-异步电路>同步电路 vs 异步电路</a></li><li><a href=#时序逻辑电路的设计从状态机到电路尤其是mealy型电路的设计>时序逻辑电路的设计：从状态机到电路（尤其是Mealy型电路的设计）</a><ul><li><a href=#状态机的化简流程>状态机的化简流程</a></li><li><a href=#二进制序列检测器>二进制序列检测器</a></li><li><a href=#grey-code状态机生成器>Grey Code状态机生成器</a></li></ul></li><li><a href=#时序逻辑电路的分析从电路到状态机>时序逻辑电路的分析：从电路到状态机</a></li><li><a href=#时序逻辑电路中的限制与延迟>时序逻辑电路中的限制与延迟</a></li></ul></li><li><a href=#interview-questions>Interview Questions</a></li></ul></li><li><a href=#chapter-4硬件描述语言>Chapter 4：硬件描述语言</a></li><li><a href=#chapter-5数字电路设计>Chapter 5：数字电路设计</a></li><li><a href=#chapter-6risc-v-汇编语言>Chapter 6：RISC-V 汇编语言</a></li><li><a href=#chapter-7微架构处理器设计>Chapter 7：微架构处理器设计</a></li><li><a href=#chapter-8主存和-io-系统设计>Chapter 8：主存和 I/O 系统设计</a></li><li><a href=#后续任务>后续任务</a></li></ul></nav></div></div><dialog id=toc-dialog class="tw-max-w-full tw-w-full tw-max-h-full tw-h-full tw-ml-16"><div class="toc tw-mx-4 tw-max-w-full"><h2 class="tw-mx-0 tw-my-6 tw-uppercase tw-text-2xl">目录</h2><div class=toc-content><nav id=TableOfContents><ul><li><a href=#chapter-1从-0-到-1>Chapter 1：从 0 到 1</a><ul><li><a href=#11-大纲>1.1 大纲</a></li></ul></li><li><a href=#chapter-2组合逻辑设计>Chapter 2：组合逻辑设计</a><ul><li><a href=#21-introduction>2.1 Introduction</a></li><li><a href=#22-boolean-equations>2.2 Boolean Equations</a><ul><li><a href=#最小项>最小项</a></li><li><a href=#最大项>最大项</a></li><li><a href=#最大项和最小项的关系>最大项和最小项的关系</a></li></ul></li><li><a href=#23-boolean-algebra>2.3 Boolean Algebra</a></li><li><a href=#24-from-logic-to-gates>2.4 From Logic to Gates</a></li><li><a href=#25-multilevel-combinational-logic>2.5 Multilevel Combinational Logic</a></li><li><a href=#26-xs-and-zs-oh-my>2.6 X&rsquo;s and Z&rsquo;s, Oh My</a></li><li><a href=#27-karnaugh-maps>2.7 Karnaugh Maps</a></li><li><a href=#28-combinational-building-blocks>2.8 Combinational Building Blocks</a></li><li><a href=#29-timing>2.9 Timing</a><ul><li><a href=#propagation>Propagation</a></li><li><a href=#glitches>Glitches</a></li></ul></li></ul></li><li><a href=#chapter-3时序逻辑设计>Chapter 3：时序逻辑设计</a><ul><li><a href=#31-introduction>3.1 Introduction</a></li><li><a href=#32-latches-and-flip-flops>3.2 Latches and Flip-Flops</a><ul><li><a href=#sr-latch>SR Latch</a></li><li><a href=#d-latch>D Latch</a></li><li><a href=#d-flip-flop>D flip-flop</a></li><li><a href=#register>Register</a></li><li><a href=#enabled-flip-flop>Enabled Flip-Flop</a></li><li><a href=#resettable-flip-flop>Resettable Flip-Flop</a></li><li><a href=#transistor-level-latch-and-flip-flop-designs>Transistor-Level Latch and Flip-Flop Designs*</a></li><li><a href=#putting-it-all-together>Putting It All Together</a></li><li><a href=#summary>Summary</a></li></ul></li><li><a href=#33-synchronous-logic-design>3.3 Synchronous Logic Design</a><ul><li><a href=#331-some-problematic-circuits>3.3.1 Some Problematic Circuits</a></li><li><a href=#332-synchronous-sequential-circuits>3.3.2 Synchronous Sequential Circuits</a></li><li><a href=#333-synchronous-and-asynchronous-circuits>3.3.3 Synchronous and Asynchronous Circuits</a></li></ul></li><li><a href=#34-finite-state-machines>3.4 Finite State Machines</a><ul><li><a href=#341-fsm-design-example>3.4.1 FSM Design Example</a><ul><li><a href=#步骤一明确问题背景>步骤一：明确问题背景</a></li><li><a href=#步骤二绘制状态转换图>步骤二：绘制状态转换图</a></li><li><a href=#步骤三绘制状态转换表>步骤三：绘制状态转换表</a></li><li><a href=#步骤四对状态进行二进制编码>步骤四：对状态进行二进制编码</a></li><li><a href=#步骤五对输出进行二进制编码>步骤五：对输出进行二进制编码</a></li><li><a href=#步骤六确定状态与输入关系表将状态编码嵌入到状态转换表>步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表）</a></li><li><a href=#步骤七确定状态与输出的关系表根据电路分析状态编码和输出编码>步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码）</a></li><li><a href=#步骤八写出状态表达式>步骤八：写出状态表达式</a></li><li><a href=#步骤九写出输出表达式>步骤九：写出输出表达式</a></li><li><a href=#步骤十画出电路图>步骤十：画出电路图</a></li></ul></li><li><a href=#342-state-encodings>3.4.2 State Encodings</a><ul><li><a href=#binary-encoding>Binary Encoding</a></li><li><a href=#one-hot-encoding>One-hot Encoding</a></li><li><a href=#设计示例13进制计数器>设计示例1：3进制计数器</a><ul><li><a href=#背景分析>背景分析</a></li><li><a href=#状态转换图绘制>状态转换图绘制</a></li><li><a href=#采用二进制编码设计>采用二进制编码设计</a></li><li><a href=#采用独热编码设计>采用独热编码设计</a></li></ul></li><li><a href=#设计示例23进制累加器>设计示例2：3进制累加器</a><ul><li><a href=#背景分析-1>背景分析</a></li><li><a href=#状态转换图绘制-1>状态转换图绘制</a></li><li><a href=#状态转换表绘制>状态转换表绘制</a></li><li><a href=#二进制编码实现>二进制编码实现</a></li></ul></li></ul></li><li><a href=#343-moore-and-mealy-machines>3.4.3 Moore and Mealy Machines</a></li><li><a href=#344-factoring-state-machines>3.4.4 Factoring State Machines</a></li><li><a href=#345-deriving-an-fsm-from-a-schematic>3.4.5 Deriving an FSM from a Schematic</a></li><li><a href=#346-fsm-review>3.4.6 FSM Review</a></li></ul></li><li><a href=#35-timing-of-sequential-logic>3.5 Timing of Sequential Logic</a><ul><li><a href=#351-the-dynamic-discipline>3.5.1 The Dynamic Discipline</a></li><li><a href=#352-system-timing>3.5.2 System Timing</a><ul><li><a href=#setup-time-constraint>Setup Time Constraint</a></li><li><a href=#hold-time-constraint>Hold Time Constraint</a></li><li><a href=#putting-it-all-together-1>Putting It All Together</a></li></ul></li><li><a href=#353-clock-skew>3.5.3 Clock Skew</a><ul><li><a href=#setup-time-constraint分析>setup time constraint分析</a></li><li><a href=#hold-time-constraint分析>hold time constraint分析</a></li><li><a href=#put-it-all-together>Put it all together</a></li></ul></li><li><a href=#354-metastability>3.5.4 Metastability</a><ul><li><a href=#metastable-state>Metastable State</a></li><li><a href=#resolution-time>Resolution Time</a></li></ul></li><li><a href=#355-synchronizers>3.5.5 Synchronizers</a></li><li><a href=#356-derivation-of-resolution-time>3.5.6 Derivation of Resolution Time*</a></li></ul></li><li><a href=#36-parallelism>3.6 Parallelism</a></li><li><a href=#37-summary>3.7 Summary</a></li><li><a href=#exercises>Exercises</a><ul><li><a href=#基础的锁存器--触发器特性>基础的锁存器 & 触发器特性</a></li><li><a href=#各类触发器之间的互相转换>各类触发器之间的互相转换</a></li><li><a href=#同步电路-vs-异步电路>同步电路 vs 异步电路</a></li><li><a href=#时序逻辑电路的设计从状态机到电路尤其是mealy型电路的设计>时序逻辑电路的设计：从状态机到电路（尤其是Mealy型电路的设计）</a><ul><li><a href=#状态机的化简流程>状态机的化简流程</a></li><li><a href=#二进制序列检测器>二进制序列检测器</a></li><li><a href=#grey-code状态机生成器>Grey Code状态机生成器</a></li></ul></li><li><a href=#时序逻辑电路的分析从电路到状态机>时序逻辑电路的分析：从电路到状态机</a></li><li><a href=#时序逻辑电路中的限制与延迟>时序逻辑电路中的限制与延迟</a></li></ul></li><li><a href=#interview-questions>Interview Questions</a></li></ul></li><li><a href=#chapter-4硬件描述语言>Chapter 4：硬件描述语言</a></li><li><a href=#chapter-5数字电路设计>Chapter 5：数字电路设计</a></li><li><a href=#chapter-6risc-v-汇编语言>Chapter 6：RISC-V 汇编语言</a></li><li><a href=#chapter-7微架构处理器设计>Chapter 7：微架构处理器设计</a></li><li><a href=#chapter-8主存和-io-系统设计>Chapter 8：主存和 I/O 系统设计</a></li><li><a href=#后续任务>后续任务</a></li></ul></nav></div></div></dialog><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single print:!tw-w-full print:!tw-max-w-none print:!tw-m-0 print:!tw-p-0"><h1 class=single-title data-pagefind-meta=date:2024-05-01 data-pagefind-body>&lt;Digital Design and Computer Architecture> MIPS 版本 阅读笔记</h1><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><span class=screen-reader-text></span><a href=https://salvely.github.io/authors/salvely/><img class="tw-inline-block tw-max-h-4 tw-rounded-full tw-translate-y-[-2px] tw-mr-1" src=/images/Salvely.jpg srcset="/images/Salvely_hu_d1b6716dad6d20f5.webp 16w, /images/Salvely_hu_e7e468e0168e4ede.webp 24w, /images/Salvely_hu_67e7b6815a7669d2.webp 32w" alt="Wen Gao avatar" height=16 width=16>Wen Gao</a></span>
</span>&nbsp;<span class=post-category>收录于 </span>&nbsp;<span class=post-category>类别 <a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/><svg class="icon" viewBox="0 0 512 512"><path d="M464 128H272l-54.63-54.63c-6-6-14.14-9.37-22.63-9.37H48C21.49 64 0 85.49.0 112v288c0 26.51 21.49 48 48 48h416c26.51.0 48-21.49 48-48V176c0-26.51-21.49-48-48-48zm0 272H48V112h140.12l54.63 54.63c6 6 14.14 9.37 22.63 9.37H464v224z"/></svg>计算机体系结构</a></span></div><div class=post-meta-line><svg class="icon" viewBox="0 0 448 512"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;<time datetime=2024-05-01>2024-05-01</time>&nbsp;<svg class="icon" viewBox="0 0 576 512"><path d="M402.3 344.9l32-32c5-5 13.7-1.5 13.7 5.7V464c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h273.5c7.1.0 10.7 8.6 5.7 13.7l-32 32c-1.5 1.5-3.5 2.3-5.7 2.3H48v352h352V350.5c0-2.1.8-4.1 2.3-5.6zm156.6-201.8L296.3 405.7l-90.4 10c-26.2 2.9-48.5-19.2-45.6-45.6l10-90.4L432.9 17.1c22.9-22.9 59.9-22.9 82.7.0l43.2 43.2c22.9 22.9 22.9 60 .1 82.8zM460.1 174 402 115.9 216.2 301.8l-7.3 65.3 65.3-7.3L460.1 174zm64.8-79.7-43.2-43.2c-4.1-4.1-10.8-4.1-14.8.0L436 82l58.1 58.1 30.9-30.9c4-4.2 4-10.8-.1-14.9z"/></svg>&nbsp;<time datetime=2025-03-24>2025-03-24</time>&nbsp;<svg class="icon" viewBox="0 0 512 512"><path d="M497.9 142.1l-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3.0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9.0l60.1 60.1c18.8 18.7 18.8 49.1.0 67.9zM284.2 99.8 21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3.0-17l-111-111c-4.8-4.7-12.4-4.7-17.1.0zM124.1 339.9c-5.5-5.5-5.5-14.3.0-19.8l154-154c5.5-5.5 14.3-5.5 19.8.0s5.5 14.3.0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8.0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z"/></svg>&nbsp;约 14343 字&nbsp;
<svg class="icon" viewBox="0 0 512 512"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5.0-2e2-89.5-2e2-2e2S145.5 56 256 56s2e2 89.5 2e2 2e2-89.5 2e2-2e2 2e2zm61.8-104.4-84.9-61.7c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h32c6.6.0 12 5.4 12 12v141.7l66.8 48.6c5.4 3.9 6.5 11.4 2.6 16.8L334.6 349c-3.9 5.3-11.4 6.5-16.8 2.6z"/></svg>&nbsp;预计阅读 63 分钟&nbsp;</div></div><div class="details toc print:!tw-block" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span class=details-icon><svg class="icon" viewBox="0 0 256 512"><path d="M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9.0l-22.6-22.6c-9.4-9.4-9.4-24.6.0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6.0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9.0l136 136c9.5 9.4 9.5 24.6.1 34z"/></svg></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#chapter-1从-0-到-1>Chapter 1：从 0 到 1</a><ul><li><a href=#11-大纲>1.1 大纲</a></li></ul></li><li><a href=#chapter-2组合逻辑设计>Chapter 2：组合逻辑设计</a><ul><li><a href=#21-introduction>2.1 Introduction</a></li><li><a href=#22-boolean-equations>2.2 Boolean Equations</a><ul><li><a href=#最小项>最小项</a></li><li><a href=#最大项>最大项</a></li><li><a href=#最大项和最小项的关系>最大项和最小项的关系</a></li></ul></li><li><a href=#23-boolean-algebra>2.3 Boolean Algebra</a></li><li><a href=#24-from-logic-to-gates>2.4 From Logic to Gates</a></li><li><a href=#25-multilevel-combinational-logic>2.5 Multilevel Combinational Logic</a></li><li><a href=#26-xs-and-zs-oh-my>2.6 X&rsquo;s and Z&rsquo;s, Oh My</a></li><li><a href=#27-karnaugh-maps>2.7 Karnaugh Maps</a></li><li><a href=#28-combinational-building-blocks>2.8 Combinational Building Blocks</a></li><li><a href=#29-timing>2.9 Timing</a><ul><li><a href=#propagation>Propagation</a></li><li><a href=#glitches>Glitches</a></li></ul></li></ul></li><li><a href=#chapter-3时序逻辑设计>Chapter 3：时序逻辑设计</a><ul><li><a href=#31-introduction>3.1 Introduction</a></li><li><a href=#32-latches-and-flip-flops>3.2 Latches and Flip-Flops</a><ul><li><a href=#sr-latch>SR Latch</a></li><li><a href=#d-latch>D Latch</a></li><li><a href=#d-flip-flop>D flip-flop</a></li><li><a href=#register>Register</a></li><li><a href=#enabled-flip-flop>Enabled Flip-Flop</a></li><li><a href=#resettable-flip-flop>Resettable Flip-Flop</a></li><li><a href=#transistor-level-latch-and-flip-flop-designs>Transistor-Level Latch and Flip-Flop Designs*</a></li><li><a href=#putting-it-all-together>Putting It All Together</a></li><li><a href=#summary>Summary</a></li></ul></li><li><a href=#33-synchronous-logic-design>3.3 Synchronous Logic Design</a><ul><li><a href=#331-some-problematic-circuits>3.3.1 Some Problematic Circuits</a></li><li><a href=#332-synchronous-sequential-circuits>3.3.2 Synchronous Sequential Circuits</a></li><li><a href=#333-synchronous-and-asynchronous-circuits>3.3.3 Synchronous and Asynchronous Circuits</a></li></ul></li><li><a href=#34-finite-state-machines>3.4 Finite State Machines</a><ul><li><a href=#341-fsm-design-example>3.4.1 FSM Design Example</a><ul><li><a href=#步骤一明确问题背景>步骤一：明确问题背景</a></li><li><a href=#步骤二绘制状态转换图>步骤二：绘制状态转换图</a></li><li><a href=#步骤三绘制状态转换表>步骤三：绘制状态转换表</a></li><li><a href=#步骤四对状态进行二进制编码>步骤四：对状态进行二进制编码</a></li><li><a href=#步骤五对输出进行二进制编码>步骤五：对输出进行二进制编码</a></li><li><a href=#步骤六确定状态与输入关系表将状态编码嵌入到状态转换表>步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表）</a></li><li><a href=#步骤七确定状态与输出的关系表根据电路分析状态编码和输出编码>步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码）</a></li><li><a href=#步骤八写出状态表达式>步骤八：写出状态表达式</a></li><li><a href=#步骤九写出输出表达式>步骤九：写出输出表达式</a></li><li><a href=#步骤十画出电路图>步骤十：画出电路图</a></li></ul></li><li><a href=#342-state-encodings>3.4.2 State Encodings</a><ul><li><a href=#binary-encoding>Binary Encoding</a></li><li><a href=#one-hot-encoding>One-hot Encoding</a></li><li><a href=#设计示例13进制计数器>设计示例1：3进制计数器</a><ul><li><a href=#背景分析>背景分析</a></li><li><a href=#状态转换图绘制>状态转换图绘制</a></li><li><a href=#采用二进制编码设计>采用二进制编码设计</a></li><li><a href=#采用独热编码设计>采用独热编码设计</a></li></ul></li><li><a href=#设计示例23进制累加器>设计示例2：3进制累加器</a><ul><li><a href=#背景分析-1>背景分析</a></li><li><a href=#状态转换图绘制-1>状态转换图绘制</a></li><li><a href=#状态转换表绘制>状态转换表绘制</a></li><li><a href=#二进制编码实现>二进制编码实现</a></li></ul></li></ul></li><li><a href=#343-moore-and-mealy-machines>3.4.3 Moore and Mealy Machines</a></li><li><a href=#344-factoring-state-machines>3.4.4 Factoring State Machines</a></li><li><a href=#345-deriving-an-fsm-from-a-schematic>3.4.5 Deriving an FSM from a Schematic</a></li><li><a href=#346-fsm-review>3.4.6 FSM Review</a></li></ul></li><li><a href=#35-timing-of-sequential-logic>3.5 Timing of Sequential Logic</a><ul><li><a href=#351-the-dynamic-discipline>3.5.1 The Dynamic Discipline</a></li><li><a href=#352-system-timing>3.5.2 System Timing</a><ul><li><a href=#setup-time-constraint>Setup Time Constraint</a></li><li><a href=#hold-time-constraint>Hold Time Constraint</a></li><li><a href=#putting-it-all-together-1>Putting It All Together</a></li></ul></li><li><a href=#353-clock-skew>3.5.3 Clock Skew</a><ul><li><a href=#setup-time-constraint分析>setup time constraint分析</a></li><li><a href=#hold-time-constraint分析>hold time constraint分析</a></li><li><a href=#put-it-all-together>Put it all together</a></li></ul></li><li><a href=#354-metastability>3.5.4 Metastability</a><ul><li><a href=#metastable-state>Metastable State</a></li><li><a href=#resolution-time>Resolution Time</a></li></ul></li><li><a href=#355-synchronizers>3.5.5 Synchronizers</a></li><li><a href=#356-derivation-of-resolution-time>3.5.6 Derivation of Resolution Time*</a></li></ul></li><li><a href=#36-parallelism>3.6 Parallelism</a></li><li><a href=#37-summary>3.7 Summary</a></li><li><a href=#exercises>Exercises</a><ul><li><a href=#基础的锁存器--触发器特性>基础的锁存器 & 触发器特性</a></li><li><a href=#各类触发器之间的互相转换>各类触发器之间的互相转换</a></li><li><a href=#同步电路-vs-异步电路>同步电路 vs 异步电路</a></li><li><a href=#时序逻辑电路的设计从状态机到电路尤其是mealy型电路的设计>时序逻辑电路的设计：从状态机到电路（尤其是Mealy型电路的设计）</a><ul><li><a href=#状态机的化简流程>状态机的化简流程</a></li><li><a href=#二进制序列检测器>二进制序列检测器</a></li><li><a href=#grey-code状态机生成器>Grey Code状态机生成器</a></li></ul></li><li><a href=#时序逻辑电路的分析从电路到状态机>时序逻辑电路的分析：从电路到状态机</a></li><li><a href=#时序逻辑电路中的限制与延迟>时序逻辑电路中的限制与延迟</a></li></ul></li><li><a href=#interview-questions>Interview Questions</a></li></ul></li><li><a href=#chapter-4硬件描述语言>Chapter 4：硬件描述语言</a></li><li><a href=#chapter-5数字电路设计>Chapter 5：数字电路设计</a></li><li><a href=#chapter-6risc-v-汇编语言>Chapter 6：RISC-V 汇编语言</a></li><li><a href=#chapter-7微架构处理器设计>Chapter 7：微架构处理器设计</a></li><li><a href=#chapter-8主存和-io-系统设计>Chapter 8：主存和 I/O 系统设计</a></li><li><a href=#后续任务>后续任务</a></li></ul></nav></div></div><div class=content id=content data-pagefind-body><blockquote><p>以下是 《Digital Design and Computer Architecture》 第 1-8 章的阅读笔记，目录采用原书结构，笔记内容为自己整理（3.5节 时序逻辑电路的时序特性分析跳过）。数字电路部分还可以参考这本教材：<a href=https://www.auhd.edu.ye/upfiles/elibrary/Azal2020-01-22-12-23-12-14318.pdf target=_blank rel="noopener noreferrer">Fundamentals of Digital Logic with Verilog Design, THIRD EDITION (auhd.edu.ye)</a></p></blockquote><h2 id=chapter-1从-0-到-1 class=headerLink><a href=#chapter-1%e4%bb%8e-0-%e5%88%b0-1 class=header-mark></a>1 Chapter 1：从 0 到 1</h2><h3 id=11-大纲 class=headerLink><a href=#11-%e5%a4%a7%e7%ba%b2 class=header-mark></a>1.1 1.1 大纲</h3><blockquote><p>这一章主要为导引内容，比较简单，因此阅读笔记中仅介绍大纲和课后作业。</p></blockquote><ul><li>Abstraction</li><li>Dicipline</li><li>3Y&rsquo;s Deisng Dicipline<ul><li>Hierarchy</li><li>Modularity</li><li>Regularity</li></ul></li><li>Digital Abstraction：From Analog to Digital System</li><li>Number System<ul><li>Decimal Numbers</li><li>Binary Numbers</li><li>Hexdecimal Numbers</li><li>Bytes, Nibbles and All that Jazz</li><li>8 bits -> bytes</li><li>4 bits -> nibble</li><li>Data in chunks -> words -> depend on the architecture of the microprocessor</li><li>Memory size -> bytes</li><li>Communication speed -> bits/sec</li><li>Arithmetic</li><li>Unsigned numbers<ul><li>Binary Addition<ul><li>溢出判断：使用全加器时，最高位是否为 1</li></ul></li></ul></li><li>Signed Numbers<ul><li>Sign-magnitude representation</li><li>2&rsquo;s complement representation<ul><li>溢出判断：如果两数的符号位相同，最高位是否和他们不同</li></ul></li></ul></li><li>Comparison of Number System</li><li>Unsigned</li><li>Sign-Magnitude</li><li>2&rsquo;s Complement</li></ul></li><li>Logic Gates<ul><li>Or</li><li>And</li><li>Not</li><li>Buffer</li><li>Nand</li><li>Xor</li></ul></li><li>Beneath the Digital Abstraction</li><li>CMOS Transistors*</li><li>Power Consumption*</li></ul><h2 id=chapter-2组合逻辑设计 class=headerLink><a href=#chapter-2%e7%bb%84%e5%90%88%e9%80%bb%e8%be%91%e8%ae%be%e8%ae%a1 class=header-mark></a>2 Chapter 2：组合逻辑设计</h2><blockquote><p>这一章前面的布尔运算、公理和对偶式、卡诺图的使用、以及布尔代数到电路图的转换较为简单，因此不作详细说明，摆出重点公式和算法。</p></blockquote><h3 id=21-introduction class=headerLink><a href=#21-introduction class=header-mark></a>2.1 2.1 Introduction</h3><p>组合逻辑电路主要有 4 个组成部分：</p><ul><li>一个或多个输入</li><li>一个或多个输出</li><li>组合逻辑函数</li><li>表示组合逻辑延迟的时序</li></ul><h3 id=22-boolean-equations class=headerLink><a href=#22-boolean-equations class=header-mark></a>2.2 2.2 Boolean Equations</h3><h4 id=最小项 class=headerLink><a href=#%e6%9c%80%e5%b0%8f%e9%a1%b9 class=header-mark></a>2.2.1 最小项</h4><p>每个布尔变量，以原变量或者其反变量的形式，在各个<code>&</code>式中出现一次。真值表中输出为 1 的行，可以表示为所有这种<code>&</code>式的或。譬如有布尔变量<code>A</code>和<code>B</code>，其输出公式为$F(A,B)=\bar{A}B+AB$将每个<code>&</code>式表达为一个十进制的值（如 AB 对应<code>0b11</code>，其十进制的值为 3，该项就可以表示为<code>m3</code>），对他们进行<code>|</code>运算，这种表示就是最小项。其最小项公式可以表述为：</p><p>$F(A,B)=\Sigma(m1,m3)$</p><h4 id=最大项 class=headerLink><a href=#%e6%9c%80%e5%a4%a7%e9%a1%b9 class=header-mark></a>2.2.2 最大项</h4><p>找到真值表中所有输出为 0 的行，将其中为 1 的布尔变量取反，和值为 0 的布尔变量相或。将每个这样的行的值相与，得到的就是最大项。</p><h4 id=最大项和最小项的关系 class=headerLink><a href=#%e6%9c%80%e5%a4%a7%e9%a1%b9%e5%92%8c%e6%9c%80%e5%b0%8f%e9%a1%b9%e7%9a%84%e5%85%b3%e7%b3%bb class=header-mark></a>2.2.3 最大项和最小项的关系</h4><ul><li>最小项中的每一项结果都为 1，只要这些项有 1 个为 1，结果就为 1</li><li>最大项中每一项的结果都为 0，只要有一个项为 0，结果就为 0</li><li>最大项可以由最小项进行取反得到</li></ul><h3 id=23-boolean-algebra class=headerLink><a href=#23-boolean-algebra class=header-mark></a>2.3 2.3 Boolean Algebra</h3><ul><li>公理及其对偶式</li><li>单变量定理</li><li>多变量定理</li><li>真值表</li><li>简化真值表</li></ul><h3 id=24-from-logic-to-gates class=headerLink><a href=#24-from-logic-to-gates class=header-mark></a>2.4 2.4 From Logic to Gates</h3><ul><li>单输出的 Gates：单个逻辑表达式</li><li>多输出的 Gates：多个逻辑表达式</li></ul><h3 id=25-multilevel-combinational-logic class=headerLink><a href=#25-multilevel-combinational-logic class=header-mark></a>2.5 2.5 Multilevel Combinational Logic</h3><ul><li>硬件简化</li><li>Bubble Pushing</li></ul><h3 id=26-xs-and-zs-oh-my class=headerLink><a href=#26-xs-and-zs-oh-my class=header-mark></a>2.6 2.6 X&rsquo;s and Z&rsquo;s, Oh My</h3><p>X：</p><ul><li>不合法的值，如输出同时出现 1 和 0，导致冲突</li><li>电路尚未初始化的值</li><li>卡诺图中的无关项（注意区分和电路中的区别）
Z：</li><li>高阻态，非 0 也非 1</li><li>多见于三态门</li></ul><h3 id=27-karnaugh-maps class=headerLink><a href=#27-karnaugh-maps class=header-mark></a>2.7 2.7 Karnaugh Maps</h3><ul><li>一次在卡诺图中圈出一个大小为 1，2，4，8（或其他 2 的倍数）的块</li><li>每个圈都代表一个逻辑表达式</li><li>卡诺图的上下，左右的边缘相连</li><li>所有逻辑表达式的和就是，电路最后的简化逻辑表达式</li></ul><h3 id=28-combinational-building-blocks class=headerLink><a href=#28-combinational-building-blocks class=header-mark></a>2.8 2.8 Combinational Building Blocks</h3><ul><li>选择器</li><li>译码器</li></ul><h3 id=29-timing class=headerLink><a href=#29-timing class=header-mark></a>2.9 2.9 Timing</h3><h4 id=propagation class=headerLink><a href=#propagation class=header-mark></a>2.9.1 Propagation</h4><ul><li>传播延迟：从输入改变 -> 输出值完全稳定下来，中间所需要的时间，一个模块从输入到输出的传播延迟取决于最长的那条路径（关键路径）</li><li>最小延迟：从输入改变 -> 输出开始改变，中间所需要的时间</li></ul><h4 id=glitches class=headerLink><a href=#glitches class=header-mark></a>2.9.2 Glitches</h4><ul><li>竞争冒险：多见于关键路径和最短路径输出的值不一样，而其值到达输出的时刻不一样，导致输出电路的值出现波动。</li><li>竞争冒险的消除可以通过向电路中增加卡诺图中的冗余项实现。冗余项来源于卡诺图中两个圈相切的部分，将相切的部分的两个圈化为一个圈，将其添加到电路中，即可消除竞争冒险。</li></ul><h2 id=chapter-3时序逻辑设计 class=headerLink><a href=#chapter-3%e6%97%b6%e5%ba%8f%e9%80%bb%e8%be%91%e8%ae%be%e8%ae%a1 class=header-mark></a>3 Chapter 3：时序逻辑设计</h2><blockquote><p>这一章的时序逻辑分析和设计较为重要，学习过程中可以参考这个油管系列视频：
<a href="https://www.youtube.com/playlist?list=PLwjK_iyK4LLCCpnnybEztvRqxpMyfgarS" target=_blank rel="noopener noreferrer">Sequential Circuits - YouTube</a></p><p>学习完成之后可以：</p><ol><li>完成华科的数字逻辑设计头歌平台所有作业</li><li>HDLBits Verilog语言学习</li><li>Vivado/Quartus Verilog编程环境配置</li><li>其他学校的数字电路实验课完成</li></ol></blockquote><h3 id=31-introduction class=headerLink><a href=#31-introduction class=header-mark></a>3.1 3.1 Introduction</h3><ul><li>组合逻辑电路的输出只和输入有关</li><li>时序逻辑电路的输出不只和输入有关，还和之前的状态相关</li><li>本章我们会<ul><li>介绍时序逻辑电路的组成</li><li>状态变量的设计</li><li>介绍状态机</li><li>时序逻辑电路的效率</li><li>提高时序逻辑电路效率的方法：并行化</li></ul></li></ul><h3 id=32-latches-and-flip-flops class=headerLink><a href=#32-latches-and-flip-flops class=header-mark></a>3.2 3.2 Latches and Flip-Flops</h3><p><img class=tw-inline loading=lazy src=/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/latch.png srcset="/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/latch_hu_525955188a57332b.webp 800w, /ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/latch_hu_e298604ce9ea1ce.webp 1200w, /ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/latch_hu_e59b593f9367da6e.webp 1600w" alt=latch height=180 width=416></p><p>上图中表示的是一个维持稳定状态的电路，为什么说它们维持稳定状态呢？</p><ul><li>对（a）中电路，如果 I2 的输入为 0，$\bar{Q}$为 1，I1 的输入为 0，又传回 I2，电路状态永远不变。当 I2 的输入为 1 时，同上。</li><li>对（b）中电路，如果 I2 的输入为 0，那么 I1 的输入为 1，Q 为 0，$\bar{Q}$为 1，电路状态保持不变；反之亦然。
在 Q 和$\bar{Q}$的值变化的过程中，可能存在其他的状态，这个情况我们在后面会进行讨论。</li></ul><p>以上的电路有 2 个状态，可以承载 1 个 bit 的信息。那么 N 个状态的电路，就可以承载$\log_{2}N$个 bit 的信息。Q 是该电路的一个有效状态，$\bar{Q}$也可以说是一个有效状态，但是我们知道它是 Q 的取反，因此知道 Q 就够了。</p><p>但是这个电路的不足在于，我们不知道他是什么状态，我们无法输入，这个问题需要修复。</p><h4 id=sr-latch class=headerLink><a href=#sr-latch class=header-mark></a>3.2.1 SR Latch</h4><p><img class=tw-inline loading=lazy src=SR%20latch.png></p><p>SR 锁存器特点：</p><ul><li>2 个输入：S 和 R</li><li>2 个输出：Q 和$\bar{Q}$</li></ul><p>SR 锁存器真值表：</p><ul><li>S=0，R=0<ul><li>N2 输出对 Q 取反，N1 输出对$\bar{Q}$取反。因为 N2 的输出原本就是$\bar{Q}$，N1 的输出原本就是 Q，因此状态不变</li></ul></li><li>S=0，R=1<ul><li>N1 输出 0（Q=0），N2 这里 Q 和 S 都是 0，因此输出 1（$\bar{Q}$=1）</li></ul></li><li>S=1，R=0<ul><li>N2 输出 0（$\bar{Q}$=0），N1 这里$\bar{Q}$和 R 都是 0，因此输出 1（$Q$=1）</li></ul></li><li>S=1，R=1<ul><li>Q 和$\bar{Q}$都输出 0，冲突，这种情况不应当存在</li></ul></li></ul><p>因为 R=1 时 Q=0，S=1 时 Q=1，因此 S 和 R 称为 Set 和 Reset。</p><p>SR 锁存器有一些问题：</p><ul><li>S 和 R 都为 1 时发生冲突，因此不应该让 SR 同时为 1</li><li>当某个输入被设置为 1 时，状态立刻改变，我们应当对这个改变的时刻加以控制。输入的改变和状态的改变，应当分开进行控制。</li></ul><h4 id=d-latch class=headerLink><a href=#d-latch class=header-mark></a>3.2.2 D Latch</h4><p><img class=tw-inline loading=lazy src=D%20latch.png></p><p>D 锁存器的出现是为了解决 SR 锁存器的上述两个问题，我们进行了两方面的调整：</p><ul><li>引入输入 D</li><li>引入时钟信号 CLK，用 CLK 的高低控制锁存器的开闭</li></ul><p>D 锁存器的工作机制和 SR 锁存器类似，当 CLK=1 时，S=$\bar{D}$，否则 SR 寄存器保持原有状态，这种机制称为<code>level-sensitive latch</code>，也就是锁存器状态取决于 CLK 为 1 时电平信号的高低。</p><p>D 锁存器也有一点小小的缺陷，也就是 CLK 为 1 时，锁存器的状态完全取决于 D 电平信号的高低。如果 D 的电平信号震荡，锁存器的状态也会随之上下改变。我们希望能够实现锁存器状态的稳定，让状态更新在一个时刻完成，而不是一段时间，要解决这个问题，下面我们引入 D 触发器。</p><h4 id=d-flip-flop class=headerLink><a href=#d-flip-flop class=header-mark></a>3.2.3 D flip-flop</h4><p><img class=tw-inline loading=lazy src=D%20flip%20flop.png alt="D flip flop"></p><p>D 触发器由两个接入相反时钟状态的 D 锁存器构成，前一个称为<code>master</code>，后一个称为<code>slave</code>。其特性在于：</p><ul><li>当 CLK=0 时，<code>master</code>打入值，<code>slave</code>的值不随<code>master</code>改变</li><li>当 CLK=1 时，<code>slave</code>打入值，<code>master</code>的值不随输入改变</li></ul><p>因此，触发器的状态主要取决于 CLK 从 0 到 1 时，实现锁存器的状态转换，而其他时刻状态不变。这样就解决了 D 锁存器状态因转换的时间过长而带来的可能的状态震荡。该触发方式也叫<code>边沿触发</code>。</p><h4 id=register class=headerLink><a href=#register class=header-mark></a>3.2.4 Register</h4><p>寄存器由多个触发器组成，可以存储多位的值，每个触发器存储 1 位的值，通过给他们连接同步的时实现。</p><h4 id=enabled-flip-flop class=headerLink><a href=#enabled-flip-flop class=header-mark></a>3.2.5 Enabled Flip-Flop</h4><p><img class=tw-inline loading=lazy src=enabled%20flip-flop.png></p><p>使能触发器在普通的 D 触发器的基础上，增加了一个 2 选 1 数据选择器。数据选择器的选择端是使能信号，两个数据信号分别是输入 D 和触发器的之前状态。</p><p>其状态如下：</p><ul><li>Enable = 1 时，使能触发器输入为 D</li><li>Enable = 0 时，使能触发器保持之前状态</li></ul><p>使能触发器相对于 D 触发器做出的改进在于：我们只有在希望的时候才打入输入，而不是在每次时钟上升沿都打入。其控制能力相比 D 触发器更上一层。</p><h4 id=resettable-flip-flop class=headerLink><a href=#resettable-flip-flop class=header-mark></a>3.2.6 Resettable Flip-Flop</h4><p><img class=tw-inline loading=lazy src=resettable%20flip-flop.png alt="resettabel flip-flop"></p><p>可复位触发器相比使能触发器的区别在于，当 reset 信号为 1 时，与门输出为 0，打入的信号为 0，状态更新为 0，实现状态复位。该设置常用于对触发器进行同步/异步复位。</p><h4 id=transistor-level-latch-and-flip-flop-designs class=headerLink><a href=#transistor-level-latch-and-flip-flop-designs class=header-mark></a>3.2.7 Transistor-Level Latch and Flip-Flop Designs*</h4><blockquote><p>此段省略。</p></blockquote><h4 id=putting-it-all-together class=headerLink><a href=#putting-it-all-together class=header-mark></a>3.2.8 Putting It All Together</h4><ul><li>D 锁存器：高电平触发</li><li>D 触发器：时钟上升沿触发</li></ul><h4 id=summary class=headerLink><a href=#summary class=header-mark></a>3.2.9 Summary</h4><p>下面我们对本章介绍的多个锁存器和触发器、以及寄存器进行介绍，最重要的是<strong>D 触发器</strong>。</p><ol><li><strong>SR 锁存器</strong>：实现了<strong>过去状态的存储</strong>，但是 SR 均为 1 时电路无效，并且无法控制状态转换的时刻</li><li><strong>D 锁存器</strong>：解决了 SR=1 时的无效状态，引入 CLK 时钟对电路进行控制，但是状态变化的间隔过长，容易导致在高电平期间，电路状态随着输入变化而持续变化，我们希望在某个时刻完成状态转换，然后保持其不变</li><li><strong>D 触发器</strong>：采用<code>master-slave</code>结构，<code>master</code>接$\bar{CLK}$，而<code>slave</code>接 CLK。<code>master</code>在低电平期间状态改变，其他时候不变。<code>slave</code>在高电平期间状态改变，其他时候不变。因此最终的结果是触发器的状态取决于时钟上升沿。但是在每次时钟上升沿，电路的状态都会随着输入的状态改变。因此我们希望设置一下电路是接受输入，还是保持状态不变</li><li><strong>D 使能触发器</strong>：在 D 触发器的基础上增加一个数据选择器，利用使能信号来选择下一个时钟上升沿，打入<code>slave</code>的值是新的输入，还是电路之前的状态</li><li><strong>D 复位触发器</strong>：将 D 触发器的输入和$\bar{RESET}$进行与操作，如果<code>RESET = 1</code>，那么$\bar{RESET} = 0$，输入为 0，实现了触发器的复位</li><li><strong>寄存器</strong>：由多个触发器构成，每个触发器接的是相同的时钟</li></ol><h3 id=33-synchronous-logic-design class=headerLink><a href=#33-synchronous-logic-design class=header-mark></a>3.3 3.3 Synchronous Logic Design</h3><h4 id=331-some-problematic-circuits class=headerLink><a href=#331-some-problematic-circuits class=header-mark></a>3.3.1 3.3.1 Some Problematic Circuits</h4><ol><li>以一段时间为周期的周期性震荡的电路
<img class=tw-inline loading=lazy src=3%20inverter%20loop.png alt="3 inverter loop"></li><li>存在因电路延迟带来的竞争冒险的电路
<img class=tw-inline loading=lazy src=race%20circuit.png alt="race circuits"></li></ol><h4 id=332-synchronous-sequential-circuits class=headerLink><a href=#332-synchronous-sequential-circuits class=header-mark></a>3.3.2 3.3.2 Synchronous Sequential Circuits</h4><p>上述电路出现问题的原因：电路中出现了环路</p><p>如何消除环路？通过向环路中间加入寄存器，将环路转化成多个段，每个寄存器都由触发器组成，在时钟上升沿触发，因此我们说该电路是时钟同步电路，以此为基础，我们设计了时序逻辑电路。</p><p>时序逻辑电路有 5 个组成要素：</p><ul><li>多个中间状态</li><li>输入</li><li>输出</li><li>组合逻辑函数</li><li>时序，即一个同步的 CLK<ul><li>时钟上升沿 -> 输出开始变化：$T_{setup}$</li><li>时钟上升沿 -> 输出值稳定：$T_{hold}$</li></ul></li></ul><p>时序逻辑电路的特点在于：</p><ul><li>由寄存器（触发器，不是锁存器）和组合逻辑电路组成</li><li>至少有一个寄存器（触发器，不是锁存器）</li><li>所有寄存器接受相同的时钟信号（不可以有延迟）</li><li>每个环路至少有一个寄存器</li></ul><h4 id=333-synchronous-and-asynchronous-circuits class=headerLink><a href=#333-synchronous-and-asynchronous-circuits class=header-mark></a>3.3.3 3.3.3 Synchronous and Asynchronous Circuits</h4><p>异步时序逻辑电路比同步时序逻辑电路更常见，但是更复杂。这里不详述。</p><h3 id=34-finite-state-machines class=headerLink><a href=#34-finite-state-machines class=header-mark></a>3.4 3.4 Finite State Machines</h3><p>时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分：</p><ul><li>M 个输入</li><li>N 个输出</li><li>k 位的状态（因此电路一共可以有$2^{k}$个状态）</li><li>一个时钟</li></ul><p>时序逻辑电路又分两种：</p><ul><li>Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定</li><li>Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定</li></ul><p><img class=tw-inline loading=lazy src=Moore%20&%20Mealy.png alt="Moore and Mealy"></p><h4 id=341-fsm-design-example class=headerLink><a href=#341-fsm-design-example class=header-mark></a>3.4.1 3.4.1 FSM Design Example</h4><blockquote><p>下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。</p></blockquote><h5 id=步骤一明确问题背景 class=headerLink><a href=#%e6%ad%a5%e9%aa%a4%e4%b8%80%e6%98%8e%e7%a1%ae%e9%97%ae%e9%a2%98%e8%83%8c%e6%99%af class=header-mark></a>3.4.1.1 步骤一：明确问题背景</h5><ol><li>十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为<code>True</code>代表有学生，输出为<code>False</code>代表道路空</li><li>两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出<code>红</code>，<code>绿</code>，还是<code>黄</code></li><li>每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态</li><li>控制器还有一个 reset 按钮来实现复位</li></ol><p>交通灯概念图设计如下：</p><p><img class=tw-inline loading=lazy src=traffic%20light%20concept.png></p><p>交通灯接口设计如下：</p><p><img class=tw-inline loading=lazy src=/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/api.png srcset="/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/api_hu_2c45d879eb536291.webp 800w, /ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/api_hu_b1f5a830cd77906a.webp 1200w, /ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/api_hu_1cc48c9b50de0dea.webp 1600w" height=225 width=298></p><h5 id=步骤二绘制状态转换图 class=headerLink><a href=#%e6%ad%a5%e9%aa%a4%e4%ba%8c%e7%bb%98%e5%88%b6%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2%e5%9b%be class=header-mark></a>3.4.1.2 步骤二：绘制状态转换图</h5><p>电路状态转换过程分析如下：</p><ol><li>状态的初始值（复位状态）如下：<strong>A 路绿，B 路红</strong></li><li>如果$T_{A}$为<code>True</code>，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红</li><li><strong>A 路黄，B 路红</strong>时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿</li><li><strong>A 路红，B 路绿</strong>时，如果$T_{B}$为<code>True</code>，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色</li><li><strong>A 路红，B 路进入黄色</strong>时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红</li></ol><p>根据以上分析，电路可以划分为以下几个状态：</p><ol><li>A 路绿，B 路红：$T_{A}$为<code>True</code>时保持，否则进入状态 2</li><li>A 路黄，B 路红：5 秒后进入状态 3</li><li>A 路红，B 路绿：$T_{B}$为<code>True</code>时保持，否则进入状态 4</li><li>A 路红，B 路黄：5 秒后进入状态 1
<img class=tw-inline loading=lazy src=state%20transition%20diagram.png alt=状态转换图>
电路转换的时机是时钟上升沿</li></ol><h5 id=步骤三绘制状态转换表 class=headerLink><a href=#%e6%ad%a5%e9%aa%a4%e4%b8%89%e7%bb%98%e5%88%b6%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2%e8%a1%a8 class=header-mark></a>3.4.1.3 步骤三：绘制状态转换表</h5><p>我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样：</p><ul><li>状态表示：这里我们用 S0，S1，S2，S3 来表示</li><li>状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图）</li></ul><p>状态转换表的每行有 3 项：</p><ul><li>该状态</li><li>输入</li><li>下一状态</li></ul><p>绘制状态转换表如下：</p><div class=table-wrapper><table><thead><tr><th style=text-align:>当前状态</th><th style=text-align:>输入$T_{A}$</th><th style=text-align:>输入$T_{B}$</th><th style=text-align:>下一状态</th></tr></thead><tbody><tr><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>X</td><td style=text-align:>S1</td></tr><tr><td style=text-align:>S0</td><td style=text-align:>1</td><td style=text-align:>X</td><td style=text-align:>S0</td></tr><tr><td style=text-align:>S1</td><td style=text-align:>X</td><td style=text-align:>X</td><td style=text-align:>S2</td></tr><tr><td style=text-align:>S2</td><td style=text-align:>X</td><td style=text-align:>0</td><td style=text-align:>S3</td></tr><tr><td style=text-align:>S2</td><td style=text-align:>X</td><td style=text-align:>1</td><td style=text-align:>S2</td></tr><tr><td style=text-align:>S3</td><td style=text-align:>X</td><td style=text-align:>X</td><td style=text-align:>S0</td></tr></tbody></table></div><h5 id=步骤四对状态进行二进制编码 class=headerLink><a href=#%e6%ad%a5%e9%aa%a4%e5%9b%9b%e5%af%b9%e7%8a%b6%e6%80%81%e8%bf%9b%e8%a1%8c%e4%ba%8c%e8%bf%9b%e5%88%b6%e7%bc%96%e7%a0%81 class=header-mark></a>3.4.1.4 步骤四：对状态进行二进制编码</h5><p>状态分为：S0，S1，S2，S3</p><div class=table-wrapper><table><thead><tr><th style=text-align:>状态</th><th style=text-align:>$S_{1}$</th><th style=text-align:>$S_{0}$</th></tr></thead><tbody><tr><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S1</td><td style=text-align:>0</td><td style=text-align:>1</td></tr><tr><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S3</td><td style=text-align:>1</td><td style=text-align:>1</td></tr></tbody></table></div><h5 id=步骤五对输出进行二进制编码 class=headerLink><a href=#%e6%ad%a5%e9%aa%a4%e4%ba%94%e5%af%b9%e8%be%93%e5%87%ba%e8%bf%9b%e8%a1%8c%e4%ba%8c%e8%bf%9b%e5%88%b6%e7%bc%96%e7%a0%81 class=header-mark></a>3.4.1.5 步骤五：对输出进行二进制编码</h5><p>输出分为：红、黄、绿</p><div class=table-wrapper><table><thead><tr><th style=text-align:>输出</th><th style=text-align:>$L_{1}$</th><th style=text-align:>$L_{0}$</th></tr></thead><tbody><tr><td style=text-align:>绿</td><td style=text-align:>0</td><td style=text-align:>0</td></tr><tr><td style=text-align:>黄</td><td style=text-align:>0</td><td style=text-align:>1</td></tr><tr><td style=text-align:>红</td><td style=text-align:>1</td><td style=text-align:>0</td></tr></tbody></table></div><h5 id=步骤六确定状态与输入关系表将状态编码嵌入到状态转换表 class=headerLink><a href=#%e6%ad%a5%e9%aa%a4%e5%85%ad%e7%a1%ae%e5%ae%9a%e7%8a%b6%e6%80%81%e4%b8%8e%e8%be%93%e5%85%a5%e5%85%b3%e7%b3%bb%e8%a1%a8%e5%b0%86%e7%8a%b6%e6%80%81%e7%bc%96%e7%a0%81%e5%b5%8c%e5%85%a5%e5%88%b0%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2%e8%a1%a8 class=header-mark></a>3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表）</h5><div class=table-wrapper><table><thead><tr><th style=text-align:>当前状态</th><th style=text-align:>$S_{1}$</th><th style=text-align:>$S_{0}$</th><th style=text-align:>输入$T_{A}$</th><th style=text-align:>输入$T_{B}$</th><th style=text-align:>下一状态</th><th style=text-align:>$S_{1}$</th><th style=text-align:>$S_{0}$</th></tr></thead><tbody><tr><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>X</td><td style=text-align:>S1</td><td style=text-align:>0</td><td style=text-align:>1</td></tr><tr><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>X</td><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S1</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>X</td><td style=text-align:>X</td><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>X</td><td style=text-align:>0</td><td style=text-align:>S3</td><td style=text-align:>1</td><td style=text-align:>1</td></tr><tr><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>X</td><td style=text-align:>1</td><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S3</td><td style=text-align:>1</td><td style=text-align:>1</td><td style=text-align:>X</td><td style=text-align:>X</td><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td></tr></tbody></table></div><h5 id=步骤七确定状态与输出的关系表根据电路分析状态编码和输出编码 class=headerLink><a href=#%e6%ad%a5%e9%aa%a4%e4%b8%83%e7%a1%ae%e5%ae%9a%e7%8a%b6%e6%80%81%e4%b8%8e%e8%be%93%e5%87%ba%e7%9a%84%e5%85%b3%e7%b3%bb%e8%a1%a8%e6%a0%b9%e6%8d%ae%e7%94%b5%e8%b7%af%e5%88%86%e6%9e%90%e7%8a%b6%e6%80%81%e7%bc%96%e7%a0%81%e5%92%8c%e8%be%93%e5%87%ba%e7%bc%96%e7%a0%81 class=header-mark></a>3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码）</h5><div class=table-wrapper><table><thead><tr><th style=text-align:>状态</th><th style=text-align:>$S_{1}$</th><th style=text-align:>$S_{0}$</th><th style=text-align:>$L_{A1}$</th><th style=text-align:>$L_{A0}$</th><th style=text-align:>$L_{B1}$</th><th style=text-align:>$L_{B0}$</th></tr></thead><tbody><tr><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S1</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>1</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S3</td><td style=text-align:>1</td><td style=text-align:>1</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>1</td></tr></tbody></table></div><h5 id=步骤八写出状态表达式 class=headerLink><a href=#%e6%ad%a5%e9%aa%a4%e5%85%ab%e5%86%99%e5%87%ba%e7%8a%b6%e6%80%81%e8%a1%a8%e8%be%be%e5%bc%8f class=header-mark></a>3.4.1.8 步骤八：写出状态表达式</h5><p>我们使用$S’$来表示下一时刻的状态，可以如下表示：</p><p>$$
S_{1}&rsquo; = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B}
$$</p><p>$$
S_{0}&rsquo; = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B}
$$</p><h5 id=步骤九写出输出表达式 class=headerLink><a href=#%e6%ad%a5%e9%aa%a4%e4%b9%9d%e5%86%99%e5%87%ba%e8%be%93%e5%87%ba%e8%a1%a8%e8%be%be%e5%bc%8f class=header-mark></a>3.4.1.9 步骤九：写出输出表达式</h5><p>$$
L_{A1} = S_{1}L_{A0} = S_{1}S_{0}
$$</p><p>$$
L_{B1} = S_{1}L_{B0} = S_{1}S_{0}
$$</p><h5 id=步骤十画出电路图 class=headerLink><a href=#%e6%ad%a5%e9%aa%a4%e5%8d%81%e7%94%bb%e5%87%ba%e7%94%b5%e8%b7%af%e5%9b%be class=header-mark></a>3.4.1.10 步骤十：画出电路图</h5><ol><li><p>设计寄存器
<img class=tw-inline loading=lazy src=state%20register.png alt=状态寄存器>
状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。</p></li><li><p>添加状态与输入关系电路
<img class=tw-inline loading=lazy src=next%20state%20logic.png></p></li><li><p>添加状态与输出关系电路
<img class=tw-inline loading=lazy src=state%20machine.png></p></li></ol><h4 id=342-state-encodings class=headerLink><a href=#342-state-encodings class=header-mark></a>3.4.2 3.4.2 State Encodings</h4><blockquote><p>状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding）</p></blockquote><h5 id=binary-encoding class=headerLink><a href=#binary-encoding class=header-mark></a>3.4.2.1 Binary Encoding</h5><p>N 个编码只需要$log_{2}N$位就可以表示。</p><h5 id=one-hot-encoding class=headerLink><a href=#one-hot-encoding class=header-mark></a>3.4.2.2 One-hot Encoding</h5><p>N 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。</p><h5 id=设计示例13进制计数器 class=headerLink><a href=#%e8%ae%be%e8%ae%a1%e7%a4%ba%e4%be%8b13%e8%bf%9b%e5%88%b6%e8%ae%a1%e6%95%b0%e5%99%a8 class=header-mark></a>3.4.2.3 设计示例1：3进制计数器</h5><p>设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0</p><h6 id=背景分析 class=headerLink><a href=#%e8%83%8c%e6%99%af%e5%88%86%e6%9e%90 class=header-mark></a>3.4.2.3.1 背景分析</h6><p>根据分析，电路存在3个状态：</p><ul><li>S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1</li><li>S1：输出为0，下一时刻跳转到S2</li><li>S2：输出为0，下一时刻跳转到S0</li></ul><p>电路状态转换图如下：</p><p><img class=tw-inline loading=lazy src=divide%20by%203%20state%20diagram.png></p><h6 id=状态转换图绘制 class=headerLink><a href=#%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2%e5%9b%be%e7%bb%98%e5%88%b6 class=header-mark></a>3.4.2.3.2 状态转换图绘制</h6><p><img class=tw-inline loading=lazy src=divide%20by%203%20state%20diagram.png></p><p>状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。</p><h6 id=采用二进制编码设计 class=headerLink><a href=#%e9%87%87%e7%94%a8%e4%ba%8c%e8%bf%9b%e5%88%b6%e7%bc%96%e7%a0%81%e8%ae%be%e8%ae%a1 class=header-mark></a>3.4.2.3.3 采用二进制编码设计</h6><ol><li>状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。</li></ol><div class=table-wrapper><table><thead><tr><th style=text-align:>状态</th><th style=text-align:>$S_{1}$</th><th style=text-align:>$S_{0}$</th></tr></thead><tbody><tr><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S1</td><td style=text-align:>0</td><td style=text-align:>1</td></tr><tr><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td></tr></tbody></table></div><ol><li>输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示</li><li>状态转换表</li></ol><div class=table-wrapper><table><thead><tr><th style=text-align:>状态</th><th style=text-align:>$S_{1}$</th><th style=text-align:>$S_{0}$</th><th style=text-align:>下一状态</th><th style=text-align:>$S_{1}'$</th><th style=text-align:>$S_{0}'$</th></tr></thead><tbody><tr><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>S1</td><td style=text-align:>0</td><td style=text-align:>1</td></tr><tr><td style=text-align:>S1</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td></tr></tbody></table></div><p>由图我们可以得到状态表达式，下一时刻的状态用$S&rsquo;$表示。</p><p>$$
S_{1}&rsquo; = \bar{S_{1}}S_{0}
$$</p><p>$$
S_{0}&rsquo; = \bar{S_{1}}\bar{S_{0}}
$$</p><ol><li>状态与输出关系表</li></ol><div class=table-wrapper><table><thead><tr><th style=text-align:>状态</th><th style=text-align:>$S_{1}$</th><th style=text-align:>$S_{0}$</th><th style=text-align:>输出Y</th></tr></thead><tbody><tr><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>1</td></tr><tr><td style=text-align:>S1</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>0</td></tr></tbody></table></div><p>由图我们可以得到输出与状态的关系式：</p><p>$$
Y=\bar{S_{1}}\bar{S_{0}}
$$</p><ol><li>电路图设计</li></ol><p><img class=tw-inline loading=lazy src=binary%20encoding.png></p><h6 id=采用独热编码设计 class=headerLink><a href=#%e9%87%87%e7%94%a8%e7%8b%ac%e7%83%ad%e7%bc%96%e7%a0%81%e8%ae%be%e8%ae%a1 class=header-mark></a>3.4.2.3.4 采用独热编码设计</h6><ol><li>状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。</li></ol><div class=table-wrapper><table><thead><tr><th style=text-align:>状态</th><th style=text-align:>$S_{2}$</th><th style=text-align:>$S_{1}$</th><th style=text-align:>$S_{0}$</th></tr></thead><tbody><tr><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>1</td></tr><tr><td style=text-align:>S1</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>0</td></tr></tbody></table></div><ol><li>输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示</li><li>状态转换表</li></ol><div class=table-wrapper><table><thead><tr><th style=text-align:>状态</th><th style=text-align:>$S_{2}$</th><th style=text-align:>$S_{1}$</th><th style=text-align:>$S_{0}$</th><th style=text-align:>下一时刻状态</th><th style=text-align:>$S_{2}'$</th><th style=text-align:>$S_{1}'$</th><th style=text-align:>$S_{0}'$</th></tr></thead><tbody><tr><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>S1</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S1</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>1</td></tr></tbody></table></div><p>由图我们可以得到状态表达式：</p><p>$$
S_{1}&rsquo; = S{0}
$$</p><p>$$
S_{2}&rsquo; = S{1}
$$</p><p>$$
S_{0}&rsquo; = S{2}
$$</p><ol><li>状态与输出关系表</li></ol><div class=table-wrapper><table><thead><tr><th style=text-align:>状态</th><th style=text-align:>$S_{2}$</th><th style=text-align:>$S_{1}$</th><th style=text-align:>$S_{0}$</th><th style=text-align:>输出Y</th></tr></thead><tbody><tr><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>1</td></tr><tr><td style=text-align:>S1</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>0</td></tr></tbody></table></div><p>由此我们可以得到状态与输出表达式：$Y=S_{0}$</p><ol><li>电路设计</li></ol><p>通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下：</p><p><img class=tw-inline loading=lazy src=one%20hot%20encoding.png></p><h5 id=设计示例23进制累加器 class=headerLink><a href=#%e8%ae%be%e8%ae%a1%e7%a4%ba%e4%be%8b23%e8%bf%9b%e5%88%b6%e7%b4%af%e5%8a%a0%e5%99%a8 class=header-mark></a>3.4.2.4 设计示例2：3进制累加器</h5><p>设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。</p><h6 id=背景分析-1 class=headerLink><a href=#%e8%83%8c%e6%99%af%e5%88%86%e6%9e%90-1 class=header-mark></a>3.4.2.4.1 背景分析</h6><p>根据分析，电路存在3个状态：</p><ul><li>S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0</li><li>S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0</li><li>S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0</li><li>S3：输入3个3时，输出为1。下一状态为S0</li></ul><h6 id=状态转换图绘制-1 class=headerLink><a href=#%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2%e5%9b%be%e7%bb%98%e5%88%b6-1 class=header-mark></a>3.4.2.4.2 状态转换图绘制</h6><p><img class=tw-inline loading=lazy src=/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/counter.png srcset="/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/counter_hu_1c64c8d1a7101fc5.webp 800w, /ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/counter_hu_6519e11d834a8eb6.webp 1200w, /ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/counter_hu_84e9a59484e3cfe4.webp 1600w" height=516 width=1262></p><h6 id=状态转换表绘制 class=headerLink><a href=#%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2%e8%a1%a8%e7%bb%98%e5%88%b6 class=header-mark></a>3.4.2.4.3 状态转换表绘制</h6><div class=table-wrapper><table><thead><tr><th style=text-align:>状态</th><th style=text-align:>$S_{1}$</th><th style=text-align:>$S_{0}$</th><th style=text-align:>输入T</th><th style=text-align:>下一时刻状态</th><th style=text-align:>$S_{1}'$</th><th style=text-align:>$S_{0}'$</th><th style=text-align:>输出</th></tr></thead><tbody><tr><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>S1</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S1</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S1</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>1</td><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td><td style=text-align:>1</td><td style=text-align:>S3</td><td style=text-align:>1</td><td style=text-align:>1</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S3</td><td style=text-align:>1</td><td style=text-align:>1</td><td style=text-align:>X</td><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td><td style=text-align:>1</td></tr></tbody></table></div><h6 id=二进制编码实现 class=headerLink><a href=#%e4%ba%8c%e8%bf%9b%e5%88%b6%e7%bc%96%e7%a0%81%e5%ae%9e%e7%8e%b0 class=header-mark></a>3.4.2.4.4 二进制编码实现</h6><ol><li>状态编码：状态有4个，因此使用2位二进制数进行编码</li></ol><div class=table-wrapper><table><thead><tr><th style=text-align:>状态</th><th style=text-align:>$S_{1}$</th><th style=text-align:>$S_{0}$</th></tr></thead><tbody><tr><td style=text-align:>S0</td><td style=text-align:>0</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S1</td><td style=text-align:>0</td><td style=text-align:>1</td></tr><tr><td style=text-align:>S2</td><td style=text-align:>1</td><td style=text-align:>0</td></tr><tr><td style=text-align:>S3</td><td style=text-align:>1</td><td style=text-align:>1</td></tr></tbody></table></div><ol><li><p>输入编码：输入只有1个，因此使用1位二进制数表示</p></li><li><p>输出编码：输出只有1个，因此使用1位二进制数表示</p></li><li><p>状态转换表达式
$S_{1}&rsquo;=\bar{S_{1}}S_{0}T + S_{1}\bar{S_{0}}T$
$S_{0}&rsquo;=\bar{S_{0}}$</p></li><li><p>输出表达式：$Y=S_{1}S_{0}$</p></li></ol><blockquote><p>此处不画电路图。</p></blockquote><h4 id=343-moore-and-mealy-machines class=headerLink><a href=#343-moore-and-mealy-machines class=header-mark></a>3.4.3 3.4.3 Moore and Mealy Machines</h4><blockquote><p>详细的案例可见教材P132面蜗牛爬行问题。</p></blockquote><p>Mealy型电路相比Moore型电路的主要区别在于，它的输出不仅取决于之前的状态，还取决于输入。通常在设计Mealy型电路的状态转换图时，我们会使用较少的状态，将状态之间的输入和输出用<code>输入/输出</code>的方式写在状态转换弧线上。此外，因为输出跟输入有关，因此有时我们会直接用与门来确定输出。这样做带来的好处是，相比Moore型电路中，一定要等到状态确定才能确定输出，Mealy型电路的输出少了一个触发器（寄存器）的延迟。</p><p><img class=tw-inline loading=lazy src=Moore%20Mealy.png></p><h4 id=344-factoring-state-machines class=headerLink><a href=#344-factoring-state-machines class=header-mark></a>3.4.4 3.4.4 Factoring State Machines</h4><p>当遇到比较复杂的问题时，我们需要将问题分解为多个状态机，将一个状态机的输出作为另一个状态机的输入，而不是使用一个状态机解决。这种做法会带来相当程度的简化。</p><p><img class=tw-inline loading=lazy src=factor%20state%20machine.png></p><p><img class=tw-inline loading=lazy src=state%20machine%20comparsion.png></p><h4 id=345-deriving-an-fsm-from-a-schematic class=headerLink><a href=#345-deriving-an-fsm-from-a-schematic class=header-mark></a>3.4.5 3.4.5 Deriving an FSM from a Schematic</h4><blockquote><p>本节介绍如何由时序逻辑电路电路还原状态机，并且分析电路功能，这节的内容主要在于对电路的逆向工程。详细的案例可参考课本P137</p></blockquote><ul><li>分析电路的输入、输出、状态位</li><li>写出状态转换逻辑表达式，和输出逻辑表达式</li><li>根据表达式构建状态转换真值表，输出逻辑真值表</li><li>消除真值表中不存在的状态项（因为如果使用二进制表示法编码的话，二进制位可以产生的状态个数可能会大于实际需要的状态个数）</li><li>给每个有效状态分配一个状态名</li><li>将原来的状态转换表和输出表中的二进制编码替换为状态名</li><li>画出状态转换图</li><li>语言描述状态机的用途</li></ul><h4 id=346-fsm-review class=headerLink><a href=#346-fsm-review class=header-mark></a>3.4.6 3.4.6 FSM Review</h4><blockquote><p>本节介绍如何实现一个时序逻辑电路。</p></blockquote><ul><li>确定输入和输出</li><li>画出状态转换图</li><li>对于Moore型电路<ul><li>写出状态转换表</li><li>写出输出逻辑表</li></ul></li><li>对于Mealy型电路<ul><li>写出一个状态转换表，其中合并了状态转换和输出</li></ul></li><li>选择状态编码</li><li>写出状态转换逻辑函数和输出逻辑函数</li><li>画出电路图</li></ul><h3 id=35-timing-of-sequential-logic class=headerLink><a href=#35-timing-of-sequential-logic class=header-mark></a>3.5 3.5 Timing of Sequential Logic</h3><blockquote><p>这一段写得非常绕，但是我在找了几个油管的视频之后理解了，视频链接如下：
<img class=tw-inline loading=lazy src='https://www.youtube.com/watch?v=lsxh_GfR6s4' alt="62 - Sequential Circuits Timing Analysis (youtube.com)">
<img class=tw-inline loading=lazy src='https://www.youtube.com/watch?v=3t8ndX2hqHA&pp=ygUZc2VxdWVudGlhbCBjaXJjdWl0IHRpbWluZw%3D%3D'></p></blockquote><p>首先，我们需要了解一个原则，就是CLK时钟从0到1的变化，并不是突然之间产生的，而是经过一个短暂的阶梯型变化过程。从第一章的内容我们可以知道，模拟电路到数字电路的转换之前，需要对高电平和低电平进行定义。在某个电压之上，我们将其状态定义为高电平；在某个电压之下，我们将其定义为低电平；而在这之间，电平处于无效状态。</p><p>触发器的状态更新，就是发生在时钟上升沿。但是触发器并不是一个单一的部件，其由内部多个逻辑门所构成。如D触发器的结构如下：</p><p><img class=tw-inline loading=lazy src=D%20flip%20flop.png></p><p>在CLK位于低电平时，输入从D到N1，需要经过一个D锁存器。从N1到Q，需要经过一个D锁存器。我们需要保证触发器中的值（也就是<code>slave</code>锁存器中的值）是稳定的，那么就要求从D输入到N1，以及N1输入到Q的过程中，这个值保持稳定。从D输入到N1的时间，我们称为<code>setup time</code>；从N1到Q的时间，我们称为<code>hold time</code>。也就是说，输入必须在<code>setup time + hold time</code>期间内，保持稳定。不稳定所带来的情况，我们将在<code>3.5.4 Metastability</code>一节中讨论。</p><blockquote><p><code>setup time</code>和<code>hold time</code>之和也叫<code>aperture time</code></p></blockquote><h4 id=351-the-dynamic-discipline class=headerLink><a href=#351-the-dynamic-discipline class=header-mark></a>3.5.1 3.5.1 The Dynamic Discipline</h4><p><img class=tw-inline loading=lazy src=path%20between%20registers%20and%20timing%20diagram.png></p><p>结合上述电路图，我们阐述几个重要的时间：</p><ul><li>contamination delay（$t_{ccq}$）：从上升沿获取输入，到得到Q1输出的最短时间</li><li>propagation delay（$t_{pcq}$）：从上升沿获取输入，到得到Q1输出的最长时间</li><li>setup time：在CLK上升沿之前，输入至少保持<code>setup time</code></li><li>hold time：在CLK上升沿之后，输入至少保持<code>hold time</code></li><li>组合逻辑电路的延迟（$t_{pd}$）：值从Q1到Q2的最大时间</li></ul><h4 id=352-system-timing class=headerLink><a href=#352-system-timing class=header-mark></a>3.5.2 3.5.2 System Timing</h4><p>在对电路的时序进行分析之前，我们需要明确两个值：$T_{c}$和$f_{c}$。前者是指两个时钟上升沿之间的时间间隔，也叫时钟周期。后者是前者的倒数，是时钟频率。时钟频率的增加，可以带来吞吐量的增加。时钟频率的单位包括：<code>Hz</code>，<code>MHz</code>和<code>GHz</code>。其单位换算如下：</p><ul><li>1 megahertz (MHz) = 106 Hz</li><li>1 gigahertz (GHz) = 109 Hz.</li></ul><p>结合上述电路块的结构分析，一个电路的值传递有如下几个阶段：</p><ul><li>从输入，经过触发器R1，到Q1</li><li>从Q1，经过组合逻辑电路，到D2</li><li>从D2输入到触发器R2</li></ul><h5 id=setup-time-constraint class=headerLink><a href=#setup-time-constraint class=header-mark></a>3.5.2.1 Setup Time Constraint</h5><blockquote><p>在对约束条件进行分析时，我们采用<code>worst case analysis</code>，也就是分析极限情况下的边界条件。需要注意的是<code>setup time constraint</code>指的不是<code>setup time</code>，而是对组合逻辑电路最大值的限制，因为组合逻辑部分是这个电路唯一可以优化的部分。</p></blockquote><p>对电路<code>setup time</code>的约束主要在于触发器R2。分析如下：</p><ul><li>在时钟上升沿后，触发器R1的值最多需要经过$t_{pcq}$才能到达Q1</li><li>Q1的值最多需要经过$t_{pd}$才能到达D2</li><li>总的时钟周期为$T_{c}$</li></ul><p>而D2输入必须满足<code>setup time</code>的要求，也就是说：</p><ul><li>D2的输入必须至少在时钟上升沿前$t_{setup}$刻开始保持稳定，即组合逻辑电路的值必须在$T_{c} - t_{setup}$时刻或之前抵达D2</li></ul><p>综上分析，我们可以得出以下公式：</p><p>$t_{pcq}+t_{pd}&lt;=T_{c}-t_{setup}$</p><p>通过移项运算，我们可以得到如下公式：</p><p>$$
T_{c} >= t_{pcq}+t_{pd}+t_{setup}
$$</p><p>那么，$T_{c}$的值至少为$t_{pcq}+t_{pd}+t_{setup}$，那么$f_{c}$的值最大为</p><p>$$
f_{c} = \frac{1}{t_{pcq}+t_{pd}+t_{setup}}
$$</p><p>通过这个公式，我们可以了解到，该电路的主要可优化部分为组合逻辑部分，$t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ 称为<code>setup time constraint</code>。</p><h5 id=hold-time-constraint class=headerLink><a href=#hold-time-constraint class=header-mark></a>3.5.2.2 Hold Time Constraint</h5><p>对于<code>hold time</code>的约束条件探索，我们同样采用取极端情况的情况，就是不考虑组合逻辑（其延迟为0）。</p><p>对于R2的输入D2，其之前的值需要保存$t_{hold}$个单位的时间。但是从R1过来的值，最短只需要$t_{ccq}+t_{cd}$个时刻就能到达，因此可以得出以下表达式：</p><p>$$
t_{ccq}+t_{cd}>=t_{hold}
$$</p><p>因此，可以得出如下表达式：</p><p>$$
t_{cd} ≥ t_{hold}-t_{ccq}
$$</p><p>组合逻辑电路延迟的最小值是 $t_{hold}-t{ccq}$。当两个触发器直接相接的时候，$t_{ccq}=0$，那么要求$t_{hold}&lt;=t_{ccq}$。通常情况下我们默认$t_{hold}=0$，那么上述不等于恒成立。但是如果该条件不成立，我们就需要增加$t_{ccq}$，这需要对电路进行大量的修改，并且耗费巨大的资金，因此我们在设计电路时需要谨慎地考虑$t_{hold}$约束。</p><h5 id=putting-it-all-together-1 class=headerLink><a href=#putting-it-all-together-1 class=header-mark></a>3.5.2.3 Putting It All Together</h5><blockquote><p>时序分析案例见课本P145面</p></blockquote><p>两条约束原则：</p><ul><li>$t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$</li><li>$t_{cd} ≥ t_{hold}-t_{ccq}$</li></ul><p>修复<code>hold time violation</code>，可以用加buffer的方式。但是要注意的是，有的时候加了Buffer后会改变关键路径，从而改变<code>setup time</code>的约束情况。</p><h4 id=353-clock-skew class=headerLink><a href=#353-clock-skew class=header-mark></a>3.5.3 3.5.3 Clock Skew</h4><blockquote><p>这一段也不太好理解，尤其是hold time的部分，我参考了以下油管视频：
<img class=tw-inline loading=lazy src='https://www.youtube.com/watch?v=q135Lw-RiHY' alt="64 - Clock Skew - YouTube">
<img class=tw-inline loading=lazy src='https://www.youtube.com/watch?v=bxEJqzMziz0' alt="Impact of Skew on Hold time violation (youtube.com)"></p></blockquote><p><code>Clock skew</code>的含义是：对各个触发器时钟上升沿到达的时间不一致。</p><p>产生clock skew的原因包括：</p><ul><li>通往多个clock的线的长度不一致</li><li>噪声（<code>Noise</code>）</li><li><code>clock gating</code></li></ul><p>在讲解<code>Clock Skew</code>之前，我们需要再看一下电路图：</p><p><img class=tw-inline loading=lazy src=D%20flip%20flop.png></p><p>对于一个触发器，<code>master</code>的CLK是通过<code>slave</code>的CLK取反得到的，因此这个非门可能会导致两个CLK的上升沿不一致，如图：</p><p><img class=tw-inline loading=lazy src=clock%20skew.png></p><p>因CLK1比CLK2多经过1个非门，因此时钟到达CLK2的时间更早，CLK1更晚</p><h5 id=setup-time-constraint分析 class=headerLink><a href=#setup-time-constraint%e5%88%86%e6%9e%90 class=header-mark></a>3.5.3.1 setup time constraint分析</h5><p>我们从<code>worst case scenario</code>分析（这里的<code>worst case scenario</code>指的是触发器输出和组合逻辑传递都取最长时间。因为我们要探索的是，在CLK1和CLK2的时钟上升沿间隔缩短，触发器输出和组合逻辑传输时间最长的情况下，依然保证留有$t_{setup}$个单位的时间，供R2维持输入的稳定）：</p><ul><li>从CLK1的上升沿开始，R1的值经过最多$t_{pcq}$进入到Q1；</li><li>经过组合逻辑的电路的延迟$t_{pd}$，Q1传输到D2，</li><li>D2输入至少要在CLK2的上升沿前$t_{setup}$时刻达到，甚至更早</li></ul><p>也就是说，从CLK1的上升沿，至少经过$t_{pcq}+t_{pd}+t_{setup}$抵达CLK2的上升沿。而从CLK1的上升沿到CLK2的上升沿，经过的时间是$T_{c}-t_{skew}$</p><p>经过如上分析，我们可以建立不等式：</p><p>$$
T_{c} - t_{skew} >= t_{pcq} + t_{pd} + t_{setup}
$$</p><p>对其进行移位变换，我们可以得到：</p><p>$$
T_{c} >= t_{pcq} + t_{pd} + t_{setup} + t_{skew}
$$</p><p>同上，<code>setup time constraint</code>指的是组合逻辑电路的延迟限制（因为组合逻辑电路是电路中唯一一个可以优化的部分，其他的时钟频率、触发器时延、时钟时延、setup time 都是不可改变的），我们可以得到如下不等式：</p><p>$$
t_{pd} &lt;= T_{c} - (t_{pcq}+t_{setup}+t_{skew})
$$</p><h5 id=hold-time-constraint分析 class=headerLink><a href=#hold-time-constraint%e5%88%86%e6%9e%90 class=header-mark></a>3.5.3.2 hold time constraint分析</h5><p>对于<code>hold time constraint</code>，我们同样分析的是R2，R2的值必须<strong>在CLK2时钟上升沿后</strong>，R1传过来的值到达前，保持至少<code>hold time</code>个时间单位。我们依然从<code>worst case scenario</code>分析（这里与<code>setup time constraint</code>的<code>worst case</code>不同，我们需要探测从R1传输过来的时间最短的情况，必须要让<code>hold time</code>比最短的传输时间还短，否则会导致<code>hold time violation</code>）：</p><ul><li>R1的输出最少需要$t_{ccq}$个时间单位进入Q1</li><li>Q1最少需要$t_{cd}$个时间单位进入D2</li></ul><p>但是，因为有了<code>clock skew</code>。因此，哪怕信号已经到达了，而且CLK1已经经过了一个时钟周期，它也还需要再等待$t_{skew}$个单位的时间，才能进入R2。这为R2的$t_{hold}$争取到了一些额外的时间。</p><p>那么，我们就可以得到如下不等式：</p><p>$$
t_{hold} + t_{skew} &lt;= t_{ccq} + t_{cd}
$$</p><p>同上，组合逻辑电路是这个电路中唯一可以优化的部分，组合逻辑电路的时延要求如下：</p><p>$$
t_{cd} >= t_{hold} + t_{skew} - t_{ccq}
$$</p><h5 id=put-it-all-together class=headerLink><a href=#put-it-all-together class=header-mark></a>3.5.3.3 Put it all together</h5><p>在存在<code>clock skew</code>的情况下，我们得到了两个不等式，描述了对于组合逻辑延迟的约束：</p><p>$$
t_{pd} &lt;= T_{c} - (t_{pcq}+t_{setup}+t_{skew})
$$</p><p>$$
t_{cd} >= t_{hold} + t_{skew} - t_{ccq}
$$</p><p>通过如上不等式，我们可以看到，<code>clock skew</code>使得组合逻辑电路的最大值减少、最小值增加。者带来的问题是，当两个触发器直接相接（无组合逻辑电路时），$t_{cd}=0$，$t_{skew}-t{ccq}$如果大于0，哪怕$t_{hold}$等于0，都会导致<code>hold time violation</code>。因此，很多厂家会把$t_{ccq}$设计的比较大，哪怕$t_{skew}$的值有时并不大，但是一旦导致<code>hold time violation</code>，修改电路导致的各方面的损失是巨大的。</p><blockquote><p>带有<code>clock skew</code>的时序电路分析案例见课本P150面。</p></blockquote><p>对于存在<code>hold time violation</code>的电路，修复的方法包括：</p><ul><li>加buffer（关键路径也要加）</li><li>改进触发器，将<code>hold time</code>缩短</li><li>增加$t_{ccq}$</li></ul><h4 id=354-metastability class=headerLink><a href=#354-metastability class=header-mark></a>3.5.4 3.5.4 Metastability</h4><blockquote><p>这个油管视频讲的非常好：
<img class=tw-inline loading=lazy src='https://www.youtube.com/watch?v=N6piOpykbuk' alt="60 - Metastability and Synchronizers (youtube.com)"></p></blockquote><h5 id=metastable-state class=headerLink><a href=#metastable-state class=header-mark></a>3.5.4.1 Metastable State</h5><p><code>Metastability</code>指的是亚稳态，亚稳态指的是，输入在<code>setup time</code>和<code>hold time</code>内没有保持稳定，这导致输出不确定。输出可能会在0和$V_{DD}$之间（即<code>forbidden zone</code>），但是最终总会达到0或者1。</p><h5 id=resolution-time class=headerLink><a href=#resolution-time class=header-mark></a>3.5.4.2 Resolution Time</h5><p>我们把电路从亚稳态到稳态的时间记为$t_{res}$，有如下两种情况：</p><ul><li><p>输入的变化是在<code>aperture time</code>之外发生的，那么$t_{res} = t_{ccq}$</p></li><li><p>否则，时间无法估计，只能用一个概率函数表示：</p><p>$$
P(t_{res}>t) = \frac{T_{0}}{T_{c}}e^{-\frac{t}{τ}}</p></li></ul><p>$$
这个概率函数的推导在这里意义不大，因此不与呈现。但是可以看到的是，这个概率是一个以$e$为底的指数函数，并且指数是负数，那么随着$t$增大，这个概率会以指数级别的速度减小，但是它不可能为0。</p><p>从第一章的介绍中我们可以知道，模拟电路到数字电路的映射方式是，将某个电压以上均视为高电平，某个电压以下均视为低电平，中间的称为<code>forbidden zone</code>。因此，电压无需完全的达到0，只需要最终下降到一个合理的区间内即可。随着时间的推移，电路极大可能处于稳态。</p><h4 id=355-synchronizers class=headerLink><a href=#355-synchronizers class=header-mark></a>3.5.5 3.5.5 Synchronizers</h4><p>在设计电路时，有时我们需要设计多个模块，这些个模块在时钟上可能不是完全同步的。或者，我们设计了一个同步电路，但是电路的输入是随机发生的，不一定会在<code>aperture time</code>内保持稳定，但是我们需要保证输出处于稳态，这时候就需要用到同步器。一个同步器有一个输入，一个CLK时钟，和一个输出，如图所示：</p><p><img class=tw-inline loading=lazy src=/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/synchronizer.png srcset="/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/synchronizer_hu_bf787ba8fed76d0e.webp 800w, /ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/synchronizer_hu_aa9befda38c01fba.webp 1200w, /ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/synchronizer_hu_19d1ec40326f5ba9.webp 1600w" height=225 width=228></p><p>一个可能的同步器的实现就是将两个触发器直接相接，得到的电路如下：</p><p><img class=tw-inline loading=lazy src=synchronizer%20implementation.png></p><p>在上述电路中，如果输入在<code>aperture time</code>中保持稳定，那么输出自然保持稳定。如果输入不稳定，如果给的时间够长，它极大概率会在$t_{res}$内转换到稳态。</p><blockquote><p>对于无法转换到稳态的概率计算，详见课本P153面</p></blockquote><h4 id=356-derivation-of-resolution-time class=headerLink><a href=#356-derivation-of-resolution-time class=header-mark></a>3.5.6 3.5.6 Derivation of Resolution Time*</h4><blockquote><p>此节为前文$t_{res}$公式的推导，本节涉及到模拟电路的内容，此处略过。</p></blockquote><h3 id=36-parallelism class=headerLink><a href=#36-parallelism class=header-mark></a>3.6 3.6 Parallelism</h3><blockquote><p>参考了课程官方讲解视频：</p><p><img class=tw-inline loading=lazy src='https://www.youtube.com/watch?v=Udw41Ba5DR8' alt="DDCA Ch3- Part 21: Parallelism (youtube.com)"></p></blockquote><p>此节有几个重要概念：</p><ul><li>延迟（<code>latency</code>）：完成一项工作所花费的时间</li><li>吞吐量（<code>throughoutput</code>）：单位时间内完成工作的量</li></ul><p>为了提高吞吐率，我们可以采用并行（<code>parallelism</code>）的方式，<code>parallelism</code>有两种：</p><ul><li><code>spatial parallelism</code>：复制硬件</li><li><code>temporal parallelism</code>：将工作拆分为多个阶段，不同的工作可能处于不同的阶段中，即流水线</li></ul><p>量化分析，假设如下场景：</p><ul><li>一个任务的延迟是L（完成一项任务所花费的时间是L）</li><li>它的吞吐量是1/L（在单位时间内完成的工作量是1/L）</li></ul><p>对于<code>spatial parallelism</code>的系统，假设硬件复制了N份，那么：</p><ul><li>任务的延迟依然是L</li><li>它的吞吐量是N/L（同一时刻有N份硬件完成该任务）</li></ul><p>对于<code>temporal parallelism</code>的系统，假设把他划分为N个阶段，那么：</p><ul><li>任务的延迟依然是L</li><li>对于流水线，第一个任务完成所需要的时间是L，自那以后每过L/N个单位的时间，就有一项任务完成。对于$n$个任务来说，完成所需要的总时间是$L+(N-1)<em>\frac{L}{N}$，那么它的吞吐量就是$\frac{n}{L+(N-1)</em>(\frac{L}{N})}$，对该式进行化简，过程如下：
$$</li></ul><p>\frac{n}{L+(N-1)*(\frac{L}{N})} = \frac{n}{2L-\frac{L}{N}}</p><p>$$</p><p>对于流水线来说，其一个阶段的<code>时钟周期</code>，取决于这个阶段中<strong>关键路径所花的时间</strong>（也就是从上个寄存器到下个寄存器，通过最长时间的路径）；其<code>延迟</code>是指从流水线开头到流水线结尾所花费的时间；其<code>吞吐量</code>可以约等于$\frac{1}{时钟周期}$</p><p><code>temporal parallelism</code>和<code>spatial parallelism</code>相比，其优势在于其可以通过不增加硬件达到加倍的吞吐量。</p><h3 id=37-summary class=headerLink><a href=#37-summary class=header-mark></a>3.7 3.7 Summary</h3><p>本章介绍了：</p><ul><li>时序逻辑电路和组合逻辑电路的区别</li><li>多种锁存器 -> 多种触发器 -> 使能触发器和复位触发器</li><li>从状态转换图到时序逻辑电路的设计</li><li>时序逻辑电路的时序分析</li><li>多种<code>parallelism</code>：<code>spatial parallelism</code>和<code>temporal parallelism</code>的延迟和吞吐量</li></ul><h3 id=exercises class=headerLink><a href=#exercises class=header-mark></a>3.8 Exercises</h3><blockquote><p>触发器的转换方法参考链接<a href=https://www.elecfans.com/book/625/ target=_blank rel="noopener noreferrer">各类触发器的转换-数字电子技术-电子发烧友网站 (elecfans.com)</a></p></blockquote><h4 id=基础的锁存器--触发器特性 class=headerLink><a href=#%e5%9f%ba%e7%a1%80%e7%9a%84%e9%94%81%e5%ad%98%e5%99%a8--%e8%a7%a6%e5%8f%91%e5%99%a8%e7%89%b9%e6%80%a7 class=header-mark></a>3.8.1 基础的锁存器 & 触发器特性</h4><ul><li>SR锁存器<ul><li>S为set，S=1时，输出信号为1</li><li>R为reset，R=1时，输出信号为0</li><li>SR=1时，电路状态无效</li><li>SR=0时，电路状态保持不变</li></ul></li><li>D锁存器<ul><li>CLK=1时，输出Q=D</li><li>CLK=0时，输出保持不变</li></ul></li><li>D触发器<ul><li>CLK上升沿把D的值输入到Q</li><li>其他时候输出保持不变</li></ul></li></ul><h4 id=各类触发器之间的互相转换 class=headerLink><a href=#%e5%90%84%e7%b1%bb%e8%a7%a6%e5%8f%91%e5%99%a8%e4%b9%8b%e9%97%b4%e7%9a%84%e4%ba%92%e7%9b%b8%e8%bd%ac%e6%8d%a2 class=header-mark></a>3.8.2 各类触发器之间的互相转换</h4><p>没有在课本中提到的是一些其他的触发器，以及触发器的特性方程，而触发器之间的互相转换需要利用到特性方程。特性方程指的是锁存器/触发器的下一时刻输出$Q*$与输入信号之间的关系。</p><ul><li>RS触发器：输入信号R和S，输出为Q*。特性方程为$Q^{*}=S+\bar{R}Q$</li><li>D触发器：输入信号D和CLK，输出为Q*。特性方程为$Q^{*} = D$</li><li>JK触发器：功能最强大<ul><li>JK都为0，保持输入</li><li>J=1，输出为1</li><li>K=1，输出为0</li><li>JK都为1，输出取前一个时刻输出的取反</li><li>输入信号为J和K，输出为$Q^{<em>}$，特性方程为$Q^{</em>}=J\bar{Q}+\bar{K}Q$</li></ul></li><li>T触发器：<ul><li>功能是每个时钟上升沿，输出为前一个时刻输出的取反。输入信号为T和CLK，输出为Q*；</li><li>特性方程为$Q^{*}=\bar{T}Q+T\bar{Q}$</li></ul></li></ul><p>各个触发器的状态转换的方法在于，用已知的触发器去表达未知的触发器，如下：</p><ul><li>D触发器 -> T触发器（用T表示D）：$D=\bar{T}Q+T\bar{Q}$</li><li>D触发器 -> JK触发器（用JK表示D）：$D=J\bar{Q}+\bar{K}Q$</li><li>JK触发器 -> D触发器（用D表示JK）：<ul><li>可以将D转化为$Q^{*}=D(Q+\bar{Q})=DQ+D\bar{Q}$</li><li>因为JK触发器特性方程为$Q^{*}=J\bar{Q}+\bar{K}Q$</li><li>那么$J=D,K=\bar{D}$</li></ul></li><li>JK触发器 -> T触发器（用T表示JK）：<ul><li>JK触发器：$Q^{*}=J\bar{Q}+\bar{K}Q$</li><li>T触发器：$D=\bar{T}Q+T\bar{Q}$</li><li>那么$J=T,K=T$</li></ul></li></ul><h4 id=同步电路-vs-异步电路 class=headerLink><a href=#%e5%90%8c%e6%ad%a5%e7%94%b5%e8%b7%af-vs-%e5%bc%82%e6%ad%a5%e7%94%b5%e8%b7%af class=header-mark></a>3.8.3 同步电路 vs 异步电路</h4><blockquote><p>异步 <code>preset & clear</code>电路的工作时序可以参考这个油管视频：<img class=tw-inline loading=lazy src='https://www.youtube.com/watch?v=6mf64D0bayE' alt="Digital Design (120 9a5) Asynchronous Flip-Flop Inputs: Preset and Clear - YouTube">
<code>preset & clear latch/flip-flop</code>的设计可以参考这个油管视频：
<img class=tw-inline loading=lazy src='https://www.youtube.com/watch?v=xe8ME6nYYHk' alt="PRESET and CLEAR inputs in Flip-Flop | Asynchronous inputs in Flip-Flop (youtube.com)">
以及这个油管视频：<img class=tw-inline loading=lazy src='https://www.youtube.com/watch?v=o-fmMz2k_kQ' alt="Digital Design (120 9a6) Flip-Flop Edge Triggering (youtube.com)"></p><p>查找异步视频资料的时候还费了点功夫，一开始搜索的是<code>asynchronous d latch/flip flop/sequential circuit design</code>，结果搜到的资料非常有限，直到搜到一本<code>sequential circuit design</code>还是什么教材，里面管这个特性叫<code>preset & clear</code>，才恍然大悟查错了资料。后来换了个方式查找资料，果然搜到了。</p></blockquote><ul><li>异步复位的D锁存器设计</li><li>异步设置D锁存器设计</li><li>异步复位的D触发器设计</li><li>异步设置D触发器设计</li></ul><h4 id=时序逻辑电路的设计从状态机到电路尤其是mealy型电路的设计 class=headerLink><a href=#%e6%97%b6%e5%ba%8f%e9%80%bb%e8%be%91%e7%94%b5%e8%b7%af%e7%9a%84%e8%ae%be%e8%ae%a1%e4%bb%8e%e7%8a%b6%e6%80%81%e6%9c%ba%e5%88%b0%e7%94%b5%e8%b7%af%e5%b0%a4%e5%85%b6%e6%98%afmealy%e5%9e%8b%e7%94%b5%e8%b7%af%e7%9a%84%e8%ae%be%e8%ae%a1 class=header-mark></a>3.8.4 时序逻辑电路的设计：从状态机到电路（尤其是Mealy型电路的设计）</h4><blockquote><p>Moore型电路和Mealy型电路的主要差别在于：<strong>Moore型电路的输出与状态有关，而Mealy型电路的输出与状态和输入有关。</strong></p><p>Mealy型电路的设计还不太会（如课本P166 习题3.25）(说白了其实是DFA的设计不太会，过会儿补一补）
DFA的介绍看这里：<img class=tw-inline loading=lazy src='https://www.youtube.com/watch?v=PK3wL7DXuuw' alt="Regular Languages: Deterministic Finite Automaton (DFA) (youtube.com)"></p></blockquote><h5 id=状态机的化简流程 class=headerLink><a href=#%e7%8a%b6%e6%80%81%e6%9c%ba%e7%9a%84%e5%8c%96%e7%ae%80%e6%b5%81%e7%a8%8b class=header-mark></a>3.8.4.1 状态机的化简流程</h5><blockquote><p>状态机的化简看这里：<img class=tw-inline loading=lazy src='https://www.youtube.com/watch?v=qq7moL5ueNQ' alt="Finite State Machine : State Reduction and State Assignment in the State Diagram (youtube.com)"></p></blockquote><p>化简流程：</p><ol><li>根据状态转换图，画出状态转换表</li><li>消去等效状态</li><li>把表中消去的等效状态用已有的状态替代</li><li>画出新的状态转换图</li></ol><h5 id=二进制序列检测器 class=headerLink><a href=#%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%ba%8f%e5%88%97%e6%a3%80%e6%b5%8b%e5%99%a8 class=header-mark></a>3.8.4.2 二进制序列检测器</h5><blockquote><p>基础二进制序列检测器的实现方法看这里：<img class=tw-inline loading=lazy src='https://www.youtube.com/watch?v=PbjntQf3sGc' alt="Sequence Detector | How to Design a Finite State Machine ? Step By Step Guide with Examples (youtube.com)"></p></blockquote><h5 id=grey-code状态机生成器 class=headerLink><a href=#grey-code%e7%8a%b6%e6%80%81%e6%9c%ba%e7%94%9f%e6%88%90%e5%99%a8 class=header-mark></a>3.8.4.3 Grey Code状态机生成器</h5><h4 id=时序逻辑电路的分析从电路到状态机 class=headerLink><a href=#%e6%97%b6%e5%ba%8f%e9%80%bb%e8%be%91%e7%94%b5%e8%b7%af%e7%9a%84%e5%88%86%e6%9e%90%e4%bb%8e%e7%94%b5%e8%b7%af%e5%88%b0%e7%8a%b6%e6%80%81%e6%9c%ba class=header-mark></a>3.8.5 时序逻辑电路的分析：从电路到状态机</h4><h4 id=时序逻辑电路中的限制与延迟 class=headerLink><a href=#%e6%97%b6%e5%ba%8f%e9%80%bb%e8%be%91%e7%94%b5%e8%b7%af%e4%b8%ad%e7%9a%84%e9%99%90%e5%88%b6%e4%b8%8e%e5%bb%b6%e8%bf%9f class=header-mark></a>3.8.6 时序逻辑电路中的限制与延迟</h4><h3 id=interview-questions class=headerLink><a href=#interview-questions class=header-mark></a>3.9 Interview Questions</h3><h2 id=chapter-4硬件描述语言 class=headerLink><a href=#chapter-4%e7%a1%ac%e4%bb%b6%e6%8f%8f%e8%bf%b0%e8%af%ad%e8%a8%80 class=header-mark></a>4 Chapter 4：硬件描述语言</h2><blockquote><p>这一章的学习可以配套 HDLBits 的 Verilog 练习，以及其他学校的 Verilog 数字电路设计课程进行练习，光看是没有用的。</p></blockquote><h2 id=chapter-5数字电路设计 class=headerLink><a href=#chapter-5%e6%95%b0%e5%ad%97%e7%94%b5%e8%b7%af%e8%ae%be%e8%ae%a1 class=header-mark></a>5 Chapter 5：数字电路设计</h2><blockquote><p>这一章的学习过程中，可以使用 Logisim 将所有基础电路搭起来，并且使用 Verilog 构建所有的电路</p></blockquote><h2 id=chapter-6risc-v-汇编语言 class=headerLink><a href=#chapter-6risc-v-%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80 class=header-mark></a>6 Chapter 6：RISC-V 汇编语言</h2><blockquote><p>这一章学习过后可以学习汇编和链接过程，文件格式，实现一个 RISC-V 汇编器，和一个 RISC-V 反汇编器</p></blockquote><h2 id=chapter-7微架构处理器设计 class=headerLink><a href=#chapter-7%e5%be%ae%e6%9e%b6%e6%9e%84%e5%a4%84%e7%90%86%e5%99%a8%e8%ae%be%e8%ae%a1 class=header-mark></a>7 Chapter 7：微架构处理器设计</h2><blockquote><p>这一章学习后，可以使用 Logisim 实现 MIPS 单周期/多周期/流水线处理器（完成华科头歌实验），并用 Verilog 进行实现并仿真</p></blockquote><h2 id=chapter-8主存和-io-系统设计 class=headerLink><a href=#chapter-8%e4%b8%bb%e5%ad%98%e5%92%8c-io-%e7%b3%bb%e7%bb%9f%e8%ae%be%e8%ae%a1 class=header-mark></a>8 Chapter 8：主存和 I/O 系统设计</h2><blockquote><p>这一章学习后，可以使用 Logisim 实现简单的 Memory 和 Cache（完成华科头歌实验），而后可以使用 Verilog 实现并仿真</p></blockquote><h2 id=后续任务 class=headerLink><a href=#%e5%90%8e%e7%bb%ad%e4%bb%bb%e5%8a%a1 class=header-mark></a>9 后续任务</h2><ul><li><svg class="icon" viewBox="0 0 448 512"><path d="M4e2 32H48C21.5 32 0 53.5.0 80v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-6 4e2H54c-3.3.0-6-2.7-6-6V86c0-3.3 2.7-6 6-6h340c3.3.0 6 2.7 6 6v340c0 3.3-2.7 6-6 6z"/></svg> 华科数字逻辑+组成原理课程学完</li><li><svg class="icon" viewBox="0 0 448 512"><path d="M4e2 32H48C21.5 32 0 53.5.0 80v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-6 4e2H54c-3.3.0-6-2.7-6-6V86c0-3.3 2.7-6 6-6h340c3.3.0 6 2.7 6 6v340c0 3.3-2.7 6-6 6z"/></svg> 其他学校数字逻辑+组成原理课程学完</li><li><svg class="icon" viewBox="0 0 448 512"><path d="M4e2 32H48C21.5 32 0 53.5.0 80v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-6 4e2H54c-3.3.0-6-2.7-6-6V86c0-3.3 2.7-6 6-6h340c3.3.0 6 2.7 6 6v340c0 3.3-2.7 6-6 6z"/></svg> Verilog 基础数字电路构建块设计</li><li><svg class="icon" viewBox="0 0 448 512"><path d="M4e2 32H48C21.5 32 0 53.5.0 80v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-6 4e2H54c-3.3.0-6-2.7-6-6V86c0-3.3 2.7-6 6-6h340c3.3.0 6 2.7 6 6v340c0 3.3-2.7 6-6 6z"/></svg> 设计一些小型的数字电路</li><li><svg class="icon" viewBox="0 0 448 512"><path d="M4e2 32H48C21.5 32 0 53.5.0 80v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-6 4e2H54c-3.3.0-6-2.7-6-6V86c0-3.3 2.7-6 6-6h340c3.3.0 6 2.7 6 6v340c0 3.3-2.7 6-6 6z"/></svg> 实现一个带存储+I/O+五级流水的 MIPS CPU</li><li><svg class="icon" viewBox="0 0 448 512"><path d="M4e2 32H48C21.5 32 0 53.5.0 80v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-6 4e2H54c-3.3.0-6-2.7-6-6V86c0-3.3 2.7-6 6-6h340c3.3.0 6 2.7 6 6v340c0 3.3-2.7 6-6 6z"/></svg> 文件格式学习</li><li><svg class="icon" viewBox="0 0 448 512"><path d="M4e2 32H48C21.5 32 0 53.5.0 80v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-6 4e2H54c-3.3.0-6-2.7-6-6V86c0-3.3 2.7-6 6-6h340c3.3.0 6 2.7 6 6v340c0 3.3-2.7 6-6 6z"/></svg> 链接过程学习</li><li><svg class="icon" viewBox="0 0 448 512"><path d="M4e2 32H48C21.5 32 0 53.5.0 80v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-6 4e2H54c-3.3.0-6-2.7-6-6V86c0-3.3 2.7-6 6-6h340c3.3.0 6 2.7 6 6v340c0 3.3-2.7 6-6 6z"/></svg> MIPS 汇编器实现</li><li><svg class="icon" viewBox="0 0 448 512"><path d="M4e2 32H48C21.5 32 0 53.5.0 80v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-6 4e2H54c-3.3.0-6-2.7-6-6V86c0-3.3 2.7-6 6-6h340c3.3.0 6 2.7 6 6v340c0 3.3-2.7 6-6 6z"/></svg> MIPS 反汇编器实现</li><li><svg class="icon" viewBox="0 0 448 512"><path d="M4e2 32H48C21.5 32 0 53.5.0 80v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-6 4e2H54c-3.3.0-6-2.7-6-6V86c0-3.3 2.7-6 6-6h340c3.3.0 6 2.7 6 6v340c0 3.3-2.7 6-6 6z"/></svg> 学习基础的编译原理知识</li><li><svg class="icon" viewBox="0 0 448 512"><path d="M4e2 32H48C21.5 32 0 53.5.0 80v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-6 4e2H54c-3.3.0-6-2.7-6-6V86c0-3.3 2.7-6 6-6h340c3.3.0 6 2.7 6 6v340c0 3.3-2.7 6-6 6z"/></svg> 小型 C 语言编译器实现</li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2025-03-24</span></div><div class=post-info-license></div></div><div class="post-info-line print:!tw-hidden"><div class=post-info-md><span><a class=link-to-mardown href=/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.md target=_blank rel="noopener noreferrer">阅读原始文档</a>
</span><span>|&nbsp;<a class=link-to-source href=https://github.com/HEIGE-PCloud/DoIt/blob/main/exampleSite/content/posts/cs/计算机体系结构/DDCA阅读笔记/index.md target=_blank rel="noopener noreferrer">查看源代码</a>
</span><span>|&nbsp;<a class=link-to-edit href=https://github.com/HEIGE-PCloud/DoIt/edit/main/exampleSite/content/posts/cs/计算机体系结构/DDCA阅读笔记/index.md target=_blank rel="noopener noreferrer">编辑此页</a>
</span><span>|&nbsp;<a class=link-to-report href="https://github.com/HEIGE-PCloud/DoIt/issues/new?title=[bug]%20%3CDigital+Design+and+Computer+Architecture%3E+MIPS+%E7%89%88%E6%9C%AC+%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0&body=|Field|Value|%0A|-|-|%0A|Title|%3CDigital+Design+and+Computer+Architecture%3E+MIPS+%E7%89%88%E6%9C%AC+%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0|%0A|Url|https://salvely.github.io/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/|%0A|Filename|https://github.com/HEIGE-PCloud/DoIt/blob/main/exampleSite/content/posts/cs/计算机体系结构/DDCA阅读笔记/index.md|" target=_blank rel="noopener noreferrer">报告问题</a></span></div><div class=post-info-share><button title="分享到 Twitter" data-sharer=twitter data-url=https://salvely.github.io/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/ data-title="<Digital Design and Computer Architecture> MIPS 版本 阅读笔记" data-hashtags=计算机组成原理><svg class="icon" viewBox="0 0 512 512"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645.0 138.72-105.583 298.558-298.558 298.558-59.452.0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055.0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421.0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391.0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04.0-57.828 46.782-104.934 104.934-104.934 30.213.0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg></button><button title="分享到 Facebook" data-sharer=facebook data-url=https://salvely.github.io/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/ data-hashtag=计算机组成原理><svg class="icon" viewBox="0 0 512 512"><path d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14.0 55.52 4.84 55.52 4.84v61h-31.28c-30.8.0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"/></svg></button><button title="分享到 Hacker News" data-sharer=hackernews data-url=https://salvely.github.io/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/ data-title="<Digital Design and Computer Architecture> MIPS 版本 阅读笔记"><svg class="icon" viewBox="0 0 448 512"><path d="M0 32v448h448V32H0zm21.2 197.2H21c.1-.1.2-.3.3-.4.0.1.0.3-.1.4zm218 53.9V384h-31.4V281.3L128 128h37.3c52.5 98.3 49.2 101.2 59.3 125.6 12.3-27 5.8-24.4 60.6-125.6H320l-80.8 155.1z"/></svg></button><button title="分享到 Line" data-sharer=line data-url=https://salvely.github.io/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/ data-title="<Digital Design and Computer Architecture> MIPS 版本 阅读笔记"><svg class="icon" role="img" viewBox="0 0 24 24"><title>LINE</title><path d="M19.365 9.863c.349.0.63.285.63.631.0.345-.281.63-.63.63H17.61v1.125h1.755c.349.0.63.283.63.63.0.344-.281.629-.63.629h-2.386c-.345.0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63h2.386c.346.0.627.285.627.63.0.349-.281.63-.63.63H17.61v1.125h1.755zm-3.855 3.016c0 .27-.174.51-.432.596-.064.021-.133.031-.199.031-.211.0-.391-.09-.51-.25l-2.443-3.317v2.94c0 .344-.279.629-.631.629-.346.0-.626-.285-.626-.629V8.108c0-.27.173-.51.43-.595.06-.023.136-.033.194-.033.195.0.375.104.495.254l2.462 3.33V8.108c0-.345.282-.63.63-.63.345.0.63.285.63.63v4.771zm-5.741.0c0 .344-.282.629-.631.629-.345.0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63.346.0.628.285.628.63v4.771zm-2.466.629H4.917c-.345.0-.63-.285-.63-.629V8.108c0-.345.285-.63.63-.63.348.0.63.285.63.63v4.141h1.756c.348.0.629.283.629.63.0.344-.282.629-.629.629M24 10.314C24 4.943 18.615.572 12 .572S0 4.943.0 10.314c0 4.811 4.27 8.842 10.035 9.608.391.082.923.258 1.058.59.12.301.079.766.038 1.08l-.164 1.02c-.045.301-.24 1.186 1.049.645 1.291-.539 6.916-4.078 9.436-6.975C23.176 14.393 24 12.458 24 10.314"/></svg></button><button title="分享到 微博" data-sharer=weibo data-url=https://salvely.github.io/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/ data-title="<Digital Design and Computer Architecture> MIPS 版本 阅读笔记"><svg class="icon" viewBox="0 0 512 512"><path d="M407 177.6c7.6-24-13.4-46.8-37.4-41.7-22 4.8-28.8-28.1-7.1-32.8 50.1-10.9 92.3 37.1 76.5 84.8-6.8 21.2-38.8 10.8-32-10.3zM214.8 446.7C108.5 446.7.0 395.3.0 310.4c0-44.3 28-95.4 76.3-143.7C176 67 279.5 65.8 249.9 161c-4 13.1 12.3 5.7 12.3 6 79.5-33.6 140.5-16.8 114 51.4-3.7 9.4 1.1 10.9 8.3 13.1 135.7 42.3 34.8 215.2-169.7 215.2zm143.7-146.3c-5.4-55.7-78.5-94-163.4-85.7-84.8 8.6-148.8 60.3-143.4 116s78.5 94 163.4 85.7c84.8-8.6 148.8-60.3 143.4-116zM347.9 35.1c-25.9 5.6-16.8 43.7 8.3 38.3 72.3-15.2 134.8 52.8 111.7 124-7.4 24.2 29.1 37 37.4 12 31.9-99.8-55.1-195.9-157.4-174.3zm-78.5 311c-17.1 38.8-66.8 60-109.1 46.3-40.8-13.1-58-53.4-40.3-89.7 17.7-35.4 63.1-55.4 103.4-45.1 42 10.8 63.1 50.2 46 88.5zm-86.3-30c-12.9-5.4-30 .3-38 12.9-8.3 12.9-4.3 28 8.6 34 13.1 6 30.8.3 39.1-12.9 8-13.1 3.7-28.3-9.7-34zm32.6-13.4c-5.1-1.7-11.4.6-14.3 5.4-2.9 5.1-1.4 10.6 3.7 12.9 5.1 2 11.7-.3 14.6-5.4 2.8-5.2 1.1-10.9-4-12.9z"/></svg></button><button title="分享到 Telegram" data-sharer=telegram data-url=https://salvely.github.io/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/ data-title="<Digital Design and Computer Architecture> MIPS 版本 阅读笔记" data-web><svg class="icon" viewBox="0 0 448 512"><path d="M446.7 98.6l-67.6 318.8c-5.1 22.5-18.4 28.1-37.3 17.5l-103-75.9-49.7 47.8c-5.5 5.5-10.1 10.1-20.7 10.1l7.4-104.9 190.9-172.5c8.3-7.4-1.8-11.5-12.9-4.1L117.8 284 16.2 252.2c-22.1-6.9-22.5-22.1 4.6-32.7L418.2 66.4c18.4-6.9 34.5 4.1 28.5 32.2z"/></svg></button><script>function shareOnMastodon(e,t){const o="share_mastodon_domain",i=localStorage.getItem(o)??"mastodon.social",n=prompt("Enter your Mastodon domain",i);if(n===null)return;localStorage.setItem(o,n);const a=e+`

`+t,s=new URL("https://"+n);s.pathname="share",s.searchParams.append("text",a),window.open(s,"_blank","width=500,height=500,left=500,toolbar=0,status=0")}</script>
<button title="分享到 Mastodon" onclick='shareOnMastodon("<Digital Design and Computer Architecture> MIPS 版本 阅读笔记","https://salvely.github.io/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/")'><svg class="icon" viewBox="0 0 448 512"><path d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48.0.0.0-63.72 28.5-63.72 125.7.0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54.0 01-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"/></svg></button></div></div></div><div class=post-info-more><section class=post-tags><svg class="icon" viewBox="0 0 640 512"><path d="M497.941 225.941 286.059 14.059A48 48 0 00252.118.0H48C21.49.0.0 21.49.0 48v204.118a48 48 0 0014.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882.0l204.118-204.118c18.745-18.745 18.745-49.137.0-67.882zM112 160c-26.51.0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882.0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397.0h48.721a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882z"/></svg>&nbsp;<a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/>计算机组成原理</a></section><section class=print:!tw-hidden><span><button class="tw-text-fgColor-link-muted hover:tw-text-fgColor-link-muted-hover" onclick=window.history.back()>返回</button></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class="post-nav print:tw-hidden"><a href=/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/ class=prev rel=prev title="Arch Lab实验总结"><svg class="icon" viewBox="0 0 256 512"><path d="M31.7 239l136-136c9.4-9.4 24.6-9.4 33.9.0l22.6 22.6c9.4 9.4 9.4 24.6.0 33.9L127.9 256l96.4 96.4c9.4 9.4 9.4 24.6.0 33.9L201.7 409c-9.4 9.4-24.6 9.4-33.9.0l-136-136c-9.5-9.4-9.5-24.6-.1-34z"/></svg>Arch Lab实验总结</a>
<a href=/rustlings-%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/ class=next rel=next title="rustlings 通关记录">rustlings 通关记录<svg class="icon" viewBox="0 0 256 512"><path d="M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9.0l-22.6-22.6c-9.4-9.4-9.4-24.6.0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6.0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9.0l136 136c9.5 9.4 9.5 24.6.1 34z"/></svg></a></div></div><div id=comments class="print:!tw-hidden tw-pt-32 tw-pb-8"><div id=giscus></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/>giscus</a>.</noscript></div></article></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.146.5">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href=https://github.com/HEIGE-PCloud/DoIt target=_blank rel="noopener noreferrer" title="DoIt 0.4.1"><svg class="icon" viewBox="0 0 576 512"><path d="M402.3 344.9l32-32c5-5 13.7-1.5 13.7 5.7V464c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h273.5c7.1.0 10.7 8.6 5.7 13.7l-32 32c-1.5 1.5-3.5 2.3-5.7 2.3H48v352h352V350.5c0-2.1.8-4.1 2.3-5.6zm156.6-201.8L296.3 405.7l-90.4 10c-26.2 2.9-48.5-19.2-45.6-45.6l10-90.4L432.9 17.1c22.9-22.9 59.9-22.9 82.7.0l43.2 43.2c22.9 22.9 22.9 60 .1 82.8zM460.1 174 402 115.9 216.2 301.8l-7.3 65.3 65.3-7.3L460.1 174zm64.8-79.7-43.2-43.2c-4.1-4.1-10.8-4.1-14.8.0L436 82l58.1 58.1 30.9-30.9c4-4.2 4-10.8-.1-14.9z"/></svg> DoIt</a></div><div class=footer-line><svg class="icon" viewBox="0 0 512 512"><path d="M256 8C119.033 8 8 119.033 8 256s111.033 248 248 248 248-111.033 248-248S392.967 8 256 8zm0 448c-110.532.0-2e2-89.451-2e2-2e2.0-110.531 89.451-2e2 2e2-2e2 110.532.0 2e2 89.451 2e2 2e2.0 110.532-89.451 2e2-2e2 2e2zm107.351-101.064c-9.614 9.712-45.53 41.396-104.065 41.396-82.43.0-140.484-61.425-140.484-141.567.0-79.152 60.275-139.401 139.762-139.401 55.531.0 88.738 26.62 97.593 34.779a11.965 11.965.0 011.936 15.322l-18.155 28.113c-3.841 5.95-11.966 7.282-17.499 2.921-8.595-6.776-31.814-22.538-61.708-22.538-48.303.0-77.916 35.33-77.916 80.082.0 41.589 26.888 83.692 78.277 83.692 32.657.0 56.843-19.039 65.726-27.225 5.27-4.857 13.596-4.039 17.82 1.738l19.865 27.17a11.947 11.947.0 01-1.152 15.518z"/></svg>2024 - 2025<span class=author>&nbsp;<a href=https://github.com/Salvely target=_blank rel="noopener noreferrer">Salvely</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class=footer-line></div><div class=footer-line></div></div></footer><div class="print:!tw-hidden tw-flex tw-flex-col tw-fixed tw-right-4 tw-bottom-4 tw-gap-2"><a href=#back-to-top id=back-to-top-button class="tw-transition-opacity tw-opacity-0 tw-block tw-bg-bgColor-secondary tw-rounded-full" style=padding:.6rem;line-height:1.3rem;font-size:1rem title=回到顶部><svg class="icon" viewBox="0 0 448 512"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg>
</a><button id=toc-drawer-button class="tw-block tw-bg-bgColor-secondary tw-rounded-full md:tw-hidden" style=padding:.6rem;line-height:1.3rem;font-size:1rem>
<svg class="icon" viewBox="0 0 448 512"><path d="M16 132h416c8.837.0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163.0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837.0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837.0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837.0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837.0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"/></svg>
</button><a href=#comments id=view-comments class="tw-block tw-bg-bgColor-secondary tw-rounded-full" style=padding:.6rem;line-height:1.3rem;font-size:1rem title=查看评论><svg class="icon" viewBox="0 0 512 512"><path d="M256 32C114.6 32 0 125.1.0 240c0 49.6 21.4 95 57 130.7C44.5 421.1 2.7 466 2.2 466.5c-2.2 2.3-2.8 5.7-1.5 8.7S4.8 480 8 480c66.3.0 116-31.8 140.6-51.4 32.7 12.3 69 19.4 107.4 19.4 141.4.0 256-93.1 256-208S397.4 32 256 32z"/></svg></a></div><script type=module>
        (async () => {
            const supportSpeculationRules = HTMLScriptElement.supports && HTMLScriptElement.supports("speculationrules");
            if (!supportSpeculationRules) {
              await import("\/lib\/instant.page\/instantpage.min.js");
            }
        })();
    </script><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/katex/copy-tex.min.css><noscript><link rel=stylesheet href=/lib/katex/copy-tex.min.css></noscript><script>window.config={"autocomplete.min.js":"/lib/autocomplete/autocomplete.min.js",comment:{giscus:{darkTheme:"dark",dataCategory:"Announcements",dataCategoryId:"DIC_kwDOM7VfQc4CjD-y",dataEmitMetadata:"0",dataInputPosition:"bottom",dataLang:"zh-CN",dataLoading:"lazy",dataMapping:"pathname",dataReactionsEnabled:"1",dataRepo:"Salvely/salvely.github.io",dataRepoId:"R_kgDOM7VfQQ",dataStrict:"0",lightTheme:"light"}},"fuse.min.js":"/lib/fuse/fuse.min.js",math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!0,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:50,threshold:.1,type:"fuse",useExtendedSearch:!1},sharerjs:!0,table:{sort:!0}}</script><script src=/lib/tablesort/tablesort.min.js></script><script src=/lib/sharer/sharer.min.js></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/copy-tex.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/js/katex.min.js defer></script><script src=/js/theme.min.js defer></script><script src=/js/giscus.min.js defer></script><script type=speculationrules>
  {
    "prerender": [
      {
        "where": { "href_matches": "/*" },
        "eagerness": "moderate"
      }
    ]
  }
</script></body></html>