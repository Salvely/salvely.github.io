[{"categories":null,"content":" Tip chloneda/vim-cheatsheet: 🍁Vim cheat sheet with everything you want to know. 这个表更全面。此外，如果你的终端是gb2312编码，vimtutor会是中文版本，详情见此如何获取VIM自带的vimtutor中文版 – 小顾de杂记。如果你想要获得vimtutor的中文版本，可以输入vimtutor zh_cn；英文版是vimtutor en。 打开vim：vim \u003cfile\u003e 不保存强制退出vim：:q! 保存：:w，:w \u003cfile\u003e 保存到文件file中 w是下一个单词开头，e是下一个文字结尾，$是行末，0是行开头 删除：dw de d$ dd，要指明删除到哪里：d2w d2e，命令模式：operation num motion 撤回：u 撤回一个操作 ，U 撤回一行 ，CTRL+R redo 单个替换：r，多个替换：R c是change，c后可接c/e/$ dd 删除一行 p 粘贴刚才删除的那行 CTRL+G 获得当前光标位置（文件，行号，列号等），G 跳到末尾 gg 跳到开头 行号+G 跳到该行 / 搜索并向后查找，?搜索并向前查找， n 向后找 N 向前找 CTRL+O 上一个查找到的 CTRL+I 下一个查找到的 wrpscan模式 当查找到最后一个以后，下一次查找就找到第一个 % 匹配括号 ( [ { } ] ) :s/old/new 搜索到该行第一个old并替换为new :s/old/new/g 搜索到该行所有的old并替换为new :%s/old/new 在整个文件搜索到第一个old并替换为new :%s/old/new/g 在整个文件搜索到所有的old并替换为new gc 逐个询问你是否替换 :#,#s 从某行到某行之间替换 :! \u003c外部命令\u003e 执行外部命令（如ls dir cat等等） y复制 p 粘贴 v 视觉模式 v后再输入:可以输入普通模式下的命令（如!cat \u003cfile\u003e） :r 读内容，并复制到光标处，比如:r !ls就是把ls命令的结果输出到光标处； o在该行下面插入一行 O在该行上面插入一行 a在该字符后面插入字符 A在该行末尾插入字符 :set 设置模式 hls hlsearch 高亮搜索 nohls nohlsearch 非高亮搜索 ic ignorecase忽略大小写 noic noignorecase不忽略大小写 如果仅仅想要在一次搜索中忽略大小写，可以使用/c，如/[text]\\c is incsearch 查找输入时动态增量显示查找结果 nois noicsearch 不动态增量显示 nocp 不兼容vi 按F1或输入:help [命令]调出命令帮助，直接输入:help调出vim帮助，如:help vimrc-intro vim配置文件：~/.vimrc :e，在进入vim后， 在不离开vim的情况下打开其他文件 CTRL+D 列出所有候选命令，Tab 补全当前命令 ","date":"2025-07-10","objectID":"/vimtutor-%E6%80%BB%E7%BB%93/:0:0","series":null,"tags":["vim"],"title":"vimtutor 总结","uri":"/vimtutor-%E6%80%BB%E7%BB%93/#"},{"categories":["理论计算机"],"content":" 1 图灵机设计对二进制加法过程进行分析，我们可以得出如下过程： 使用小端法在纸带上存储输入的二进制串，即低位放在最左边 第一格是blank，也就是空，最后我们会回退到这个状态，来进入halt状态 最初是start状态，经过blank后改为carry状态 carry状态下，如果最低为是 0，那么直接将其加 1，然后返回（向左行走）即可，进入back状态 carry状态下，如果最低为是 1，将其改为 0，保持carry状态向右行走，继续对高位进行修改 如果在carry状态下遇到blank，也就是最高位还有进位，那么将blank改为 1 在回退状态下，一般来说只会遇到0，保留 0 不动，继续回退 达到halt之后停止操作，打印字符串 那么，在该图灵机中，我们需要使用到如下几个状态： start，即开始状态 carry，进位状态 back，回退状态 halt，停止状态 有如下几种符号： blank，表示空 0，即二进制符号 0 1，即二进制符号 1 根据设计，图灵机定义二进制加法的计算过程如下： start, blank-\u003eblank, RIGHT, carry carry, 1 -\u003e 0, RIGHT, carry carry, blank-\u003e1, LEFT, back carry, 0-\u003e1, LEFT, back back, 0-\u003e0, LEFT, back back, blank-\u003eblank, halt ","date":"2025-01-12","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:1:0","series":null,"tags":["图灵机","计算理论"],"title":"二进制加法图灵机的C语言实现","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/#图灵机设计"},{"categories":["理论计算机"],"content":" 2 C 语言代码实现 c // Turing machines for computations. #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #define N 4 // the number of states #define M 3 // the number of symbols #define TAPE_SIZE 20 // the size of the tape enum direction { LEFT, RIGHT, STAY }; /** * @brief encoding for binary addtion * 1. 4 states start:0 carry:1 back:2 halt:3 * 2. 3 symbols 0-\u003e0 1-\u003e1 blank-\u003e2 */ enum STATE { START, CARRY, BACK, HALT }; enum SYMBOL { SYMBOL_0, SYMBOL_1, BLANK }; int state_arr [N]; // state_arr[0] as start state, state_arr[N-2] as accept state, state_arr[N-1] as reject state int symbol_arr[M]; // symbol_arr[0] as empty symbol int tape[TAPE_SIZE]; typedef struct head { int location; // the location of the head int state_num; // the state of the head } head_t; typedef struct action { int head_state; int current_symbol; int next_symbol; enum direction dir; int next_state; } action_t; /** * @brief turing machine for binary addition * 1. start, blank-\u003eblank, RIGHT, carry * 2. carry, 1 -\u003e 0, RIGHT, carry * 3. carry, blank-\u003e1, LEFT, back * 4. carry, 0-\u003e1, LEFT, back * 5. back, 0-\u003e0, LEFT, back * 6. back, blank-\u003eblank, halt */ action_t turing_machine(action_t act) { if (act.head_state == state_arr[START] \u0026\u0026 act.current_symbol == symbol_arr[BLANK]) { act.next_symbol = act.current_symbol; act.dir = RIGHT; act.next_state = state_arr[CARRY]; } else if (act.head_state == state_arr[CARRY] \u0026\u0026 act.current_symbol == symbol_arr[SYMBOL_1]) { act.next_symbol = symbol_arr[SYMBOL_0]; act.dir = RIGHT; act.next_state = act.head_state; } else if (act.head_state == state_arr[CARRY] \u0026\u0026 act.current_symbol == symbol_arr[BLANK]) { act.next_symbol = symbol_arr[SYMBOL_1]; act.dir = LEFT; act.next_state = state_arr[BACK]; } else if (act.head_state == state_arr[CARRY] \u0026\u0026 act.current_symbol == symbol_arr[SYMBOL_0]) { act.next_symbol = symbol_arr[SYMBOL_1]; act.dir = LEFT; act.next_state = state_arr[BACK]; } else if (act.head_state == state_arr[BACK] \u0026\u0026 act.current_symbol == symbol_arr[SYMBOL_0]) { act.next_symbol = act.current_symbol; act.dir = LEFT; act.next_state = state_arr[BACK]; } else if (act.head_state == state_arr[BACK] \u0026\u0026 act.current_symbol == symbol_arr[BLANK]) { act.next_symbol = act.current_symbol; act.dir = STAY; act.next_state = state_arr[HALT]; } return act; } void state_transition(char* s, int length) { // initiliaze the state array and symbol array for (int i = 0; i \u003c N; i++) { state_arr[i] = i; } for (int i = 0; i \u003c M; i++) { symbol_arr[i] = i; } // initialize the tape for (int i = 0; i \u003c TAPE_SIZE; i++) { tape[i] = BLANK; // initialize all tape as blank } for (int i = 0; i \u003c length; i++) { tape[i + 1] = s[i] - '0'; } // initialize the head head_t h; h.location = 0; h.state_num = state_arr[START]; // initialie the action action_t a; a.dir = STAY; // define the state transition while (h.state_num != 3) { a.head_state = h.state_num; a.current_symbol = tape[h.location]; a = turing_machine(a); tape[h.location] = a.next_symbol; // update the head if (a.dir == RIGHT) { h.location += 1; } else if (a.dir == LEFT) { h.location -= 1; } h.state_num = a.next_state; } // print the added string for (int i = length; i \u003e= 1; i--) { printf(\"%d\", tape[i]); } } int main(void) { printf(\"Input the binary string: \"); char* s = (char*)malloc(10 * sizeof(char)); scanf(\"%s\", s); // reverse the string, and enter it into turing machine int length = strlen(s); for (int i = 0; i \u003c length / 2; i++) { char temp = s[length - 1 - i]; s[length - 1 - i] = s[i]; s[i] = temp; } state_transition(s, strlen(s)); return 0; } ","date":"2025-01-12","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:2:0","series":null,"tags":["图灵机","计算理论"],"title":"二进制加法图灵机的C语言实现","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/#c-语言代码实现"}]