[{"categories":null,"content":"今天写下这篇文章，是因为我过去多年一直饱受身体疾病和体质虚弱的困扰，实在是绷不住了。 在过去的多年里，每个月我必然要经历： 5天例假，整个人虚的一批，只能在床上挺尸； 隔三岔五的荨麻疹，浑身瘙痒难耐，还会因为出汗身上黏糊糊，又不能一直洗澡，浑身起红色划痕一样的疹子； 吹点风就感冒发烧了，出点汗吹点空调又感冒了； 健身两天就膝盖不舒服了，还得吃氨糖； 因为荨麻疹伴随的玫瑰痤疮，不能用护肤品和化妆品，脸上时不时泛红瘙痒； 浑身汗腺发达， 手汗脚汗不断。腋下甚至有时候会有味道，每天要用硫磺皂洗。稍微健个身身上就会有味道。每年换季的时候，两只手还会有很多的汗疱疹，连在一起，又痒又恶心，还不能根治； 脚气和脚藓，这个是伴随着脚汗出来的，跟随我爸遗传的，天天都要用上海药皂洗脚。最近发现超市居然不卖上海药皂和硫磺皂了，妈的； 晕车晕3d，一次只能扛过生化危机8的一章，每次到存档点的时候都脑袋发晕、恶心想吐、浑身出汗、面色苍白，扛过去是因为没有存档点，要是存档点再靠后点我就要扛不住了； 不能接受任何不舒适条件下的活动（比如3月份的炎热户外会让我中暑，有烟味的动车车厢会让我想吐）； 等等等等； 所导致的结果就是： 经常需要睡觉休息，不能进行任何高强度的学习工作活动，否则就会生病，虚弱，扛不住； 身体疾病导致心理韧性差，抗压能力弱，经常想要哭哭，想要别人的安慰和抱抱； 生命力弱，经常出现3分钟热度的情况，因为我的身体能量只够我燃烧那么久，再久点就扛不住了； 看着别人一个个生龙活虎，活力四射，朝着他们的目标和挑战前进，就觉得特别羡慕。但是自己模仿着行动一段时间，身体就报警了，要我去睡觉，无奈最后只能到床上去挺尸； 我不要再这样啦！我也要当健康人！我也要成为活力四射的小朋友！我要健身！健身！ 可是我有时候健身的时候，感觉自己快要扛不住了，感觉浑身出汗，脑袋乏累，眼皮变重，有时候甚至能在健身之后，从镜子里看到自己的单眼皮变成了双眼皮。健身结束以后，就特别想睡觉，一次又是几个小时，也没有做其他事情的动力了。很苦恼哇。 我怎么这么脆弱，呜呜呜，哇哇哇。 ","date":"2025-08-07","objectID":"/%E8%BA%AB%E4%BD%93%E6%98%AF%E9%9D%A9%E5%91%BD%E7%9A%84%E6%9C%AC%E9%92%B1/:0:0","series":["随记"],"tags":null,"title":"身体是革命的本钱！","uri":"/%E8%BA%AB%E4%BD%93%E6%98%AF%E9%9D%A9%E5%91%BD%E7%9A%84%E6%9C%AC%E9%92%B1/#"},{"categories":null,"content":" Tip chloneda/vim-cheatsheet: 🍁Vim cheat sheet with everything you want to know. 这个表更全面。此外，如果你的终端是gb2312编码，vimtutor会是中文版本，详情见此如何获取VIM自带的vimtutor中文版 – 小顾de杂记。如果你想要获得vimtutor的中文版本，可以输入vimtutor zh_cn；英文版是vimtutor en。 打开vim：vim \u003cfile\u003e 不保存强制退出vim：:q! 保存：:w，:w \u003cfile\u003e 保存到文件file中 w是下一个单词开头，e是下一个文字结尾，$是行末，0是行开头 删除：dw de d$ dd，要指明删除到哪里：d2w d2e，命令模式：operation num motion 撤回：u 撤回一个操作 ，U 撤回一行 ，CTRL+R redo 单个替换：r，多个替换：R c是change，c后可接c/e/$ dd 删除一行 p 粘贴刚才删除的那行 CTRL+G 获得当前光标位置（文件，行号，列号等），G 跳到末尾 gg 跳到开头 行号+G 跳到该行 / 搜索并向后查找，?搜索并向前查找， n 向后找 N 向前找 CTRL+O 上一个查找到的 CTRL+I 下一个查找到的 wrpscan模式 当查找到最后一个以后，下一次查找就找到第一个 % 匹配括号 ( [ { } ] ) :s/old/new 搜索到该行第一个old并替换为new :s/old/new/g 搜索到该行所有的old并替换为new :%s/old/new 在整个文件搜索到第一个old并替换为new :%s/old/new/g 在整个文件搜索到所有的old并替换为new gc 逐个询问你是否替换 :#,#s 从某行到某行之间替换 :! \u003c外部命令\u003e 执行外部命令（如ls dir cat等等） y复制 p 粘贴 v 视觉模式 v后再输入:可以输入普通模式下的命令（如!cat \u003cfile\u003e） :r 读内容，并复制到光标处，比如:r !ls就是把ls命令的结果输出到光标处； o在该行下面插入一行 O在该行上面插入一行 a在该字符后面插入字符 A在该行末尾插入字符 :set 设置模式 hls hlsearch 高亮搜索 nohls nohlsearch 非高亮搜索 ic ignorecase忽略大小写 noic noignorecase不忽略大小写 如果仅仅想要在一次搜索中忽略大小写，可以使用/c，如/[text]\\c is incsearch 查找输入时动态增量显示查找结果 nois noicsearch 不动态增量显示 nocp 不兼容vi 按F1或输入:help [命令]调出命令帮助，直接输入:help调出vim帮助，如:help vimrc-intro vim配置文件：~/.vimrc :e，在进入vim后， 在不离开vim的情况下打开其他文件 CTRL+D 列出所有候选命令，Tab 补全当前命令 ","date":"2025-07-10","objectID":"/vimtutor-%E6%80%BB%E7%BB%93/:0:0","series":null,"tags":["vim"],"title":"vimtutor 总结","uri":"/vimtutor-%E6%80%BB%E7%BB%93/#"},{"categories":["Linux"],"content":" Warning 这个帖子并不是什么安装教程，只是纯纯的过程记录。因此其中不乏一些碎碎念和踩坑过程。安装过程参考：在 WSL 上安装 Arch Linux - Arch Linux 中文维基 ","date":"2025-05-21","objectID":"/wsl2%E4%B8%8A%E7%9A%84arch-linux%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:0:0","series":["Arch 探索"],"tags":["Arch","安装","配置","WSL2"],"title":"WSL2上的Arch Linux安装过程记录","uri":"/wsl2%E4%B8%8A%E7%9A%84arch-linux%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/#"},{"categories":["Linux"],"content":" 1 前言很早之前我就听说Arch Linux是个很有趣的Linux发行版了，自定义程度很高，但是之前由于对Linux本身并不那么熟悉，因此并没有使用的想法。在学习Linux期间，我使用的是Ubuntu，挺方便的，通过apt-get安装一些工具，稍微配置一下就可以用。我利用Ubuntu学习了很多的基础Linux命令，还在Ubuntu环境下刷过几门课，算是对Linux环境有个基本的熟悉了。因此现在打算尝试一下Arch Linux，也来折腾折腾。 我以前没有使用过WSL2，都是用的VMWare虚拟机，但是感觉VMWare的屏幕很小，用起来不顺手。我每次写代码的时候，都是用的Windows宿主机上的VSCode，通过SSH远程连接到虚拟机。最早我以为SSH是个VSCode中内置的虚拟机开关，可以在VSCode后台直接开Ubuntu虚拟机，还问群友为什么半天连接不上，闹了笑话（话说我很想实现一个VSCode中内置的虚拟机，这样就不用使用VMWare这样笨重的软件了，我要把这条加到我的待办清单中去）。这次我决定使用WSL2，说实话WSL2跟Arch Linux一样，对我来说都是新事物，需要自己去踩坑折腾的，不过我也不害怕，来就来嘛。我的安装过程主要根据官方文档：在 WSL 上安装 Arch Linux - Arch Linux 中文维基，中间穿插一些踩坑之类的内容。 ","date":"2025-05-21","objectID":"/wsl2%E4%B8%8A%E7%9A%84arch-linux%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:1:0","series":["Arch 探索"],"tags":["Arch","安装","配置","WSL2"],"title":"WSL2上的Arch Linux安装过程记录","uri":"/wsl2%E4%B8%8A%E7%9A%84arch-linux%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/#前言"},{"categories":["Linux"],"content":" 2 安装","date":"2025-05-21","objectID":"/wsl2%E4%B8%8A%E7%9A%84arch-linux%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:2:0","series":["Arch 探索"],"tags":["Arch","安装","配置","WSL2"],"title":"WSL2上的Arch Linux安装过程记录","uri":"/wsl2%E4%B8%8A%E7%9A%84arch-linux%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/#安装"},{"categories":["Linux"],"content":" 2.1 启用虚拟化手册的第一步是在 UEFI 设置中启用虚拟化（说实话我不太清楚UEFI是什么，这里要记录一下，后面学习硬件和操作系统的时候得学） 通过在Google中搜索：how to check if I have enabled the virtualization in UEFI - Google 搜索，我得到的答案是：要检查UEFI是否启动了虚拟化，我们需要在Windows控制台中输入msinfo32命令查看系统信息，然后在系统摘要一栏，看Hyper-V-固件中启用的虚拟化一栏是否为是。我这里显示已经启用了虚拟化，进入下一步。如果没有的话，参考这篇文档：Enable Virtualization on Windows - Microsoft Support。 此外，根据这篇文档Windows 10 支持将于 2025 年 10 月 14 日结束，但是看了网上对Win 11多半差评，还是不升级了。 ","date":"2025-05-21","objectID":"/wsl2%E4%B8%8A%E7%9A%84arch-linux%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:2:1","series":["Arch 探索"],"tags":["Arch","安装","配置","WSL2"],"title":"WSL2上的Arch Linux安装过程记录","uri":"/wsl2%E4%B8%8A%E7%9A%84arch-linux%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/#启用虚拟化"},{"categories":["Linux"],"content":" 2.2 Arch Linux安装首先介绍一下WSL，根据这篇文档：适用于 Linux 的 Windows 子系统文档 | Microsoft Learn（文档非常好，可以深入学习一下WSL） 适用于 Linux 的 Windows 子系统 (WSL) 可让开发人员直接在 Windows 上按原样运行 GNU/Linux 环境（包括大多数命令行工具、实用工具和应用程序），且不会产生传统虚拟机或双启动设置开销。 这次我们的目的是安装Arch Linux，所以先不了解那么多。对于安装命令，文档中是这样写的： 在管理员模式下打开 PowerShell 或 Windows 命令提示符，方法是右键单击并选择\"以管理员身份运行\"，输入 wsl --install 命令，然后重启计算机。 需要注意的是，wsl --install命令安装的是默认Ubuntu发行版，要想安装其他发行版，我们需要输入wsl --install \u003cDistribution Name\u003e。通过wsl --list --online，我们看一下都有哪些发行版： powershell PS C:\\Windows\\system32\u003e wsl --list --online 以下是可安装的有效分发的列表。 使用 'wsl.exe --install \u003cDistro\u003e' 安装。 NAME FRIENDLY NAME AlmaLinux-8 AlmaLinux OS 8 AlmaLinux-9 AlmaLinux OS 9 AlmaLinux-Kitten-10 AlmaLinux OS Kitten 10 Debian Debian GNU/Linux FedoraLinux-42 Fedora Linux 42 SUSE-Linux-Enterprise-15-SP5 SUSE Linux Enterprise 15 SP5 SUSE-Linux-Enterprise-15-SP6 SUSE Linux Enterprise 15 SP6 Ubuntu Ubuntu Ubuntu-24.04 Ubuntu 24.04 LTS archlinux Arch Linux kali-linux Kali Linux Rolling openSUSE-Tumbleweed openSUSE Tumbleweed openSUSE-Leap-15.6 openSUSE Leap 15.6 Ubuntu-18.04 Ubuntu 18.04 LTS Ubuntu-20.04 Ubuntu 20.04 LTS Ubuntu-22.04 Ubuntu 22.04 LTS OracleLinux_7_9 Oracle Linux 7.9 OracleLinux_8_7 Oracle Linux 8.7 OracleLinux_9_1 Oracle Linux 9.1 这里我们想要安装的是archlinux，安装到D盘去。使用如下命令（管理员权限执行）： powershell wsl --install -d archlinux --name _自定义名称_ --location _自定义路径_ 譬如： powershell PS C:\\Windows\\system32\u003e wsl --install -d archlinux --location D:\\Program_Files\\VM\\Arch 正在下载: Arch Linux 正在安装: Arch Linux 已成功安装分发。它可通过 “wsl.exe -d archlinux” 启动 安装过程中还会弹出来一个欢迎界面： 安装完成后，输入wsl -d archlinux运行archlinux，powershell中的运行效果如下： powershell PS C:\\Windows\\system32\u003e wsl -d archlinux Welcome to the Arch Linux WSL image! This image is maintained at \u003chttps://gitlab.archlinux.org/archlinux/archlinux-wsl\u003e. Please, report bugs at \u003chttps://gitlab.archlinux.org/archlinux/archlinux-wsl/-/issues\u003e. Note that WSL 1 is not supported. For more information about this WSL image and its usage (including \"tips and tricks\" and troubleshooting steps), see the related Arch Wiki page at \u003chttps://wiki.archlinux.org/title/Install_Arch_Linux_on_WSL\u003e. While images are built regularly, it is strongly recommended running \"pacman -Syu\" right after the first launch due to the rolling release nature of Arch Linux. Generating pacman keys... ==\u003e Generating pacman master key. This may take some time. ==\u003e Updating trust database... Done [root@DESKTOP-ROOSFVQ system32]# 成功！ ","date":"2025-05-21","objectID":"/wsl2%E4%B8%8A%E7%9A%84arch-linux%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:2:2","series":["Arch 探索"],"tags":["Arch","安装","配置","WSL2"],"title":"WSL2上的Arch Linux安装过程记录","uri":"/wsl2%E4%B8%8A%E7%9A%84arch-linux%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/#arch-linux安装"},{"categories":["数电"],"content":"记录一下我在做HDLBits的时候被卡了的一些关键题目的题解","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/"},{"categories":["数电"],"content":" 我的HDLBits刷题记录和一些debug记录见此：weekly-report/记录/HDLBits.md at main · Salvely/weekly-report ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:0:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#"},{"categories":["数电"],"content":" 1 Adder100i verilog module fadd( input a, b, cin, output cout, sum ); assign sum = a ^ b ^ cin; assign cout = (a \u0026 b) | ((a | b) \u0026 cin); endmodule module top_module( input [99:0] a, b, input cin, output [99:0] cout, output [99:0] sum ); genvar i; fadd adder0(.a(a[0]),.b(b[0]),.cin(cin),.cout(cout[0]),.sum(sum[0])); generate for(i = 1; i \u003c 100; i++) begin: adder_block fadd adder_i(.a(a[i]),.b(b[i]),.cin(cout[i-1]),.cout(cout[i]),.sum(sum[i])); end endgenerate endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:1:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#adder100i"},{"categories":["数电"],"content":" 2 Bcdadd100 verilog module top_module( input [399:0] a, b, input cin, output cout, output [399:0] sum ); wire[100:0] cout_arr; genvar i; bcd_fadd adder0(.a(a[3:0]),.b(b[3:0]),.cin(cin),.cout(cout_arr[0]),.sum(sum[3:0])); generate for(i = 1; i \u003c 100; i++) begin: bcd_adder bcd_fadd(.a(a[3 + 4 * i:4 * i]),.b(b[3 + 4 * i:4 * i]),.cin(cout_arr[i-1]),.sum(sum[3 + 4 * i:4 * i]),.cout(cout_arr[i])); end assign cout = cout_arr[99]; endgenerate endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:2:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#bcdadd100"},{"categories":["数电"],"content":" 3 Mux256to1 verilog module top_module( input [255:0] in, input [7:0] sel, output out ); assign out = in[sel]; endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:3:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#mux256to1"},{"categories":["数电"],"content":" 4 Mux256to1v verilog module top_module( input [1023:0] in, input [7:0] sel, output [3:0] out ); assign out = in[4 * sel +: 4]; endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:4:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#mux256to1v"},{"categories":["数电"],"content":" 5 Fadd verilog module top_module( input a, b, cin, output cout, sum ); assign sum = a ^ b ^ cin; assign cout = (a \u0026 b) | ((a | b) \u0026 cin); endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:5:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#fadd"},{"categories":["数电"],"content":" 6 Exams/m2014 q4j verilog module fadd( input a, b, cin, output cout, sum ); assign sum = a ^ b ^ cin; assign cout = (a \u0026 b) | ((a | b) \u0026 cin); endmodule module top_module ( input [3:0] x, input [3:0] y, output [4:0] sum); wire [3:0] cout; fadd adder0(.a(x[0]),.b(y[0]),.cin(0),.cout(cout[0]),.sum(sum[0])); fadd adder1(.a(x[1]),.b(y[1]),.cin(cout[0]),.cout(cout[1]),.sum(sum[1])); fadd adder2(.a(x[2]),.b(y[2]),.cin(cout[1]),.cout(cout[2]),.sum(sum[2])); fadd adder3(.a(x[3]),.b(y[3]),.cin(cout[2]),.cout(cout[3]),.sum(sum[3])); assign sum[4] = cout[3]; endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:6:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#examsm2014-q4j"},{"categories":["数电"],"content":" 7 Exams/ece241 2014 q1c verilog module fadd( input a, b, cin, output cout, sum ); assign sum = a ^ b ^ cin; assign cout = (a \u0026 b) | ((a | b) \u0026 cin); endmodule module top_module ( input [7:0] a, input [7:0] b, output [7:0] s, output overflow ); // // assign s = ... // assign overflow = ... generate wire [7:0] cout; fadd adderi(.a(a[0]),.b(b[0]),.cin(0),.cout(cout[0]),.sum(s[0])); genvar i; for(i = 1; i \u003c 8; i++) begin: add_block fadd adderi(.a(a[i]),.b(b[i]),.cin(cout[i-1]),.cout(cout[i]),.sum(s[i])); end assign overflow = ~(a[7] ^ b[7]) \u0026\u0026 (s[7] ^ b[7]); endgenerate endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:7:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#examsece241-2014-q1c"},{"categories":["数电"],"content":" 8 Adder100 verilog module top_module( input [99:0] a, b, input cin, output cout, output [99:0] sum ); assign {cout,sum} = a + b + cin; endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:8:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#adder100"},{"categories":["数电"],"content":" 9 Dff8r verilog module top_module ( input clk, input reset, // Synchronous reset input [7:0] d, output [7:0] q ); always @(posedge clk) begin if(reset == 1) q \u003c= 8'h00; else q \u003c= d; end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:9:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#dff8r"},{"categories":["数电"],"content":" 10 Exams/ece241 2014 q4 verilog module dffr(input clk, input reset, input d, output q, output notq); always @(posedge clk, posedge reset) begin if(reset) q \u003c= 1'b0; else q \u003c= d; notq = ~q; end endmodule module top_module ( input clk, input x, output z ); wire d_in0; wire d_in1; wire d_in2; wire q_out0; wire notq_out0; wire q_out1; wire notq_out1; wire q_out2; wire notq_out2; assign d_in0 = x ^ q_out0; assign d_in1 = x \u0026 notq_out1; assign d_in2 = x | notq_out2; dffr(clk,d_in0,q_out0,notq_out0); dffr(clk,d_in1,q_out1,notq_out1); dffr(clk,d_in2,q_out2,notq_out2); assign z = ~(q_out0 | q_out1 | q_out2); endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:10:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#examsece241-2014-q4"},{"categories":["数电"],"content":" 11 Exams/ece241 2013 q7 verilog module top_module ( input clk, input j, input k, output Q); always @(posedge clk) begin case({j,k}) 2'b00: Q \u003c= Q; 2'b01: Q \u003c= 0; 2'b10: Q \u003c= 1; 2'b11: Q \u003c= ~Q; endcase end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:11:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#examsece241-2013-q7"},{"categories":["数电"],"content":" 12 Edgedetect2 verilog module top_module ( input clk, input [7:0] in, output [7:0] anyedge ); wire [7:0] pre_in; always @(posedge clk) begin integer i; for(i = 0; i \u003c 8; i++) begin if(in[i] == ~pre_in[i]) anyedge[i] = 1; else anyedge[i] = 0; end pre_in \u003c= in; end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:12:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#edgedetect2"},{"categories":["数电"],"content":" 13 Edgecapture verilog module capture_dff(input clk, input [31:0] capture_arr, output [31:0] capture_sig); always @(posedge clk) begin capture_sig \u003c= capture_arr; end endmodule module dff_out(input clk, input [31:0] capture_sig, output [31:0] out); always @(posedge clk) begin out \u003c= capture_sig; end endmodule module top_module ( input clk, input reset, input [31:0] in, output [31:0] out ); wire [31:0] capture; wire [31:0] capture_sig; wire [31:0] pre_in; always @(posedge clk) begin integer i; for(i = 0; i \u003c 32; i++) begin if(reset == 1) capture[i] = 0; else begin if(in[i] == 0 \u0026\u0026 pre_in[i] == 1) begin capture[i] = 1; end end pre_in \u003c= in; out \u003c= capture; end end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:13:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#edgecapture"},{"categories":["数电"],"content":" 14 Dualedge verilog module pos_dff(input clk, input d, output q); always @(posedge clk) begin q \u003c= d; end endmodule module neg_dff(input clk, input d, output q); always @(negedge clk) begin q \u003c= d; end endmodule module mux_clk(input sel, input d0, input d1, output q); always @(*) begin if(sel == 1'b0) q = d0; else q = d1; end endmodule module top_module ( input clk, input d, output q ); wire out1; wire out2; pos_dff(clk,d,out1); neg_dff(clk,d,out2); mux_clk(clk,out2,out1,q); endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:14:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#dualedge"},{"categories":["数电"],"content":" 15 Exams/ece241 2014 q7a verilog module top_module ( input clk, input reset, input enable, output [3:0] Q, output c_enable, output c_load, output [3:0] c_d ); // count4 the_counter (clk, c_enable, c_load, c_d, Q); assign c_enable = enable; assign c_load = (enable \u0026\u0026 (Q == 4'd12)) || (reset == 1); assign c_d = 4'd1; endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:15:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#examsece241-2014-q7a"},{"categories":["数电"],"content":" 16 Count10 verilog module top_module ( input clk, input reset, // Synchronous active-high reset output [3:0] q); always @(posedge clk) begin if(reset == 1 || q == 4'd9) q \u003c= 4'd0; else q++; end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:16:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#count10"},{"categories":["数电"],"content":" 17 Countbcd verilog module bcd_counter ( input clk, input reset, // Synchronous active-high reset input enable, output [3:0] q); always @(posedge clk) begin if(reset == 1) q \u003c= 4'd0; else begin if(enable == 1) begin if(q == 4'd9) q \u003c= 4'd0; else q++; end end end endmodule module top_module ( input clk, input reset, // Synchronous active-high reset output [3:1] ena, output [15:0] q); assign ena[1] = (q[3:0] == 4'h9); assign ena[2] = (q[7:0] == 8'h99); assign ena[3] = (q[11:0] == 12'h999); bcd_counter counter0(clk,reset,q[3:0]); bcd_counter counter1(clk,reset,ena[1],q[7:4]); bcd_counter counter2(clk,reset,ena[2],q[11:8]); bcd_counter counter3(clk,reset,ena[3],q[15:12]); endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:17:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#countbcd"},{"categories":["数电"],"content":" 18 Count clock verilog module top_module( input clk, input reset, input ena, output pm, output [7:0] hh, output [7:0] mm, output [7:0] ss); always @(posedge clk) begin if(reset == 1) begin {hh,mm,ss,pm} = {8'h12,8'h0,8'h0,1'b0}; end else begin if(ena == 1) begin case({hh,mm,ss,pm}) {8'h11,8'h59,8'h59,1'b0}: {hh,mm,ss,pm} \u003c= {8'h12,8'h0,8'h0,1'b1}; {8'h12,8'h59,8'h59,1'b1}: {hh,mm,ss,pm} \u003c= {8'h1,8'h0,8'h0,1'b1}; {8'h11,8'h59,8'h59,1'b1}: {hh,mm,ss,pm} \u003c= {8'h12,8'h0,8'h0,1'b0}; {8'h12,8'h59,8'h59,1'b0}: {hh,mm,ss,pm} \u003c= {8'h1,8'h0,8'h0,1'b0}; default: begin if({mm,ss} == {8'h59,8'h59}) begin if(hh == 8'h09) hh \u003c= 8'h10; else hh++; {mm,ss} \u003c= {8'h00,8'h00}; end else begin if(ss == 8'h59) begin if(mm[3:0] == 4'h9) begin mm[3:0] \u003c= 4'h0; mm[7:4] ++; end else mm++; ss \u003c= 8'h00; end else begin if(ss[3:0] == 4'h9) begin ss[3:0] \u003c= 4'h0; ss[7:4] ++; end else ss++; end end end endcase end end end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:18:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#count-clock"},{"categories":["数电"],"content":" 19 Lfsr5 verilog module top_module( input clk, input reset, // Active-high synchronous reset to 5'h1 output [4:0] q ); always @(posedge clk) begin if(reset) q \u003c= 5'h1; else begin q[4] \u003c= 1'b0 ^ q[0]; q[3] \u003c= q[4]; q[2] \u003c= q[3] ^ q[0]; q[1] \u003c= q[2]; q[0] \u003c= q[1]; end end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:19:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#lfsr5"},{"categories":["数电"],"content":" 20 Mt2015 lfsr verilog module mux2(input sel, input d0, input d1, output out); always @(*) begin case(sel) 1'b0: out = d0; 1'b1: out = d1; endcase end endmodule module dff1(input clk, input d, output q); always @(posedge clk) begin q \u003c= d; end endmodule module onebit(input clk, input sel, input d0, input d1, output q); wire d_in; mux2 m(sel, d0, d1, d_in); dff1 d(clk, d_in, q); endmodule module top_module ( input [2:0] SW, // R input [1:0] KEY, // L and clk output [2:0] LEDR); // Q onebit o0(KEY[0],KEY[1],LEDR[2],SW[0],LEDR[0]); onebit o1(KEY[0],KEY[1],LEDR[0],SW[1],LEDR[1]); onebit o2(KEY[0],KEY[1],LEDR[2] ^ LEDR[1],SW[2],LEDR[2]); endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:20:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#mt2015-lfsr"},{"categories":["数电"],"content":" 21 Lfsr5 verilog module top_module( input clk, input reset, // Active-high synchronous reset to 5'h1 output [4:0] q ); always @(posedge clk) begin if(reset) q \u003c= 5'h1; else begin q[4] \u003c= 1'b0 ^ q[0]; q[3] \u003c= q[4]; q[2] \u003c= q[3] ^ q[0]; q[1] \u003c= q[2]; q[0] \u003c= q[1]; end end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:21:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#lfsr5-1"},{"categories":["数电"],"content":" 22 Lfsr32 verilog module top_module( input clk, input reset, // Active-high synchronous reset to 32'h1 output [31:0] q ); always @(posedge clk) begin integer i; if(reset) q \u003c= 32'h1; else begin q[31] \u003c= q[0] ^ 1'b0; q[21] \u003c= q[0] ^ q[22]; q[1] \u003c= q[0] ^ q[2]; q[0] \u003c= q[0] ^ q[1]; for(i = 0; i \u003c 32; i++) begin if(!(i == 31 || i == 21 || i == 1 || i == 0)) q[i] \u003c= q[i+1]; end end end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:22:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#lfsr32"},{"categories":["数电"],"content":" 23 Exams/m2014 q4k verilog module dffnr(input clk, input resetn, input d, output q); always @(posedge clk) begin if(resetn == 0) q \u003c= 1'b0; else begin q \u003c= d; end end endmodule module top_module ( input clk, input resetn, // synchronous reset input in, output out); wire out3; wire out2; wire out1; dffnr d3(clk, resetn, in, out3); dffnr d2(clk, resetn, out3, out2); dffnr d1(clk, resetn, out2, out1); dffnr d0(clk, resetn, out1, out); endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:23:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#examsm2014-q4k"},{"categories":["数电"],"content":" 24 Exams/2014 q4a verilog module dff1(input clk, input d, output reg Q); always @(posedge clk) begin Q = d; end endmodule module mux1(input sel, input port0, input port1, output out); always @(*) begin case(sel) 1'b0: out = port0; 1'b1: out = port1; endcase end endmodule module top_module ( input clk, input w, R, E, L, output Q ); wire q_in; wire mux_out; wire d_in; mux1(E,q_in,w,mux_out); mux1(L,mux_out,R,d_in); dff1(clk,d_in,q_in); assign Q = q_in; endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:24:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#exams2014-q4a"},{"categories":["数电"],"content":" 25 Exams/2014 q4b verilog module MUX1(input sel, input data0, input data1, output out); always @(*) begin if(sel == 1'b0) out = data0; else out = data1; end endmodule module DFF1(input clk, input D, output Q); always @(posedge clk) begin Q \u003c= D; end endmodule module MUXDFF (input clk, input sel0, input data0, input data1, input sel1, input data2, output out); wire out1; wire d_in; MUX1(sel0, data0, data1, out1); MUX1(sel1, out1, data2, d_in); DFF1(clk, d_in, out); endmodule module top_module ( input [3:0] SW, input [3:0] KEY, output [3:0] LEDR ); // //clk, sel0, data0, data1, sel1, data2, out MUXDFF(KEY[0],KEY[1],LEDR[3],KEY[3],KEY[2],SW[3],LEDR[3]); MUXDFF(KEY[0],KEY[1],LEDR[2],LEDR[3],KEY[2],SW[2],LEDR[2]); MUXDFF(KEY[0],KEY[1],LEDR[1],LEDR[2],KEY[2],SW[1],LEDR[1]); MUXDFF(KEY[0],KEY[1],LEDR[0],LEDR[1],KEY[2],SW[0],LEDR[0]); endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:25:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#exams2014-q4b"},{"categories":["数电"],"content":" 26 Exams/m2014 q4k verilog module dffnr(input clk, input resetn, input d, output q); always @(posedge clk) begin if(resetn == 0) q \u003c= 1'b0; else begin q \u003c= d; end end endmodule module top_module ( input clk, input resetn, // synchronous reset input in, output out); wire out3; wire out2; wire out1; dffnr d3(clk, resetn, in, out3); dffnr d2(clk, resetn, out3, out2); dffnr d1(clk, resetn, out2, out1); dffnr d0(clk, resetn, out1, out); endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:26:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#examsm2014-q4k-1"},{"categories":["数电"],"content":" 27 Rule90 verilog module top_module( input clk, input load, input [511:0] data, output [511:0] q ); always @(posedge clk) begin if(load) q \u003c= data; else begin integer i; q[0] \u003c= 0 ^ q[1]; q[511] \u003c= 0 ^ q[510]; for(i = 1; i \u003c= 510; i++) begin q[i] \u003c= q[i-1] ^ q[i+1]; end end end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:27:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#rule90"},{"categories":["数电"],"content":" 28 Rule110 verilog module comp(input a, input b, input c, output s); assign s = (~b \u0026 c) | (~a \u0026 b) | (b \u0026 ~c); endmodule module top_module( input clk, input load, input [511:0] data, output [511:0] q ); wire [511:0] next_q; generate genvar i; comp c1(q[1],q[0],next_q[0]); comp c2(0,q[511],q[510],next_q[511]); for(i = 1; i \u003c= 510; i++) begin: comp_block comp (q[i+1],q[i],q[i-1],next_q[i]); end endgenerate always @(posedge clk) begin if(load) q \u003c= data; else begin q \u003c= next_q; end end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:28:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#rule110"},{"categories":["数电"],"content":" 29 Fsm1 verilog module top_module( input clk, input areset, // Asynchronous reset to state B input in, output out);// parameter A=0, B=1; reg state, next_state; always @(*) begin // This is a combinational always block // State transition logic next_state = (state \u0026 in) | (~state \u0026 ~in); end always @(posedge clk, posedge areset) begin // This is a sequential always block // State flip-flops with asynchronous reset if(areset) state \u003c= B; else begin state \u003c= next_state; end end // Output logic // assign out = (state == ...); assign out = (state == B); endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:29:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#fsm1"},{"categories":["数电"],"content":" 30 Exams/ece241 2013 q4 verilog module top_module ( input clk, input reset, input [3:1] s, output fr3, output fr2, output fr1, output dfr ); wire [1:0] next_state; wire [1:0] state; wire [1:0] past_state; // from s to state always @(*) begin if(reset) next_state = 2'd0; else begin case({s}) 3'b111: next_state = 2'd3; 3'b011: next_state = 2'd2; 3'b001: next_state = 2'd1; 3'b000: next_state = 2'd0; default: next_state = 2'd0; endcase end end // from state to next_state always @(posedge clk) begin if(reset) begin past_state \u003c= {2'd0}; state \u003c= {2'd0}; end else begin past_state \u003c= state; state \u003c= next_state; end end // output logic always @(*) begin fr1 = 0; fr2 = 0; fr3 = 0; casez({state,past_state}) {2'd3,2'bzz}: begin dfr = 0; end {2'd2,2'd3}: begin fr1 = 1; dfr = 1; end {2'd2,2'd2}: begin fr1 = 1; end {2'd2,2'd1}: begin fr1 = 1; dfr = 0; end {2'd2,2'd0}: begin fr1 = 1; dfr = 0; end {2'd1,2'd3}: begin fr1 = 1; fr2 = 1; dfr = 1; end {2'd1,2'd2}: begin fr1 = 1; fr2 = 1; dfr = 1; end {2'd1,2'd1}: begin fr1 = 1; fr2 = 1; end {2'd1,2'd0}: begin fr1 = 1; fr2 = 1; dfr = 0; end {2'd0,2'bzz}: begin fr1 = 1; fr2 = 1; fr3 = 1; dfr = 1; end endcase end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:30:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#examsece241-2013-q4"},{"categories":["数电"],"content":" 31 Lemmings1 verilog module top_module( input clk, input areset, // Freshly brainwashed Lemmings walk left. input bump_left, input bump_right, output walk_left, output walk_right); // parameter LEFT=0, RIGHT=1; reg state, next_state; always @(*) begin // State transition logic if(state == LEFT) begin if(bump_left) next_state = RIGHT; else next_state = LEFT; end else begin if(bump_right) next_state = LEFT; else next_state = RIGHT; end end always @(posedge clk, posedge areset) begin // State flip-flops with asynchronous reset if(areset) state \u003c= LEFT; else state \u003c= next_state; end // Output logic // assign walk_left = (state == ...); // assign walk_right = (state == ...); assign walk_left = (state == LEFT); assign walk_right = (state == RIGHT); endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:31:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#lemmings1"},{"categories":["数电"],"content":" 32 Lemmings2 verilog module top_module( input clk, input areset, // Freshly brainwashed Lemmings walk left. input bump_left, input bump_right, input ground, output walk_left, output walk_right, output aaah ); // state parameter parameter LEFT = 2'd0, RIGHT = 2'd1, FALL_L = 2'd2, FALL_R = 2'd3; reg [1:0] state; reg [1:0] next_state; // state transition logic always @(*) begin if(state == LEFT) begin if(!ground) begin next_state = FALL_L; end else begin if(bump_left) next_state = RIGHT; else next_state = LEFT; end end if(state == RIGHT) begin if(!ground) begin next_state = FALL_R; end else begin if(bump_right) next_state = LEFT; else next_state = RIGHT; end end if(state == FALL_L) begin if(ground) next_state = LEFT; else next_state = FALL_L; end if(state == FALL_R) begin if(ground) next_state = RIGHT; else next_state = FALL_R; end end // generate next_state always @(posedge clk, posedge areset) begin if(areset) state \u003c= LEFT; else state \u003c= next_state; end // output logic always @(*) begin walk_left = 0; walk_right = 0; if(state == LEFT) begin walk_left = 1; walk_right = 0; end if(state == RIGHT) begin walk_right = 1; walk_left = 0; end if(state == FALL_L | state == FALL_R) aaah = 1; else aaah = 0; end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:32:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#lemmings2"},{"categories":["数电"],"content":" 33 Lemmings4 verilog module top_module( input clk, input areset, // Freshly brainwashed Lemmings walk left. input bump_left, input bump_right, input ground, input dig, output walk_left, output walk_right, output aaah, output digging ); // parameter and state register parameter LEFT = 0, RIGHT = 1, DIG_L = 2, DIG_R = 3, FALL_L = 4, FALL_R = 5, SPLAT = 6; reg [2:0] state, next_state; integer counter; // next state combination logic always @(*) begin next_state = state; case({state}) LEFT: begin if(!ground) next_state = FALL_L; if(ground \u0026 dig) next_state = DIG_L; if(ground \u0026 !dig \u0026 bump_left) next_state = RIGHT; end DIG_L: begin if(!ground) next_state = FALL_L; if(ground \u0026 dig) next_state = DIG_L; end FALL_L: begin if(counter \u003c= 20 \u0026 ground) next_state = LEFT; if(counter \u003e 20 \u0026 ground) next_state = SPLAT; end RIGHT: begin if(!ground) next_state = FALL_R; if(ground \u0026 dig) next_state = DIG_R; if(ground \u0026 !dig \u0026 bump_right) next_state = LEFT; end DIG_R: begin if(!ground) next_state = FALL_R; if(ground \u0026 dig) next_state = DIG_R; end FALL_R: begin if(counter \u003c= 20 \u0026 ground) next_state = RIGHT; if(counter \u003e 20 \u0026 ground) next_state = SPLAT; end SPLAT: begin end endcase end // generate next state(sequanetial logic) always @(posedge clk, posedge areset) begin if(areset) begin state \u003c= LEFT; counter \u003c= 0; end else begin state \u003c= next_state; if(!ground) counter \u003c= counter + 1; else counter \u003c= 0; end end // output logic always @(*) begin walk_left = 0; walk_right = 0; aaah = 0; digging = 0; if(state == LEFT) walk_left = 1; if(state == RIGHT) walk_right = 1; if(state == DIG_L | state == DIG_R) digging = 1; if(state == FALL_L | state == FALL_R) aaah = 1; end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:33:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#lemmings4"},{"categories":["数电"],"content":" 34 Fsm ps2 verilog module top_module( input clk, input [7:0] in, input reset, // Synchronous reset output done); // reg [1:0] state; reg [1:0] next_state; // State transition logic (combinational) always @(*) begin if(state == 2'd0 \u0026\u0026 ~in[3]) next_state = 2'd0; if(state == 2'd0 \u0026\u0026 in[3]) next_state = 2'd1; if(state == 2'd1) next_state = 2'd2; if(state == 2'd2) next_state = 2'd3; if(state == 2'd3 \u0026\u0026 ~in[3]) next_state = 2'd0; if(state == 2'd3 \u0026\u0026 in[3]) next_state = 2'd1; end // State flip-flops (sequential) always @(posedge clk) begin if(reset) state \u003c= 2'd0; else state \u003c= next_state; end // Output logic assign done = (state == 2'd3); endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:34:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#fsm-ps2"},{"categories":["数电"],"content":" 35 Fsm ps2data verilog module top_module( input clk, input [7:0] in, input reset, // Synchronous reset output [23:0] out_bytes, output done); // reg [1:0] state; reg [1:0] next_state; wire [23:0] out_temp; // State transition logic (combinational) always @(*) begin if(state == 2'd0 \u0026\u0026 ~in[3]) next_state = 2'd0; if(state == 2'd0 \u0026\u0026 in[3]) begin next_state = 2'd1; out_temp[23:16] = in; end if(state == 2'd1) begin next_state = 2'd2; out_temp[15:8] = in; end if(state == 2'd2) begin next_state = 2'd3; out_temp[7:0] = in; out_bytes = out_temp; end if(state == 2'd3 \u0026\u0026 ~in[3]) begin // out_bytes = out_temp; next_state = 2'd0; end if(state == 2'd3 \u0026\u0026 in[3]) begin next_state = 2'd1; // out_bytes = out_temp; out_temp[23:16] = in; end end // State flip-flops (sequential) always @(posedge clk) begin if(reset) begin state \u003c= 2'd0; end else state \u003c= next_state; end // Output logic assign done = (state == 2'd3); endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:35:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#fsm-ps2data"},{"categories":["数电"],"content":" 36 Fsm serial verilog module top_module( input clk, input in, input reset, // Synchronous reset output done ); reg [3:0] state, next_state; // transition logic design always @(*) begin next_state = state; casez({state,in}) {4'd0,1'b0}: next_state = 4'd1; {4'd0,1'b1}: next_state = 4'd0; {4'd1,1'bz}: next_state = 4'd2; {4'd2,1'bz}: next_state = 4'd3; {4'd3,1'bz}: next_state = 4'd4; {4'd4,1'bz}: next_state = 4'd5; {4'd5,1'bz}: next_state = 4'd6; {4'd6,1'bz}: next_state = 4'd7; {4'd7,1'bz}: next_state = 4'd8; {4'd8,1'bz}: next_state = 4'd9; {4'd9,1'b0}: next_state = 4'd11; {4'd9,1'b1}: next_state = 4'd10; {4'd10,1'b0}: next_state = 4'd1; {4'd10,1'b1}: next_state = 4'd0; {4'd11,1'b0}: next_state = 4'd11; {4'd11,1'b1}: next_state = 4'd0; endcase end // next state sequential logic always @(posedge clk) begin if(reset) state \u003c= 4'd0; else state \u003c= next_state; end // output logic assign done = (state == 4'd10); endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:36:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#fsm-serial"},{"categories":["数电"],"content":" 37 Tb/clock verilog module top_module (); reg clk; parameter PERIOD = 10; initial begin clk = 0; forever #(PERIOD/2) clk = ~clk; end dut d(clk); endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:37:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#tbclock"},{"categories":["数电"],"content":" 38 Tb/clock verilog module top_module (); reg clk; parameter PERIOD = 10; initial begin clk = 0; forever #(PERIOD/2) clk = ~clk; end dut d(clk); endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:38:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#tbclock-1"},{"categories":["数电"],"content":" 39 Tb/tb1 verilog module top_module ( output reg A, output reg B );// // generate input patterns here initial begin A = 0; B = 0; #10 A = 1; B = 0; #5 A = 1; B = 1; #5 A = 0; B = 1; #20 A = 0; B = 0; end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:39:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#tbtb1"},{"categories":["数电"],"content":" 40 Tb/and verilog module top_module(); reg [1:0] in; reg out; andgate a(in,out); initial begin in[0] = 0; in[1] = 0; #10 in[0] = 1; in[1] = 0; #10 in[0] = 0; in[1] = 1; #10 in[0] = 1; in[1] = 1; end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:40:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#tband"},{"categories":["数电"],"content":" 41 Tb/tb2 verilog module top_module(); reg clk; parameter PERIOD = 5; reg in; reg [2:0] s; reg out; q7 q(clk,in,s,out); initial begin clk = 0; forever #(PERIOD) clk=~clk; end initial begin in = 1'b0; s = 3'd2; #10 in = 1'b0; s = 3'd6; #10 in = 1'b1; s = 3'd2; #10 in = 1'b0; s = 3'd7; #10 in = 1'b1; s = 3'd0; #30 in = 1'b0; s = 3'd0; end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:41:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#tbtb2"},{"categories":["数电"],"content":" 42 Exams/review2015 shiftcount verilog module top_module ( input clk, input shift_ena, input count_ena, input data, output [3:0] q); always @(posedge clk) begin if(shift_ena) begin q[3] \u003c= q[2]; q[2] \u003c= q[1]; q[1] \u003c= q[0]; q[0] \u003c= data; end if(count_ena) q \u003c= q - 1; end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:42:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#examsreview2015-shiftcount"},{"categories":["数电"],"content":" 43 Exams/review2015 fancytimer verilog module shiftcount ( input clk, input shift_ena, input count_ena, input data, output [3:0] q, output [31:0] countnum, output done_counting); always @(posedge clk) begin if(shift_ena) begin q[3] \u003c= q[2]; q[2] \u003c= q[1]; q[1] \u003c= q[0]; q[0] \u003c= data; end if(count_ena) begin countnum ++; end else countnum \u003c= 32'd0; end assign done_counting = (countnum == (q + 1) * 1000 - 1); endmodule module top_module ( input clk, input reset, // Synchronous reset input data, output [3:0] count, output counting, output done, input ack ); reg [3:0] state, next_state; wire done_counting; wire shift_ena; reg [3:0] delay; reg [31:0] cnt; parameter S = 4'd0, S1 = 4'd1, S2 = 4'd2, S3 = 4'd3, B0 = 4'd4, B1 = 4'd5, B2 = 4'd6, B3 = 4'd7; parameter Count = 4'd8, Wait = 4'd9; shiftcount sc(clk, shift_ena, counting, data, delay, cnt, done_counting); assign count = delay - cnt / 1000; // calculate done_counting and counting // always @(*) begin // done_counting = (count == 4'hf); // end // next state logic always @(*) begin next_state = state; if(state == S) begin if(data == 0) next_state = S; if(data == 1) next_state = S1; end if(state == S1) begin if(data == 0) next_state = S; if(data == 1) next_state = S2; end if(state == S2) begin if(data == 0) next_state = S3; if(data == 1) next_state = S2; end if(state == S3) begin if(data == 0) next_state = S; if(data == 1) next_state = B0; end if(state == B0) begin next_state = B1; end if(state == B1) begin next_state = B2; end if(state == B2) begin next_state = B3; end if(state == B3) begin next_state = Count; end if(state == Count) begin if(done_counting) next_state = Wait; if(!done_counting) next_state = Count; end if(state == Wait) begin if(ack) next_state = S; if(!ack) next_state = Wait; end end // generate next state always @(posedge clk) begin if(reset) state \u003c= S; else state \u003c= next_state; end // output logic always @(*) begin shift_ena = (state == B0) | (state == B1) | (state == B2) | (state == B3); counting = (state == Count); done = (state == Wait); end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:43:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#examsreview2015-fancytimer"},{"categories":["数电"],"content":" 44 Cs450/counter 2bc verilog module top_module( input clk, input areset, input train_valid, input train_taken, output [1:0] state ); parameter SN = 2'd0, WN = 2'd1, WT = 2'd2, ST = 2'd3; reg [1:0] next_state; // next state transition logic always @(*) begin next_state = state; if(train_valid == 1'b1) begin if(state == SN) begin next_state = (train_taken == 1'b0)? SN: WN; end if(state == WN) begin next_state = (train_taken == 1'b0)? SN: WT; end if(state == WT) begin next_state = (train_taken == 1'b0)? WN: ST; end if(state == ST) begin next_state = (train_taken == 1'b0)? WT:ST; end end end // generate next state always @(posedge clk, posedge areset) begin if(areset) state \u003c= WN; else state \u003c= next_state; end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:44:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#cs450counter-2bc"},{"categories":["数电"],"content":" 45 Cs450/history shift verilog module top_module( input clk, input areset, input predict_valid, input predict_taken, output [31:0] predict_history, input train_mispredicted, input train_taken, input [31:0] train_history ); always @(posedge clk, posedge areset) begin if(areset) predict_history \u003c= 32'd0; else begin if(train_mispredicted) begin predict_history \u003c= {train_history[30:0], train_taken}; end else if(predict_valid) begin predict_history \u003c= {predict_history[30:0], predict_taken}; end end end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:45:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#cs450history-shift"},{"categories":["数电"],"content":" 46 Cs450/gshare verilog module top_module( input clk, input areset, input predict_valid, // 是否在预测，否则是训练，优先级低于train_mispredicted input [6:0] predict_pc, // 当前预测的pc output predict_taken, // 新的预测分支指令 output [6:0] predict_history, // 预测历史 input train_valid, // 正在训练，需要更新counter_2bc input train_taken, // 训练的新值，输入到counter_2bc input train_mispredicted, // 预测失败，需要洗流水线 input [6:0] train_history, // 预测失败后，预留的流水线历史 input [6:0] train_pc // 训练的pc ); reg [1:0] pht [127:0]; // ghr表，每个是2个state， reg [6:0] predict_idx; reg [6:0] train_idx; reg [1:0] predict_state; // reg [6:0] ghr; integer i; // for generate pht[train_idx]; parameter SN = 2'd0, WN = 2'd1, WT = 2'd2, ST = 2'd3; reg [1:0] next_state; // assign predict_history = ghr; assign predict_idx = predict_pc ^ predict_history; assign predict_taken = pht[predict_idx][1]; assign train_idx = train_pc ^ train_history; always @(posedge clk, posedge areset) begin if(areset) begin predict_history \u003c= 7'd0; for (i = 0; i \u003c 128; i = i + 1) begin pht[i] \u003c= WN; // 将所有PHT条目初始化为WN (2'b01) end end else begin if(train_valid) begin case(pht[train_idx]) SN: pht[train_idx] \u003c= (train_taken == 1'b0)? SN: WN; WN: pht[train_idx] \u003c= (train_taken == 1'b0)? SN: WT; WT: pht[train_idx] \u003c= (train_taken == 1'b0)? WN: ST; ST: pht[train_idx] \u003c= (train_taken == 1'b0)? WT:ST; endcase end if(train_valid \u0026 train_mispredicted) begin predict_history \u003c= {train_history[5:0], train_taken}; end else if(predict_valid) begin predict_history \u003c= {predict_history[5:0], predict_taken}; end end end endmodule ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:46:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#cs450gshare"},{"categories":["数电"],"content":" 47 参考资料 有限状态机 - 数字电路教程 Logisim基本使用 蓝灰红线出现原因_logisim蓝色线怎么变成绿色-CSDN博客 logisim输出值为E是什么意思啊?求告知。_测试-CSDN问答 数字电路教程 HDLbits学习记录 uwaterloo cs450 - 知乎 Verilog Tutorial（6）如何编写一个基础的Testbench_verilog testbench怎么写-CSDN博客 6.6 Verilog 仿真激励 | 菜鸟教程 TestBench 编写及仿真 - 数字电路教程 【数字IC设计】Testbench 编写基础 - Hypoxanthine’s Blog | 贺云翔的博客 TestBench基本写法与语法详解 - 知乎 6.6 Verilog 仿真激励 | 菜鸟教程 Verilog测试（仿真）文件TestBench如何编写_verilog测试文件怎么写-CSDN博客 Generate custom waveform in verilog - EDA Playground Verilog Clock Generator - Alphom Silicon 仿真时间`timescale 1ns/1ps 的定义 延迟赋值与阻塞赋值非阻塞赋值的一个小问题-CSDN博客 Verilog Clock Generator How to set all the bits to be 0 in a two-dimensional array in Verilog? - Stack Overflow Verilog初级教程（11）Verilog中的initial块_verilog initial-CSDN博客 Verilog Clock Generator - Alphom Silicon Verilog Clock Generator Verilog 变量初始化_tlc16c550c初始化verilog-CSDN博客 13.Verilog中的时钟(clk)的产生方法_verilog 时钟-CSDN博客 HDLbits Lemmings4_falling for 20 cycles is survivable:-CSDN博客 systemverilog编程陷阱——自加与赋值冲突_system verilog里的++是先赋值还是先加一-CSDN博客 简单时序逻辑电路 - 数字电路教程 复杂时序逻辑电路 - 数字电路教程 7.1 Verilog 除法器设计 | 菜鸟教程 verilog中的除法运算/_verilog 除法-CSDN博客 Linear-feedback shift register - Wikipedia 【HDLBits刷题笔记】10 Counters - Magnolia666 - 博客园 HDL-Bits 刷题记录 02-阿里云开发者社区 Verilog之非阻塞赋值（三）—— 赋值延后一个周期_verilog延迟一个周期-CSDN博客 Verilog中的#延时_verilog 一定要加延迟吗 #-CSDN博客 为什么时序逻辑电路会落后一拍？ | FPGA 开发圈 简单时序逻辑电路 - 数字电路教程 Verilog中使用连续@posedge会是什么现象，是否可综合_verilog 可以有2个posedge吗-CSDN博客 【HDLBits刷题】Exams/ece241 2013 q7._改写下述jk触发器程序,用case语句实现相同功能。请将改写之后的完整程序写出-CSDN博客 FPGA错误集锦(三):[No output dependent on input pin “clk“]-CSDN博客 TestBench 编写及仿真 - 数字电路教程 记录一下verilog重复例化的两种方式_verilog 多次例化module-CSDN博客 【HDLBits刷题】Dff8r-CSDN博客 HDLBits - Circuits / Sequential Logic / Latches and Flip-Flops | by yfwang | Medium Verilog使用always块实现时序逻辑 | FPGA 开发圈 verilog-doc/HDLBits_doc/verilog.md at master · Yvan-xy/verilog-doc 【HDLBits刷题】Adder100.-CSDN博客 Verilog实现加法运算：从半加器到BCD码加法器-CSDN博客 64，Verilog-2005标准篇：行为模型（behavioral model）简介_数字behavior model-CSDN博客 Verilog 语法 - 数字电路教程 行為層次 Behavior Level | Verilog HDL 教學講義 Verilog Behavioral Modeling Part-I Behavioral Model (Verilog) 【HDLBits刷题笔记】14 Building Larger Circuits - Magnolia666 - 博客园 ","date":"2025-01-24","objectID":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/:47:0","series":null,"tags":["HDLBits"],"title":"HDLBits 题解记录","uri":"/hdlbits-%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/#参考资料"},{"categories":["理论计算机"],"content":" 1 图灵机设计对二进制加法过程进行分析，我们可以得出如下过程： 使用小端法在纸带上存储输入的二进制串，即低位放在最左边 第一格是blank，也就是空，最后我们会回退到这个状态，来进入halt状态 最初是start状态，经过blank后改为carry状态 carry状态下，如果最低为是 0，那么直接将其加 1，然后返回（向左行走）即可，进入back状态 carry状态下，如果最低为是 1，将其改为 0，保持carry状态向右行走，继续对高位进行修改 如果在carry状态下遇到blank，也就是最高位还有进位，那么将blank改为 1 在回退状态下，一般来说只会遇到0，保留 0 不动，继续回退 达到halt之后停止操作，打印字符串 那么，在该图灵机中，我们需要使用到如下几个状态： start，即开始状态 carry，进位状态 back，回退状态 halt，停止状态 有如下几种符号： blank，表示空 0，即二进制符号 0 1，即二进制符号 1 根据设计，图灵机定义二进制加法的计算过程如下： start, blank-\u003eblank, RIGHT, carry carry, 1 -\u003e 0, RIGHT, carry carry, blank-\u003e1, LEFT, back carry, 0-\u003e1, LEFT, back back, 0-\u003e0, LEFT, back back, blank-\u003eblank, halt ","date":"2025-01-12","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:1:0","series":null,"tags":["图灵机","计算理论"],"title":"二进制加法图灵机的C语言实现","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/#图灵机设计"},{"categories":["理论计算机"],"content":" 2 C 语言代码实现 c // Turing machines for computations. #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #define N 4 // the number of states #define M 3 // the number of symbols #define TAPE_SIZE 20 // the size of the tape enum direction { LEFT, RIGHT, STAY }; /** * @brief encoding for binary addtion * 1. 4 states start:0 carry:1 back:2 halt:3 * 2. 3 symbols 0-\u003e0 1-\u003e1 blank-\u003e2 */ enum STATE { START, CARRY, BACK, HALT }; enum SYMBOL { SYMBOL_0, SYMBOL_1, BLANK }; int state_arr [N]; // state_arr[0] as start state, state_arr[N-2] as accept state, state_arr[N-1] as reject state int symbol_arr[M]; // symbol_arr[0] as empty symbol int tape[TAPE_SIZE]; typedef struct head { int location; // the location of the head int state_num; // the state of the head } head_t; typedef struct action { int head_state; int current_symbol; int next_symbol; enum direction dir; int next_state; } action_t; /** * @brief turing machine for binary addition * 1. start, blank-\u003eblank, RIGHT, carry * 2. carry, 1 -\u003e 0, RIGHT, carry * 3. carry, blank-\u003e1, LEFT, back * 4. carry, 0-\u003e1, LEFT, back * 5. back, 0-\u003e0, LEFT, back * 6. back, blank-\u003eblank, halt */ action_t turing_machine(action_t act) { if (act.head_state == state_arr[START] \u0026\u0026 act.current_symbol == symbol_arr[BLANK]) { act.next_symbol = act.current_symbol; act.dir = RIGHT; act.next_state = state_arr[CARRY]; } else if (act.head_state == state_arr[CARRY] \u0026\u0026 act.current_symbol == symbol_arr[SYMBOL_1]) { act.next_symbol = symbol_arr[SYMBOL_0]; act.dir = RIGHT; act.next_state = act.head_state; } else if (act.head_state == state_arr[CARRY] \u0026\u0026 act.current_symbol == symbol_arr[BLANK]) { act.next_symbol = symbol_arr[SYMBOL_1]; act.dir = LEFT; act.next_state = state_arr[BACK]; } else if (act.head_state == state_arr[CARRY] \u0026\u0026 act.current_symbol == symbol_arr[SYMBOL_0]) { act.next_symbol = symbol_arr[SYMBOL_1]; act.dir = LEFT; act.next_state = state_arr[BACK]; } else if (act.head_state == state_arr[BACK] \u0026\u0026 act.current_symbol == symbol_arr[SYMBOL_0]) { act.next_symbol = act.current_symbol; act.dir = LEFT; act.next_state = state_arr[BACK]; } else if (act.head_state == state_arr[BACK] \u0026\u0026 act.current_symbol == symbol_arr[BLANK]) { act.next_symbol = act.current_symbol; act.dir = STAY; act.next_state = state_arr[HALT]; } return act; } void state_transition(char* s, int length) { // initiliaze the state array and symbol array for (int i = 0; i \u003c N; i++) { state_arr[i] = i; } for (int i = 0; i \u003c M; i++) { symbol_arr[i] = i; } // initialize the tape for (int i = 0; i \u003c TAPE_SIZE; i++) { tape[i] = BLANK; // initialize all tape as blank } for (int i = 0; i \u003c length; i++) { tape[i + 1] = s[i] - '0'; } // initialize the head head_t h; h.location = 0; h.state_num = state_arr[START]; // initialie the action action_t a; a.dir = STAY; // define the state transition while (h.state_num != 3) { a.head_state = h.state_num; a.current_symbol = tape[h.location]; a = turing_machine(a); tape[h.location] = a.next_symbol; // update the head if (a.dir == RIGHT) { h.location += 1; } else if (a.dir == LEFT) { h.location -= 1; } h.state_num = a.next_state; } // print the added string for (int i = length; i \u003e= 1; i--) { printf(\"%d\", tape[i]); } } int main(void) { printf(\"Input the binary string: \"); char* s = (char*)malloc(10 * sizeof(char)); scanf(\"%s\", s); // reverse the string, and enter it into turing machine int length = strlen(s); for (int i = 0; i \u003c length / 2; i++) { char temp = s[length - 1 - i]; s[length - 1 - i] = s[i]; s[i] = temp; } state_transition(s, strlen(s)); return 0; } ","date":"2025-01-12","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:2:0","series":null,"tags":["图灵机","计算理论"],"title":"二进制加法图灵机的C语言实现","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/#c-语言代码实现"},{"categories":["Linux"],"content":" Warning 此坑还没填完，暂时只添加了安装部分（装完发现 Arch wiki 实在是已经写得很详细了），还有很多的知识还没有完全弄清楚和补充。 等我学习完计算机组成原理，操作系统和计算机网络后会再来填坑。 本文安装过程基本按照 Arch Linux 安装文档，附带了额外的相关知识。其中可能伴有踩坑，但是也是一种经验啦！ 如发现本文某些地方有误，请在评论区评论，我看到的话会改过来哒！ ","date":"2023-10-12","objectID":"/vmware/:0:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#"},{"categories":["Linux"],"content":" 1 写作起因Arch Linux 的安装过程涉及较多的操作系统知识，而不仅仅是像 Ubuntu/Debian 那样提供 GUI 中的几个选项供你选择。此外，Arch Linux 的文档较为详细（Arch wiki 简直是棒极了！）。 因此，本教程不只是演示本人的安装\u0026踩坑过程，还附带许多的相关文档带读、踩坑原因分析等。 ","date":"2023-10-12","objectID":"/vmware/:1:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#写作起因"},{"categories":["Linux"],"content":" 2 本文适合哪些人 热爱倒腾的 不怕踩坑的 想要通过 Arch Linux 安装过程递归学习其他知识的 ","date":"2023-10-12","objectID":"/vmware/:2:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#本文适合哪些人"},{"categories":["Linux"],"content":" 3 对于其他同学若您仅需要高效的安装 Arch Linux，而不希望看相关知识及其他无关的踩坑过程的，可以： 参考其他博主的奶妈式教程 Arch Linux 详细安装教程，萌新再也不怕了！「2023.09」 archlinux 简明指南 包含安装、配置、维护等，帮助新手快速上手 Arch Linux 安装使用教程 - ArchTutorial - Arch Linux Studio Github 教程 1 Github 教程 2 2022 年 12 月最新安装 Archlinux 一次过的教程 2022.5 archlinux 详细安装过程 ArchLinux 安装指南（新手向） Archlinux 安装教程超详细（2021.11.15 Arch Linux 完全安装教程 2023.10 archinstall 工具 用 archinstall 自动化脚本安装 Arch Linux archinstall github 链接 一些图形化界面安装工具 Zen installer archlinuxgui Netboot 网络安装 Github 上提供的脚本（按照里面的命令一个个输入） 其他安装方式 要在一个 Ubuntu 虚拟机上安装 Arch 虚拟机（嵌套虚拟机），请看这里 ","date":"2023-10-12","objectID":"/vmware/:3:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#对于其他同学"},{"categories":["Linux"],"content":" 4 前言在使用 Arch 前看了 UCB System Admin Decal 的 Linux Pre-install and Install 一节，其中的实验是在 Ubuntu 虚拟机上安装 Arch。Arch 的安装涉及到自己进行分区，对系统进行加密和解密等，我觉得非常有趣，对于操作系统本身也是一个探索的过程。因此决定挑战自己跟着官方文档进行安装。 以前每次安装 Linux 虚拟机，包括 Ubuntu 和 Debian，都是跟着一些博主自己写的奶妈式手把手安装教程一步步的装。每次都能安装成功，但是总是感觉少了一些【探索的乐趣】😆。 今天我就要跟着 Arch Linux 的官方文档一步步装，感受一把极致的安装酸爽体验！ 如果你也想体验自己安装 Arch，或者是想成为 Arch 开发者，下面内容可能对你有帮助： Arch Linux 官方安装文档 Issue tracker Mailing List 常见问题及解答 帮助 贡献项目 帮助手册 ","date":"2023-10-12","objectID":"/vmware/:4:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#前言"},{"categories":["Linux"],"content":" 5 过程简介安装过程涉及到的步骤包含： UEFI 模式启动（或 BIOS，但是分区会不一样，需要注意） 设置键盘模式 检查网络连接 更新系统时钟 创建磁盘分区 初始化分区中的文件系统（/文件系统可选是否加密） 挂载文件系统 利用pacstrap安装必要的包：linux 内核，initrd、init system、pacman\\、base等等 利用genfstab生成/etc/fstab（文件系统表） arch-chroot进入/mnt目录 通过修改/etc/hostname修改主机名 boot 启动原理如下： 图源自 UCB System Admin Decal(https://docs.google.com/presentation/d/1oLtsjsEIsvChOI31_5YYFhILfzGlyx7Hk9DsL1Nv-mc/edit?pli=1#slide=id.g9b414dda04_0_158) ","date":"2023-10-12","objectID":"/vmware/:5:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#过程简介"},{"categories":["Linux"],"content":" 6 获取安装镜像（后缀为.iso）看了一下下载界面，最顶部写了当前发行版的信息，下面是对于几种不同用户的安装方式以及校验和，最后是所有的 Arch 镜像源集合。 ","date":"2023-10-12","objectID":"/vmware/:6:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#获取安装镜像后缀为iso"},{"categories":["Linux"],"content":" 6.1 发行版信息当前发布版本: 2023.09.01 内核版本: 6.4.12 ISO 镜像文件大小: 804.3 MB ","date":"2023-10-12","objectID":"/vmware/:6:1","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#发行版信息"},{"categories":["Linux"],"content":" 6.2 几种下载方式 6.2.1 对于已经是 Arch 用户的人 通过命令pacman -Syu更新 通过这里更新镜像源 6.2.2 种子链接下载（官方推荐）对于这种资源，可以使用百度网盘或者迅雷下载（和下载电影相同），下载格式为.torrent，该种子链接需要上传到百度网盘/迅雷，然后将其中的 iso 镜像文件下载到本地目录中。 6.2.3 Netboot安装时需要联网，最新版本会自动推送，可用于在系统启动时即时下载最新的 Arch Linux 版本。 Netboot 使用定制的 iPXE 版本。 实时系统的 Linux 内核、initramfs 和 squashfs 文件是从 Arch Linux 镜像下载的。 所有下载文件的完整性都使用加密签名进行验证。 这其中有几个问题： iPXE是啥？一种开源的网络启动固件 其官方文档中的描述如下： iPXE 是领先的开源网络引导固件。它提供了完整的 PXE 实现，并通过其他功能进行了增强，例如： 通过 HTTP 从 Web 服务器启动 从 iSCSI SAN 引导 通过 FCoE 从光纤通道 SAN 启动 从 AoE SAN 引导 从无线网络引导 从广域网引导 从 Infiniband 网络引导 使用脚本控制引导过程 由此可以看出，iPXE 是一种基于网络进行系统启动的固件。它的启动需要依附于计算机网络的各种协议。在 Arch Linux 文档中也指明，使用 Netboot 安装需要满足以下两点要求： 具有 DHCP 自配置的网络 能够运行系统的足够存储 而它的具体实现是基于PXE协议。 基于递归学习的理念，我又查了查PXE。。。 其基本概念如下： 预启动执行环境（Preboot eXecution Environment，PXE，也被称为预执行环境）提供了一种使用网络接口（Network Interface）启动计算机的机制。这种机制让计算机的启动可以不依赖本地数据存储设备（如硬盘）或本地已安装的操作系统。 PXE 当初是作为 Intel 的有线管理体系的一部分，Intel 和 Systemsoft 于 1999 年 9 月 20 日公布其规格（版本 2.1）[1]。通过使用像网际协议（IP）、用户数据报协议（UDP）、动态主机设定协定（DHCP）、BOOTP、小型文件传输协议（TFTP）等几种网络协议和全局唯一标识符（GUID）、通用网络驱动接口（UNDI）、通用唯一识别码（UUID）的概念并通过对客户机（通过 PXE 自检的电脑）固件扩展预设的 API 来实现目的。 PXE 客户机（client）这个术语是指机器在 PXE 启动过程中的角色。 其基本的运行机制是： 客户机的固件（如网卡的 PXE 固件）通过 DHCP 协议找到可用的 PXE 启动服务器。在找到可用的 PXE 启动服务器后，固件会向合适的启动服务器询问网络启动程序（NBP，Network Boot Program）的路径，并且通过 TFTP 协议将网络启动程序下载到电脑的内存中，最后执行它[2]。 由PXE机制又衍生出了无盘系统，其利用网络服务器下载启动系统的镜像，而不是本地硬盘。PXE的协议规范在intel 的这篇文档中可以查到。而 PXE 的两个实现，一个为iPXE，另一个则是gPXE。gPXE目前已经停止开发，取而代之的是iPXE。 对于iPXE和gPXE更详细的介绍，可以参考这篇博文 initramfs文件和squashfs文件做什么用？ TODO 为什么Arch Linux在下载过程中需要使用加密签名对镜像完整性进行验证？ TODO 6.2.4 VM imagearchlinux 虚拟机可从这里下载，使用手册在此。 6.2.5 HTTP 下载（最常用） Tip sq命令需要使用scoop进行安装，如果是 windows 用户，会比较麻烦，详细解决办法见后文 从后文中的镜像源中下载镜像。需要注意的是，我们需要保证下载的镜像的校验和，和同一目录sha256sums.txt及b2sums.txt文件中的校验和匹配。 下载签名：sq wkd get pierre@archlinux.org -o release-key.pgp 验证：sq verify --signer-file release-key.pgp --detached archlinux-2023.09.01-x86_64.iso.sig archlinux-2023.09.01-x86_64.iso ","date":"2023-10-12","objectID":"/vmware/:6:2","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#几种下载方式"},{"categories":["Linux"],"content":" 6.2 几种下载方式 6.2.1 对于已经是 Arch 用户的人 通过命令pacman -Syu更新 通过这里更新镜像源 6.2.2 种子链接下载（官方推荐）对于这种资源，可以使用百度网盘或者迅雷下载（和下载电影相同），下载格式为.torrent，该种子链接需要上传到百度网盘/迅雷，然后将其中的 iso 镜像文件下载到本地目录中。 6.2.3 Netboot安装时需要联网，最新版本会自动推送，可用于在系统启动时即时下载最新的 Arch Linux 版本。 Netboot 使用定制的 iPXE 版本。 实时系统的 Linux 内核、initramfs 和 squashfs 文件是从 Arch Linux 镜像下载的。 所有下载文件的完整性都使用加密签名进行验证。 这其中有几个问题： iPXE是啥？一种开源的网络启动固件 其官方文档中的描述如下： iPXE 是领先的开源网络引导固件。它提供了完整的 PXE 实现，并通过其他功能进行了增强，例如： 通过 HTTP 从 Web 服务器启动 从 iSCSI SAN 引导 通过 FCoE 从光纤通道 SAN 启动 从 AoE SAN 引导 从无线网络引导 从广域网引导 从 Infiniband 网络引导 使用脚本控制引导过程 由此可以看出，iPXE 是一种基于网络进行系统启动的固件。它的启动需要依附于计算机网络的各种协议。在 Arch Linux 文档中也指明，使用 Netboot 安装需要满足以下两点要求： 具有 DHCP 自配置的网络 能够运行系统的足够存储 而它的具体实现是基于PXE协议。 基于递归学习的理念，我又查了查PXE。。。 其基本概念如下： 预启动执行环境（Preboot eXecution Environment，PXE，也被称为预执行环境）提供了一种使用网络接口（Network Interface）启动计算机的机制。这种机制让计算机的启动可以不依赖本地数据存储设备（如硬盘）或本地已安装的操作系统。 PXE 当初是作为 Intel 的有线管理体系的一部分，Intel 和 Systemsoft 于 1999 年 9 月 20 日公布其规格（版本 2.1）[1]。通过使用像网际协议（IP）、用户数据报协议（UDP）、动态主机设定协定（DHCP）、BOOTP、小型文件传输协议（TFTP）等几种网络协议和全局唯一标识符（GUID）、通用网络驱动接口（UNDI）、通用唯一识别码（UUID）的概念并通过对客户机（通过 PXE 自检的电脑）固件扩展预设的 API 来实现目的。 PXE 客户机（client）这个术语是指机器在 PXE 启动过程中的角色。 其基本的运行机制是： 客户机的固件（如网卡的 PXE 固件）通过 DHCP 协议找到可用的 PXE 启动服务器。在找到可用的 PXE 启动服务器后，固件会向合适的启动服务器询问网络启动程序（NBP，Network Boot Program）的路径，并且通过 TFTP 协议将网络启动程序下载到电脑的内存中，最后执行它[2]。 由PXE机制又衍生出了无盘系统，其利用网络服务器下载启动系统的镜像，而不是本地硬盘。PXE的协议规范在intel 的这篇文档中可以查到。而 PXE 的两个实现，一个为iPXE，另一个则是gPXE。gPXE目前已经停止开发，取而代之的是iPXE。 对于iPXE和gPXE更详细的介绍，可以参考这篇博文 initramfs文件和squashfs文件做什么用？ TODO 为什么Arch Linux在下载过程中需要使用加密签名对镜像完整性进行验证？ TODO 6.2.4 VM imagearchlinux 虚拟机可从这里下载，使用手册在此。 6.2.5 HTTP 下载（最常用） Tip sq命令需要使用scoop进行安装，如果是 windows 用户，会比较麻烦，详细解决办法见后文 从后文中的镜像源中下载镜像。需要注意的是，我们需要保证下载的镜像的校验和，和同一目录sha256sums.txt及b2sums.txt文件中的校验和匹配。 下载签名：sq wkd get pierre@archlinux.org -o release-key.pgp 验证：sq verify --signer-file release-key.pgp --detached archlinux-2023.09.01-x86_64.iso.sig archlinux-2023.09.01-x86_64.iso ","date":"2023-10-12","objectID":"/vmware/:6:2","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#对于已经是-arch-用户的人"},{"categories":["Linux"],"content":" 6.2 几种下载方式 6.2.1 对于已经是 Arch 用户的人 通过命令pacman -Syu更新 通过这里更新镜像源 6.2.2 种子链接下载（官方推荐）对于这种资源，可以使用百度网盘或者迅雷下载（和下载电影相同），下载格式为.torrent，该种子链接需要上传到百度网盘/迅雷，然后将其中的 iso 镜像文件下载到本地目录中。 6.2.3 Netboot安装时需要联网，最新版本会自动推送，可用于在系统启动时即时下载最新的 Arch Linux 版本。 Netboot 使用定制的 iPXE 版本。 实时系统的 Linux 内核、initramfs 和 squashfs 文件是从 Arch Linux 镜像下载的。 所有下载文件的完整性都使用加密签名进行验证。 这其中有几个问题： iPXE是啥？一种开源的网络启动固件 其官方文档中的描述如下： iPXE 是领先的开源网络引导固件。它提供了完整的 PXE 实现，并通过其他功能进行了增强，例如： 通过 HTTP 从 Web 服务器启动 从 iSCSI SAN 引导 通过 FCoE 从光纤通道 SAN 启动 从 AoE SAN 引导 从无线网络引导 从广域网引导 从 Infiniband 网络引导 使用脚本控制引导过程 由此可以看出，iPXE 是一种基于网络进行系统启动的固件。它的启动需要依附于计算机网络的各种协议。在 Arch Linux 文档中也指明，使用 Netboot 安装需要满足以下两点要求： 具有 DHCP 自配置的网络 能够运行系统的足够存储 而它的具体实现是基于PXE协议。 基于递归学习的理念，我又查了查PXE。。。 其基本概念如下： 预启动执行环境（Preboot eXecution Environment，PXE，也被称为预执行环境）提供了一种使用网络接口（Network Interface）启动计算机的机制。这种机制让计算机的启动可以不依赖本地数据存储设备（如硬盘）或本地已安装的操作系统。 PXE 当初是作为 Intel 的有线管理体系的一部分，Intel 和 Systemsoft 于 1999 年 9 月 20 日公布其规格（版本 2.1）[1]。通过使用像网际协议（IP）、用户数据报协议（UDP）、动态主机设定协定（DHCP）、BOOTP、小型文件传输协议（TFTP）等几种网络协议和全局唯一标识符（GUID）、通用网络驱动接口（UNDI）、通用唯一识别码（UUID）的概念并通过对客户机（通过 PXE 自检的电脑）固件扩展预设的 API 来实现目的。 PXE 客户机（client）这个术语是指机器在 PXE 启动过程中的角色。 其基本的运行机制是： 客户机的固件（如网卡的 PXE 固件）通过 DHCP 协议找到可用的 PXE 启动服务器。在找到可用的 PXE 启动服务器后，固件会向合适的启动服务器询问网络启动程序（NBP，Network Boot Program）的路径，并且通过 TFTP 协议将网络启动程序下载到电脑的内存中，最后执行它[2]。 由PXE机制又衍生出了无盘系统，其利用网络服务器下载启动系统的镜像，而不是本地硬盘。PXE的协议规范在intel 的这篇文档中可以查到。而 PXE 的两个实现，一个为iPXE，另一个则是gPXE。gPXE目前已经停止开发，取而代之的是iPXE。 对于iPXE和gPXE更详细的介绍，可以参考这篇博文 initramfs文件和squashfs文件做什么用？ TODO 为什么Arch Linux在下载过程中需要使用加密签名对镜像完整性进行验证？ TODO 6.2.4 VM imagearchlinux 虚拟机可从这里下载，使用手册在此。 6.2.5 HTTP 下载（最常用） Tip sq命令需要使用scoop进行安装，如果是 windows 用户，会比较麻烦，详细解决办法见后文 从后文中的镜像源中下载镜像。需要注意的是，我们需要保证下载的镜像的校验和，和同一目录sha256sums.txt及b2sums.txt文件中的校验和匹配。 下载签名：sq wkd get pierre@archlinux.org -o release-key.pgp 验证：sq verify --signer-file release-key.pgp --detached archlinux-2023.09.01-x86_64.iso.sig archlinux-2023.09.01-x86_64.iso ","date":"2023-10-12","objectID":"/vmware/:6:2","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#种子链接下载官方推荐"},{"categories":["Linux"],"content":" 6.2 几种下载方式 6.2.1 对于已经是 Arch 用户的人 通过命令pacman -Syu更新 通过这里更新镜像源 6.2.2 种子链接下载（官方推荐）对于这种资源，可以使用百度网盘或者迅雷下载（和下载电影相同），下载格式为.torrent，该种子链接需要上传到百度网盘/迅雷，然后将其中的 iso 镜像文件下载到本地目录中。 6.2.3 Netboot安装时需要联网，最新版本会自动推送，可用于在系统启动时即时下载最新的 Arch Linux 版本。 Netboot 使用定制的 iPXE 版本。 实时系统的 Linux 内核、initramfs 和 squashfs 文件是从 Arch Linux 镜像下载的。 所有下载文件的完整性都使用加密签名进行验证。 这其中有几个问题： iPXE是啥？一种开源的网络启动固件 其官方文档中的描述如下： iPXE 是领先的开源网络引导固件。它提供了完整的 PXE 实现，并通过其他功能进行了增强，例如： 通过 HTTP 从 Web 服务器启动 从 iSCSI SAN 引导 通过 FCoE 从光纤通道 SAN 启动 从 AoE SAN 引导 从无线网络引导 从广域网引导 从 Infiniband 网络引导 使用脚本控制引导过程 由此可以看出，iPXE 是一种基于网络进行系统启动的固件。它的启动需要依附于计算机网络的各种协议。在 Arch Linux 文档中也指明，使用 Netboot 安装需要满足以下两点要求： 具有 DHCP 自配置的网络 能够运行系统的足够存储 而它的具体实现是基于PXE协议。 基于递归学习的理念，我又查了查PXE。。。 其基本概念如下： 预启动执行环境（Preboot eXecution Environment，PXE，也被称为预执行环境）提供了一种使用网络接口（Network Interface）启动计算机的机制。这种机制让计算机的启动可以不依赖本地数据存储设备（如硬盘）或本地已安装的操作系统。 PXE 当初是作为 Intel 的有线管理体系的一部分，Intel 和 Systemsoft 于 1999 年 9 月 20 日公布其规格（版本 2.1）[1]。通过使用像网际协议（IP）、用户数据报协议（UDP）、动态主机设定协定（DHCP）、BOOTP、小型文件传输协议（TFTP）等几种网络协议和全局唯一标识符（GUID）、通用网络驱动接口（UNDI）、通用唯一识别码（UUID）的概念并通过对客户机（通过 PXE 自检的电脑）固件扩展预设的 API 来实现目的。 PXE 客户机（client）这个术语是指机器在 PXE 启动过程中的角色。 其基本的运行机制是： 客户机的固件（如网卡的 PXE 固件）通过 DHCP 协议找到可用的 PXE 启动服务器。在找到可用的 PXE 启动服务器后，固件会向合适的启动服务器询问网络启动程序（NBP，Network Boot Program）的路径，并且通过 TFTP 协议将网络启动程序下载到电脑的内存中，最后执行它[2]。 由PXE机制又衍生出了无盘系统，其利用网络服务器下载启动系统的镜像，而不是本地硬盘。PXE的协议规范在intel 的这篇文档中可以查到。而 PXE 的两个实现，一个为iPXE，另一个则是gPXE。gPXE目前已经停止开发，取而代之的是iPXE。 对于iPXE和gPXE更详细的介绍，可以参考这篇博文 initramfs文件和squashfs文件做什么用？ TODO 为什么Arch Linux在下载过程中需要使用加密签名对镜像完整性进行验证？ TODO 6.2.4 VM imagearchlinux 虚拟机可从这里下载，使用手册在此。 6.2.5 HTTP 下载（最常用） Tip sq命令需要使用scoop进行安装，如果是 windows 用户，会比较麻烦，详细解决办法见后文 从后文中的镜像源中下载镜像。需要注意的是，我们需要保证下载的镜像的校验和，和同一目录sha256sums.txt及b2sums.txt文件中的校验和匹配。 下载签名：sq wkd get pierre@archlinux.org -o release-key.pgp 验证：sq verify --signer-file release-key.pgp --detached archlinux-2023.09.01-x86_64.iso.sig archlinux-2023.09.01-x86_64.iso ","date":"2023-10-12","objectID":"/vmware/:6:2","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#netboot"},{"categories":["Linux"],"content":" 6.2 几种下载方式 6.2.1 对于已经是 Arch 用户的人 通过命令pacman -Syu更新 通过这里更新镜像源 6.2.2 种子链接下载（官方推荐）对于这种资源，可以使用百度网盘或者迅雷下载（和下载电影相同），下载格式为.torrent，该种子链接需要上传到百度网盘/迅雷，然后将其中的 iso 镜像文件下载到本地目录中。 6.2.3 Netboot安装时需要联网，最新版本会自动推送，可用于在系统启动时即时下载最新的 Arch Linux 版本。 Netboot 使用定制的 iPXE 版本。 实时系统的 Linux 内核、initramfs 和 squashfs 文件是从 Arch Linux 镜像下载的。 所有下载文件的完整性都使用加密签名进行验证。 这其中有几个问题： iPXE是啥？一种开源的网络启动固件 其官方文档中的描述如下： iPXE 是领先的开源网络引导固件。它提供了完整的 PXE 实现，并通过其他功能进行了增强，例如： 通过 HTTP 从 Web 服务器启动 从 iSCSI SAN 引导 通过 FCoE 从光纤通道 SAN 启动 从 AoE SAN 引导 从无线网络引导 从广域网引导 从 Infiniband 网络引导 使用脚本控制引导过程 由此可以看出，iPXE 是一种基于网络进行系统启动的固件。它的启动需要依附于计算机网络的各种协议。在 Arch Linux 文档中也指明，使用 Netboot 安装需要满足以下两点要求： 具有 DHCP 自配置的网络 能够运行系统的足够存储 而它的具体实现是基于PXE协议。 基于递归学习的理念，我又查了查PXE。。。 其基本概念如下： 预启动执行环境（Preboot eXecution Environment，PXE，也被称为预执行环境）提供了一种使用网络接口（Network Interface）启动计算机的机制。这种机制让计算机的启动可以不依赖本地数据存储设备（如硬盘）或本地已安装的操作系统。 PXE 当初是作为 Intel 的有线管理体系的一部分，Intel 和 Systemsoft 于 1999 年 9 月 20 日公布其规格（版本 2.1）[1]。通过使用像网际协议（IP）、用户数据报协议（UDP）、动态主机设定协定（DHCP）、BOOTP、小型文件传输协议（TFTP）等几种网络协议和全局唯一标识符（GUID）、通用网络驱动接口（UNDI）、通用唯一识别码（UUID）的概念并通过对客户机（通过 PXE 自检的电脑）固件扩展预设的 API 来实现目的。 PXE 客户机（client）这个术语是指机器在 PXE 启动过程中的角色。 其基本的运行机制是： 客户机的固件（如网卡的 PXE 固件）通过 DHCP 协议找到可用的 PXE 启动服务器。在找到可用的 PXE 启动服务器后，固件会向合适的启动服务器询问网络启动程序（NBP，Network Boot Program）的路径，并且通过 TFTP 协议将网络启动程序下载到电脑的内存中，最后执行它[2]。 由PXE机制又衍生出了无盘系统，其利用网络服务器下载启动系统的镜像，而不是本地硬盘。PXE的协议规范在intel 的这篇文档中可以查到。而 PXE 的两个实现，一个为iPXE，另一个则是gPXE。gPXE目前已经停止开发，取而代之的是iPXE。 对于iPXE和gPXE更详细的介绍，可以参考这篇博文 initramfs文件和squashfs文件做什么用？ TODO 为什么Arch Linux在下载过程中需要使用加密签名对镜像完整性进行验证？ TODO 6.2.4 VM imagearchlinux 虚拟机可从这里下载，使用手册在此。 6.2.5 HTTP 下载（最常用） Tip sq命令需要使用scoop进行安装，如果是 windows 用户，会比较麻烦，详细解决办法见后文 从后文中的镜像源中下载镜像。需要注意的是，我们需要保证下载的镜像的校验和，和同一目录sha256sums.txt及b2sums.txt文件中的校验和匹配。 下载签名：sq wkd get pierre@archlinux.org -o release-key.pgp 验证：sq verify --signer-file release-key.pgp --detached archlinux-2023.09.01-x86_64.iso.sig archlinux-2023.09.01-x86_64.iso ","date":"2023-10-12","objectID":"/vmware/:6:2","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#vm-image"},{"categories":["Linux"],"content":" 6.2 几种下载方式 6.2.1 对于已经是 Arch 用户的人 通过命令pacman -Syu更新 通过这里更新镜像源 6.2.2 种子链接下载（官方推荐）对于这种资源，可以使用百度网盘或者迅雷下载（和下载电影相同），下载格式为.torrent，该种子链接需要上传到百度网盘/迅雷，然后将其中的 iso 镜像文件下载到本地目录中。 6.2.3 Netboot安装时需要联网，最新版本会自动推送，可用于在系统启动时即时下载最新的 Arch Linux 版本。 Netboot 使用定制的 iPXE 版本。 实时系统的 Linux 内核、initramfs 和 squashfs 文件是从 Arch Linux 镜像下载的。 所有下载文件的完整性都使用加密签名进行验证。 这其中有几个问题： iPXE是啥？一种开源的网络启动固件 其官方文档中的描述如下： iPXE 是领先的开源网络引导固件。它提供了完整的 PXE 实现，并通过其他功能进行了增强，例如： 通过 HTTP 从 Web 服务器启动 从 iSCSI SAN 引导 通过 FCoE 从光纤通道 SAN 启动 从 AoE SAN 引导 从无线网络引导 从广域网引导 从 Infiniband 网络引导 使用脚本控制引导过程 由此可以看出，iPXE 是一种基于网络进行系统启动的固件。它的启动需要依附于计算机网络的各种协议。在 Arch Linux 文档中也指明，使用 Netboot 安装需要满足以下两点要求： 具有 DHCP 自配置的网络 能够运行系统的足够存储 而它的具体实现是基于PXE协议。 基于递归学习的理念，我又查了查PXE。。。 其基本概念如下： 预启动执行环境（Preboot eXecution Environment，PXE，也被称为预执行环境）提供了一种使用网络接口（Network Interface）启动计算机的机制。这种机制让计算机的启动可以不依赖本地数据存储设备（如硬盘）或本地已安装的操作系统。 PXE 当初是作为 Intel 的有线管理体系的一部分，Intel 和 Systemsoft 于 1999 年 9 月 20 日公布其规格（版本 2.1）[1]。通过使用像网际协议（IP）、用户数据报协议（UDP）、动态主机设定协定（DHCP）、BOOTP、小型文件传输协议（TFTP）等几种网络协议和全局唯一标识符（GUID）、通用网络驱动接口（UNDI）、通用唯一识别码（UUID）的概念并通过对客户机（通过 PXE 自检的电脑）固件扩展预设的 API 来实现目的。 PXE 客户机（client）这个术语是指机器在 PXE 启动过程中的角色。 其基本的运行机制是： 客户机的固件（如网卡的 PXE 固件）通过 DHCP 协议找到可用的 PXE 启动服务器。在找到可用的 PXE 启动服务器后，固件会向合适的启动服务器询问网络启动程序（NBP，Network Boot Program）的路径，并且通过 TFTP 协议将网络启动程序下载到电脑的内存中，最后执行它[2]。 由PXE机制又衍生出了无盘系统，其利用网络服务器下载启动系统的镜像，而不是本地硬盘。PXE的协议规范在intel 的这篇文档中可以查到。而 PXE 的两个实现，一个为iPXE，另一个则是gPXE。gPXE目前已经停止开发，取而代之的是iPXE。 对于iPXE和gPXE更详细的介绍，可以参考这篇博文 initramfs文件和squashfs文件做什么用？ TODO 为什么Arch Linux在下载过程中需要使用加密签名对镜像完整性进行验证？ TODO 6.2.4 VM imagearchlinux 虚拟机可从这里下载，使用手册在此。 6.2.5 HTTP 下载（最常用） Tip sq命令需要使用scoop进行安装，如果是 windows 用户，会比较麻烦，详细解决办法见后文 从后文中的镜像源中下载镜像。需要注意的是，我们需要保证下载的镜像的校验和，和同一目录sha256sums.txt及b2sums.txt文件中的校验和匹配。 下载签名：sq wkd get pierre@archlinux.org -o release-key.pgp 验证：sq verify --signer-file release-key.pgp --detached archlinux-2023.09.01-x86_64.iso.sig archlinux-2023.09.01-x86_64.iso ","date":"2023-10-12","objectID":"/vmware/:6:2","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#http-下载最常用"},{"categories":["Linux"],"content":" 6.3 校验和最新版本的校验和下载详见官网。在镜像源网站上也可以看到sha256sums.txt和b2sums.txt 。下载镜像后我们需要利用它与我们下载到的镜像的校验和进行比对(主要是用于比对，这两个文件可下载也可不下载，在镜像站上也能打开，只要我们下载到的镜像的校验和文件中版本对应的那行的校验和匹配就行了)。 ","date":"2023-10-12","objectID":"/vmware/:6:3","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#校验和"},{"categories":["Linux"],"content":" 6.4 方法一 Tip 由于这种方式下载过慢，笔者建议使用方法二，即通过开源镜像站进行下载。 在Download 界面选择推荐的 BitTorrent Download: 下载到本地电脑的 Downloads 文件夹中，其后缀名为.torrent 打开百度网盘，在其中上传该文件 上传后双击该文件，点击开始下载到网盘，等待下载完成（有点慢哈！） 下载到网盘后，将iso镜像文件下载到在自选的本地目录中 ","date":"2023-10-12","objectID":"/vmware/:6:4","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#方法一"},{"categories":["Linux"],"content":" 6.5 方法二 在Download 界面下翻，找到中国的镜像站列表: 在其中选择tuna.tsinghua.edu.cn，即清华大学镜像站（我每次都用他们的镜像，速度不错） 选择archlinux-2023.09.01-x86_64.iso下载 将.iso文件保存到我们想要虚拟机保存的目录中 ","date":"2023-10-12","objectID":"/vmware/:6:5","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#方法二"},{"categories":["Linux"],"content":" 7 获取GnuPG签名 GnuPG 是什么？ GnuPG 是完整实现了 RFC4880（即 PGP）所定义的 OpenPGP 标准的自由软件。GnuPG 可以加密和签名你的数据和通讯信息，包含一个通用的密钥管理系统以及用于各种公钥目录的访问模块。GnuPG，简称 GPG，是一个易于与其它程序整合的命令行工具，拥有很多前端程序和函数库。GnuPG 还支持 S/MIME 和 Secure Shell (ssh)。 从上述清华大学镜像站，可获取 iso 版本对应的 PGP 签名` archlinux-2023.09.01-x86_64.iso.sig`` 在本次安装中，我使用的是 Git Bash，其中装有GPG，cmd和powershell中也装有 gpg，可选择一个终端进行后续操作。 ","date":"2023-10-12","objectID":"/vmware/:7:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#获取gnupg签名"},{"categories":["Linux"],"content":" 8 验证签名为避免因 HTTP 连接下载镜像时遭到拦截，获取到恶意镜像，我们需要利用 PGP 签名对镜像进行验证。 通过以下命令验证: bash gpg --keyserver-options auto-key-retrieve --verify archlinux-version-x86_64.iso.sig 其中version替换成你所下载的版本号，如2023.09.01。我的显示结果是： bash legion@DESKTOP-ROOSFVQ MINGW64 /e/VMs/Arch $ gpg --keyserver-options auto-key-retrieve --verify archlinux-2023.09.01-x86_64.iso.sig gpg: assuming signed data in 'archlinux-2023.09.01-x86_64.iso' gpg: Signature made 2023年09月 1日 18:48:49 gpg: using EDDSA key 3E80CA1A8B89F69CBA57D98A76A5EF9054449A5C gpg: issuer \"pierre@archlinux.org\" gpg: Good signature from \"Pierre Schmitz \u003cpierre@archlinux.org\u003e\" [unknown] gpg: WARNING: This key is not certified with a trusted signature! gpg: There is no indication that the signature belongs to the owner. Primary key fingerprint: 3E80 CA1A 8B89 F69C BA57 D98A 76A5 EF90 5444 9A5C 若从镜像站下载，则会显示fingerprint，我们需要打开fingerprint 合集,确保我们所获得的镜像的fingerprint和该网站上的 fingerprint 吻合。（确保公钥的指纹等于其中一位签署了 ISO 文件 Arch Linux 开发者的指纹） ","date":"2023-10-12","objectID":"/vmware/:8:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#验证签名"},{"categories":["Linux"],"content":" 9 准备安装介质安装镜像包括：U 盘，光盘，和带有 PXE 的网络安装镜像。此处我是用 VMWare 虚拟机进行安装。 ","date":"2023-10-12","objectID":"/vmware/:9:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#准备安装介质"},{"categories":["Linux"],"content":" 10 VMWare 新建虚拟机依次选择： 自定义（高级） 硬件兼容性 稍后安装操作系统 本内核版本为 6.4.12，因 VMware 中没有 Arch，因此我选择其他 Linux 5.x 内核 64位 选择安装目录（自定） 处理器配置、内存大小分配均选择默认（注意：内存大小选择 2G，768MB 完全不够) 使用网络地址转换（NAT） SCSI 控制器:LSI Logic（L） 虚拟磁盘类型：SCSI（S） 创建新虚拟磁盘 最大磁盘大小默认，将虚拟磁盘拆分成多个文件 磁盘文件名默认 自定义硬件-\u003e新 CD/DVD-\u003e使用 ISO 映像文件-\u003e选择我们下载的 iso 文件-\u003e关闭 完成 你可以自行决定 BIOS 或 UEFI 模式启动（我选择 UEFI，但是应该影响不大） 点击开启此虚拟机 Ready for the journey? Let’s go! ","date":"2023-10-12","objectID":"/vmware/:10:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#vmware-新建虚拟机"},{"categories":["Linux"],"content":" 11 进入安装程序 默认第一项，等待一会儿，随后进入命令行模式 ","date":"2023-10-12","objectID":"/vmware/:11:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#进入安装程序"},{"categories":["Linux"],"content":" 12 一号坑：VMware 默认分配内存 768MB 过小，需要 2G开局遇雷：怎么回事？ 参考了这篇博文虚拟机默认的是 768MB，不够。在设置中修改为 2G,成功启动。 ","date":"2023-10-12","objectID":"/vmware/:12:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#一号坑vmware-默认分配内存-768mb-过小需要-2g"},{"categories":["Linux"],"content":" 13 二号坑：网络出现问题 关了虚拟机，重新开机，成功启动 ","date":"2023-10-12","objectID":"/vmware/:13:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#二号坑网络出现问题"},{"categories":["Linux"],"content":" 14 配置控制台键盘布局和字体系统启动后，控制台键盘布局默认为 us（美式键盘）。如果您需要列出所有可用的键盘布局，可以使用以下命令： bash ls /usr/share/kbd/keymaps/**/*.map.gz 此处我使用us键盘布局，不修改。 ","date":"2023-10-12","objectID":"/vmware/:14:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#配置控制台键盘布局和字体"},{"categories":["Linux"],"content":" 15 检查是否连接到互联网 bash ip link ping archlinux.org ","date":"2023-10-12","objectID":"/vmware/:15:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#检查是否连接到互联网"},{"categories":["Linux"],"content":" 16 更新系统时间 bash timedatectl #查看系统时间 timedatectl list-timezones #查看所有时区 timedatectl set-timezone \"Asia/Shanghai\" # 设置为亚洲上海 要创建磁盘分区了，为保证出问题后还能倒回来，此处拍摄快照 1 ","date":"2023-10-12","objectID":"/vmware/:16:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#更新系统时间"},{"categories":["Linux"],"content":" 17 创建硬盘分区","date":"2023-10-12","objectID":"/vmware/:17:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#创建硬盘分区"},{"categories":["Linux"],"content":" 17.1 指南系统如果识别到计算机的内置硬盘、U 盘或者移动硬盘等类型磁盘，就会将其分配为一个块设备，如 /dev/sda、/dev/nvme0n1 或 /dev/mmcblk0。可以使用 lsblk 或者 fdisk 查看： bash fdisk -l(此处为小写字母l) 结果中以 rom、loop 或者 airoot 结尾的设备可以被忽略。 提示：在分区之前，请您检查 NVMe 驱动器和 Advanced Format 硬盘是否使用了最佳逻辑扇区大小。需要注意的是，更改逻辑扇区大小后，可能会导致在 Windows 系统中出现兼容性问题。 对于一个选定的设备，以下分区是必须要有的： 一个根分区（挂载在 根目录）/； 要在 UEFI 模式中启动，还需要一个 EFI 系统分区。 如果您需要创建多级存储例如 LVM、磁盘加密 或 RAID，请您在这时候完成。 请使用分区工具（fdisk 、parted、cfdisk 等等）修改分区表。例如： bash fdisk /dev/the_disk_to_be_partitioned（要被分区的磁盘） 注意： 如果您想要的磁盘没有显示出来， 确保您的磁盘控制器未处于 RAID 模式。 如果要启动的磁盘已经有一个 EFI 系统分区，就不要再新建 EFI 分区了，而是使用现有的 EFI 分区。 如果文件系统支持，交换空间 可以通过 交换文件 实现。 ","date":"2023-10-12","objectID":"/vmware/:17:1","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#指南"},{"categories":["Linux"],"content":" 17.2 分区方案： ","date":"2023-10-12","objectID":"/vmware/:17:2","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#分区方案"},{"categories":["Linux"],"content":" 17.3 分区步骤 17.3.1 创建 GPT 分区表 输入fdisk /dev/sda，对/dev/sda磁盘进行分区 输入g，创建一个GUID分区表 17.3.2 创建第一个分区：EFI 分区 输入n，创建第一个分区，输入其编号（默认为 1，即/dev/sda1） 回车，默认其大小 对最后一个扇区，输入+512M 输入t来将这个新分区改为\"EFI System\" 输入L来查看所有分区名，输入q退出，可见EFI System分区别名为 1 输入1，将分区改为EFI System 17.3.3 创建第二个分区：文件系统分区 输入n，创建第二个分区 两次回车，使用默认分区号和扇区大小 输入-512M，为交换分区留出 512MB 大小来 分区默认名为Linux filesystem，因此不需要改 17.3.4 创建第三个分区：交换分区 输入n，创建第三个分区 连按 3 次回车，接受所有默认设置 输入t，将新分区改为Linux Swap,别名为 19 17.3.5 查看分区结果输入p 17.3.6 完成修改输入w ","date":"2023-10-12","objectID":"/vmware/:17:3","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#分区步骤"},{"categories":["Linux"],"content":" 17.3 分区步骤 17.3.1 创建 GPT 分区表 输入fdisk /dev/sda，对/dev/sda磁盘进行分区 输入g，创建一个GUID分区表 17.3.2 创建第一个分区：EFI 分区 输入n，创建第一个分区，输入其编号（默认为 1，即/dev/sda1） 回车，默认其大小 对最后一个扇区，输入+512M 输入t来将这个新分区改为\"EFI System\" 输入L来查看所有分区名，输入q退出，可见EFI System分区别名为 1 输入1，将分区改为EFI System 17.3.3 创建第二个分区：文件系统分区 输入n，创建第二个分区 两次回车，使用默认分区号和扇区大小 输入-512M，为交换分区留出 512MB 大小来 分区默认名为Linux filesystem，因此不需要改 17.3.4 创建第三个分区：交换分区 输入n，创建第三个分区 连按 3 次回车，接受所有默认设置 输入t，将新分区改为Linux Swap,别名为 19 17.3.5 查看分区结果输入p 17.3.6 完成修改输入w ","date":"2023-10-12","objectID":"/vmware/:17:3","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#创建-gpt-分区表"},{"categories":["Linux"],"content":" 17.3 分区步骤 17.3.1 创建 GPT 分区表 输入fdisk /dev/sda，对/dev/sda磁盘进行分区 输入g，创建一个GUID分区表 17.3.2 创建第一个分区：EFI 分区 输入n，创建第一个分区，输入其编号（默认为 1，即/dev/sda1） 回车，默认其大小 对最后一个扇区，输入+512M 输入t来将这个新分区改为\"EFI System\" 输入L来查看所有分区名，输入q退出，可见EFI System分区别名为 1 输入1，将分区改为EFI System 17.3.3 创建第二个分区：文件系统分区 输入n，创建第二个分区 两次回车，使用默认分区号和扇区大小 输入-512M，为交换分区留出 512MB 大小来 分区默认名为Linux filesystem，因此不需要改 17.3.4 创建第三个分区：交换分区 输入n，创建第三个分区 连按 3 次回车，接受所有默认设置 输入t，将新分区改为Linux Swap,别名为 19 17.3.5 查看分区结果输入p 17.3.6 完成修改输入w ","date":"2023-10-12","objectID":"/vmware/:17:3","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#创建第一个分区efi-分区"},{"categories":["Linux"],"content":" 17.3 分区步骤 17.3.1 创建 GPT 分区表 输入fdisk /dev/sda，对/dev/sda磁盘进行分区 输入g，创建一个GUID分区表 17.3.2 创建第一个分区：EFI 分区 输入n，创建第一个分区，输入其编号（默认为 1，即/dev/sda1） 回车，默认其大小 对最后一个扇区，输入+512M 输入t来将这个新分区改为\"EFI System\" 输入L来查看所有分区名，输入q退出，可见EFI System分区别名为 1 输入1，将分区改为EFI System 17.3.3 创建第二个分区：文件系统分区 输入n，创建第二个分区 两次回车，使用默认分区号和扇区大小 输入-512M，为交换分区留出 512MB 大小来 分区默认名为Linux filesystem，因此不需要改 17.3.4 创建第三个分区：交换分区 输入n，创建第三个分区 连按 3 次回车，接受所有默认设置 输入t，将新分区改为Linux Swap,别名为 19 17.3.5 查看分区结果输入p 17.3.6 完成修改输入w ","date":"2023-10-12","objectID":"/vmware/:17:3","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#创建第二个分区文件系统分区"},{"categories":["Linux"],"content":" 17.3 分区步骤 17.3.1 创建 GPT 分区表 输入fdisk /dev/sda，对/dev/sda磁盘进行分区 输入g，创建一个GUID分区表 17.3.2 创建第一个分区：EFI 分区 输入n，创建第一个分区，输入其编号（默认为 1，即/dev/sda1） 回车，默认其大小 对最后一个扇区，输入+512M 输入t来将这个新分区改为\"EFI System\" 输入L来查看所有分区名，输入q退出，可见EFI System分区别名为 1 输入1，将分区改为EFI System 17.3.3 创建第二个分区：文件系统分区 输入n，创建第二个分区 两次回车，使用默认分区号和扇区大小 输入-512M，为交换分区留出 512MB 大小来 分区默认名为Linux filesystem，因此不需要改 17.3.4 创建第三个分区：交换分区 输入n，创建第三个分区 连按 3 次回车，接受所有默认设置 输入t，将新分区改为Linux Swap,别名为 19 17.3.5 查看分区结果输入p 17.3.6 完成修改输入w ","date":"2023-10-12","objectID":"/vmware/:17:3","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#创建第三个分区交换分区"},{"categories":["Linux"],"content":" 17.3 分区步骤 17.3.1 创建 GPT 分区表 输入fdisk /dev/sda，对/dev/sda磁盘进行分区 输入g，创建一个GUID分区表 17.3.2 创建第一个分区：EFI 分区 输入n，创建第一个分区，输入其编号（默认为 1，即/dev/sda1） 回车，默认其大小 对最后一个扇区，输入+512M 输入t来将这个新分区改为\"EFI System\" 输入L来查看所有分区名，输入q退出，可见EFI System分区别名为 1 输入1，将分区改为EFI System 17.3.3 创建第二个分区：文件系统分区 输入n，创建第二个分区 两次回车，使用默认分区号和扇区大小 输入-512M，为交换分区留出 512MB 大小来 分区默认名为Linux filesystem，因此不需要改 17.3.4 创建第三个分区：交换分区 输入n，创建第三个分区 连按 3 次回车，接受所有默认设置 输入t，将新分区改为Linux Swap,别名为 19 17.3.5 查看分区结果输入p 17.3.6 完成修改输入w ","date":"2023-10-12","objectID":"/vmware/:17:3","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#查看分区结果"},{"categories":["Linux"],"content":" 17.3 分区步骤 17.3.1 创建 GPT 分区表 输入fdisk /dev/sda，对/dev/sda磁盘进行分区 输入g，创建一个GUID分区表 17.3.2 创建第一个分区：EFI 分区 输入n，创建第一个分区，输入其编号（默认为 1，即/dev/sda1） 回车，默认其大小 对最后一个扇区，输入+512M 输入t来将这个新分区改为\"EFI System\" 输入L来查看所有分区名，输入q退出，可见EFI System分区别名为 1 输入1，将分区改为EFI System 17.3.3 创建第二个分区：文件系统分区 输入n，创建第二个分区 两次回车，使用默认分区号和扇区大小 输入-512M，为交换分区留出 512MB 大小来 分区默认名为Linux filesystem，因此不需要改 17.3.4 创建第三个分区：交换分区 输入n，创建第三个分区 连按 3 次回车，接受所有默认设置 输入t，将新分区改为Linux Swap,别名为 19 17.3.5 查看分区结果输入p 17.3.6 完成修改输入w ","date":"2023-10-12","objectID":"/vmware/:17:3","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#完成修改"},{"categories":["Linux"],"content":" 18 格式化分区对于不同的分区，我们使用不同的文件系统： ","date":"2023-10-12","objectID":"/vmware/:18:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#格式化分区"},{"categories":["Linux"],"content":" 18.1 ESP 分区格式化：mkfs.fat格式化 FAT32 文件系统ESP 在/dev/sda1中，运行mkfs.fat -F32 /dev/sda1来挂载 FAT32 文件系统 ","date":"2023-10-12","objectID":"/vmware/:18:1","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#esp-分区格式化mkfsfat格式化-fat32-文件系统"},{"categories":["Linux"],"content":" 19 根分区：通过mkfs.ext4格式化 ext4 文件系统mkfs.ext4 /dev/sad2 ","date":"2023-10-12","objectID":"/vmware/:19:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#根分区通过mkfsext4格式化-ext4-文件系统"},{"categories":["Linux"],"content":" 20 交换分区格式化：mkswapmkswap /dev/sda3 ","date":"2023-10-12","objectID":"/vmware/:20:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#交换分区格式化mkswap"},{"categories":["Linux"],"content":" 21 挂载分区","date":"2023-10-12","objectID":"/vmware/:21:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#挂载分区"},{"categories":["Linux"],"content":" 21.1 挂载根分区将根磁盘卷挂载到/mnt，使用命令：mount /dev/sda2 /mnt ","date":"2023-10-12","objectID":"/vmware/:21:1","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#挂载根分区"},{"categories":["Linux"],"content":" 21.2 挂载 EFI 分区 bash mount --mkdir /dev/sda1 /mnt/boot ","date":"2023-10-12","objectID":"/vmware/:21:2","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#挂载-efi-分区"},{"categories":["Linux"],"content":" 21.3 挂载 swap 分区swapon /dev/sda3来启用交换分区 稍后 genfstab(8) 将自动检测挂载的文件系统和交换空间。 ","date":"2023-10-12","objectID":"/vmware/:21:3","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#挂载-swap-分区"},{"categories":["Linux"],"content":" 22 开始安装系统","date":"2023-10-12","objectID":"/vmware/:22:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#开始安装系统"},{"categories":["Linux"],"content":" 22.1 选择镜像站 22.1.1 安装reflector包通常来说系统默认有，如果没有的话使用如下命令安装： sudo pacman -S reflector 22.1.2 更新源 bash sudo reflector --country China --save /etc/pacman.d/mirrorlist.pacnew 确保源准确无误后，将mirrorlist.pacnew复制到mirrorlist ","date":"2023-10-12","objectID":"/vmware/:22:1","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#选择镜像站"},{"categories":["Linux"],"content":" 22.1 选择镜像站 22.1.1 安装reflector包通常来说系统默认有，如果没有的话使用如下命令安装： sudo pacman -S reflector 22.1.2 更新源 bash sudo reflector --country China --save /etc/pacman.d/mirrorlist.pacnew 确保源准确无误后，将mirrorlist.pacnew复制到mirrorlist ","date":"2023-10-12","objectID":"/vmware/:22:1","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#安装reflector包"},{"categories":["Linux"],"content":" 22.1 选择镜像站 22.1.1 安装reflector包通常来说系统默认有，如果没有的话使用如下命令安装： sudo pacman -S reflector 22.1.2 更新源 bash sudo reflector --country China --save /etc/pacman.d/mirrorlist.pacnew 确保源准确无误后，将mirrorlist.pacnew复制到mirrorlist ","date":"2023-10-12","objectID":"/vmware/:22:1","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#更新源"},{"categories":["Linux"],"content":" 22.2 安装必须的软件包使用 pacstrap(8) 脚本，安装 base 包 软件包和 Linux 内核以及常规硬件的固件： bash pacstrap -K /mnt base linux vim man-db man-pages texinfo 这时候可以同时额外安装计算机的 CPU 微码包。如果计算机是 Intel 的 CPU ，使用intel-ucode包，AMD CPU 则使用 amd-ucode包。也可以暂时都不安装，等到进入系统后再安装。 因为我是在虚拟机中安装，因此我不安装固件linux-firmware和微码包intel-ucode。如果你有想补充的软件，请加在pacstrap后面。 是texinfo，不是textinfo，不要看错啦！ ","date":"2023-10-12","objectID":"/vmware/:22:2","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#安装必须的软件包"},{"categories":["Linux"],"content":" 23 配置系统","date":"2023-10-12","objectID":"/vmware/:23:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#配置系统"},{"categories":["Linux"],"content":" 23.1 生成 fstab 文件通过以下命令生成 fstab 文件 (用 -U 或 -L 选项设置 UUID 或卷标)： bash genfstab -U /mnt \u003e\u003e /mnt/etc/fstab 强烈建议在执行完以上命令后，检查一下生成的/mnt/etc/fstab文件是否正确。 ","date":"2023-10-12","objectID":"/vmware/:23:1","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#生成-fstab-文件"},{"categories":["Linux"],"content":" 23.2 chroot 到新安装的系统 bash arch-chroot /mnt 提示：此处使用的是 arch-chroot 而不是直接使用 chroot，注意不要输错了。在arch-chroot进入/mnt后，提示符应该变为了[root@archiso]样式，如果没有，请检查一下前面的步骤是否都准确完成了。 ","date":"2023-10-12","objectID":"/vmware/:23:2","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#chroot-到新安装的系统"},{"categories":["Linux"],"content":" 23.3 设置时区 bash ln -sf /usr/share/zoneinfo/Region（地区名）/City（城市名） /etc/localtime 地区名填 Asia,城市名填 Shanghai 然后运行 hwclock(8) 以生成 /etc/adjtime： bash hwclock --systohc 这个命令假定已设置硬件时间为 UTC 时间。 ","date":"2023-10-12","objectID":"/vmware/:23:3","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#设置时区"},{"categories":["Linux"],"content":" 23.4 区域和本地化设置 编辑/etc/locale.gen。将en_US.UTF-8或其他你想要的配置，对应那行取消注释。修改后，执行locale-gen，以生成locale信息。 创建/etc/locale.conf，在其中写入： bash LANG=en_US.UTF-8 ","date":"2023-10-12","objectID":"/vmware/:23:4","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#区域和本地化设置"},{"categories":["Linux"],"content":" 23.5 控制台键盘布局和字体设置如果需要修改控制台键盘布局和字体，可编辑 /etc/vconsole.conf 使其长期生效，例如： bash KEYMAP=de-latin1 ","date":"2023-10-12","objectID":"/vmware/:23:5","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#控制台键盘布局和字体设置"},{"categories":["Linux"],"content":" 23.6 网络配置网络配置很重要,否则安装系统后会连不上网（例如VirtualBox桥接模式就需要配置 DHCP） 23.6.1 设置主机名创建/etc/hostname文件，在其中直接填写你所设定的主机名，我填写的主机名是arch 23.6.2 安装网络管理器 pacman -S networkmanager systemctl enable NetworkManager.service设置网络管理器开机自启动 ","date":"2023-10-12","objectID":"/vmware/:23:6","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#网络配置"},{"categories":["Linux"],"content":" 23.6 网络配置网络配置很重要,否则安装系统后会连不上网（例如VirtualBox桥接模式就需要配置 DHCP） 23.6.1 设置主机名创建/etc/hostname文件，在其中直接填写你所设定的主机名，我填写的主机名是arch 23.6.2 安装网络管理器 pacman -S networkmanager systemctl enable NetworkManager.service设置网络管理器开机自启动 ","date":"2023-10-12","objectID":"/vmware/:23:6","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#设置主机名"},{"categories":["Linux"],"content":" 23.6 网络配置网络配置很重要,否则安装系统后会连不上网（例如VirtualBox桥接模式就需要配置 DHCP） 23.6.1 设置主机名创建/etc/hostname文件，在其中直接填写你所设定的主机名，我填写的主机名是arch 23.6.2 安装网络管理器 pacman -S networkmanager systemctl enable NetworkManager.service设置网络管理器开机自启动 ","date":"2023-10-12","objectID":"/vmware/:23:6","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#安装网络管理器"},{"categories":["Linux"],"content":" 23.7 关于 initramfs通常不需要自己创建新的 initramfs，因为在执行 pacstrap 时已经安装 linux 包，这时已经运行过 mkinitcpio 了。 ","date":"2023-10-12","objectID":"/vmware/:23:7","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#关于-initramfs"},{"categories":["Linux"],"content":" 23.8 设置 root 密码输入passwd创建一个root密码 ","date":"2023-10-12","objectID":"/vmware/:23:8","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#设置-root-密码"},{"categories":["Linux"],"content":" 23.9 安装引导程序需要安装 Linux 引导加载程序，才能在安装后启动系统，可以使用的的引导程序已在启动加载器中列出，请选择一个安装并配置它，GRUB 是最常见的选择。 如果有 Intel 或 AMD 的 CPU，请另外启用微码更新。 安装grub和efibootmgr：输入pacman -S grub efibootmgr 输入grub-install --target=x86_64-efi --efi-directory=[esp] --bootloader-id=GRUB 我的esp挂载点是/mnt/boot，因为我已经arch-chroot到/mnt中了，因此esp字段填写/boot即可。如果你安装在了其他挂载点上，请在esp字段填写你自己的挂载点。如果出现问题，检查： 是否已经arch-chroot到了/mnt下？命令提示符为[root@archiso] 前面的配置过程有没有出现问题？ grub-install命令成功时应该出现: 生成主配置文件:grub-mkconfig -o /boot/grub/grub.cfg 配置成功时界面： ","date":"2023-10-12","objectID":"/vmware/:23:9","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#安装引导程序"},{"categories":["Linux"],"content":" 24 重新启动计算机 exit退出chroot环境 umount -R /mnt取消挂载/mnt（也等到可reboot时 systemd 自动卸载） reboot重启系统 ","date":"2023-10-12","objectID":"/vmware/:24:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#重新启动计算机"},{"categories":["Linux"],"content":" 25 安装后的工作参见建议阅读列表及应用程序列表 ","date":"2023-10-12","objectID":"/vmware/:25:0","series":["Arch 探索"],"tags":["Arch","Linux","安装"],"title":"VMWare下的Arch Linux安装过程记录","uri":"/vmware/#安装后的工作"}]