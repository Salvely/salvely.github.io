[{"categories":null,"content":" Tip chloneda/vim-cheatsheet: 🍁Vim cheat sheet with everything you want to know. 这个表更全面。此外，如果你的终端是gb2312编码，vimtutor会是中文版本，详情见此如何获取VIM自带的vimtutor中文版 – 小顾de杂记。如果你想要获得vimtutor的中文版本，可以输入vimtutor zh_cn；英文版是vimtutor en。 打开vim：vim \u003cfile\u003e 不保存强制退出vim：:q! 保存：:w，:w \u003cfile\u003e 保存到文件file中 w是下一个单词开头，e是下一个文字结尾，$是行末，0是行开头 删除：dw de d$ dd，要指明删除到哪里：d2w d2e，命令模式：operation num motion 撤回：u 撤回一个操作 ，U 撤回一行 ，CTRL+R redo 单个替换：r，多个替换：R c是change，c后可接c/e/$ dd 删除一行 p 粘贴刚才删除的那行 CTRL+G 获得当前光标位置（文件，行号，列号等），G 跳到末尾 gg 跳到开头 行号+G 跳到该行 / 搜索并向后查找，?搜索并向前查找， n 向后找 N 向前找 CTRL+O 上一个查找到的 CTRL+I 下一个查找到的 wrpscan模式 当查找到最后一个以后，下一次查找就找到第一个 % 匹配括号 ( [ { } ] ) :s/old/new 搜索到该行第一个old并替换为new :s/old/new/g 搜索到该行所有的old并替换为new :%s/old/new 在整个文件搜索到第一个old并替换为new :%s/old/new/g 在整个文件搜索到所有的old并替换为new gc 逐个询问你是否替换 :#,#s 从某行到某行之间替换 :! \u003c外部命令\u003e 执行外部命令（如ls dir cat等等） y复制 p 粘贴 v 视觉模式 v后再输入:可以输入普通模式下的命令（如!cat \u003cfile\u003e） :r 读内容，并复制到光标处，比如:r !ls就是把ls命令的结果输出到光标处； o在该行下面插入一行 O在该行上面插入一行 a在该字符后面插入字符 A在该行末尾插入字符 :set 设置模式 hls hlsearch 高亮搜索 nohls nohlsearch 非高亮搜索 ic ignorecase忽略大小写 noic noignorecase不忽略大小写 如果仅仅想要在一次搜索中忽略大小写，可以使用/c，如/[text]\\c is incsearch 查找输入时动态增量显示查找结果 nois noicsearch 不动态增量显示 nocp 不兼容vi 按F1或输入:help [命令]调出命令帮助，直接输入:help调出vim帮助，如:help vimrc-intro vim配置文件：~/.vimrc :e，在进入vim后， 在不离开vim的情况下打开其他文件 CTRL+D 列出所有候选命令，Tab 补全当前命令 ","date":"2025-07-10","objectID":"/vimtutor-%E6%80%BB%E7%BB%93/:0:0","series":null,"tags":["vim"],"title":"vimtutor 总结","uri":"/vimtutor-%E6%80%BB%E7%BB%93/#"},{"categories":null,"content":"今天写下这篇文章，是因为我过去多年一直饱受身体疾病和体质虚弱的困扰，实在是绷不住了。 在过去的多年里，每个月我必然要经历： 5天例假，整个人虚的一批，只能在床上挺尸； 隔三岔五的荨麻疹，浑身瘙痒难耐，还会因为出汗身上黏糊糊，又不能一直洗澡，浑身起红色划痕一样的疹子； 吹点风就感冒发烧了，出点汗吹点空调又感冒了； 健身两天就膝盖不舒服了，还得吃氨糖； 因为荨麻疹伴随的玫瑰痤疮，不能用护肤品和化妆品，脸上时不时泛红瘙痒； 浑身汗腺发达， 手汗脚汗不断。腋下甚至有时候会有味道，每天要用硫磺皂洗。稍微健个身身上就会有味道。每年换季的时候，两只手还会有很多的汗疱疹，连在一起，又痒又恶心，还不能根治； 脚气和脚藓，这个是伴随着脚汗出来的，跟随我爸遗传的，天天都要用上海药皂洗脚。最近发现超市居然不卖上海药皂和硫磺皂了，妈的； 晕车晕3d，一次只能扛过生化危机8的一章，每次到存档点的时候都脑袋发晕、恶心想吐、浑身出汗、面色苍白，扛过去是因为没有存档点，要是存档点再靠后点我就要扛不住了； 不能接受任何不舒适条件下的活动（比如3月份的炎热户外会让我中暑，有烟味的动车车厢会让我想吐）； 等等等等； 所导致的结果就是： 经常需要睡觉休息，不能进行任何高强度的学习工作活动，否则就会生病，虚弱，扛不住； 身体疾病导致心理韧性差，抗压能力弱，经常想要哭哭，想要别人的安慰和抱抱； 生命力弱，经常出现3分钟热度的情况，因为我的身体能量只够我燃烧那么久，再久点就扛不住了； 看着别人一个个生龙活虎，活力四射，朝着他们的目标和挑战前进，就觉得特别羡慕。但是自己模仿着行动一段时间，身体就报警了，要我去睡觉，无奈最后只能到床上去挺尸； 我不要再这样啦！我也要当健康人！我也要成为活力四射的小朋友！我要健身！健身！ 可是我有时候健身的时候，感觉自己快要扛不住了，感觉浑身出汗，脑袋乏累，眼皮变重，有时候甚至能在健身之后，从镜子里看到自己的单眼皮变成了双眼皮。健身结束以后，就特别想睡觉，一次又是几个小时，也没有做其他事情的动力了。很苦恼哇。 我怎么这么脆弱，呜呜呜，哇哇哇。 ","date":"2025-01-24","objectID":"/%E8%BA%AB%E4%BD%93%E6%98%AF%E9%9D%A9%E5%91%BD%E7%9A%84%E6%9C%AC%E9%92%B1/:0:0","series":["随记"],"tags":null,"title":"身体是革命的本钱！","uri":"/%E8%BA%AB%E4%BD%93%E6%98%AF%E9%9D%A9%E5%91%BD%E7%9A%84%E6%9C%AC%E9%92%B1/#"},{"categories":["理论计算机"],"content":" 1 图灵机设计对二进制加法过程进行分析，我们可以得出如下过程： 使用小端法在纸带上存储输入的二进制串，即低位放在最左边 第一格是blank，也就是空，最后我们会回退到这个状态，来进入halt状态 最初是start状态，经过blank后改为carry状态 carry状态下，如果最低为是 0，那么直接将其加 1，然后返回（向左行走）即可，进入back状态 carry状态下，如果最低为是 1，将其改为 0，保持carry状态向右行走，继续对高位进行修改 如果在carry状态下遇到blank，也就是最高位还有进位，那么将blank改为 1 在回退状态下，一般来说只会遇到0，保留 0 不动，继续回退 达到halt之后停止操作，打印字符串 那么，在该图灵机中，我们需要使用到如下几个状态： start，即开始状态 carry，进位状态 back，回退状态 halt，停止状态 有如下几种符号： blank，表示空 0，即二进制符号 0 1，即二进制符号 1 根据设计，图灵机定义二进制加法的计算过程如下： start, blank-\u003eblank, RIGHT, carry carry, 1 -\u003e 0, RIGHT, carry carry, blank-\u003e1, LEFT, back carry, 0-\u003e1, LEFT, back back, 0-\u003e0, LEFT, back back, blank-\u003eblank, halt ","date":"2025-01-12","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:1:0","series":null,"tags":["图灵机","计算理论"],"title":"二进制加法图灵机的C语言实现","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/#图灵机设计"},{"categories":["理论计算机"],"content":" 2 C 语言代码实现 c // Turing machines for computations. #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #define N 4 // the number of states #define M 3 // the number of symbols #define TAPE_SIZE 20 // the size of the tape enum direction { LEFT, RIGHT, STAY }; /** * @brief encoding for binary addtion * 1. 4 states start:0 carry:1 back:2 halt:3 * 2. 3 symbols 0-\u003e0 1-\u003e1 blank-\u003e2 */ enum STATE { START, CARRY, BACK, HALT }; enum SYMBOL { SYMBOL_0, SYMBOL_1, BLANK }; int state_arr [N]; // state_arr[0] as start state, state_arr[N-2] as accept state, state_arr[N-1] as reject state int symbol_arr[M]; // symbol_arr[0] as empty symbol int tape[TAPE_SIZE]; typedef struct head { int location; // the location of the head int state_num; // the state of the head } head_t; typedef struct action { int head_state; int current_symbol; int next_symbol; enum direction dir; int next_state; } action_t; /** * @brief turing machine for binary addition * 1. start, blank-\u003eblank, RIGHT, carry * 2. carry, 1 -\u003e 0, RIGHT, carry * 3. carry, blank-\u003e1, LEFT, back * 4. carry, 0-\u003e1, LEFT, back * 5. back, 0-\u003e0, LEFT, back * 6. back, blank-\u003eblank, halt */ action_t turing_machine(action_t act) { if (act.head_state == state_arr[START] \u0026\u0026 act.current_symbol == symbol_arr[BLANK]) { act.next_symbol = act.current_symbol; act.dir = RIGHT; act.next_state = state_arr[CARRY]; } else if (act.head_state == state_arr[CARRY] \u0026\u0026 act.current_symbol == symbol_arr[SYMBOL_1]) { act.next_symbol = symbol_arr[SYMBOL_0]; act.dir = RIGHT; act.next_state = act.head_state; } else if (act.head_state == state_arr[CARRY] \u0026\u0026 act.current_symbol == symbol_arr[BLANK]) { act.next_symbol = symbol_arr[SYMBOL_1]; act.dir = LEFT; act.next_state = state_arr[BACK]; } else if (act.head_state == state_arr[CARRY] \u0026\u0026 act.current_symbol == symbol_arr[SYMBOL_0]) { act.next_symbol = symbol_arr[SYMBOL_1]; act.dir = LEFT; act.next_state = state_arr[BACK]; } else if (act.head_state == state_arr[BACK] \u0026\u0026 act.current_symbol == symbol_arr[SYMBOL_0]) { act.next_symbol = act.current_symbol; act.dir = LEFT; act.next_state = state_arr[BACK]; } else if (act.head_state == state_arr[BACK] \u0026\u0026 act.current_symbol == symbol_arr[BLANK]) { act.next_symbol = act.current_symbol; act.dir = STAY; act.next_state = state_arr[HALT]; } return act; } void state_transition(char* s, int length) { // initiliaze the state array and symbol array for (int i = 0; i \u003c N; i++) { state_arr[i] = i; } for (int i = 0; i \u003c M; i++) { symbol_arr[i] = i; } // initialize the tape for (int i = 0; i \u003c TAPE_SIZE; i++) { tape[i] = BLANK; // initialize all tape as blank } for (int i = 0; i \u003c length; i++) { tape[i + 1] = s[i] - '0'; } // initialize the head head_t h; h.location = 0; h.state_num = state_arr[START]; // initialie the action action_t a; a.dir = STAY; // define the state transition while (h.state_num != 3) { a.head_state = h.state_num; a.current_symbol = tape[h.location]; a = turing_machine(a); tape[h.location] = a.next_symbol; // update the head if (a.dir == RIGHT) { h.location += 1; } else if (a.dir == LEFT) { h.location -= 1; } h.state_num = a.next_state; } // print the added string for (int i = length; i \u003e= 1; i--) { printf(\"%d\", tape[i]); } } int main(void) { printf(\"Input the binary string: \"); char* s = (char*)malloc(10 * sizeof(char)); scanf(\"%s\", s); // reverse the string, and enter it into turing machine int length = strlen(s); for (int i = 0; i \u003c length / 2; i++) { char temp = s[length - 1 - i]; s[length - 1 - i] = s[i]; s[i] = temp; } state_transition(s, strlen(s)); return 0; } ","date":"2025-01-12","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/:2:0","series":null,"tags":["图灵机","计算理论"],"title":"二进制加法图灵机的C语言实现","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/#c-语言代码实现"}]